<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Gentoo 内核编译 - 00002000的小窝</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="00002000" /><meta name="description" content="还在慢慢整理 1 2 3 4 emerge --ask sys-kernel/gentoo-sources #安装Linux内核源码 eselect kernel list eselect kernel set 1 ls -l /usr/src/linux # linux-6.1.46-gentoo 在此以 Linux/x86 6.1.46-gentoo内核为例，详解每个选项。 y : 编译" /><meta name="keywords" content="blog, 00002000, 技术" />






<meta name="generator" content="Hugo 0.118.2 with theme even" />


<link rel="canonical" href="https://blog.00002000.xyz/post/code/linux/gentoo-kernel/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Gentoo 内核编译" />
<meta property="og:description" content="还在慢慢整理 1 2 3 4 emerge --ask sys-kernel/gentoo-sources #安装Linux内核源码 eselect kernel list eselect kernel set 1 ls -l /usr/src/linux # linux-6.1.46-gentoo 在此以 Linux/x86 6.1.46-gentoo内核为例，详解每个选项。 y : 编译" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.00002000.xyz/post/code/linux/gentoo-kernel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-08T16:14:37+08:00" />
<meta property="article:modified_time" content="2023-09-14T16:14:37+08:00" />
<meta itemprop="name" content="Gentoo 内核编译">
<meta itemprop="description" content="还在慢慢整理 1 2 3 4 emerge --ask sys-kernel/gentoo-sources #安装Linux内核源码 eselect kernel list eselect kernel set 1 ls -l /usr/src/linux # linux-6.1.46-gentoo 在此以 Linux/x86 6.1.46-gentoo内核为例，详解每个选项。 y : 编译"><meta itemprop="datePublished" content="2023-07-08T16:14:37+08:00" />
<meta itemprop="dateModified" content="2023-09-14T16:14:37+08:00" />
<meta itemprop="wordCount" content="341004">
<meta itemprop="keywords" content="linux,gentoo,安装," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Gentoo 内核编译"/>
<meta name="twitter:description" content="还在慢慢整理 1 2 3 4 emerge --ask sys-kernel/gentoo-sources #安装Linux内核源码 eselect kernel list eselect kernel set 1 ls -l /usr/src/linux # linux-6.1.46-gentoo 在此以 Linux/x86 6.1.46-gentoo内核为例，详解每个选项。 y : 编译"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">00002000的小窝</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">合集</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">00002000的小窝</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">合集</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Gentoo 内核编译</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-07-08 </span>
        <div class="post-category">
            <a href="/categories/linux%E5%AE%89%E8%A3%85/"> linux安装 </a>
            </div>
          <span class="more-meta"> 约 341004 字 </span>
          <span class="more-meta"> 预计阅读 681 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#gentoo-linux内核gentoo-sourceshttppackagesgentooorgpackagesys-kernelgentoo-sources特有的选项">Gentoo Linux内核(<a href="http://packages.gentoo.org/package/sys-kernel/gentoo-sources">gentoo-sources</a>)特有的选项</a>
      <ul>
        <li><a href="#-gentoo-linux-support">[*] Gentoo Linux support</a>
          <ul>
            <li><a href="#---linux-dynamic-and-persistent-device-naming-userspace-devfs-support">[*]   Linux dynamic and persistent device naming (userspace devfs) support</a></li>
            <li><a href="#---select-options-required-by-portage-features">[*]   Select options required by Portage features</a></li>
          </ul>
        </li>
        <li><a href="#support-for-init-systems-system-and-service-managers">Support for init systems, system and service managers</a>
          <ul>
            <li><a href="#--openrc-runit-and-other-script-based-systems-and-managers">[ ] OpenRC, runit and other script based systems and managers</a></li>
            <li><a href="#-systemd">[*] systemd</a></li>
          </ul>
        </li>
        <li><a href="#--kernel-self-protection-project">[ ] Kernel Self Protection Project</a>
          <ul>
            <li><a href="#----kernel-self-protection-project">&mdash; Kernel Self Protection Project</a></li>
          </ul>
        </li>
        <li><a href="#-print-firmware-information-that-the-kernel-attempts-to-load">[*] Print firmware information that the kernel attempts to load</a></li>
      </ul>
    </li>
    <li><a href="#-64-bit-kernel">[*] 64-bit kernel</a></li>
    <li><a href="#general-setup-常规设置">General setup 常规设置</a>
      <ul>
        <li><a href="#--compile-also-drivers-which-will-not-load">[ ] Compile also drivers which will not load</a></li>
        <li><a href="#-compile-the-kernel-with-warnings-as-errors">[*] Compile the kernel with warnings as errors</a></li>
        <li><a href="#me--local-version---append-to-kernel-release">(me)  Local version - append to kernel release</a></li>
        <li><a href="#-automatically-append-version-information-to-the-version-string">[*] Automatically append version information to the version string</a></li>
        <li><a href="#--build-id-salt">()  Build ID Salt</a></li>
        <li><a href="#kernel-compression-mode-zstd-----">Kernel compression mode (ZSTD)  &mdash;&gt;</a></li>
        <li><a href="#--default-init-path">()  Default init path</a></li>
        <li><a href="#amd-default-hostname">(amd) Default hostname</a></li>
        <li><a href="#---system-v-ipc">-*- System V IPC</a></li>
        <li><a href="#-posix-message-queues">[*] POSIX Message Queues</a></li>
        <li><a href="#--general-notification-queue-通用通知机制">[ ] General notification queue 通用通知机制</a></li>
        <li><a href="#-enable-process_vm_readvwritev-syscalls">[*] Enable process_vm_readv/writev syscalls</a></li>
        <li><a href="#-uselib-syscall-for-libc5-and-earlier">[*] uselib syscall (for libc5 and earlier)</a></li>
        <li><a href="#--auditing-support">[ ] Auditing support</a></li>
        <li><a href="#irq-subsystem-----">IRQ subsystem  &mdash;&gt;</a>
          <ul>
            <li><a href="#--expose-irq-internals-in-debugfs">[ ] Expose irq internals in debugfs</a></li>
          </ul>
        </li>
        <li><a href="#timers-subsystem-----">Timers subsystem  &mdash;&gt;</a>
          <ul>
            <li><a href="#timer-tick-handling-idle-dynticks-system-tickless-idle-----">Timer tick handling (Idle dynticks system (tickless idle))  &mdash;&gt;</a></li>
            <li><a href="#--old-idle-dynticks-config">[ ] Old Idle dynticks config</a></li>
            <li><a href="#-high-resolution-timer-support">[*] High Resolution Timer Support</a></li>
            <li><a href="#100-clocksource-watchdog-maximum-allowable-skew-in---s">(100) Clocksource watchdog maximum allowable skew (in   s)</a></li>
          </ul>
        </li>
        <li><a href="#bpf-subsystem-----">BPF subsystem  &mdash;&gt;</a>
          <ul>
            <li><a href="#---enable-bpf-system-call">-*- Enable bpf() system call</a></li>
            <li><a href="#-disable-unprivileged-bpf-by-default">[*] Disable unprivileged BPF by default</a></li>
            <li><a href="#--preload-bpf-file-system-with-kernel-specific-program-and-map-iterators------">[ ] Preload BPF file system with kernel specific program and map iterators  &mdash;-</a></li>
          </ul>
        </li>
        <li><a href="#preemption-model-voluntary-kernel-preemption-desktop-----">Preemption Model (Voluntary Kernel Preemption (Desktop))  &mdash;&gt;</a></li>
        <li><a href="#--preemption-behaviour-defined-on-boot">[ ] Preemption behaviour defined on boot</a></li>
        <li><a href="#--core-scheduling-for-smt">[ ] Core Scheduling for SMT</a></li>
        <li><a href="#cputask-time-and-stats-accounting-----">CPU/Task time and stats accounting  &mdash;&gt;</a>
          <ul>
            <li><a href="#cputime-accounting-simple-tick-based-cputime-accounting-----">Cputime accounting (Simple tick based cputime accounting)  &mdash;&gt;</a></li>
            <li><a href="#--fine-granularity-task-level-irq-time-accounting">[ ] Fine granularity task level IRQ time accounting</a></li>
            <li><a href="#-bsd-process-accounting">[*] BSD Process Accounting</a></li>
            <li><a href="#--export-taskprocess-statistics-through-netlink">[ ] Export task/process statistics through netlink</a></li>
            <li><a href="#--pressure-stall-information-tracking">[ ] Pressure stall information tracking</a></li>
          </ul>
        </li>
        <li><a href="#--cpu-isolation">[ ] CPU isolation</a></li>
        <li><a href="#rcu-subsystem-----">RCU Subsystem  &mdash;&gt;</a>
          <ul>
            <li><a href="#--make-expert-level-adjustments-to-rcu-configuration">[ ] Make expert-level adjustments to RCU configuration</a></li>
            <li><a href="#--force-selection-of-tasks_rcu-new">[ ] Force selection of TASKS_RCU (NEW)</a></li>
            <li><a href="#--force-selection-of-tasks-rude-rcu-new">[ ] Force selection of Tasks Rude RCU (NEW)</a></li>
            <li><a href="#--force-selection-of-tasks-trace-rcu-new">[ ] Force selection of Tasks Trace RCU (NEW)</a></li>
            <li><a href="#64-tree-based-hierarchical-rcu-fanout-value-new">(64) Tree-based hierarchical RCU fanout value (NEW)</a></li>
            <li><a href="#16-tree-based-hierarchical-rcu-leaf-level-fanout-value-new">(16) Tree-based hierarchical RCU leaf-level fanout value (NEW)</a></li>
            <li><a href="#--offload-rcu-callback-processing-from-boot-selected-cpus-new">[ ] Offload RCU callback processing from boot-selected CPUs (NEW)</a></li>
            <li><a href="#--tasks-trace-rcu-readers-use-memory-barriers-in-user-and-idle-new">[ ] Tasks Trace RCU readers use memory barriers in user and idle (NEW)</a></li>
          </ul>
        </li>
        <li><a href="#--kernel-config-support">[ ] Kernel .config support</a></li>
        <li><a href="#----enable-access-to-config-through-procconfiggz">[ ]   Enable access to .config through /proc/config.gz</a></li>
        <li><a href="#--enable-kernel-headers-through-syskernelkheaderstarxz">[ ] Enable kernel headers through /sys/kernel/kheaders.tar.xz</a></li>
        <li><a href="#scheduler-features-----">Scheduler features  &mdash;&gt;</a>
          <ul>
            <li><a href="#-enable-utilization-clamping-for-rtfair-tasks">[*] Enable utilization clamping for RT/FAIR tasks</a></li>
            <li><a href="#5---number-of-supported-utilization-clamp-buckets">(5)   Number of supported utilization clamp buckets</a></li>
          </ul>
        </li>
        <li><a href="#--memory-placement-aware-numa-scheduler">[ ] Memory placement aware NUMA scheduler</a></li>
        <li><a href="#---control-group-support-----">-*- Control Group support  &mdash;&gt;</a>
          <ul>
            <li><a href="#----favor-dynamic-modification-latency-reduction-by-default">[ ]   Favor dynamic modification latency reduction by default</a></li>
            <li><a href="#---memory-controller">[*]   Memory controller</a></li>
            <li><a href="#----io-controller">[ ]   IO controller</a></li>
            <li><a href="#-cpu-controller-----">[*] CPU controller  &mdash;&gt;</a></li>
            <li><a href="#----pids-controller-docker-optional">[ ]   PIDs controller (docker Optional)</a></li>
            <li><a href="#----rdma-controller">[ ]   RDMA controller</a></li>
            <li><a href="#---freezer-controller">[*]   Freezer controller</a></li>
            <li><a href="#----hugetlb-controller">[ ]   HugeTLB controller</a></li>
            <li><a href="#---cpuset-controller">[*]   Cpuset controller</a></li>
            <li><a href="#----device-controller">[ ]   Device controller</a></li>
            <li><a href="#----simple-cpu-accounting-controller">[ ]   Simple CPU accounting controller</a></li>
            <li><a href="#----perf-controller">[ ]   Perf controller</a></li>
            <li><a href="#-----support-for-ebpf-programs-attached-to-cgroups">-*-   Support for eBPF programs attached to cgroups</a></li>
            <li><a href="#----misc-resource-controller">[ ]   Misc resource controller</a></li>
            <li><a href="#----debug-controller">[ ]   Debug controller</a></li>
          </ul>
        </li>
        <li><a href="#---namespaces-support-----">-*- Namespaces support  &mdash;&gt;</a></li>
        <li><a href="#--checkpointrestore-support">[ ] Checkpoint/restore support</a></li>
        <li><a href="#--automatic-process-group-scheduling">[ ] Automatic process group scheduling</a></li>
        <li><a href="#--enable-deprecated-sysfs-features-to-support-old-userspace-tools">[ ] Enable deprecated sysfs features to support old userspace tools</a></li>
        <li><a href="#---kernel-user-space-relay-support-formerly-relayfs">-*- Kernel-&gt;user space relay support (formerly relayfs)</a></li>
        <li><a href="#-initial-ram-filesystem-and-ram-disk-initramfsinitrd-support">[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</a></li>
        <li><a href="#----initramfs-source-files">()    Initramfs source file(s)</a></li>
        <li><a href="#---support-initial-ramdiskramfs-compressed-using-xxx">[*]   Support initial ramdisk/ramfs compressed using xxx</a>
          <ul>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-gzip">[*]   Support initial ramdisk/ramfs compressed using gzip</a></li>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-bzip2">[*]   Support initial ramdisk/ramfs compressed using bzip2</a></li>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-lzma">[*]   Support initial ramdisk/ramfs compressed using LZMA</a></li>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-xz">[*]   Support initial ramdisk/ramfs compressed using XZ</a></li>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-lzo">[*]   Support initial ramdisk/ramfs compressed using LZO</a></li>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-lz4">[*]   Support initial ramdisk/ramfs compressed using LZ4</a></li>
            <li><a href="#---support-initial-ramdiskramfs-compressed-using-zstd">[*]   Support initial ramdisk/ramfs compressed using ZSTD</a></li>
          </ul>
        </li>
        <li><a href="#--boot-config-support">[ ] Boot config support</a></li>
        <li><a href="#-preserve-cpio-archive-mtimes-in-initramfs">[*] Preserve cpio archive mtimes in initramfs</a></li>
        <li><a href="#compiler-optimization-level-optimize-for-performance--o2-----">Compiler optimization level (Optimize for performance (-O2))  &mdash;&gt;</a></li>
        <li><a href="#-configure-standard-kernel-features-expert-users-----">[*] Configure standard kernel features (expert users)  &mdash;&gt;</a></li>
        <li><a href="#---enable-kcmp-system-call">-*- Enable kcmp() system call</a></li>
        <li><a href="#-enable-rseq-system-call">[*] Enable rseq() system call</a></li>
        <li><a href="#----enabled-debugging-of-rseq-system-call">[ ]   Enabled debugging of rseq() system call</a></li>
        <li><a href="#--embedded-system">[ ] Embedded system</a></li>
        <li><a href="#--pc104-support">[ ] PC/104 support</a></li>
        <li><a href="#kernel-performance-events-and-counters-----">Kernel Performance Events And Counters  &mdash;&gt;</a></li>
        <li><a href="#--profiling-support">[ ] Profiling support</a></li>
        <li><a href="#enable-loadable-module-support-可加载模块支持"><a href=""></a>Enable loadable module support 可加载模块支持</a></li>
        <li><a href="#enable-the-block-layer-块设备支持"><a href=""></a>Enable the block layer 块设备支持</a></li>
        <li><a href="#processor-type-and-features-中央处理器cpu类型及特性"><a href=""></a>Processor type and features 中央处理器(CPU)类型及特性</a></li>
        <li><a href="#power-management-and-acpi-options-电源管理和acpi选项"><a href=""></a>Power management and ACPI options 电源管理和ACPI选项</a></li>
        <li><a href="#bus-options-pci-etc-总线选项"><a href=""></a>Bus options (PCI etc.) 总线选项</a></li>
        <li><a href="#executable-file-formats--emulations-可执行文件格式仿真"><a href=""></a>Executable file formats / Emulations 可执行文件格式/仿真</a></li>
        <li><a href="#networking-support-网络支持"><a href=""></a>Networking support 网络支持</a></li>
        <li><a href="#device-drivers-设备驱动程序"><a href=""></a>Device Drivers 设备驱动程序</a></li>
        <li><a href="#firmware-drivers-固件firmwarehttpbaikebaiducomview33738htm驱动"><a href=""></a>Firmware Drivers 固件(<a href="http://baike.baidu.com/view/33738.htm">Firmware</a>)驱动</a></li>
        <li><a href="#file-systems-文件系统"><a href=""></a>File systems 文件系统</a></li>
        <li><a href="#kernel-hacking-内核hack选项"><a href=""></a>Kernel hacking 内核hack选项</a></li>
        <li><a href="#security-options-安全选项-这里的选项不明白的建议不要选否则有可能弄巧成拙"><a href=""></a>Security options 安全选项 这里的选项不明白的建议不要选,否则有可能弄巧成拙.</a></li>
        <li><a href="#cryptographic-api-内核加密api支持-这里的加密算法被广泛的应用于驱动程序通信协议等机制中子选项可以全不选内核中若有其他部分依赖它会自动选上使用内核树外的模块时可能需要手动选择"><a href=""></a>Cryptographic API 内核加密API支持 这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选,内核中若有其他部分依赖它,会自动选上.使用内核树外的模块时可能需要手动选择.</a></li>
        <li><a href="#virtualization-虚拟化支持-仅在将此内核用作宿主机host的情况下才需要开启这里的子项"><a href=""></a>Virtualization 虚拟化支持 仅在将此内核用作宿主机(host)的情况下才需要开启这里的子项</a></li>
        <li><a href="#library-routines-库子程序-子选项可以全不选内核中若有其他部分依赖它会自动选上使用内核树外的模块时可能需要手动选择"><a href=""></a>Library routines 库子程序 子选项可以全不选,内核中若有其他部分依赖它,会自动选上.使用内核树外的模块时可能需要手动选择.</a></li>
        <li><a href="#general-setup通用选项">General setup（通用选项）</a></li>
      </ul>
    </li>
    <li><a href="#make-config-文本配置方式">make config 文本配置方式</a></li>
    <li><a href="#make-menuconfig-菜单配置方式">make menuconfig 菜单配置方式</a></li>
    <li><a href="#make-xconfig-图形界面配置方式">make xconfig 图形界面配置方式</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>还在慢慢整理</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">emerge --ask sys-kernel/gentoo-sources  <span class="c1">#安装Linux内核源码</span>
</span></span><span class="line"><span class="cl">eselect kernel list
</span></span><span class="line"><span class="cl">eselect kernel <span class="nb">set</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">ls -l /usr/src/linux  <span class="c1"># linux-6.1.46-gentoo</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在此以 Linux/x86 6.1.46-gentoo内核为例，详解每个选项。</p>
<ul>
<li><code>y</code> : 编译进内核；</li>
<li><code>m</code> : 编译成可加载模块；</li>
<li><code>n</code> : 不提供支持。</li>
</ul>
<h1 id="gentoo-linux内核gentoo-sourceshttppackagesgentooorgpackagesys-kernelgentoo-sources特有的选项">Gentoo Linux内核(<a href="http://packages.gentoo.org/package/sys-kernel/gentoo-sources">gentoo-sources</a>)特有的选项</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menu <span class="s2">&#34;Gentoo Linux&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="-gentoo-linux-support">[*] Gentoo Linux support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_LINUX
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Gentoo Linux support&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CPU_FREQ_DEFAULT_GOV_SCHEDUTIL
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		In order to boot Gentoo Linux a minimal <span class="nb">set</span> of config settings needs to
</span></span><span class="line"><span class="cl">		be enabled in the kernel<span class="p">;</span> to avoid the users from having to <span class="nb">enable</span> them
</span></span><span class="line"><span class="cl">		manually as part of a Gentoo Linux installation or a new clean config,
</span></span><span class="line"><span class="cl">		we <span class="nb">enable</span> these config settings by default <span class="k">for</span> convenience.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		See the settings that become available <span class="k">for</span> more details and fine-tuning.
</span></span></code></pre></td></tr></table>
</div>
</div><p>自动选中<strong>在Gentoo环境中必须开启的内核选项</strong>,以避免用户遗漏某些必要的选项,减轻一些用户配置内核的难度。</p>
<h3 id="---linux-dynamic-and-persistent-device-naming-userspace-devfs-support">[*]   Linux dynamic and persistent device naming (userspace devfs) support</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_LINUX_UDEV
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Linux dynamic and persistent device naming (userspace devfs) support&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX
</span></span><span class="line"><span class="cl">	default y <span class="k">if</span> GENTOO_LINUX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEVTMPFS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TMPFS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> UNIX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> MMU
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SHMEM
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		In order to boot Gentoo Linux a minimal <span class="nb">set</span> of config settings needs to
</span></span><span class="line"><span class="cl">		be enabled in the kernel<span class="p">;</span> to avoid the users from having to <span class="nb">enable</span> them
</span></span><span class="line"><span class="cl">		manually as part of a Gentoo Linux installation or a new clean config,
</span></span><span class="line"><span class="cl">		we <span class="nb">enable</span> these config settings by default <span class="k">for</span> convenience.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		Currently this only selects TMPFS, DEVTMPFS and their dependencies.
</span></span><span class="line"><span class="cl">		TMPFS is enabled to maintain a tmpfs file system at /dev/shm, /run and
</span></span><span class="line"><span class="cl">		/sys/fs/cgroup<span class="p">;</span> DEVTMPFS to maintain a devtmpfs file system at /dev.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		Some of these are critical files that need to be available early in the
</span></span><span class="line"><span class="cl">		boot process<span class="p">;</span> <span class="k">if</span> not available, it causes sysfs and udev to malfunction.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		To ensure Gentoo Linux boots, it is best to leave this setting enabled<span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> you run a custom setup, you could consider whether to disable this.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Gentoo Linux 的启动需要一些关键文件，比如 /dev/shm、/run 和 /sys/fs/cgroup。如果你想让你的 Gentoo Linux 顺利启动，那就选 Y 吧！</p>
</blockquote>
<p>目前此项的作用仅是开启CONFIG_TMPFS和CONFIG_DEVTMPFS及其所依赖的选项.CONFIG_TMPFS是为了在&quot;/dev/shm&quot;,&quot;/run&quot;,&quot;/sys/fs/cgroup&quot;三个目录中挂载tmpfs文件系统,CONFIG_DEVTMPFS是为了在&quot;/dev&quot;目录挂载devtmpfs文件系统.建议选&quot;Y&quot;.</p>
<p>目前，这只选择TMPFS、DEVTMPFS及其依赖项。
TMPFS用于在/dev/shm、/run和/sys/fs/cgroup中维护tmpfs文件系统；DEVTMPFS在/dev中维护一个devtmpfs文件系统。
其中一些是关键文件，需要在引导过程的早期可用；如果不可用，则会导致sysfs和udev发生故障。
为了确保Gentoo Linux启动，最好保持此设置处于启用状态；如果运行自定义设置，可以考虑是否禁用此设置。</p>
<h3 id="---select-options-required-by-portage-features">[*]   Select options required by Portage features</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_LINUX_PORTAGE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Select options required by Portage features&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX
</span></span><span class="line"><span class="cl">	default y <span class="k">if</span> GENTOO_LINUX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CGROUPS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> NAMESPACES
</span></span><span class="line"><span class="cl">	<span class="k">select</span> IPC_NS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> NET_NS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PID_NS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SYSVIPC
</span></span><span class="line"><span class="cl">	<span class="k">select</span> USER_NS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> UTS_NS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		This enables options required by various Portage FEATURES.
</span></span><span class="line"><span class="cl">		Currently this selects:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		CGROUPS     <span class="o">(</span>required <span class="k">for</span> <span class="nv">FEATURES</span><span class="o">=</span>cgroup<span class="o">)</span>
</span></span><span class="line"><span class="cl">		IPC_NS      <span class="o">(</span>required <span class="k">for</span> <span class="nv">FEATURES</span><span class="o">=</span>ipc-sandbox<span class="o">)</span>
</span></span><span class="line"><span class="cl">		NET_NS      <span class="o">(</span>required <span class="k">for</span> <span class="nv">FEATURES</span><span class="o">=</span>network-sandbox<span class="o">)</span>
</span></span><span class="line"><span class="cl">		PID_NS		<span class="o">(</span>required <span class="k">for</span> <span class="nv">FEATURES</span><span class="o">=</span>pid-sandbox<span class="o">)</span>
</span></span><span class="line"><span class="cl">		SYSVIPC     <span class="o">(</span>required by IPC_NS<span class="o">)</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		It is highly recommended that you leave this enabled as these FEATURES
</span></span><span class="line"><span class="cl">		are, or will soon be, enabled by default.
</span></span></code></pre></td></tr></table>
</div>
</div><p>这启用了各种Portage功能所需的选项。
强烈建议您保持启用状态，因为这些功能默认情况下已启用或即将启用。</p>
<h2 id="support-for-init-systems-system-and-service-managers">Support for init systems, system and service managers</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menu <span class="s2">&#34;Support for init systems, system and service managers&#34;</span>
</span></span><span class="line"><span class="cl">	visible <span class="k">if</span> GENTOO_LINUX
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="--openrc-runit-and-other-script-based-systems-and-managers">[ ] OpenRC, runit and other script based systems and managers</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_LINUX_INIT_SCRIPT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;OpenRC, runit and other script based systems and managers&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	default y <span class="k">if</span> GENTOO_LINUX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BINFMT_SCRIPT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CGROUPS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> EPOLL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FILE_LOCKING
</span></span><span class="line"><span class="cl">	<span class="k">select</span> INOTIFY_USER
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SIGNALFD
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TIMERFD
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		The init system is the first thing that loads after the kernel booted.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		These config settings allow you to <span class="k">select</span> which init systems to support<span class="p">;</span>
</span></span><span class="line"><span class="cl">		instead of having to <span class="k">select</span> all the individual settings all over the
</span></span><span class="line"><span class="cl">		place, these settings allows you to <span class="k">select</span> all the settings at once.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		This particular setting enables all the known requirements <span class="k">for</span> OpenRC,
</span></span><span class="line"><span class="cl">		runit and similar script based systems and managers.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		If you are unsure about this, it is best to leave this setting enabled.
</span></span></code></pre></td></tr></table>
</div>
</div><p>&ldquo;init&quot;系统(系统与服务管理器).&ldquo;init&quot;是内核启动的第一个用户空间程序(PID=1),也是所有用户态进程的&quot;大总管&rdquo;([提示]所有内核态进程的大总管是PID=2的[kthreadd]).
<a href="http://www.gentoo.org/doc/en/openrc-migration.xml">OpenRC</a>是Gentoo传统的&quot;init&quot;系统,使用基于<a href="https://wiki.archlinux.org/index.php/SysVinit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">SysVinit</a>的传统启动脚本技术.选&quot;Y&quot;后,所有OpenRC所必需的内核选项(目前仅有CONFIG_BINFMT_SCRIPT)都会被自动选中.不确定的选&quot;Y&rdquo;.</p>
<h3 id="-systemd">[*] systemd</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_LINUX_INIT_SYSTEMD
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;systemd&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX <span class="o">&amp;&amp;</span> GENTOO_LINUX_UDEV
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> AUTOFS_FS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BLK_DEV_BSG
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BPF_SYSCALL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CGROUP_BPF
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CGROUPS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CRYPTO_HMAC 
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CRYPTO_SHA256
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CRYPTO_USER_API_HASH
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEVPTS_MULTIPLE_INSTANCES
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DMIID <span class="k">if</span> X86_32 <span class="o">||</span> X86_64 <span class="o">||</span> X86
</span></span><span class="line"><span class="cl">	<span class="k">select</span> EPOLL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FANOTIFY
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FHANDLE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FILE_LOCKING
</span></span><span class="line"><span class="cl">	<span class="k">select</span> INOTIFY_USER
</span></span><span class="line"><span class="cl">	<span class="k">select</span> IPV6
</span></span><span class="line"><span class="cl">	<span class="k">select</span> KCMP
</span></span><span class="line"><span class="cl">	<span class="k">select</span> NET
</span></span><span class="line"><span class="cl">	<span class="k">select</span> NET_NS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PROC_FS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECCOMP <span class="k">if</span> HAVE_ARCH_SECCOMP
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECCOMP_FILTER <span class="k">if</span> HAVE_ARCH_SECCOMP_FILTER
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SIGNALFD
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SYSFS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TIMERFD
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TMPFS_POSIX_ACL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TMPFS_XATTR
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> ANON_INODES
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BLOCK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> EVENTFD
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FSNOTIFY
</span></span><span class="line"><span class="cl">	<span class="k">select</span> INET
</span></span><span class="line"><span class="cl">	<span class="k">select</span> NLATTR
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		The init system is the first thing that loads after the kernel booted.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		These config settings allow you to <span class="k">select</span> which init systems to support<span class="p">;</span>
</span></span><span class="line"><span class="cl">		instead of having to <span class="k">select</span> all the individual settings all over the
</span></span><span class="line"><span class="cl">		place, these settings allows you to <span class="k">select</span> all the settings at once.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		This particular setting enables all the known requirements <span class="k">for</span> systemd<span class="p">;</span>
</span></span><span class="line"><span class="cl">		it also enables suggested optional settings, as the package suggests to.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endmenu
</span></span></code></pre></td></tr></table>
</div>
</div><p>尽管并非完美无缺,但是<a href="http://linuxtoy.org/archives/more-than-upstart-systemd.html">systemd</a>确实是目前风头最劲的&quot;init&quot;系统,大有在Linux世界一统江湖的霸气和潜力.仅在你打算<a href="http://rca.is-programmer.com/2013/7/17/from-openrc-to-systemd.40004.html">从OpenRC迁移到systemd</a>时选&quot;Y&quot;.选&quot;Y&quot;后,内核中所有被<a href="http://wiki.gentoo.org/wiki/Systemd">systemd</a>依赖的选项都将被自动选中,包括<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>建议的(而非必须的)选项,总计约20项.</p>
<h2 id="--kernel-self-protection-project">[ ] Kernel Self Protection Project</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menuconfig GENTOO_KERNEL_SELF_PROTECTION
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Kernel Self Protection Project&#34;</span>
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		Recommended Kernel settings based on the suggestions from the Kernel Self Protection Project
</span></span><span class="line"><span class="cl">		See: https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
</span></span><span class="line"><span class="cl">		Note, there may be additional settings <span class="k">for</span> which the CONFIG_ setting is invisible in menuconfig due 
</span></span><span class="line"><span class="cl">		to unmet dependencies. Search <span class="k">for</span> GENTOO_KERNEL_SELF_PROTECTION_COMMON and search <span class="k">for</span> 
</span></span><span class="line"><span class="cl">		GENTOO_KERNEL_SELF_PROTECTION_<span class="o">{</span>X86_64, ARM64, X86_32, ARM<span class="o">}</span> <span class="k">for</span> dependency information on your 
</span></span><span class="line"><span class="cl">		specific architecture.
</span></span><span class="line"><span class="cl">		Note 2: Please see the URL above <span class="k">for</span> numeric settings, e.g. <span class="nv">CONFIG_DEFAULT_MMAP_MIN_ADDR</span><span class="o">=</span><span class="m">65536</span> 
</span></span><span class="line"><span class="cl">		<span class="k">for</span> X86_64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> GENTOO_KERNEL_SELF_PROTECTION
</span></span></code></pre></td></tr></table>
</div>
</div><p>基于内核自我保护项目建议的推荐内核设置
请参阅：https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings
注意，可能还有其他设置，由于未满足依赖关系，CONFIG_设置在menuconfig中不可见。搜索GENTOO_KERNEL_SELF_PROTECTION_COMMON并搜索GENTO_KERNEL_SELF_PROTECTION_{X86_64，ARM64，X86_32，ARM}以获取有关特定体系结构的依赖性信息。
注2：有关数字设置，请参阅上面的URL，例如CONFIG_DEFAULT_MMAP_MIN_ADDR=65536（对于X86_64）</p>
<h3 id="----kernel-self-protection-project">&mdash; Kernel Self Protection Project</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_KERNEL_SELF_PROTECTION_COMMON
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable Kernel Self Protection Project Recommendations&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX <span class="o">&amp;&amp;</span> !ACPI_CUSTOM_METHOD <span class="o">&amp;&amp;</span> !COMPAT_BRK <span class="o">&amp;&amp;</span> !PROC_KCORE <span class="o">&amp;&amp;</span> !COMPAT_VDSO <span class="o">&amp;&amp;</span> !KEXEC <span class="o">&amp;&amp;</span> !HIBERNATION <span class="o">&amp;&amp;</span> !LEGACY_PTYS <span class="o">&amp;&amp;</span> !X86_X32_ABI <span class="o">&amp;&amp;</span> !MODIFY_LDT_SYSCALL <span class="o">&amp;&amp;</span> GCC_PLUGINS <span class="o">&amp;&amp;</span> !IOMMU_DEFAULT_DMA_LAZY <span class="o">&amp;&amp;</span> !IOMMU_DEFAULT_PASSTHROUGH <span class="o">&amp;&amp;</span> IOMMU_DEFAULT_DMA_STRICT <span class="o">&amp;&amp;</span> SECURITY <span class="o">&amp;&amp;</span> !ARCH_EPHEMERAL_INODES  <span class="o">&amp;&amp;</span> RANDSTRUCT_PERFORMANCE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BUG
</span></span><span class="line"><span class="cl">	<span class="k">select</span> STRICT_KERNEL_RWX
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEBUG_WX
</span></span><span class="line"><span class="cl">	<span class="k">select</span> STACKPROTECTOR
</span></span><span class="line"><span class="cl">	<span class="k">select</span> STACKPROTECTOR_STRONG
</span></span><span class="line"><span class="cl">	<span class="k">select</span> STRICT_DEVMEM <span class="k">if</span> <span class="nv">DEVMEM</span><span class="o">=</span>y
</span></span><span class="line"><span class="cl">	<span class="k">select</span> IO_STRICT_DEVMEM <span class="k">if</span> <span class="nv">DEVMEM</span><span class="o">=</span>y
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SYN_COOKIES
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEBUG_CREDENTIALS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEBUG_NOTIFIERS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEBUG_LIST
</span></span><span class="line"><span class="cl">	<span class="k">select</span> DEBUG_SG
</span></span><span class="line"><span class="cl">	<span class="k">select</span> HARDENED_USERCOPY <span class="k">if</span> <span class="nv">HAVE_HARDENED_USERCOPY_ALLOCATOR</span><span class="o">=</span>y
</span></span><span class="line"><span class="cl">	<span class="k">select</span> KFENCE <span class="k">if</span> HAVE_ARCH_KFENCE <span class="o">&amp;&amp;</span> <span class="o">(</span>!SLAB <span class="o">||</span> SLUB<span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RANDOMIZE_KSTACK_OFFSET_DEFAULT <span class="k">if</span> HAVE_ARCH_RANDOMIZE_KSTACK_OFFSET <span class="o">&amp;&amp;</span> <span class="o">(</span>INIT_STACK_NONE <span class="o">||</span> !CC_IS_CLANG <span class="o">||</span> CLANG_VERSION&gt;<span class="o">=</span>140000<span class="o">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECURITY_LANDLOCK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SCHED_CORE <span class="k">if</span> SCHED_SMT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BUG_ON_DATA_CORRUPTION
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SCHED_STACK_END_CHECK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECCOMP <span class="k">if</span> HAVE_ARCH_SECCOMP
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECCOMP_FILTER <span class="k">if</span> HAVE_ARCH_SECCOMP_FILTER
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECURITY_YAMA
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SLAB_FREELIST_RANDOM
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SLAB_FREELIST_HARDENED
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SHUFFLE_PAGE_ALLOCATOR
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SLUB_DEBUG
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_POISONING
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_POISONING_NO_SANITY
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_POISONING_ZERO
</span></span><span class="line"><span class="cl">	<span class="k">select</span> INIT_ON_ALLOC_DEFAULT_ON
</span></span><span class="line"><span class="cl">	<span class="k">select</span> INIT_ON_FREE_DEFAULT_ON
</span></span><span class="line"><span class="cl">	<span class="k">select</span> REFCOUNT_FULL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FORTIFY_SOURCE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SECURITY_DMESG_RESTRICT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PANIC_ON_OOPS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_LATENT_ENTROPY
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_STRUCTLEAK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_STRUCTLEAK_BYREF_ALL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_RANDSTRUCT 
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_RANDSTRUCT_PERFORMANCE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> ZERO_CALL_USED_REGS <span class="k">if</span> CC_HAS_ZERO_CALL_USED_REGS
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		Search <span class="k">for</span> GENTOO_KERNEL_SELF_PROTECTION_<span class="o">{</span>X86_64, ARM64, X86_32, ARM<span class="o">}</span> <span class="k">for</span> dependency 
</span></span><span class="line"><span class="cl">		information on your specific architecture.  Note 2: Please see the URL above <span class="k">for</span> 
</span></span><span class="line"><span class="cl">		numeric settings, e.g. <span class="nv">CONFIG_DEFAULT_MMAP_MIN_ADDR</span><span class="o">=</span><span class="m">65536</span> <span class="k">for</span> X86_64
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config GENTOO_KERNEL_SELF_PROTECTION_X86_64
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;X86_64 KSPP Settings&#34;</span> <span class="k">if</span> GENTOO_KERNEL_SELF_PROTECTION_COMMON
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on !X86_MSR <span class="o">&amp;&amp;</span> X86_64 <span class="o">&amp;&amp;</span> GENTOO_KERNEL_SELF_PROTECTION
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_STACKLEAK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> LEGACY_VSYSCALL_NONE
</span></span><span class="line"><span class="cl"> 	<span class="k">select</span> PAGE_TABLE_ISOLATION
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RANDOMIZE_BASE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RANDOMIZE_MEMORY
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RELOCATABLE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> VMAP_STACK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config GENTOO_KERNEL_SELF_PROTECTION_ARM64
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;ARM64 KSPP Settings&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on ARM64
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RANDOMIZE_BASE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RELOCATABLE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> ARM64_SW_TTBR0_PAN
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CONFIG_UNMAP_KERNEL_AT_EL0
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GCC_PLUGIN_STACKLEAK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> VMAP_STACK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config GENTOO_KERNEL_SELF_PROTECTION_X86_32
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;X86_32 KSPP Settings&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on !X86_MSR <span class="o">&amp;&amp;</span> !MODIFY_LDT_SYSCALL <span class="o">&amp;&amp;</span> !M486 <span class="o">&amp;&amp;</span> X86_32
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> HIGHMEM64G
</span></span><span class="line"><span class="cl">	<span class="k">select</span> X86_PAE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RANDOMIZE_BASE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> RELOCATABLE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_TABLE_ISOLATION
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config GENTOO_KERNEL_SELF_PROTECTION_ARM
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;ARM KSPP Settings&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on !OABI_COMPAT <span class="o">&amp;&amp;</span> ARM
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">select</span> VMSPLIT_3G
</span></span><span class="line"><span class="cl">	<span class="k">select</span> STRICT_MEMORY_RWX
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CPU_SW_DOMAIN_PAN
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endif
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="-print-firmware-information-that-the-kernel-attempts-to-load">[*] Print firmware information that the kernel attempts to load</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENTOO_PRINT_FIRMWARE_INFO
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Print firmware information that the kernel attempts to load&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	depends on GENTOO_LINUX
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">		Enable this option to print information about firmware that the kernel
</span></span><span class="line"><span class="cl">		is attempting to load.  This information can be accessible via the
</span></span><span class="line"><span class="cl">		dmesg command-line utility
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		See the settings that become available <span class="k">for</span> more details and fine-tuning.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endmenu
</span></span></code></pre></td></tr></table>
</div>
</div><p>启用此选项可以打印有关内核试图加载的固件的信息。
可以通过<code>dmesg</code>命令行实用程序访问此信息
有关更多详细信息和微调，请参阅可用的设置。</p>
<h1 id="-64-bit-kernel">[*] 64-bit kernel</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># Select 32 or 64 bit</span>
</span></span><span class="line"><span class="cl">config 64BIT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;64-bit kernel&#34;</span> <span class="k">if</span> <span class="s2">&#34;</span><span class="k">$(</span>ARCH<span class="k">)</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="s2">&#34;x86&#34;</span>
</span></span><span class="line"><span class="cl">	default <span class="s2">&#34;</span><span class="k">$(</span>ARCH<span class="k">)</span><span class="s2">&#34;</span> !<span class="o">=</span> <span class="s2">&#34;i386&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Say yes to build a 64-bit kernel - formerly known as x86_64
</span></span><span class="line"><span class="cl">	  Say no to build a 32-bit kernel - formerly known as i386
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译64位内核.本文仅讲述x86_64(AMD64)平台的内核编译,所以这个是必选项.</p>
<h1 id="general-setup-常规设置">General setup 常规设置</h1>
<h2 id="--compile-also-drivers-which-will-not-load">[ ] Compile also drivers which will not load</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config COMPILE_TEST
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Compile also drivers which will not load&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAS_IOMEM
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Some drivers can be compiled on a different platform than they are
</span></span><span class="line"><span class="cl">	  intended to be run on. Despite they cannot be loaded there <span class="o">(</span>or even
</span></span><span class="line"><span class="cl">	  when they load they cannot be used due to missing HW support<span class="o">)</span>,
</span></span><span class="line"><span class="cl">	  developers still, opposing to distributors, might want to build such
</span></span><span class="line"><span class="cl">	  drivers to compile-test them.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If you are a developer and want to build everything available, say Y
</span></span><span class="line"><span class="cl">	  here. If you are a user/distributor, say N here to exclude useless
</span></span><span class="line"><span class="cl">	  drivers to be distributed.
</span></span></code></pre></td></tr></table>
</div>
</div><p>显示专属于其他平台 (非 x86 平台) 的驱动选项(需要交叉编译), 仅供驱动开发者使用, 普通的发行版制作者应该选 &ldquo;N&rdquo;.</p>
<h2 id="-compile-the-kernel-with-warnings-as-errors">[*] Compile the kernel with warnings as errors</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config WERROR
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Compile the kernel with warnings as errors&#34;</span>
</span></span><span class="line"><span class="cl">	default COMPILE_TEST
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  A kernel build should not cause any compiler warnings, and this
</span></span><span class="line"><span class="cl">	  enables the <span class="s1">&#39;-Werror&#39;</span> <span class="o">(</span><span class="k">for</span> C<span class="o">)</span> and <span class="s1">&#39;-Dwarnings&#39;</span> <span class="o">(</span><span class="k">for</span> Rust<span class="o">)</span> flags
</span></span><span class="line"><span class="cl">	  to enforce that rule by default.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  However, <span class="k">if</span> you have a new <span class="o">(</span>or very old<span class="o">)</span> compiler with odd and
</span></span><span class="line"><span class="cl">	  unusual warnings, or you have some architecture with problems,
</span></span><span class="line"><span class="cl">	  you may need to disable this config option in order to
</span></span><span class="line"><span class="cl">	  successfully build the kernel.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If in doubt, say Y.
</span></span></code></pre></td></tr></table>
</div>
</div><p>内核构建不应导致任何编译器警告，这将在默认情况下启用“-Werror”（对于C）和“-Dwarnings”（对于Rust）标志来强制执行该规则。
但是，如果您有一个新的（或非常旧的）编译器出现奇怪和不寻常的警告，或者您的某些体系结构有问题，则可能需要禁用此配置选项才能成功构建内核。</p>
<h2 id="me--local-version---append-to-kernel-release">(me)  Local version - append to kernel release</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config LOCALVERSION
</span></span><span class="line"><span class="cl">	string <span class="s2">&#34;Local version - append to kernel release&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Append an extra string to the end of your kernel version.
</span></span><span class="line"><span class="cl">	  This will show up when you <span class="nb">type</span> uname, <span class="k">for</span> example.
</span></span><span class="line"><span class="cl">	  The string you <span class="nb">set</span> here will be appended after the contents of
</span></span><span class="line"><span class="cl">	  any files with a filename matching localversion* in your
</span></span><span class="line"><span class="cl">	  object and <span class="nb">source</span> tree, in that order.  Your total string can
</span></span><span class="line"><span class="cl">	  be a maximum of <span class="m">64</span> characters.
</span></span></code></pre></td></tr></table>
</div>
</div><p>在内核版本后面加上自定义的版本字符串(不能超过64位),用<code>uname -a</code>命令查看。如果不清楚，则选择 N就可以。</p>
<h2 id="-automatically-append-version-information-to-the-version-string">[*] Automatically append version information to the version string</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config LOCALVERSION_AUTO
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Automatically append version information to the version string&#34;</span>
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">	depends on !COMPILE_TEST
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This will try to automatically determine <span class="k">if</span> the current tree is a
</span></span><span class="line"><span class="cl">	  release tree by looking <span class="k">for</span> git tags that belong to the current
</span></span><span class="line"><span class="cl">	  top of tree revision.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  A string of the format -gxxxxxxxx will be added to the localversion
</span></span><span class="line"><span class="cl">	  <span class="k">if</span> a git-based tree is found.  The string generated by this will be
</span></span><span class="line"><span class="cl">	  appended after any matching localversion* files, and after the value
</span></span><span class="line"><span class="cl">	  <span class="nb">set</span> in CONFIG_LOCALVERSION.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  <span class="o">(</span>The actual string used here is the first eight characters produced
</span></span><span class="line"><span class="cl">	  by running the command:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	    $ git rev-parse --verify HEAD
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  which is <span class="k">done</span> within the script <span class="s2">&#34;scripts/setlocalversion&#34;</span>.<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>自动在上一个选项<code>版本字符串(CONFIG_LOCALVERSION)</code>后面添加版本信息(类似&quot;-gxxxxxxxx&quot;格式),这个选项会自动探测内核并且生成相应的版本。在编译时需要有 perl 及 git 仓库的支持。在一般情况下，建议选择 Y。</p>
<h2 id="--build-id-salt">()  Build ID Salt</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config BUILD_SALT
</span></span><span class="line"><span class="cl">	string <span class="s2">&#34;Build ID Salt&#34;</span>
</span></span><span class="line"><span class="cl">	default
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  The build ID is used to link binaries and their debug info. Setting
</span></span><span class="line"><span class="cl">	  this option will use the value in the calculation of the build id.
</span></span><span class="line"><span class="cl">	  This is mostly useful <span class="k">for</span> distributions which want to ensure the
</span></span><span class="line"><span class="cl">	  build is unique between builds. It<span class="err">&#39;</span>s safe to leave the default.
</span></span></code></pre></td></tr></table>
</div>
</div><p>内部版本ID用于链接二进制文件及其调试信息。设置此选项将在生成id的计算中使用该值。
这对于希望确保生成在生成之间唯一的分发版非常有用。保留默认设置是安全的。</p>
<h2 id="kernel-compression-mode-zstd-----">Kernel compression mode (ZSTD)  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">choice
</span></span><span class="line"><span class="cl">	prompt <span class="s2">&#34;Kernel compression mode&#34;</span>
</span></span><span class="line"><span class="cl">	default KERNEL_GZIP
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_GZIP <span class="o">||</span> HAVE_KERNEL_BZIP2 <span class="o">||</span> HAVE_KERNEL_LZMA <span class="o">||</span> HAVE_KERNEL_XZ <span class="o">||</span> HAVE_KERNEL_LZO <span class="o">||</span> HAVE_KERNEL_LZ4 <span class="o">||</span> HAVE_KERNEL_ZSTD <span class="o">||</span> HAVE_KERNEL_UNCOMPRESSED
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  The linux kernel is a kind of self-extracting executable.
</span></span><span class="line"><span class="cl">	  Several compression algorithms are available, which differ
</span></span><span class="line"><span class="cl">	  in efficiency, compression and decompression speed.
</span></span><span class="line"><span class="cl">	  Compression speed is only relevant when building a kernel.
</span></span><span class="line"><span class="cl">	  Decompression speed is relevant at each boot.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If you have any problems with bzip2 or lzma compressed
</span></span><span class="line"><span class="cl">	  kernels, mail me <span class="o">(</span>Alain Knaff<span class="o">)</span> &lt;alain@knaff.lu&gt;. <span class="o">(</span>An older
</span></span><span class="line"><span class="cl">	  version of this functionality <span class="o">(</span>bzip2 only<span class="o">)</span>, <span class="k">for</span> 2.4, was
</span></span><span class="line"><span class="cl">	  supplied by Christian Ludwig<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  High compression options are mostly useful <span class="k">for</span> users, who
</span></span><span class="line"><span class="cl">	  are low on disk space <span class="o">(</span>embedded systems<span class="o">)</span>, but <span class="k">for</span> whom ram
</span></span><span class="line"><span class="cl">	  size matters less.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If in doubt, <span class="k">select</span> <span class="s1">&#39;gzip&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_GZIP
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Gzip&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_GZIP
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  The old and tried gzip compression. It provides a good balance
</span></span><span class="line"><span class="cl">	  between compression ratio and decompression speed.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_BZIP2
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Bzip2&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_BZIP2
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Its compression ratio and speed is intermediate.
</span></span><span class="line"><span class="cl">	  Decompression speed is slowest among the choices.  The kernel
</span></span><span class="line"><span class="cl">	  size is about 10% smaller with bzip2, in comparison to gzip.
</span></span><span class="line"><span class="cl">	  Bzip2 uses a large amount of memory. For modern kernels you
</span></span><span class="line"><span class="cl">	  will need at least 8MB RAM or more <span class="k">for</span> booting.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_LZMA
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;LZMA&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_LZMA
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This compression algorithm<span class="err">&#39;</span>s ratio is best.  Decompression speed
</span></span><span class="line"><span class="cl">	  is between gzip and bzip2.  Compression is slowest.
</span></span><span class="line"><span class="cl">	  The kernel size is about 33% smaller with LZMA in comparison to gzip.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_XZ
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;XZ&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_XZ
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  XZ uses the LZMA2 algorithm and instruction <span class="nb">set</span> specific
</span></span><span class="line"><span class="cl">	  BCJ filters which can improve compression ratio of executable
</span></span><span class="line"><span class="cl">	  code. The size of the kernel is about 30% smaller with XZ in
</span></span><span class="line"><span class="cl">	  comparison to gzip. On architectures <span class="k">for</span> which there is a BCJ
</span></span><span class="line"><span class="cl">	  filter <span class="o">(</span>i386, x86_64, ARM, IA-64, PowerPC, and SPARC<span class="o">)</span>, XZ
</span></span><span class="line"><span class="cl">	  will create a few percent smaller kernel than plain LZMA.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  The speed is about the same as with LZMA: The decompression
</span></span><span class="line"><span class="cl">	  speed of XZ is better than that of bzip2 but worse than gzip
</span></span><span class="line"><span class="cl">	  and LZO. Compression is slow.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_LZO
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;LZO&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_LZO
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Its compression ratio is the poorest among the choices. The kernel
</span></span><span class="line"><span class="cl">	  size is about 10% bigger than gzip<span class="p">;</span> however its speed
</span></span><span class="line"><span class="cl">	  <span class="o">(</span>both compression and decompression<span class="o">)</span> is the fastest.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_LZ4
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;LZ4&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_LZ4
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  LZ4 is an LZ77-type compressor with a fixed, byte-oriented encoding.
</span></span><span class="line"><span class="cl">	  A preliminary version of LZ4 de/compression tool is available at
</span></span><span class="line"><span class="cl">	  &lt;https://code.google.com/p/lz4/&gt;.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Its compression ratio is worse than LZO. The size of the kernel
</span></span><span class="line"><span class="cl">	  is about 8% bigger than LZO. But the decompression speed is
</span></span><span class="line"><span class="cl">	  faster than LZO.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_ZSTD
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;ZSTD&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_ZSTD
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  ZSTD is a compression algorithm targeting intermediate compression
</span></span><span class="line"><span class="cl">	  with fast decompression speed. It will compress better than GZIP and
</span></span><span class="line"><span class="cl">	  decompress around the same speed as LZO, but slower than LZ4. You
</span></span><span class="line"><span class="cl">	  will need at least <span class="m">192</span> KB RAM or more <span class="k">for</span> booting. The zstd <span class="nb">command</span>
</span></span><span class="line"><span class="cl">	  line tool is required <span class="k">for</span> compression.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config KERNEL_UNCOMPRESSED
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;None&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_KERNEL_UNCOMPRESSED
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Produce uncompressed kernel image. This option is usually not what
</span></span><span class="line"><span class="cl">	  you want. It is useful <span class="k">for</span> debugging the kernel in slow simulation
</span></span><span class="line"><span class="cl">	  environments, where decompressing and moving the kernel is awfully
</span></span><span class="line"><span class="cl">	  slow. This option allows early boot code to skip the decompressor
</span></span><span class="line"><span class="cl">	  and jump right at uncompressed kernel image.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endchoice
</span></span></code></pre></td></tr></table>
</div>
</div><p>内核镜像的压缩格式, 若采用btrfs可使用zstd格式。 你的系统中需要有相应的压缩工具。</p>
<h2 id="--default-init-path">()  Default init path</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config DEFAULT_INIT
</span></span><span class="line"><span class="cl">	string <span class="s2">&#34;Default init path&#34;</span>
</span></span><span class="line"><span class="cl">	default
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option determines the default init <span class="k">for</span> the system <span class="k">if</span> no <span class="nv">init</span><span class="o">=</span>
</span></span><span class="line"><span class="cl">	  option is passed on the kernel <span class="nb">command</span> line. If the requested path is
</span></span><span class="line"><span class="cl">	  not present, we will still <span class="k">then</span> move on to attempting further
</span></span><span class="line"><span class="cl">	  locations <span class="o">(</span>e.g. /sbin/init, etc<span class="o">)</span>. If this is empty, we will just use
</span></span><span class="line"><span class="cl">	  the fallback list when <span class="nv">init</span><span class="o">=</span> is not passed.
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在内核命令行上没有传递init=选项，则此选项确定系统的默认init。
如果请求的路径不存在，我们仍将继续尝试其他位置（例如/sbin/init等）。
如果这是空的，那么当init=未被传递时，我们将只使用回退列表。</p>
<h2 id="amd-default-hostname">(amd) Default hostname</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config DEFAULT_HOSTNAME
</span></span><span class="line"><span class="cl">	string <span class="s2">&#34;Default hostname&#34;</span>
</span></span><span class="line"><span class="cl">	default <span class="s2">&#34;(none)&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option determines the default system hostname before userspace
</span></span><span class="line"><span class="cl">	  calls sethostname<span class="o">(</span>2<span class="o">)</span>. The kernel traditionally uses <span class="s2">&#34;(none)&#34;</span> here,
</span></span><span class="line"><span class="cl">	  but you may wish to use a different default here to make a minimal
</span></span><span class="line"><span class="cl">	  system more usable with less configuration.
</span></span></code></pre></td></tr></table>
</div>
</div><p>设置默认主机名, 默认值是 &ldquo;(none)&rdquo;. 用户可以随后使用系统调用 sethostname() 来修改主机名.
此选项在用户空间调用sethostname（2）之前确定默认系统主机名。
内核传统上在这里使用“（none）”，但您可能希望在这里使用不同的默认值，以使最小的系统在较少的配置下更可用。</p>
<h2 id="---system-v-ipc">-*- System V IPC</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config SYSVIPC
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;System V IPC&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Inter Process Communication is a suite of library functions and
</span></span><span class="line"><span class="cl">	  system calls which <span class="nb">let</span> processes <span class="o">(</span>running programs<span class="o">)</span> synchronize and
</span></span><span class="line"><span class="cl">	  exchange information. It is generally considered to be a good thing,
</span></span><span class="line"><span class="cl">	  and some programs won<span class="s1">&#39;t run unless you say Y here. In particular, if
</span></span></span><span class="line"><span class="cl"><span class="s1">	  you want to run the DOS emulator dosemu under Linux (read the
</span></span></span><span class="line"><span class="cl"><span class="s1">	  DOSEMU-HOWTO, available from &lt;http://www.tldp.org/docs.html#howto&gt;),
</span></span></span><span class="line"><span class="cl"><span class="s1">	  you&#39;</span>ll need to say Y here.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  You can find documentation about IPC with <span class="s2">&#34;info ipc&#34;</span> and also in
</span></span><span class="line"><span class="cl">	  section 6.4 of the Linux Programmer<span class="err">&#39;</span>s Guide, available from
</span></span><span class="line"><span class="cl">	  &lt;http://www.tldp.org/guides.html&gt;.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config SYSVIPC_SYSCTL
</span></span><span class="line"><span class="cl">	bool
</span></span><span class="line"><span class="cl">	depends on SYSVIPC
</span></span><span class="line"><span class="cl">	depends on SYSCTL
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config SYSVIPC_COMPAT
</span></span><span class="line"><span class="cl">	def_bool y
</span></span><span class="line"><span class="cl">	depends on COMPAT <span class="o">&amp;&amp;</span> SYSVIPC
</span></span></code></pre></td></tr></table>
</div>
</div><p>System V <a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/">进程间通信(Inter Process Communication，IPC)</a>支持,用于进程间同步和交换数据,许多程序需要这个功能。选&quot;Y&quot;,除非你确实知道自己在做什么</p>
<p>System V 进程间通信（IPC）支持，许多程序需要这个功能，因此选择 Y。中间过程连接是一组功能和系统调用，使得进程能够同步和交换信息。可以用 info ipc 命令来了解 IPC 的具体用法。</p>
<p>是组系统调用及函数库，它能让程序彼此间同步进行交换信息。某些程序以及 DOS 模拟环境都需要它。为进程提供通信机制，这将使系统中各进程间有交换信息与保持同步的能力。有些程序只有在选 Y 的情况下才能运行，所以不用考虑，这里一定要选。</p>
<h2 id="-posix-message-queues">[*] POSIX Message Queues</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config POSIX_MQUEUE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;POSIX Message Queues&#34;</span>
</span></span><span class="line"><span class="cl">	depends on NET
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  POSIX variant of message queues is a part of IPC. In POSIX message
</span></span><span class="line"><span class="cl">	  queues every message has a priority which decides about succession
</span></span><span class="line"><span class="cl">	  of receiving it by a process. If you want to compile and run
</span></span><span class="line"><span class="cl">	  programs written e.g. <span class="k">for</span> Solaris with use of its POSIX message
</span></span><span class="line"><span class="cl">	  queues <span class="o">(</span>functions mq_*<span class="o">)</span> say Y here.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  POSIX message queues are visible as a filesystem called <span class="s1">&#39;mqueue&#39;</span>
</span></span><span class="line"><span class="cl">	  and can be mounted somewhere <span class="k">if</span> you want to <span class="k">do</span> filesystem
</span></span><span class="line"><span class="cl">	  operations on message queues.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If unsure, say Y.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config POSIX_MQUEUE_SYSCTL
</span></span><span class="line"><span class="cl">	bool
</span></span><span class="line"><span class="cl">	depends on POSIX_MQUEUE
</span></span><span class="line"><span class="cl">	depends on SYSCTL
</span></span><span class="line"><span class="cl">	default y
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>POSIX（可移植操作系统接口）消息队列是 POSIX IPC 中的一部分，在通信队列中有较高的优先权来保持通信畅通。</li>
<li>编译和运行那些使用 &ldquo;mq_*&rdquo; 系统调用的程序 (比如为 Solaris 开发的程序)</li>
<li>使用 Docker 容器</li>
<li>POSIX 消息队列可以作为 &ldquo;mqueue&rdquo; 文件系统挂载以方便用户对队列进行操作</li>
<li>建议勾选。</li>
</ul>
<p>需要 mqueue 库来支持这些特性。它是作为一个文件系统存在（mqueue），可以设置它。为保证以后的不同程序的协同稳定。</p>
<h2 id="--general-notification-queue-通用通知机制">[ ] General notification queue 通用通知机制</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config WATCH_QUEUE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;General notification queue&#34;</span>
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  This is a general notification queue <span class="k">for</span> the kernel to pass events to
</span></span><span class="line"><span class="cl">	  userspace by splicing them into pipes.  It can be used in conjunction
</span></span><span class="line"><span class="cl">	  with watches <span class="k">for</span> key/keyring change notifications and device
</span></span><span class="line"><span class="cl">	  notifications.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  See Documentation/core-api/watch_queue.rst
</span></span></code></pre></td></tr></table>
</div>
</div><p>建议勾选。内核的通用通知队列。</p>
<p>启用通知缓冲区</p>
<blockquote>
<p>参见<a href="https://www.kernel.org/doc/html/latest/watch_queue.html">https://www.kernel.org/doc/html/latest/watch_queue.html</a>
<a href="https://xz.aliyun.com/t/11168">https://xz.aliyun.com/t/11168</a></p>
</blockquote>
<p><em>通用通知机制</em> 是建立在标准管道驱动之上的，其可以有效地将来自内核的通知消息拼接到用户打开的管道中，我们可以通过 <code>CONFIG_WATCH_QUEUE</code> 编译选项启用（默认开启），可以与<code>Key/keyring 通知</code>结合使用。</p>
<p>通用通知机制是建立在标准管道驱动之上的，它可以有效地将来自内核的通知消息拼接到用户空间打开的管道中。</p>
<p>该设施以一种特殊模式打开的管道形式出现，管道的内部环形缓冲区用于保存内核生成的消息。然后通过read()读出这些消息。在此类管道上禁用拼接以及类似的操作，因为它们希望在某些情况下将其添加的内容还原到环中-这可能最终会与通知消息重叠。</p>
<p>管道的所有者必须告诉内核它想通过该管道观察哪些源。只有连接到该管道上的源才会将消息插入其中。请注意，一个源可能绑定到多个管道，并同时将消息插入到所有管道中。</p>
<p>还可以将过滤器放置在管道上，以便在不感兴趣时可以忽略某些源类型和子事件。</p>
<p>如果环中没有可用的插槽，或者没有预分配的消息缓冲区可用，则将丢弃消息。在这两种情况下，read()都会在读取缓冲区中当前的最后一条消息后，将WATCH_META_LOSS_NOTIFICATION插入到输出缓冲区中。</p>
<p>请注意，当生成一个通知时，内核不会等待消费者收集它，而是继续执行。这意味着可以在持有自旋锁的同时生成通知，并且还可以保护内核不被用户空间故障无限期地阻碍。</p>
<h2 id="-enable-process_vm_readvwritev-syscalls">[*] Enable process_vm_readv/writev syscalls</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CROSS_MEMORY_ATTACH
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable process_vm_readv/writev syscalls&#34;</span>
</span></span><span class="line"><span class="cl">	depends on MMU
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Enabling this option adds the system calls process_vm_readv and
</span></span><span class="line"><span class="cl">	  process_vm_writev which allow a process with the correct privileges
</span></span><span class="line"><span class="cl">	  to directly <span class="nb">read</span> from or write to another process<span class="err">&#39;</span> address space.
</span></span><span class="line"><span class="cl">	  See the man page <span class="k">for</span> more details.
</span></span></code></pre></td></tr></table>
</div>
</div><p>Cross Memory Support
交叉内存支持, 也就是 process_vm_readv() 和 process_vm_writev() 系统调用支持. 从而允许有权限的进程直接读取 / 写入另外一个进程的地址空间. 现在它们只用于 openMPI 快速进程通信, 也可以用于调试程序. 未来也许还会有其他用途.</p>
<h2 id="-uselib-syscall-for-libc5-and-earlier">[*] uselib syscall (for libc5 and earlier)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config USELIB
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;uselib syscall (for libc5 and earlier)&#34;</span>
</span></span><span class="line"><span class="cl">	default ALPHA <span class="o">||</span> M68K <span class="o">||</span> SPARC
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables the uselib syscall, a system call used in the
</span></span><span class="line"><span class="cl">	  dynamic linker from libc5 and earlier.  glibc does not use this
</span></span><span class="line"><span class="cl">	  system call.  If you intend to run programs built on libc5 or
</span></span><span class="line"><span class="cl">	  earlier, you may need to <span class="nb">enable</span> this syscall.  Current systems
</span></span><span class="line"><span class="cl">	  running glibc can safely disable this.
</span></span></code></pre></td></tr></table>
</div>
</div><p>启用老旧的 uselib() 系统接口支持, 仅在你需要使用基于 libc5 的古董级程序时才需要, 不确定的选 &ldquo;N&rdquo;.</p>
<h2 id="--auditing-support">[ ] Auditing support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config AUDIT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Auditing support&#34;</span>
</span></span><span class="line"><span class="cl">	depends on NET
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Enable auditing infrastructure that can be used with another
</span></span><span class="line"><span class="cl">	  kernel subsystem, such as SELinux <span class="o">(</span>which requires this <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  logging of avc messages output<span class="o">)</span>.  System call auditing is included
</span></span><span class="line"><span class="cl">	  on architectures which support it.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config HAVE_ARCH_AUDITSYSCALL
</span></span><span class="line"><span class="cl">	bool
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config AUDITSYSCALL
</span></span><span class="line"><span class="cl">	def_bool y
</span></span><span class="line"><span class="cl">	depends on AUDIT <span class="o">&amp;&amp;</span> HAVE_ARCH_AUDITSYSCALL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> FSNOTIFY
</span></span></code></pre></td></tr></table>
</div>
</div><p>内核审计 (跟踪每个进程的活动情况) 支持, 某些安全相关的内核子系统 (例如 SELinux) 需要它。 但是它会<strong>与 systemd 冲突</strong>, 所以在使用 systemd 的系统上必须关闭。
对系统调用进行审计。 既可独立使用, 也可被其他内核子系统 (例如 SELinux) 使用。</p>
<p>审计支持，某些内核模块（例如 SELinux）需要它，只有同时选择其子项才能对系统调用进行审计。
允许审计 的下层能够被其他内核子系统使用，比如 SELinux，它需要这个来进行登录时的声音和视频输出。
没有 CONFIG_AUDITSYSCALL 时（即下一 个选项）无法进行系统调用。</p>
<p>Enable system-call auditing support (AUDITSYSCALL) 子选项表示支持对系统调用的审计，允许系统独立地或者通过其他内核的子系统，调用审计支持，比如 SELinux。要使用这种 审计的文件系统来查看特性，请确保 INOTIFY 已经被设置。这两个选项，要选择 Y 就都选择，以便调用其他内核。</p>
<h2 id="irq-subsystem-----">IRQ subsystem  &mdash;&gt;</h2>
<p>IRQ(中断请求) 子系统</p>
<h3 id="--expose-irq-internals-in-debugfs">[ ] Expose irq internals in debugfs</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config GENERIC_IRQ_DEBUGFS
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Expose irq internals in debugfs&#34;</span>
</span></span><span class="line"><span class="cl">	depends on DEBUG_FS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> GENERIC_IRQ_INJECTION
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Exposes internal state information through debugfs. Mostly <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  developers and debugging of hard to diagnose interrupt problems.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If you don<span class="err">&#39;</span>t know what to <span class="k">do</span> here, say N.
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 debugfs 中的 irq_domain_mapping 文件向用户显示硬件 IRQ 号 / Linux IRQ 号之间的对应关系. 仅用于开发调试.</p>
<p>Support sparse irq numbering           CONFIG_SPARSE_IRQ
稀疏IRQ号支持.它允许在小型设备上(例如嵌入式设备)定义一个很高的CONFIG_NR_CPUS值,但仍然不希望占用太多内核&quot;<a href="http://en.wikipedia.org/wiki/Memory_footprint">memory footprint</a>&quot;(一段可以被操作或被管理的内存区域)的场合.稀疏IRQ也更适合NUMA平台,因为它以一种对NUMA更友好的方式分发中断描述符.不确定的选&quot;N&quot;.</p>
<h2 id="timers-subsystem-----">Timers subsystem  &mdash;&gt;</h2>
<p>Linux 内核时钟子系统</p>
<h3 id="timer-tick-handling-idle-dynticks-system-tickless-idle-----">Timer tick handling (Idle dynticks system (tickless idle))  &mdash;&gt;</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">choice
</span></span><span class="line"><span class="cl">	prompt <span class="s2">&#34;Timer tick handling&#34;</span>
</span></span><span class="line"><span class="cl">	default NO_HZ_IDLE <span class="k">if</span> NO_HZ
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config HZ_PERIODIC
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Periodic timer ticks (constant rate, no dynticks)&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option keeps the tick running periodically at a constant
</span></span><span class="line"><span class="cl">	  rate, even when the CPU doesn<span class="s1">&#39;t need it.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">config NO_HZ_IDLE
</span></span></span><span class="line"><span class="cl"><span class="s1">	bool &#34;Idle dynticks system (tickless idle)&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">	select NO_HZ_COMMON
</span></span></span><span class="line"><span class="cl"><span class="s1">	help
</span></span></span><span class="line"><span class="cl"><span class="s1">	  This option enables a tickless idle system: timer interrupts
</span></span></span><span class="line"><span class="cl"><span class="s1">	  will only trigger on an as-needed basis when the system is idle.
</span></span></span><span class="line"><span class="cl"><span class="s1">	  This is usually interesting for energy saving.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">	  Most of the time you want to say Y here.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">config NO_HZ_FULL
</span></span></span><span class="line"><span class="cl"><span class="s1">	bool &#34;Full dynticks system (tickless)&#34;
</span></span></span><span class="line"><span class="cl"><span class="s1">	# NO_HZ_COMMON dependency
</span></span></span><span class="line"><span class="cl"><span class="s1">	# We need at least one periodic CPU for timekeeping
</span></span></span><span class="line"><span class="cl"><span class="s1">	depends on SMP
</span></span></span><span class="line"><span class="cl"><span class="s1">	depends on HAVE_CONTEXT_TRACKING_USER
</span></span></span><span class="line"><span class="cl"><span class="s1">	# VIRT_CPU_ACCOUNTING_GEN dependency
</span></span></span><span class="line"><span class="cl"><span class="s1">	depends on HAVE_VIRT_CPU_ACCOUNTING_GEN
</span></span></span><span class="line"><span class="cl"><span class="s1">	select NO_HZ_COMMON
</span></span></span><span class="line"><span class="cl"><span class="s1">	select RCU_NOCB_CPU
</span></span></span><span class="line"><span class="cl"><span class="s1">	select VIRT_CPU_ACCOUNTING_GEN
</span></span></span><span class="line"><span class="cl"><span class="s1">	select IRQ_WORK
</span></span></span><span class="line"><span class="cl"><span class="s1">	select CPU_ISOLATION
</span></span></span><span class="line"><span class="cl"><span class="s1">	help
</span></span></span><span class="line"><span class="cl"><span class="s1">	 Adaptively try to shutdown the tick whenever possible, even when
</span></span></span><span class="line"><span class="cl"><span class="s1">	 the CPU is running tasks. Typically this requires running a single
</span></span></span><span class="line"><span class="cl"><span class="s1">	 task on the CPU. Chances for running tickless are maximized when
</span></span></span><span class="line"><span class="cl"><span class="s1">	 the task mostly runs in userspace and has few kernel activity.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">	 You need to fill up the nohz_full boot parameter with the
</span></span></span><span class="line"><span class="cl"><span class="s1">	 desired range of dynticks CPUs to use it. This is implemented at
</span></span></span><span class="line"><span class="cl"><span class="s1">	 the expense of some overhead in user &lt;-&gt; kernel transitions:
</span></span></span><span class="line"><span class="cl"><span class="s1">	 syscalls, exceptions and interrupts.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">	 By default, without passing the nohz_full parameter, this behaves just
</span></span></span><span class="line"><span class="cl"><span class="s1">	 like NO_HZ_IDLE.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">	 If you&#39;</span>re a distro say Y.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endchoice
</span></span></code></pre></td></tr></table>
</div>
</div><p>选Idle dynticks system
内核时钟滴答处理程序, 更多信息可以参考内核源码树下的 &quot; Documentation/timers/NO_HZ.txt&quot; 文件</p>
<ul>
<li>Periodic timer ticks (constant rate, no dynticks)：无论 CPU 是否需要, 都强制按照固定频率不断触发时钟中断. 这是最耗电的方式, 不推荐使用</li>
<li>Idle dynticks system (tickless idle)：CPU 在空闲状态时不产生不必要的时钟中断, 以使处理器能够在较低能耗状态下运行以节约电力, 适合于大多数场合</li>
<li>Full dynticks system (tickless)：完全无滴嗒: 即使 CPU 在忙碌状态也尽可能关闭所有时钟中断, 适用于 CPU 在同一时间仅运行一个任务, 或者用户空间程序极少与内核交互的场合. 即使开启此选项, 也需要额外设置 &ldquo;nohz_full=?&rdquo; 内核命令行参数才能真正生效.
<del>* Full dynticks system on all CPUs by default：即使没有设置 &ldquo;nohz_full&rdquo; 引导参数, 也默认对所有 CPU(boot CPU 除外) 开启完全无滴答特性.</del></li>
</ul>
<h3 id="--old-idle-dynticks-config">[ ] Old Idle dynticks config</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config NO_HZ
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Old Idle dynticks config&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This is the old config entry that enables dynticks idle.
</span></span><span class="line"><span class="cl">	  We keep it around <span class="k">for</span> a little <span class="k">while</span> to enforce backward
</span></span><span class="line"><span class="cl">	  compatibility with older config files.
</span></span></code></pre></td></tr></table>
</div>
</div><p>等价于 CONFIG_NO_HZ_IDLE, 临时用来兼容老版本内核选项, 未来会被删除.</p>
<h3 id="-high-resolution-timer-support">[*] High Resolution Timer Support</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config HIGH_RES_TIMERS
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;High Resolution Timer Support&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TICK_ONESHOT
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables high resolution timer support. If your
</span></span><span class="line"><span class="cl">	  hardware is not capable <span class="k">then</span> this option only increases
</span></span><span class="line"><span class="cl">	  the size of the kernel image.
</span></span></code></pre></td></tr></table>
</div>
</div><p>高精度定时器 (hrtimer) 是从 2.6.16 开始引入, 用于取代传统 timer wheel( 基于 jiffies 定时器)的时钟子系统. 可以降低与内核其他模块的耦合性, 还可以提供比 1 毫秒更高的精度 (因为它可以读取 HPET/TSC 等新型硬件时钟源), 可以更好的支持音视频等对时间精度要求较高的应用. 建议选 &ldquo;Y&rdquo;.</p>
<blockquote>
<p>这里说的 &ldquo;定时器&rdquo; 是指 &ldquo;软件定时器&rdquo;, 而不是主板或 CPU 上集成的 硬件时钟发生器 (ACPI PM Timer/HPET Timer/TSC Timer).</p>
</blockquote>
<h3 id="100-clocksource-watchdog-maximum-allowable-skew-in---s">(100) Clocksource watchdog maximum allowable skew (in   s)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CLOCKSOURCE_WATCHDOG_MAX_SKEW_US
</span></span><span class="line"><span class="cl">	int <span class="s2">&#34;Clocksource watchdog maximum allowable skew (in μs)&#34;</span>
</span></span><span class="line"><span class="cl">	depends on CLOCKSOURCE_WATCHDOG
</span></span><span class="line"><span class="cl">	range <span class="m">50</span> <span class="m">1000</span>
</span></span><span class="line"><span class="cl">	default <span class="m">100</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Specify the maximum amount of allowable watchdog skew in
</span></span><span class="line"><span class="cl">	  microseconds before reporting the clocksource to be unstable.
</span></span></code></pre></td></tr></table>
</div>
</div><p>在报告时钟源不稳定之前，指定允许的看门狗偏斜的最大数量（以微秒为单位）。</p>
<h2 id="bpf-subsystem-----">BPF subsystem  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---enable-bpf-system-call">-*- Enable bpf() system call</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config BPF_SYSCALL
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable bpf() system call&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BPF
</span></span><span class="line"><span class="cl">	<span class="k">select</span> IRQ_WORK
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TASKS_RCU <span class="k">if</span> PREEMPTION
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TASKS_TRACE_RCU
</span></span><span class="line"><span class="cl">	<span class="k">select</span> BINARY_PRINTF
</span></span><span class="line"><span class="cl">	<span class="k">select</span> NET_SOCK_MSG <span class="k">if</span> NET
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_POOL <span class="k">if</span> NET
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Enable the bpf<span class="o">()</span> system call that allows to manipulate BPF programs
</span></span><span class="line"><span class="cl">	  and maps via file descriptors.
</span></span></code></pre></td></tr></table>
</div>
</div><p>开启内核的 bpf() 系统调用支持 (从 3.15 版本开始引入), 以支持 eBPF 功能。可用于内核调试与网络包过滤 (tcpdump,libpcap,iptables)。
Systemd依赖此项。</p>
<h3 id="-disable-unprivileged-bpf-by-default">[*] Disable unprivileged BPF by default</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config BPF_UNPRIV_DEFAULT_OFF
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Disable unprivileged BPF by default&#34;</span>
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">	depends on BPF_SYSCALL
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Disables unprivileged BPF by default by setting the corresponding
</span></span><span class="line"><span class="cl">	  /proc/sys/kernel/unprivileged_bpf_disabled knob to 2. An admin can
</span></span><span class="line"><span class="cl">	  still reenable it by setting it to <span class="m">0</span> later on, or permanently
</span></span><span class="line"><span class="cl">	  disable it by setting it to <span class="m">1</span> <span class="o">(</span>from which no other transition to
</span></span><span class="line"><span class="cl">	  <span class="m">0</span> is possible anymore<span class="o">)</span>.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Unprivileged BPF could be used to exploit certain potential
</span></span><span class="line"><span class="cl">	  speculative execution side-channel vulnerabilities on unmitigated
</span></span><span class="line"><span class="cl">	  affected hardware.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If you are unsure how to answer this question, answer Y.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">source</span> <span class="s2">&#34;kernel/bpf/preload/Kconfig&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>默认情况下，通过将相应的<code>/proc/sys/kernel/unprivileged_BPF_disabled</code>旋钮设置为2来禁用非特权BPF。
管理员仍然可以通过稍后将其设置为0来重新启用它，或者通过将其设置成1来永久禁用它（从此以后不可能再转换到0）
未经授权的BPF可用于利用未缓解的受影响硬件上的某些潜在推测性执行侧通道漏洞
如果您不确定如何回答这个问题，请回答Y。</p>
<h3 id="--preload-bpf-file-system-with-kernel-specific-program-and-map-iterators------">[ ] Preload BPF file system with kernel specific program and map iterators  &mdash;-</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menuconfig BPF_PRELOAD
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Preload BPF file system with kernel specific program and map iterators&#34;</span>
</span></span><span class="line"><span class="cl">	depends on BPF
</span></span><span class="line"><span class="cl">	depends on BPF_SYSCALL
</span></span><span class="line"><span class="cl">	<span class="c1"># The dependency on !COMPILE_TEST prevents it from being enabled</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># in allmodconfig or allyesconfig configurations</span>
</span></span><span class="line"><span class="cl">	depends on !COMPILE_TEST
</span></span><span class="line"><span class="cl">	<span class="k">select</span> USERMODE_DRIVER
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This builds kernel module with several embedded BPF programs that are
</span></span><span class="line"><span class="cl">	  pinned into BPF FS mount point as human readable files that are
</span></span><span class="line"><span class="cl">	  useful in debugging and introspection of BPF programs and maps.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> BPF_PRELOAD
</span></span><span class="line"><span class="cl">config BPF_PRELOAD_UMD
</span></span><span class="line"><span class="cl">	tristate <span class="s2">&#34;bpf_preload kernel module&#34;</span>
</span></span><span class="line"><span class="cl">	default m
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This builds bpf_preload kernel module with embedded BPF programs <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  introspection in bpffs.
</span></span><span class="line"><span class="cl">endif
</span></span></code></pre></td></tr></table>
</div>
</div><p>这用几个嵌入的BPF程序构建了内核模块，这些程序作为可读文件固定在BPF FS安装点中，在调试和内省BPF程序和映射时非常有用。
CONFIG_BPF_PRELOAD=y
CONFIG_BPF_PRELOAD_UMD=m</p>
<h2 id="preemption-model-voluntary-kernel-preemption-desktop-----">Preemption Model (Voluntary Kernel Preemption (Desktop))  &mdash;&gt;</h2>
<p>内核抢占模式，根据你的需要选server还是嵌入式内核</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">choice
</span></span><span class="line"><span class="cl">	prompt <span class="s2">&#34;Preemption Model&#34;</span>
</span></span><span class="line"><span class="cl">	default PREEMPT_NONE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config PREEMPT_NONE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;No Forced Preemption (Server)&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PREEMPT_NONE_BUILD <span class="k">if</span> !PREEMPT_DYNAMIC
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This is the traditional Linux preemption model, geared towards
</span></span><span class="line"><span class="cl">	  throughput. It will still provide good latencies most of the
</span></span><span class="line"><span class="cl">	  time, but there are no guarantees and occasional longer delays
</span></span><span class="line"><span class="cl">	  are possible.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Select this option <span class="k">if</span> you are building a kernel <span class="k">for</span> a server or
</span></span><span class="line"><span class="cl">	  scientific/computation system, or <span class="k">if</span> you want to maximize the
</span></span><span class="line"><span class="cl">	  raw processing power of the kernel, irrespective of scheduling
</span></span><span class="line"><span class="cl">	  latencies.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config PREEMPT_VOLUNTARY
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Voluntary Kernel Preemption (Desktop)&#34;</span>
</span></span><span class="line"><span class="cl">	depends on !ARCH_NO_PREEMPT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PREEMPT_VOLUNTARY_BUILD <span class="k">if</span> !PREEMPT_DYNAMIC
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option reduces the latency of the kernel by adding more
</span></span><span class="line"><span class="cl">	  <span class="s2">&#34;explicit preemption points&#34;</span> to the kernel code. These new
</span></span><span class="line"><span class="cl">	  preemption points have been selected to reduce the maximum
</span></span><span class="line"><span class="cl">	  latency of rescheduling, providing faster application reactions,
</span></span><span class="line"><span class="cl">	  at the cost of slightly lower throughput.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  This allows reaction to interactive events by allowing a
</span></span><span class="line"><span class="cl">	  low priority process to voluntarily preempt itself even <span class="k">if</span> it
</span></span><span class="line"><span class="cl">	  is in kernel mode executing a system call. This allows
</span></span><span class="line"><span class="cl">	  applications to run more <span class="s1">&#39;smoothly&#39;</span> even when the system is
</span></span><span class="line"><span class="cl">	  under load.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Select this <span class="k">if</span> you are building a kernel <span class="k">for</span> a desktop system.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config PREEMPT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Preemptible Kernel (Low-Latency Desktop)&#34;</span>
</span></span><span class="line"><span class="cl">	depends on !ARCH_NO_PREEMPT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PREEMPT_BUILD
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option reduces the latency of the kernel by making
</span></span><span class="line"><span class="cl">	  all kernel code <span class="o">(</span>that is not executing in a critical section<span class="o">)</span>
</span></span><span class="line"><span class="cl">	  preemptible.  This allows reaction to interactive events by
</span></span><span class="line"><span class="cl">	  permitting a low priority process to be preempted involuntarily
</span></span><span class="line"><span class="cl">	  even <span class="k">if</span> it is in kernel mode executing a system call and would
</span></span><span class="line"><span class="cl">	  otherwise not be about to reach a natural preemption point.
</span></span><span class="line"><span class="cl">	  This allows applications to run more <span class="s1">&#39;smoothly&#39;</span> even when the
</span></span><span class="line"><span class="cl">	  system is under load, at the cost of slightly lower throughput
</span></span><span class="line"><span class="cl">	  and a slight runtime overhead to kernel code.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Select this <span class="k">if</span> you are building a kernel <span class="k">for</span> a desktop or
</span></span><span class="line"><span class="cl">	  embedded system with latency requirements in the milliseconds
</span></span><span class="line"><span class="cl">	  range.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config PREEMPT_RT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Fully Preemptible Kernel (Real-Time)&#34;</span>
</span></span><span class="line"><span class="cl">	depends on EXPERT <span class="o">&amp;&amp;</span> ARCH_SUPPORTS_RT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PREEMPTION
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option turns the kernel into a real-time kernel by replacing
</span></span><span class="line"><span class="cl">	  various locking primitives <span class="o">(</span>spinlocks, rwlocks, etc.<span class="o">)</span> with
</span></span><span class="line"><span class="cl">	  preemptible priority-inheritance aware variants, enforcing
</span></span><span class="line"><span class="cl">	  interrupt threading and introducing mechanisms to <span class="nb">break</span> up long
</span></span><span class="line"><span class="cl">	  non-preemptible sections. This makes the kernel, except <span class="k">for</span> very
</span></span><span class="line"><span class="cl">	  low level and critical code paths <span class="o">(</span>entry code, scheduler, low
</span></span><span class="line"><span class="cl">	  level interrupt handling<span class="o">)</span> fully preemptible and brings most
</span></span><span class="line"><span class="cl">	  execution contexts under scheduler control.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Select this <span class="k">if</span> you are building a kernel <span class="k">for</span> systems which
</span></span><span class="line"><span class="cl">	  require real-time guarantees.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endchoice
</span></span></code></pre></td></tr></table>
</div>
</div><p>内核抢占模式。普通 PC 用户一般选 2，arm linux 选 1 就可以。</p>
<ul>
<li>No Forced Preemption (Server)：<strong>禁止内核抢占</strong>, 这是 Linux 的传统模式, 可以得到最大的吞吐量, 适合服务器和科学计算环境。针对于高吞吐量的设计，但有可能延时较长，适用于服务器或科学运算，或想要最大的运算能力，而不理会调度上的延时。</li>
<li>Voluntary Kernel Preemption (Desktop)：<strong>自愿内核抢占</strong>,通过在内核中设置明确的抢占点以允许明确的内核抢占,降低吞吐量和内核调度的最大延时，提供更快的应用程序响应，即使系统已经高负荷运转，应用程序仍然能运行的很 “流畅”，适合用户桌面环境。</li>
<li>Preemptible Kernel (Low-Latency Desktop)：<strong>主动内核抢占</strong>，允许抢占所有内核代码,更低的吞吐量，进一步降低内核的调度延时, 适合需要运行实时程序的场合或者追求最快响应速度的桌面环境.</li>
</ul>
<p>Preempt The Big Kernel Lock 可以抢占大内核锁, 应用于实时要求高的场合, 不适合服务器环境</p>
<h2 id="--preemption-behaviour-defined-on-boot">[ ] Preemption behaviour defined on boot</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config PREEMPT_DYNAMIC
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Preemption behaviour defined on boot&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_PREEMPT_DYNAMIC <span class="o">&amp;&amp;</span> !PREEMPT_RT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> JUMP_LABEL <span class="k">if</span> HAVE_PREEMPT_DYNAMIC_KEY
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PREEMPT_BUILD
</span></span><span class="line"><span class="cl">	default y <span class="k">if</span> HAVE_PREEMPT_DYNAMIC_CALL
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option allows to define the preemption model on the kernel
</span></span><span class="line"><span class="cl">	  <span class="nb">command</span> line parameter and thus override the default preemption
</span></span><span class="line"><span class="cl">	  model defined during compile time.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  The feature is primarily interesting <span class="k">for</span> Linux distributions which
</span></span><span class="line"><span class="cl">	  provide a pre-built kernel binary to reduce the number of kernel
</span></span><span class="line"><span class="cl">	  flavors they offer <span class="k">while</span> still offering different usecases.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  The runtime overhead is negligible with HAVE_STATIC_CALL_INLINE enabled
</span></span><span class="line"><span class="cl">	  but <span class="k">if</span> runtime patching is not available <span class="k">for</span> the specific architecture
</span></span><span class="line"><span class="cl">	  <span class="k">then</span> the potential overhead should be considered.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Interesting <span class="k">if</span> you want the same pre-built kernel should be used <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  both Server and Desktop workloads.
</span></span></code></pre></td></tr></table>
</div>
</div><p>此选项允许在内核命令行参数上定义抢占模型，从而覆盖编译时定义的默认抢占模型
该功能主要针对Linux发行版，这些发行版提供了预构建的内核二进制文件，以减少它们提供的内核风格的数量，同时仍然提供不同的用例
启用HAVE_STATIC_CALL_INLINE后，运行时开销可以忽略不计，但如果特定体系结构的运行时修补不可用，则应考虑潜在开销
有趣的是，如果您希望将相同的预构建内核同时用于服务器和桌面工作负载。</p>
<h2 id="--core-scheduling-for-smt">[ ] Core Scheduling for SMT</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config SCHED_CORE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Core Scheduling for SMT&#34;</span>
</span></span><span class="line"><span class="cl">	depends on SCHED_SMT
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option permits Core Scheduling, a means of coordinated task
</span></span><span class="line"><span class="cl">	  selection across SMT siblings. When enabled -- see
</span></span><span class="line"><span class="cl">	  prctl<span class="o">(</span>PR_SCHED_CORE<span class="o">)</span> -- task selection ensures that all SMT siblings
</span></span><span class="line"><span class="cl">	  will execute a task from the same <span class="s1">&#39;core group&#39;</span>, forcing idle when no
</span></span><span class="line"><span class="cl">	  matching task is found.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Use of this feature includes:
</span></span><span class="line"><span class="cl">	   - mitigation of some <span class="o">(</span>not all<span class="o">)</span> SMT side channels<span class="p">;</span>
</span></span><span class="line"><span class="cl">	   - limiting SMT interference to improve determinism and/or performance.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  SCHED_CORE is default disabled. When it is enabled and unused,
</span></span><span class="line"><span class="cl">	  which is the likely usage by Linux distributions, there should
</span></span><span class="line"><span class="cl">	  be no measurable impact on performance.
</span></span></code></pre></td></tr></table>
</div>
</div><p>此选项允许核心调度，这是一种跨SMT同级进行协调任务选择的方法。当启用时&ndash;参见prctl（PR_SCHED_CORE）&ndash;任务选择确保所有SMT兄弟将执行来自同一“核心组”的任务，当没有找到匹配的任务时强制空闲。</p>
<p>此功能的使用包括：</p>
<ul>
<li>减轻一些（不是全部）SMT侧通道;</li>
<li>限制SMT干扰以提高确定性和/或性能。</li>
</ul>
<p>SCHED_CORE默认禁用。当它被启用但未被使用时，这是Linux发行版可能使用的，对性能应该没有可测量的影响。</p>
<h2 id="cputask-time-and-stats-accounting-----">CPU/Task time and stats accounting  &mdash;&gt;</h2>
<p>CPU/进程的时间及状态统计</p>
<h3 id="cputime-accounting-simple-tick-based-cputime-accounting-----">Cputime accounting (Simple tick based cputime accounting)  &mdash;&gt;</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">choice
</span></span><span class="line"><span class="cl">	prompt <span class="s2">&#34;Cputime accounting&#34;</span>
</span></span><span class="line"><span class="cl">	default TICK_CPU_ACCOUNTING
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Kind of a stub config for the pure tick based cputime accounting</span>
</span></span><span class="line"><span class="cl">config TICK_CPU_ACCOUNTING
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Simple tick based cputime accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on !S390 <span class="o">&amp;&amp;</span> !NO_HZ_FULL
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This is the basic tick based cputime accounting that maintains
</span></span><span class="line"><span class="cl">	  statistics about user, system and idle <span class="nb">time</span> spent on per jiffies
</span></span><span class="line"><span class="cl">	  granularity.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If unsure, say Y.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config VIRT_CPU_ACCOUNTING_NATIVE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Deterministic task and CPU time accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_VIRT_CPU_ACCOUNTING <span class="o">&amp;&amp;</span> !NO_HZ_FULL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> VIRT_CPU_ACCOUNTING
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Select this option to <span class="nb">enable</span> more accurate task and CPU <span class="nb">time</span>
</span></span><span class="line"><span class="cl">	  accounting.  This is <span class="k">done</span> by reading a CPU counter on each
</span></span><span class="line"><span class="cl">	  kernel entry and <span class="nb">exit</span> and on transitions within the kernel
</span></span><span class="line"><span class="cl">	  between system, softirq and hardirq state, so there is a
</span></span><span class="line"><span class="cl">	  small performance impact.  In the <span class="k">case</span> of s390 or IBM POWER &gt; 5,
</span></span><span class="line"><span class="cl">	  this also enables accounting of stolen <span class="nb">time</span> on logically-partitioned
</span></span><span class="line"><span class="cl">	  systems.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config VIRT_CPU_ACCOUNTING_GEN
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Full dynticks CPU time accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_CONTEXT_TRACKING_USER
</span></span><span class="line"><span class="cl">	depends on HAVE_VIRT_CPU_ACCOUNTING_GEN
</span></span><span class="line"><span class="cl">	depends on GENERIC_CLOCKEVENTS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> VIRT_CPU_ACCOUNTING
</span></span><span class="line"><span class="cl">	<span class="k">select</span> CONTEXT_TRACKING_USER
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Select this option to <span class="nb">enable</span> task and CPU <span class="nb">time</span> accounting on full
</span></span><span class="line"><span class="cl">	  dynticks systems. This accounting is implemented by watching every
</span></span><span class="line"><span class="cl">	  kernel-user boundaries using the context tracking subsystem.
</span></span><span class="line"><span class="cl">	  The accounting is thus performed at the expense of some significant
</span></span><span class="line"><span class="cl">	  overhead.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  For now this is only useful <span class="k">if</span> you are working on the full
</span></span><span class="line"><span class="cl">	  dynticks subsystem development.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If unsure, say N.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">endchoice
</span></span></code></pre></td></tr></table>
</div>
</div><p>CPU时间统计方式
选Simple tick based cputime accounting</p>
<ul>
<li>Simple tick based cputime accounting：简单的基于滴答的统计,适用于大多数场合</li>
<li>Deterministic task and CPU time accounting：通过读取CPU计数器进行统计,可以提供更精确的统计,但是对性能有一些不利影响.</li>
<li>Full dynticks CPU time accounting：利用上下文跟踪子系统,通过观察每一个内核与用户空间的边界进行统计.该选项对性能有显著的不良影响,目前仅用于完全无滴答子系统(CONFIG_NO_HZ_FULL)的调试</li>
</ul>
<h3 id="--fine-granularity-task-level-irq-time-accounting">[ ] Fine granularity task level IRQ time accounting</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config IRQ_TIME_ACCOUNTING
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Fine granularity task level IRQ time accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HAVE_IRQ_TIME_ACCOUNTING <span class="o">&amp;&amp;</span> !VIRT_CPU_ACCOUNTING_NATIVE
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Select this option to <span class="nb">enable</span> fine granularity task irq <span class="nb">time</span>
</span></span><span class="line"><span class="cl">	  accounting. This is <span class="k">done</span> by reading a timestamp on each
</span></span><span class="line"><span class="cl">	  transitions between softirq and hardirq state, so there can be a
</span></span><span class="line"><span class="cl">	  small performance impact.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If in doubt, say N here.
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过读取TSC时间戳进行统计,这是统计进程IRQ时间的更细粒度的统计方式,但对性能有些不良影响(特别是在RDTSC指令速度较慢的CPU上).</p>
<h3 id="-bsd-process-accounting">[*] BSD Process Accounting</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config BSD_PROCESS_ACCT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;BSD Process Accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on MULTIUSER
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  If you say Y here, a user level program will be able to instruct the
</span></span><span class="line"><span class="cl">	  kernel <span class="o">(</span>via a special system call<span class="o">)</span> to write process accounting
</span></span><span class="line"><span class="cl">	  information to a file: whenever a process exits, information about
</span></span><span class="line"><span class="cl">	  that process will be appended to the file by the kernel.  The
</span></span><span class="line"><span class="cl">	  information includes things such as creation time, owning user,
</span></span><span class="line"><span class="cl">	  <span class="nb">command</span> name, memory usage, controlling terminal etc. <span class="o">(</span>the <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">	  list is in the struct acct in &lt;file:include/linux/acct.h&gt;<span class="o">)</span>.  It is
</span></span><span class="line"><span class="cl">	  up to the user level program to <span class="k">do</span> useful things with this
</span></span><span class="line"><span class="cl">	  information.  This is generally a good idea, so say Y.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>程序员们，想知道你的程序在干些什么吗？想知道它吃了多少内存、睡了多少次觉吗？那就让它把统计信息写入文件吧！
当然，这并不是一个必须的功能，但它非常有用。有了这些信息，你就可以分析程序的性能，找出潜在的问题。
所以，如果你是一个负责任的程序员，就赶快让你的程序写入统计信息吧！
（PS：如果你的程序是那种不爱洗澡、不爱刷牙的程序，那就别让它写入统计信息了，否则你会看到一堆吓人的数字。）</p>
</blockquote>
<p>将进程的统计信息写入文件的用户级系统调用，信息通常包括建立时间、所有者、命令名称、内存使用、控制终端 等。如果选择 Y，则用户级别的程序就可以通过特殊的系统调用方式来通知内核把进程统计信息记录到一个文件中，当这个进程存在的时候，信息就会被内核记录进 文件，这对用户级程序非常有用，所以通常选择 Y。</p>
<h4 id="---bsd-process-accounting-version-3-file-format-new">[*]   BSD Process Accounting version 3 file format (NEW)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config BSD_PROCESS_ACCT_V3
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;BSD Process Accounting version 3 file format&#34;</span>
</span></span><span class="line"><span class="cl">	depends on BSD_PROCESS_ACCT
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  If you say Y here, the process accounting information is written
</span></span><span class="line"><span class="cl">	  in a new file format that also logs the process IDs of each
</span></span><span class="line"><span class="cl">	  process and its parent. Note that this file format is incompatible
</span></span><span class="line"><span class="cl">	  with previous v0/v1/v2 file formats, so you will need updated tools
</span></span><span class="line"><span class="cl">	  <span class="k">for</span> processing it. A preliminary version of these tools is available
</span></span><span class="line"><span class="cl">	  at &lt;http://www.gnu.org/software/acct/&gt;.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>想让你的系统更有“情怀”吗？那就选用新的第三版文件格式吧！它不仅能记录每个进程的 ID 和父进程的 ID，还能让你回忆起老版本的“美好时光”。不过，需要注意的是，这个格式不兼容老版本的工具，所以你需要升级一下哦。</p>
</blockquote>
<p>这个选项是关于使用新的第三版文件格式的，这个格式可以包含每个进程的PID和其父进程的PID，但是不兼容老版本的文件格式。如果你选择了这个选项，统计信息将会以新的格式（V3）写入。注意这个格式和以前的v0/v1/v2格式不兼容，所以需要升级相关工具来使用它，比如 <a href="http://www.gnu.org/software/acct/">GNU Accounting Utilities</a> 这样的工具可以识别v3格式</p>
<h3 id="--export-taskprocess-statistics-through-netlink">[ ] Export task/process statistics through netlink</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config TASKSTATS
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Export task/process statistics through netlink&#34;</span>
</span></span><span class="line"><span class="cl">	depends on NET
</span></span><span class="line"><span class="cl">	depends on MULTIUSER
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Export selected statistics <span class="k">for</span> tasks/processes through the
</span></span><span class="line"><span class="cl">	  generic netlink interface. Unlike BSD process accounting, the
</span></span><span class="line"><span class="cl">	  statistics are available during the lifetime of tasks/processes as
</span></span><span class="line"><span class="cl">	  responses to commands. Like BSD accounting, they are sent to user
</span></span><span class="line"><span class="cl">	  space on task exit.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>Linux 内核新功能： “任务/进程统计信息，想看就看，想玩就玩！”</li>
<li>这项功能可以通过 <a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a> 接口向用户空间导出任务/进程的统计信息，与 BSD Process Accounting 的不同之处在于这些统计信息在整个任务/进程生存期都是可用的。</li>
<li>比如，你想知道某个进程的 CPU 使用率、内存占用、磁盘 I/O 等信息，只要打开一个 netlink 套接字，就可以随时查看。</li>
<li>当然，这项功能还在实验阶段，所以如果不确定，可以选择关闭。</li>
<li>（PS：这项功能可能会让你发现，你的电脑其实挺闲的。）</li>
</ul>
</blockquote>
<p>通过通用的网络输出工作 / 进程的相应数据，和 BSD 不同的是，这些数据在进程运行的时候就可以通过相关命令访问。和 BSD 类似，数据将在进程结束时送入用户空间。简单来说，这个功能可以让你在进程运行期间获取统计信息。如果你想了解更多，请参考这个<a href="https://docs.kernel.org/accounting/taskstats.html">链接</a>。如果不清楚，选 N。</p>
<h4 id="----enable-per-task-delay-accounting-new">[ ]   Enable per-task delay accounting (NEW)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config TASK_DELAY_ACCT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable per-task delay accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on TASKSTATS
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SCHED_INFO
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Collect information on <span class="nb">time</span> spent by a task waiting <span class="k">for</span> system
</span></span><span class="line"><span class="cl">	  resources like cpu, synchronous block I/O completion and swapping
</span></span><span class="line"><span class="cl">	  in pages. Such statistics can <span class="nb">help</span> in setting a task<span class="err">&#39;</span>s priorities
</span></span><span class="line"><span class="cl">	  relative to other tasks <span class="k">for</span> cpu, io, rss limits etc.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>Linux 内核新功能：“任务延迟计数，让你看清谁在偷懒！”</li>
<li>这项功能可以记录每个任务在等待系统资源时的时间，包括 CPU、同步块 I/O 完成和页面调度等。这些统计信息可以帮助你了解哪些任务在浪费时间，并相应调整它们的优先级。</li>
<li>比如，你发现某个任务总是在等待 CPU，那么你可以降低它的优先级，让它腾出时间给其他任务。</li>
<li>当然，这项功能还在实验阶段，所以如果不确定，可以选择关闭。</li>
<li>（PS：这项功能可能会让你发现，你自己也经常偷懒。）</li>
</ul>
</blockquote>
<p>这是一个处于实验阶段的功能，可以帮助你收集任务等待系统资源（如 CPU、同步块 I/O 完成和页面交换）的时间信息。这些统计信息可以帮助你相对于其他任务设置任务的优先级，例如 CPU、I/O、RSS 限制等。简单来说，这个功能可以让你更好地管理你的任务。如果你想了解更多，请参考这个<a href="https://www.kernel.org/doc/html/v5.15/accounting/delay-accounting.html">链接</a>。</p>
<h4 id="----enable-extended-accounting-over-taskstats-new">[ ]   Enable extended accounting over taskstats (NEW)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config TASK_XACCT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable extended accounting over taskstats&#34;</span>
</span></span><span class="line"><span class="cl">	depends on TASKSTATS
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Collect extended task accounting data and send the data
</span></span><span class="line"><span class="cl">	  to userland <span class="k">for</span> processing over the taskstats interface.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>Linux 内核新功能：“任务统计信息，再也不用偷偷摸摸了！”</li>
<li>这项功能可以收集<strong>更详细的任务统计信息</strong>，包括 CPU 使用率、内存占用、磁盘 I/O、网络 I/O 等。这些统计信息将通过 <code>taskstats</code> 接口传输到用户空间，供用户查看和分析。</li>
<li>比如，你想知道某个任务在做什么，可以通过 <code>taskstats</code> 接口查看它的 CPU 使用率、内存占用等信息。</li>
<li>当然，这项功能还在实验阶段，所以如果不确定，可以选择关闭。</li>
<li>（PS：这项功能可能会让你发现，你的电脑其实挺忙的。）</li>
</ul>
</blockquote>
<p>这是一个处于实验阶段的功能，可以帮助你收集任务的扩展统计数据，并通过 <code>taskstats</code> 接口将数据发送到用户空间进行处理。简单来说，这个功能可以让你更好地管理你的任务。如果你想了解更多，请参考这个<a href="https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html">链接</a>。</p>
<ol>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html">https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html</a></li>
<li><a href="https://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-2.8786/">https://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-2.8786/</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Iotop">https://wiki.gentoo.org/wiki/Iotop</a></li>
<li><a href="https://www.codetd.com/article/2171489">https://www.codetd.com/article/2171489</a></li>
<li><a href="https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou">https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou</a></li>
</ol>
<h5 id="------enable-per-task-storage-io-accounting-new">[ ]     Enable per-task storage I/O accounting (NEW)</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config TASK_IO_ACCOUNTING
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable per-task storage I/O accounting&#34;</span>
</span></span><span class="line"><span class="cl">	depends on TASK_XACCT
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Collect information on the number of bytes of storage I/O which this
</span></span><span class="line"><span class="cl">	  task has caused.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>Linux 内核新功能：“任务磁盘 I/O 计数，让你看清谁在占用硬盘！”</li>
<li>这项功能可以记录每个任务的磁盘 I/O 数据，包括读取和写入的字节数。这些统计信息可以帮助你了解哪些任务在大量占用磁盘资源，并相应调整它们的优先级。</li>
<li>比如，你发现某个任务的磁盘 I/O 非常高，那么你可以降低它的优先级，让它腾出空间给其他任务。</li>
<li>当然，这项功能还在实验阶段，所以如果不确定，可以选择关闭。</li>
<li>（PS：这项功能可能会让你发现，你自己也经常占用硬盘。）</li>
</ul>
</blockquote>
<ul>
<li>“任务磁盘 I/O 计数”是指记录每个任务的磁盘 I/O 数据。</li>
<li>这项功能可以帮助你了解系统的磁盘使用情况，并进行性能优化。</li>
</ul>
<p>这是一个处于实验阶段的功能，可以帮助你收集任务的存储 I/O 统计数据。简单来说，这个功能可以让你更好地管理你的任务。如果你想了解更多，请参考这个<a href="https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou">链接</a>。</p>
<ol>
<li><a href="https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou">https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou</a></li>
<li><a href="https://bkhome.org/news/202006/tracing-continuous-drive-activity.html">https://bkhome.org/news/202006/tracing-continuous-drive-activity.html</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Iotop">https://wiki.gentoo.org/wiki/Iotop</a></li>
<li><a href="https://serverfault.com/questions/169676/how-to-check-disk-i-o-utilization-per-process">https://serverfault.com/questions/169676/how-to-check-disk-i-o-utilization-per-process</a></li>
<li><a href="https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux">https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux</a></li>
</ol>
<h3 id="--pressure-stall-information-tracking">[ ] Pressure stall information tracking</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config PSI
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Pressure stall information tracking&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Collect metrics that indicate how overcommitted the CPU, memory,
</span></span><span class="line"><span class="cl">	  and IO capacity are in the system.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If you say Y here, the kernel will create /proc/pressure/ with the
</span></span><span class="line"><span class="cl">	  pressure statistics files cpu, memory, and io. These will indicate
</span></span><span class="line"><span class="cl">	  the share of walltime in which some or all tasks in the system are
</span></span><span class="line"><span class="cl">	  delayed due to contention of the respective resource.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  In kernels with cgroup support, cgroups <span class="o">(</span>cgroup2 only<span class="o">)</span> will
</span></span><span class="line"><span class="cl">	  have cpu.pressure, memory.pressure, and io.pressure files,
</span></span><span class="line"><span class="cl">	  which aggregate pressure stalls <span class="k">for</span> the grouped tasks only.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  For more details see Documentation/accounting/psi.rst.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><p>好的，以下是改写后的段落：</p>
<blockquote>
<ul>
<li>Linux 内核新功能：“压力告警，让你看清谁在卡顿！”（“压力告警”是指记录系统的压力情况。）</li>
<li>这项功能可以记录系统的压力情况，包括 CPU、内存、IO 等。这些统计信息可以帮助你了解哪些资源在发生争用，并相应调整系统的配置。</li>
<li>比如，你发现 CPU 的压力很高，那么你可以增加 CPU 的数量或频率。</li>
<li>当然，这项功能还在实验阶段，所以如果不确定，可以选择关闭。</li>
<li>（PS：这项功能可能会让你发现，你自己也经常卡顿。）</li>
</ul>
</blockquote>
<ul>
<li>PSI （Pressure Stall Information）可以帮助你了解系统的压力情况。</li>
<li>通过收集 CPU、内存、IO 等资源的使用情况来计算系统的压力。</li>
<li>可以帮助你识别系统的性能瓶颈，并进行配置优化。</li>
</ul>
<p>这是一个处于实验阶段的功能，可以帮助你收集 CPU、内存和 IO 容量过载的度量信息。如果你在这里选择 Y，内核将创建 /proc/pressure/ 目录，并在其中创建压力统计文件 cpu、memory 和 io。这些文件将指示系统中某些或所有任务由于相应资源的争用而延迟的墙时份额。在支持 cgroup 的内核中，cgroups（仅限 cgroup2）将具有 cpu.pressure、memory.pressure 和 io.pressure 文件，这些文件仅聚合分组任务的压力停顿。简单来说，这个功能可以让你更好地管理你的任务。如果你想了解更多，请参考这个<a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">链接</a>。</p>
<ol>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">https://www.kernel.org/doc/html/latest/accounting/psi.html</a></li>
<li><a href="https://lwn.net/Articles/770758/">https://lwn.net/Articles/770758/</a></li>
<li><a href="https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf">https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/523716850">https://zhuanlan.zhihu.com/p/523716850</a></li>
</ol>
<h2 id="--cpu-isolation">[ ] CPU isolation</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CPU_ISOLATION
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;CPU isolation&#34;</span>
</span></span><span class="line"><span class="cl">	depends on SMP <span class="o">||</span> COMPILE_TEST
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Make sure that CPUs running critical tasks are not disturbed by
</span></span><span class="line"><span class="cl">	  any <span class="nb">source</span> of <span class="s2">&#34;noise&#34;</span> such as unbound workqueues, timers, kthreads...
</span></span><span class="line"><span class="cl">	  Unbound <span class="nb">jobs</span> get offloaded to housekeeping CPUs. This is driven by
</span></span><span class="line"><span class="cl">	  the <span class="s2">&#34;isolcpus=&#34;</span> boot parameter.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say Y <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>“CPU 隔离，让你的程序高枕无忧！”</li>
<li>这项功能可以确保运行关键任务的 CPU 不会受到其他任务的干扰，让它们可以专心工作，不被打断。</li>
<li>比如，你正在运行一个重要的数据库服务器，那么你可以使用 CPU 隔离功能，确保数据库服务器不会受到其他任务的干扰，从而提高数据库的性能。</li>
<li>（PS：这项功能可能会让你发现，你自己也经常打断别人。）</li>
</ul>
</blockquote>
<p>建议勾选。CPU隔离功能，确保运行关键任务时不会被任何“噪音”干扰，例如未绑定的工作队列、计时器、内核线程等等。未绑定的任务将被转移到维护 CPU 上。这是由“isolcpus=”引导参数驱动的。</p>
<ol>
<li><a href="https://www.zhihu.com/question/464594238">https://www.zhihu.com/question/464594238</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100259413">https://zhuanlan.zhihu.com/p/100259413</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/139688780">https://zhuanlan.zhihu.com/p/139688780</a></li>
</ol>
<h2 id="rcu-subsystem-----">RCU Subsystem  &mdash;&gt;</h2>
<blockquote>
<ul>
<li>“RCU，让你尽情读，不用等写！”</li>
<li>RCU 是一种高性能的锁机制，在读多写少的情况下可以非常有效地提高性能。</li>
<li>RCU 的核心思想是“读，拷贝更新”，读者不需要获得任何锁就可以访问共享数据结构，而写者在修改数据时会先拷贝一份副本，然后对副本进行修改，最后使用一个回调机制在适当的时机将指向原来数据的指针重新指向新的被修改的数据。</li>
<li>RCU 只适用于读多写少的情况，比如网络路由表的查询更新、设备状态表的维护、数据结构的延迟释放以及多径 I/O 设备的维护等。</li>
</ul>
</blockquote>
<p>RCU(Read-Copy Update) 子系统是一个高性能的锁机制，它允许程序查看正在被修改/更新的文件。对于被 RCU 保护的共享数据结构，读者不需要获得任何锁就可以访问它（速度非常快），但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据，速度非常慢。RCU 只适用于读多写少的情况，例如网络路由表的查询更新、设备状态表的维护、数据结构的延迟释放以及多径 I/O 设备的维护等。</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/89439043">https://zhuanlan.zhihu.com/p/89439043</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30583695">https://zhuanlan.zhihu.com/p/30583695</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/542081111">https://zhuanlan.zhihu.com/p/542081111</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></li>
</ol>
<h3 id="--make-expert-level-adjustments-to-rcu-configuration">[ ] Make expert-level adjustments to RCU configuration</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config RCU_EXPERT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Make expert-level adjustments to RCU configuration&#34;</span>
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option needs to be enabled <span class="k">if</span> you wish to make
</span></span><span class="line"><span class="cl">	  expert-level adjustments to RCU configuration.  By default,
</span></span><span class="line"><span class="cl">	  no such adjustments can be made, which has the often-beneficial
</span></span><span class="line"><span class="cl">	  side-effect of preventing <span class="s2">&#34;make oldconfig&#34;</span> from asking you all
</span></span><span class="line"><span class="cl">	  sorts of detailed questions about how you would like numerous
</span></span><span class="line"><span class="cl">	  obscure RCU options to be <span class="nb">set</span> up.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say Y <span class="k">if</span> you need to make expert-level adjustments to RCU.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> you are unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>“RCU 专家模式，让你对 RCU 进行深度定制！”</li>
<li>这项功能可以让你对 RCU 的配置进行更细粒度的调整，以满足特定的需要。</li>
<li>比如，你可能需要调整 RCU 的回调机制，或者调整 RCU 的并发度。</li>
<li>当然，这项功能也需要你对 RCU 有比较深的理解，否则可能会导致系统不稳定。</li>
</ul>
</blockquote>
<p>这是一个处于实验阶段的功能，如果你想要进行RCU配置的专家级调整，那么你需要启用这个选项。默认情况下，不允许进行这样的调整，这通常会有一个有益的副作用，即防止“make oldconfig”询问你关于如何设置众多模糊的RCU选项的所有详细问题。如果你需要进行RCU的专家级调整，请选择Y。如果你不确定，请选择N。</p>
<h3 id="--force-selection-of-tasks_rcu-new">[ ] Force selection of TASKS_RCU (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config FORCE_TASKS_RCU
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Force selection of TASKS_RCU&#34;</span>
</span></span><span class="line"><span class="cl">	depends on RCU_EXPERT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TASKS_RCU
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option force-enables a task-based RCU implementation
</span></span><span class="line"><span class="cl">	  that uses only voluntary context switch <span class="o">(</span>not preemption!<span class="o">)</span>,
</span></span><span class="line"><span class="cl">	  idle, and user-mode execution as quiescent states.  Not <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  manual selection in most cases.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>“强制使用 TASKS_RCU，让你的系统更安全！”</li>
</ul>
</blockquote>
<ul>
<li>强制使用 TASKS_RCU 实现，TASKS_RCU 是一种 RCU 的实现方式，它只在特定的状态下（比如用户态执行、空闲态、自愿上下文切换）才会释放共享数据结构。</li>
<li>提高系统的安全性，因为它可以防止在非安全的状态下（比如被抢占）释放共享数据结构。</li>
<li>当然，这项功能也可能会影响系统的性能，因为它会增加额外的开销。</li>
<li>建议只有在确实需要的情况下才使用该选项。</li>
</ul>
<p>强制选择基于任务的RCU实现。这种实现只使用自愿上下文切换（而不是抢占！）、空闲和用户模式执行作为静止状态。在大多数情况下，不适合手动选择。</p>
<ol>
<li><a href="https://www.zhihu.com/question/464594238">https://www.zhihu.com/question/464594238</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100259413">https://zhuanlan.zhihu.com/p/100259413</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/139688780">https://zhuanlan.zhihu.com/p/139688780</a></li>
<li><a href="https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou">https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou</a></li>
<li><a href="https://bkhome.org/news/202006/tracing-continuous-drive-activity.html">https://bkhome.org/news/202006/tracing-continuous-drive-activity.html</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Iotop">https://wiki.gentoo.org/wiki/Iotop</a></li>
<li><a href="https://kernel.org/doc/html//latest/accounting/taskstats.html">https://kernel.org/doc/html//latest/accounting/taskstats.html</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">https://www.kernel.org/doc/html/latest/accounting/psi.html</a></li>
<li><a href="https://lwn.net/Articles/770758/">https://lwn.net/Articles/770758/</a></li>
<li><a href="https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf">https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/523716850">https://zhuanlan.zhihu.com/p/523716850</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/89439043">https://zhuanlan.zhihu.com/p/89439043</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30583695">https://zhuanlan.zhihu.com/p/30583695</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/542081111">https://zhuanlan.zhihu.com/p/542081111</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html">https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html</a></li>
<li><a href="https://www.kernel.org/doc/html/v5.15/accounting/delay-accounting.html">https://www.kernel.org/doc/html/v5.15/accounting/delay-accounting.html</a></li>
<li><a href="https://docs.kernel.org/5.19/accounting/delay-accounting.html">https://docs.kernel.org/5.19/accounting/delay-accounting.html</a></li>
<li><a href="https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux">https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux</a></li>
</ol>
<h3 id="--force-selection-of-tasks-rude-rcu-new">[ ] Force selection of Tasks Rude RCU (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config FORCE_TASKS_RUDE_RCU
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Force selection of Tasks Rude RCU&#34;</span>
</span></span><span class="line"><span class="cl">	depends on RCU_EXPERT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TASKS_RUDE_RCU
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option force-enables a task-based RCU implementation
</span></span><span class="line"><span class="cl">	  that uses only context switch <span class="o">(</span>including preemption<span class="o">)</span> and
</span></span><span class="line"><span class="cl">	  user-mode execution as quiescent states.  It forces IPIs and
</span></span><span class="line"><span class="cl">	  context switches on all online CPUs, including idle ones,
</span></span><span class="line"><span class="cl">	  so use with caution.	Not <span class="k">for</span> manual selection in most cases.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“强制使用 TASKS_RUDE_RCU，让你的系统更 rude（“粗鲁”或“不耐烦”）！”</p>
</blockquote>
<ul>
<li>强制使用 TASKS_RUDE_RCU 实现，TASKS_RUDE_RCU 是一种 RCU 的实现方式，它只在两个状态下（比如上下文切换、用户态执行）才会释放共享数据结构。</li>
<li>提高系统的安全性，因为它可以防止在非安全的状态下（比如被抢占）释放共享数据结构。</li>
<li>当然，这项功能也可能会影响系统的性能，因为它会增加额外的开销，而且会<strong>频繁地发送 IPI 和上下文切换</strong>。</li>
<li>建议只有在确实需要的情况下才使用该选项。</li>
</ul>
<p>强制选择基于任务的 RCU 实现。这种实现只使用上下文切换（包括抢占！）和用户模式执行作为静止状态。它会在所有在线 CPU 上强制 IPI 和上下文切换，包括空闲的 CPU，因此请谨慎使用。在大多数情况下，不适合手动选择。</p>
<h3 id="--force-selection-of-tasks-trace-rcu-new">[ ] Force selection of Tasks Trace RCU (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config FORCE_TASKS_TRACE_RCU
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Force selection of Tasks Trace RCU&#34;</span>
</span></span><span class="line"><span class="cl">	depends on RCU_EXPERT
</span></span><span class="line"><span class="cl">	<span class="k">select</span> TASKS_TRACE_RCU
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables a task-based RCU implementation that uses
</span></span><span class="line"><span class="cl">	  explicit rcu_read_lock_trace<span class="o">()</span> read-side markers, and allows
</span></span><span class="line"><span class="cl">	  these readers to appear in the idle loop as well as on the
</span></span><span class="line"><span class="cl">	  CPU hotplug code paths.  It can force IPIs on online CPUs,
</span></span><span class="line"><span class="cl">	  including idle ones, so use with caution.  Not <span class="k">for</span> manual
</span></span><span class="line"><span class="cl">	  selection in most cases.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“强制使用 TASKS_TRACE_RCU，让你的系统更 trace （“追踪”或“监控”）一些！”</p>
</blockquote>
<ul>
<li>强制使用 TASKS_TRACE_RCU 实现，TASKS_TRACE_RCU 是一种 RCU 的实现方式，它使用了显式（explicit）的 rcu_read_lock_trace() 读取锁标记，允许这些读取锁标记出现在空闲循环（idle loop）和 CPU 热插拔（CPU hotplug）代码路径中。</li>
<li>提高系统的安全性，因为它可以防止在非安全的状态下（比如被抢占）释放共享数据结构。</li>
<li>当然，这项功能也可能会影响系统的性能，因为它会增加额外的开销，而且会频繁地发送 IPI 和上下文切换。</li>
<li>建议只有在确实需要的情况下才使用该选项。</li>
</ul>
<p>强制选择基于任务的 RCU 实现。这种实现使用显式的 rcu_read_lock_trace() 读取端标记，并允许这些读取器出现在空闲循环以及 CPU 热插拔代码路径中。它可以在在线 CPU（包括空闲 CPU）上强制 IPI，因此请谨慎使用。在大多数情况下，不适合手动选择。</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/89439043">https://zhuanlan.zhihu.com/p/89439043</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30583695">https://zhuanlan.zhihu.com/p/30583695</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/542081111">https://zhuanlan.zhihu.com/p/542081111</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></li>
<li><a href="https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou">https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou</a></li>
<li><a href="https://bkhome.org/news/202006/tracing-continuous-drive-activity.html">https://bkhome.org/news/202006/tracing-continuous-drive-activity.html</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Iotop">https://wiki.gentoo.org/wiki/Iotop</a></li>
<li><a href="https://serverfault.com/questions/169676/how-to-check-disk-i-o-utilization-per-process">https://serverfault.com/questions/169676/how-to-check-disk-i-o-utilization-per-process</a></li>
<li><a href="https://cateee.net/lkddb/web-lkddb/FORCE_TASKS_RUDE_RCU.html">https://cateee.net/lkddb/web-lkddb/FORCE_TASKS_RUDE_RCU.html</a></li>
<li><a href="https://www.spinics.net/lists/kernel/msg3511171.html">https://www.spinics.net/lists/kernel/msg3511171.html</a></li>
<li><a href="https://lwn.net/Articles/608487/">https://lwn.net/Articles/608487/</a></li>
<li><a href="https://www.zhihu.com/question/464594238">https://www.zhihu.com/question/464594238</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100259413">https://zhuanlan.zhihu.com/p/100259413</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/139688780">https://zhuanlan.zhihu.com/p/139688780</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">https://www.kernel.org/doc/html/latest/accounting/psi.html</a></li>
<li><a href="https://lwn.net/Articles/770758/">https://lwn.net/Articles/770758/</a></li>
<li><a href="https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf">https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/523716850">https://zhuanlan.zhihu.com/p/523716850</a></li>
<li><a href="https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux">https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux</a></li>
</ol>
<h3 id="64-tree-based-hierarchical-rcu-fanout-value-new">(64) Tree-based hierarchical RCU fanout value (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config RCU_FANOUT
</span></span><span class="line"><span class="cl">	int <span class="s2">&#34;Tree-based hierarchical RCU fanout value&#34;</span>
</span></span><span class="line"><span class="cl">	range <span class="m">2</span> <span class="m">64</span> <span class="k">if</span> 64BIT
</span></span><span class="line"><span class="cl">	range <span class="m">2</span> <span class="m">32</span> <span class="k">if</span> !64BIT
</span></span><span class="line"><span class="cl">	depends on TREE_RCU <span class="o">&amp;&amp;</span> RCU_EXPERT
</span></span><span class="line"><span class="cl">	default <span class="m">64</span> <span class="k">if</span> 64BIT
</span></span><span class="line"><span class="cl">	default <span class="m">32</span> <span class="k">if</span> !64BIT
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option controls the fanout of hierarchical implementations
</span></span><span class="line"><span class="cl">	  of RCU, allowing RCU to work efficiently on machines with
</span></span><span class="line"><span class="cl">	  large numbers of CPUs.  This value must be at least the fourth
</span></span><span class="line"><span class="cl">	  root of NR_CPUS, which allows NR_CPUS to be insanely large.
</span></span><span class="line"><span class="cl">	  The default value of RCU_FANOUT should be used <span class="k">for</span> production
</span></span><span class="line"><span class="cl">	  systems, but <span class="k">if</span> you are stress-testing the RCU implementation
</span></span><span class="line"><span class="cl">	  itself, small RCU_FANOUT values allow you to <span class="nb">test</span> large-system
</span></span><span class="line"><span class="cl">	  code paths on small<span class="o">(</span>er<span class="o">)</span> systems.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Select a specific number <span class="k">if</span> testing RCU itself.
</span></span><span class="line"><span class="cl">	  Take the default <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“RCU 分支数，让你的系统更 fan（“繁忙”或“活跃”） 一些！”</p>
</blockquote>
<ul>
<li>控制 RCU 的层次化实现的分支数，让 RCU 能够在具有大量 CPU 的机器上高效工作。</li>
<li>该值必须至少是 NR_CPUS 的第四个根号，这允许 NR_CPUS 非常大。</li>
<li>对于生产系统，应该使用 RCU_FANOUT 的默认值。但是，如果你在对 RCU 实现进行压力测试，那么使用较小的 RCU_FANOUT 值可以让你在较小的系统上测试大型系统的代码路径。</li>
<li>所以，如果你想让你的系统更“fan”（“繁忙”或“活跃”） ，那么就选择一个特定的 RCU_FANOUT 值。如果你不确定，那么就使用默认值。</li>
</ul>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/386422612">https://zhuanlan.zhihu.com/p/386422612</a></li>
<li><a href="https://www.cnblogs.com/LoyenWang/p/12770878.html">https://www.cnblogs.com/LoyenWang/p/12770878.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></li>
</ol>
<p>用于控制 RCU 的分支数，从而使 RCU 在具有大量 CPU 的机器上高效工作。这个值必须至少是 NR_CPUS 的第四个根，这允许 NR_CPUS 变得非常大。生产系统应使用 RCU_FANOUT 的默认值，但如果您正在对 RCU 实现进行<strong>压力测试</strong>，则可以使用较小的 RCU_FANOUT 值在较小的系统上测试大型系统代码路径。如果您正在测试 RCU 本身，请选择特定的数字。如果不确定，请选择默认值。</p>
<h3 id="16-tree-based-hierarchical-rcu-leaf-level-fanout-value-new">(16) Tree-based hierarchical RCU leaf-level fanout value (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config RCU_FANOUT_LEAF
</span></span><span class="line"><span class="cl">	int <span class="s2">&#34;Tree-based hierarchical RCU leaf-level fanout value&#34;</span>
</span></span><span class="line"><span class="cl">	range <span class="m">2</span> <span class="m">64</span> <span class="k">if</span> 64BIT <span class="o">&amp;&amp;</span> !RCU_STRICT_GRACE_PERIOD
</span></span><span class="line"><span class="cl">	range <span class="m">2</span> <span class="m">32</span> <span class="k">if</span> !64BIT <span class="o">&amp;&amp;</span> !RCU_STRICT_GRACE_PERIOD
</span></span><span class="line"><span class="cl">	range <span class="m">2</span> <span class="m">3</span> <span class="k">if</span> RCU_STRICT_GRACE_PERIOD
</span></span><span class="line"><span class="cl">	depends on TREE_RCU <span class="o">&amp;&amp;</span> RCU_EXPERT
</span></span><span class="line"><span class="cl">	default <span class="m">16</span> <span class="k">if</span> !RCU_STRICT_GRACE_PERIOD
</span></span><span class="line"><span class="cl">	default <span class="m">2</span> <span class="k">if</span> RCU_STRICT_GRACE_PERIOD
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option controls the leaf-level fanout of hierarchical
</span></span><span class="line"><span class="cl">	  implementations of RCU, and allows trading off cache misses
</span></span><span class="line"><span class="cl">	  against lock contention.  Systems that synchronize their
</span></span><span class="line"><span class="cl">	  scheduling-clock interrupts <span class="k">for</span> energy-efficiency reasons will
</span></span><span class="line"><span class="cl">	  want the default because the smaller leaf-level fanout keeps
</span></span><span class="line"><span class="cl">	  lock contention levels acceptably low.  Very large systems
</span></span><span class="line"><span class="cl">	  <span class="o">(</span>hundreds or thousands of CPUs<span class="o">)</span> will instead want to <span class="nb">set</span> this
</span></span><span class="line"><span class="cl">	  value to the maximum value possible in order to reduce the
</span></span><span class="line"><span class="cl">	  number of cache misses incurred during RCU<span class="s1">&#39;s grace-period
</span></span></span><span class="line"><span class="cl"><span class="s1">	  initialization.  These systems tend to run CPU-bound, and thus
</span></span></span><span class="line"><span class="cl"><span class="s1">	  are not helped by synchronized interrupts, and thus tend to
</span></span></span><span class="line"><span class="cl"><span class="s1">	  skew them, which reduces lock contention enough that large
</span></span></span><span class="line"><span class="cl"><span class="s1">	  leaf-level fanouts work well.  That said, setting leaf-level
</span></span></span><span class="line"><span class="cl"><span class="s1">	  fanout to a large number will likely cause problematic
</span></span></span><span class="line"><span class="cl"><span class="s1">	  lock contention on the leaf-level rcu_node structures unless
</span></span></span><span class="line"><span class="cl"><span class="s1">	  you boot with the skew_tick kernel parameter.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">	  Select a specific number if testing RCU itself.
</span></span></span><span class="line"><span class="cl"><span class="s1">
</span></span></span><span class="line"><span class="cl"><span class="s1">	  Select the maximum permissible value for large systems, but
</span></span></span><span class="line"><span class="cl"><span class="s1">	  please understand that you may also need to set the skew_tick
</span></span></span><span class="line"><span class="cl"><span class="s1">	  kernel boot parameter to avoid contention on the rcu_node
</span></span></span><span class="line"><span class="cl"><span class="s1">	  structure&#39;</span>s locks.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Take the default <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“RCU 叶节点分支数，让你的系统更“fan”一些，但也要注意“skew”一下！”</p>
</blockquote>
<ul>
<li>这项功能可以控制 RCU 的层次化实现的叶节点分支数，让 RCU 能够在具有大量 CPU 的机器上高效工作。</li>
<li>该值必须至少是 2，但不能超过 64（如果是 64 位系统）或 32（如果是 32 位系统）。</li>
<li>对于生产系统，应该使用默认值（16）。但是，如果你在使用大型系统（比如数百或数千个 CPU），那么可以将该值设置为最大值。</li>
<li>但是，你需要注意，如果将该值设置为最大值，那么可能会导致 rcu_node 结构的锁争用。</li>
<li>所以，如果你想让你的系统更“fan”，那么就选择一个特定的 RCU_FANOUT_LEAF 值。但是，你也要注意“skew”一下，也就是要调整系统的调度时钟中断，以避免锁争用。</li>
</ul>
<p>这是一个处于实验阶段的功能，用于控制基于任务的RCU实现的叶级扇出，以便在大型系统上降低缓存未命中次数。如果您正在测试RCU本身，请选择特定数字。如果您不确定，请选择默认值。</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/386422612">https://zhuanlan.zhihu.com/p/386422612</a></li>
<li><a href="https://www.cnblogs.com/LoyenWang/p/12770878.html">https://www.cnblogs.com/LoyenWang/p/12770878.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></li>
</ol>
<h3 id="--offload-rcu-callback-processing-from-boot-selected-cpus-new">[ ] Offload RCU callback processing from boot-selected CPUs (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config RCU_NOCB_CPU
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Offload RCU callback processing from boot-selected CPUs&#34;</span>
</span></span><span class="line"><span class="cl">	depends on TREE_RCU
</span></span><span class="line"><span class="cl">	depends on RCU_EXPERT <span class="o">||</span> NO_HZ_FULL
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Use this option to reduce OS jitter <span class="k">for</span> aggressive HPC or
</span></span><span class="line"><span class="cl">	  real-time workloads.	It can also be used to offload RCU
</span></span><span class="line"><span class="cl">	  callback invocation to energy-efficient CPUs in battery-powered
</span></span><span class="line"><span class="cl">	  asymmetric multiprocessors.  The price of this reduced jitter
</span></span><span class="line"><span class="cl">	  is that the overhead of call_rcu<span class="o">()</span> increases and that some
</span></span><span class="line"><span class="cl">	  workloads will incur significant increases in context-switch
</span></span><span class="line"><span class="cl">	  rates.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  This option offloads callback invocation from the <span class="nb">set</span> of CPUs
</span></span><span class="line"><span class="cl">	  specified at boot <span class="nb">time</span> by the rcu_nocbs parameter.  For each
</span></span><span class="line"><span class="cl">	  such CPU, a kthread <span class="o">(</span><span class="s2">&#34;rcuox/N&#34;</span><span class="o">)</span> will be created to invoke
</span></span><span class="line"><span class="cl">	  callbacks, where the <span class="s2">&#34;N&#34;</span> is the CPU being offloaded, and where
</span></span><span class="line"><span class="cl">	  the <span class="s2">&#34;x&#34;</span> is <span class="s2">&#34;p&#34;</span> <span class="k">for</span> RCU-preempt <span class="o">(</span>PREEMPTION kernels<span class="o">)</span> and <span class="s2">&#34;s&#34;</span> <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  RCU-sched <span class="o">(</span>!PREEMPTION kernels<span class="o">)</span>.  Nothing prevents this kthread
</span></span><span class="line"><span class="cl">	  from running on the specified CPUs, but <span class="o">(</span>1<span class="o">)</span> the kthreads may be
</span></span><span class="line"><span class="cl">	  preempted between each callback, and <span class="o">(</span>2<span class="o">)</span> affinity or cgroups can
</span></span><span class="line"><span class="cl">	  be used to force the kthreads to run on whatever <span class="nb">set</span> of CPUs is
</span></span><span class="line"><span class="cl">	  desired.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say Y here <span class="k">if</span> you need reduced OS jitter, despite added overhead.
</span></span><span class="line"><span class="cl">	  Say N here <span class="k">if</span> you are unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“RCU 回调处理，让你的系统更“nocb”（“无缝”或“平滑”）一些，但也要注意“overhead”！”</p>
</blockquote>
<ul>
<li>这项功能可以将 RCU 的回调处理从启动时指定的 CPU 中卸载，以减少操作系统的抖动。</li>
<li>这项功能可以用于减少 HPC 或实时工作负载的操作系统抖动。它还可以用于将 RCU 回调调用卸载到电池供电的非对称多处理器中的高能效 CPU。</li>
<li>但是，这项功能也会增加 call_rcu() 的开销，并导致一些工作负载的上下文切换率显著增加。</li>
<li>所以，如果你想让你的系统更“nocb”，也就是更“无缝”一些，那么可以使用这个选项。但是，你也要注意“overhead”，也就是开销。</li>
</ul>
<p>这是一个处于实验阶段的功能，用于减少高性能计算或实时工作负载的操作系统抖动。它还可以用于将 RCU 回调调用从启动选定的 CPU 转移。如果您需要减少操作系统抖动，请选择 Y。如果您不确定，请选择 N。</p>
<h4 id="----offload-rcu-callback-processing-from-all-cpus-by-default-new">[ ]   Offload RCU callback processing from all CPUs by default (NEW)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config RCU_NOCB_CPU_DEFAULT_ALL
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Offload RCU callback processing from all CPUs by default&#34;</span>
</span></span><span class="line"><span class="cl">	depends on RCU_NOCB_CPU
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Use this option to offload callback processing from all CPUs
</span></span><span class="line"><span class="cl">	  by default, in the absence of the rcu_nocbs or nohz_full boot
</span></span><span class="line"><span class="cl">	  parameter. This also avoids the need to use any boot parameters
</span></span><span class="line"><span class="cl">	  to achieve the effect of offloading all CPUs on boot.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say Y here <span class="k">if</span> you want offload all CPUs by default on boot.
</span></span><span class="line"><span class="cl">	  Say N here <span class="k">if</span> you are unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“RCU 回调处理，让你的系统更“nocb”（“无缝”或“平滑”）一些，默认全部 offload！”</p>
</blockquote>
<ul>
<li>这项功能可以将 RCU 的回调处理从所有 CPU 中卸载，作为默认设置，如果没有 rcu_nocbs 或 nohz_full 引导参数。这也避免了使用任何引导参数来实现在启动时卸载所有 CPU 的效果。</li>
<li>这项功能可以用于减少 HPC 或实时工作负载的操作系统抖动。它还可以用于将 RCU 回调调用卸载到电池供电的非对称多处理器中的高能效 CPU。</li>
<li>但是，这项功能也会增加 call_rcu() 的开销，并导致一些工作负载的上下文切换率显著增加。</li>
<li>所以，如果你想让你的系统更“nocb”，也就是更“无缝”一些，那么可以使用这个选项。而且，它是默认设置，所以你不需要做任何额外的事情。但是，你也要注意“overhead”，也就是开销。</li>
</ul>
<p>这是一个处于实验阶段的功能，用于在启动时默认从所有 CPU 中卸载 RCU 回调处理。如果您想在启动时默认卸载所有 CPU 上的 RCU 回调处理，请选择 Y。如果您不确定，请选择 N。</p>
<h3 id="--tasks-trace-rcu-readers-use-memory-barriers-in-user-and-idle-new">[ ] Tasks Trace RCU readers use memory barriers in user and idle (NEW)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config TASKS_TRACE_RCU_READ_MB
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Tasks Trace RCU readers use memory barriers in user and idle&#34;</span>
</span></span><span class="line"><span class="cl">	depends on RCU_EXPERT <span class="o">&amp;&amp;</span> TASKS_TRACE_RCU
</span></span><span class="line"><span class="cl">	default PREEMPT_RT <span class="o">||</span> NR_CPUS &lt; <span class="m">8</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Use this option to further reduce the number of IPIs sent
</span></span><span class="line"><span class="cl">	  to CPUs executing in userspace or idle during tasks trace
</span></span><span class="line"><span class="cl">	  RCU grace periods.  Given that a reasonable setting of
</span></span><span class="line"><span class="cl">	  the rcupdate.rcu_task_ipi_delay kernel boot parameter
</span></span><span class="line"><span class="cl">	  eliminates such IPIs <span class="k">for</span> many workloads, proper setting
</span></span><span class="line"><span class="cl">	  of this Kconfig option is important mostly <span class="k">for</span> aggressive
</span></span><span class="line"><span class="cl">	  real-time installations and <span class="k">for</span> battery-powered devices,
</span></span><span class="line"><span class="cl">	  hence the default chosen above.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say Y here <span class="k">if</span> you hate IPIs.
</span></span><span class="line"><span class="cl">	  Say N here <span class="k">if</span> you hate read-side memory barriers.
</span></span><span class="line"><span class="cl">	  Take the default <span class="k">if</span> you are unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“让你的系统更“trace”一些，但也要注意“memory barrier”(内存屏障)！”</p>
</blockquote>
<ul>
<li>可以让 RCU 的追踪读取操作使用内存屏障，以进一步减少在用户空间或空闲 CPU 上发送的 IPI 数量。</li>
<li>可以用于减少对 IPI 的依赖，从而提高系统的响应速度。它还可以用于在电池供电的设备上延长电池寿命。</li>
<li>但是也会增加 read-side memory barrier 的开销。</li>
<li>所以，如果你想让你的系统更“trace”一些，那么可以使用这个选项。但是，你也要注意“memory barrier”带来的开销。</li>
</ul>
<p>用于减少在用户空间或空闲期间执行的 CPU 上发送的 IPI 数量。如果你讨厌 IPI，就选择 Y 吧。如果你讨厌读侧内存屏障，就选择 N 吧。如果你不确定，就选择默认值吧。这个选项对于激进的实时安装和电池供电设备非常重要，因此默认值是 PREEMPT_RT 或 NR_CPUS &lt; 8。</p>
<ol>
<li><a href="https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou">https://unix.stackexchange.com/questions/686133/from-where-htop-collects-io-read-write-data-for-one-current-user-proccess-withou</a></li>
<li><a href="https://bkhome.org/news/202006/tracing-continuous-drive-activity.html">https://bkhome.org/news/202006/tracing-continuous-drive-activity.html</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Iotop">https://wiki.gentoo.org/wiki/Iotop</a></li>
<li><a href="https://kernel.org/doc/html//latest/accounting/taskstats.html">https://kernel.org/doc/html//latest/accounting/taskstats.html</a></li>
<li><a href="https://www.zhihu.com/question/464594238">https://www.zhihu.com/question/464594238</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/100259413">https://zhuanlan.zhihu.com/p/100259413</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/139688780">https://zhuanlan.zhihu.com/p/139688780</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/psi.html">https://www.kernel.org/doc/html/latest/accounting/psi.html</a></li>
<li><a href="https://lwn.net/Articles/770758/">https://lwn.net/Articles/770758/</a></li>
<li><a href="https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf">https://lpc.events/event/2/contributions/221/attachments/45/52/02._PSI_monitor_for_memory_pressure_detection.pdf</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/523716850">https://zhuanlan.zhihu.com/p/523716850</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html">https://www.kernel.org/doc/html/latest/accounting/delay-accounting.html</a></li>
<li><a href="https://www.kernel.org/doc/html/v5.15/accounting/delay-accounting.html">https://www.kernel.org/doc/html/v5.15/accounting/delay-accounting.html</a></li>
<li><a href="https://docs.kernel.org/5.19/accounting/delay-accounting.html">https://docs.kernel.org/5.19/accounting/delay-accounting.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/89439043">https://zhuanlan.zhihu.com/p/89439043</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30583695">https://zhuanlan.zhihu.com/p/30583695</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/542081111">https://zhuanlan.zhihu.com/p/542081111</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/113999842">https://zhuanlan.zhihu.com/p/113999842</a></li>
<li><a href="https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux">https://stackoverflow.com/questions/469159/an-htop-like-tool-to-display-disk-activity-in-linux</a></li>
</ol>
<h2 id="--kernel-config-support">[ ] Kernel .config support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config IKCONFIG
</span></span><span class="line"><span class="cl">	tristate <span class="s2">&#34;Kernel .config support&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables the <span class="nb">complete</span> Linux kernel <span class="s2">&#34;.config&#34;</span> file
</span></span><span class="line"><span class="cl">	  contents to be saved in the kernel. It provides documentation
</span></span><span class="line"><span class="cl">	  of which kernel options are used in a running kernel or in an
</span></span><span class="line"><span class="cl">	  on-disk kernel.  This information can be extracted from the kernel
</span></span><span class="line"><span class="cl">	  image file with the script scripts/extract-ikconfig and used as
</span></span><span class="line"><span class="cl">	  input to rebuild the current kernel or to build another kernel.
</span></span><span class="line"><span class="cl">	  It can also be extracted from a running kernel by reading
</span></span><span class="line"><span class="cl">	  /proc/config.gz <span class="k">if</span> enabled <span class="o">(</span>below<span class="o">)</span>.
</span></span></code></pre></td></tr></table>
</div>
</div><p>“让你的内核更“ikconfig”一些，方便你随时查看和修改！”</p>
<ul>
<li>可以让 Linux 内核的 &ldquo;.config&rdquo; 文件内容保存在内核中。这可以让你在运行时查看内核使用的所有配置选项，并在需要时进行修改。</li>
<li>可以用于调试内核、配置内核、以及在不同内核之间进行移植。</li>
<li>但是，这项功能也会增加内核的大小。</li>
<li>默认值是关闭（n）。建议只有在需要在运行时查看内核配置选项或进行内核调试的情况下才使用该选项。</li>
</ul>
<p>用于启用完整的 Linux 内核“.config”文件内容保存在内核中。它提供了运行内核或磁盘内核中使用的内核选项的文档。可以使用脚本 scripts/extract-ikconfig 从内核映像文件中提取此信息，并将其用作重建当前内核或构建另一个内核的输入。如果启用（下面），也可以从运行中的内核中通过读取 /proc/config.gz 提取此信息。<a href="https://zhuanlan.zhihu.com/p/386422612">^1^</a></p>
<ol>
<li><a href="https://wiki.gentoo.org/wiki/Kernel/IKCONFIG_support">https://wiki.gentoo.org/wiki/Kernel/IKCONFIG_support</a></li>
</ol>
<h2 id="----enable-access-to-config-through-procconfiggz">[ ]   Enable access to .config through /proc/config.gz</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config IKCONFIG_PROC
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable access to .config through /proc/config.gz&#34;</span>
</span></span><span class="line"><span class="cl">	depends on IKCONFIG <span class="o">&amp;&amp;</span> PROC_FS
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables access to the kernel configuration file
</span></span><span class="line"><span class="cl">	  through /proc/config.gz.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“让你的内核配置文件随时可用，轻轻一查，尽在掌握！”</p>
</blockquote>
<ul>
<li>这项功能可以让你在运行时通过 /proc/config.gz 文件来查看和修改内核配置文件。</li>
<li>这项功能可以用于调试内核、配置内核、以及在不同内核之间进行移植。</li>
<li>但是，这项功能也需要占用一部分内存。</li>
<li>所以，如果你想让你的内核配置文件随时可用，那么可以使用这个选项。但是，你也要注意内存占用的增加。</li>
</ul>
<p>用于通过 /proc/config.gz 访问内核配置文件。如果你想要访问内核配置文件，请选择 Y。如果你不确定，请选择 N。</p>
<ol>
<li><a href="https://blog.csdn.net/gogogo_gf/article/details/123817874">https://blog.csdn.net/gogogo_gf/article/details/123817874</a></li>
<li><a href="https://blog.csdn.net/u013554213/article/details/83589247">https://blog.csdn.net/u013554213/article/details/83589247</a></li>
<li><a href="https://qastack.cn/superuser/287371/obtain-kernel-config-from-currently-running-linux-system">https://qastack.cn/superuser/287371/obtain-kernel-config-from-currently-running-linux-system</a></li>
<li><a href="https://www.cnblogs.com/embedded-linux/p/10328957.html">https://www.cnblogs.com/embedded-linux/p/10328957.html</a></li>
</ol>
<h2 id="--enable-kernel-headers-through-syskernelkheaderstarxz">[ ] Enable kernel headers through /sys/kernel/kheaders.tar.xz</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config IKHEADERS
</span></span><span class="line"><span class="cl">	tristate <span class="s2">&#34;Enable kernel headers through /sys/kernel/kheaders.tar.xz&#34;</span>
</span></span><span class="line"><span class="cl">	depends on SYSFS
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables access to the in-kernel headers that are generated during
</span></span><span class="line"><span class="cl">	  the build process. These can be used to build eBPF tracing programs,
</span></span><span class="line"><span class="cl">	  or similar programs.  If you build the headers as a module, a module called
</span></span><span class="line"><span class="cl">	  kheaders.ko is built which can be loaded on-demand to get access to headers.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“让你的<strong>内核头文件</strong>随时可用，想查就查，想用就用！”</p>
</blockquote>
<p>用于启用在构建过程中生成的内核头文件。这些文件可用于构建 eBPF 跟踪程序或类似程序。如果您将头文件构建为模块，则会构建一个名为 kheaders.ko 的模块，可以按需加载以访问头文件。如果您想要启用内核头文件，请选择 Y。如果您不确定，请选择 N。</p>
<ul>
<li>这项功能可以让你在运行时通过 /sys/kernel/kheaders.tar.xz 文件来查看和使用内核头文件。</li>
<li>这项功能可以用于编写 eBPF 追踪程序，或其他需要使用内核头文件的程序。</li>
<li>但是，这项功能也需要占用一部分内存。</li>
<li>所以，如果你想让你的内核头文件随时可用，那么可以使用这个选项。但是，你也要注意内存占用的增加。</li>
</ul>
<ol>
<li><a href="https://stackoverflow.com/questions/70139789/where-should-the-contents-of-sys-kernel-kheaders-tar-xz-be-installed">https://stackoverflow.com/questions/70139789/where-should-the-contents-of-sys-kernel-kheaders-tar-xz-be-installed</a></li>
<li><a href="https://cateee.net/lkddb/web-lkddb/IKHEADERS.html">https://cateee.net/lkddb/web-lkddb/IKHEADERS.html</a></li>
<li><a href="https://www.qiniu.com/qfans/qnso-70139789">https://www.qiniu.com/qfans/qnso-70139789</a></li>
<li><a href="https://www.linuxjournal.com/content/extending-kernel-built-kernel-headers">https://www.linuxjournal.com/content/extending-kernel-built-kernel-headers</a></li>
</ol>
<h2 id="scheduler-features-----">Scheduler features  &mdash;&gt;</h2>
<h3 id="-enable-utilization-clamping-for-rtfair-tasks">[*] Enable utilization clamping for RT/FAIR tasks</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config UCLAMP_TASK
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Enable utilization clamping for RT/FAIR tasks&#34;</span>
</span></span><span class="line"><span class="cl">	depends on CPU_FREQ_GOV_SCHEDUTIL
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This feature enables the scheduler to track the clamped utilization
</span></span><span class="line"><span class="cl">	  of each CPU based on RUNNABLE tasks scheduled on that CPU.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  With this option, the user can specify the min and max CPU
</span></span><span class="line"><span class="cl">	  utilization allowed <span class="k">for</span> RUNNABLE tasks. The max utilization defines
</span></span><span class="line"><span class="cl">	  the maximum frequency a task should use <span class="k">while</span> the min utilization
</span></span><span class="line"><span class="cl">	  defines the minimum frequency it should use.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Both min and max utilization clamp values are hints to the scheduler,
</span></span><span class="line"><span class="cl">	  aiming at improving its frequency selection policy, but they <span class="k">do</span> not
</span></span><span class="line"><span class="cl">	  enforce or grant any specific bandwidth <span class="k">for</span> tasks.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If in doubt, say N.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“让你的 RT/FAIR 任务更“合身”一些，不“挤”了！”</p>
</blockquote>
<ul>
<li>可以让调度程序跟踪每个 CPU 上运行的 RUNNABLE 任务的受限利用率。</li>
<li>可以让用户指定 RUNNABLE 任务允许的最大和最小 CPU 利用率。最大利用率定义了任务应该使用的最大频率，而最小利用率定义了任务应该使用的最小频率。</li>
<li>可以让调度程序更好地选择频率，让任务不“挤”了，但它不会强制或授予任何特定的带宽给任务。</li>
<li>默认值是关闭（n）。建议只有在需要为 RT/FAIR 任务提供特定的带宽的情况下才使用该选项。但是，你也要注意，这只是一个“hint”，调度程序可能会根据系统的实际情况做出调整。</li>
</ul>
<p>这个功能可以让你的电脑更快。它可以跟踪每个CPU的利用率，以基于在该CPU上调度的RUNNABLE任务来跟踪被夹住的利用率。使用此选项，用户可以指定RUNNABLE任务允许的最小和最大CPU利用率。最大利用率定义任务应使用的最大频率，而最小利用率定义任务应使用的最小频率。这两个最小和最大利用率夹紧值是调度程序的提示，旨在改善其频率选择策略，但它们不强制执行或授予任何特定任务的带宽。如果有疑问，请选择N。</p>
<h3 id="5---number-of-supported-utilization-clamp-buckets">(5)   Number of supported utilization clamp buckets</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config UCLAMP_BUCKETS_COUNT
</span></span><span class="line"><span class="cl">	int <span class="s2">&#34;Number of supported utilization clamp buckets&#34;</span>
</span></span><span class="line"><span class="cl">	range <span class="m">5</span> <span class="m">20</span>
</span></span><span class="line"><span class="cl">	default <span class="m">5</span>
</span></span><span class="line"><span class="cl">	depends on UCLAMP_TASK
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Defines the number of clamp buckets to use. The range of each bucket
</span></span><span class="line"><span class="cl">	  will be SCHED_CAPACITY_SCALE/UCLAMP_BUCKETS_COUNT. The higher the
</span></span><span class="line"><span class="cl">	  number of clamp buckets the finer their granularity and the higher
</span></span><span class="line"><span class="cl">	  the precision of clamping aggregation and tracking at run-time.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  For example, with the minimum configuration value we will have <span class="m">5</span>
</span></span><span class="line"><span class="cl">	  clamp buckets tracking 20% utilization each. A 25% boosted tasks will
</span></span><span class="line"><span class="cl">	  be refcounted in the <span class="o">[</span>20..39<span class="o">]</span>% bucket and will <span class="nb">set</span> the bucket clamp
</span></span><span class="line"><span class="cl">	  effective value to 25%.
</span></span><span class="line"><span class="cl">	  If a second 30% boosted task should be co-scheduled on the same CPU,
</span></span><span class="line"><span class="cl">	  that task will be refcounted in the same bucket of the first task and
</span></span><span class="line"><span class="cl">	  it will boost the bucket clamp effective value to 30%.
</span></span><span class="line"><span class="cl">	  The clamp effective value of a bucket is reset to its nominal value
</span></span><span class="line"><span class="cl">	  <span class="o">(</span>20% in the example above<span class="o">)</span> when there are no more tasks refcounted in
</span></span><span class="line"><span class="cl">	  that bucket.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  An additional boost/capping margin can be added to some tasks. In the
</span></span><span class="line"><span class="cl">	  example above the 25% task will be boosted to 30% <span class="k">until</span> it exits the
</span></span><span class="line"><span class="cl">	  CPU. If that should be considered not acceptable on certain systems,
</span></span><span class="line"><span class="cl">	  it<span class="err">&#39;</span>s always possible to reduce the margin by increasing the number of
</span></span><span class="line"><span class="cl">	  clamp buckets to trade off used memory <span class="k">for</span> run-time tracking
</span></span><span class="line"><span class="cl">	  precision.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If in doubt, use the default value.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>“让你的 RT/FAIR 任务更“细腻”一些，不“粗”了！”</p>
</blockquote>
<ul>
<li>可以让你指定受限利用率的“细腻度”。</li>
<li>可以让你选择 5 到 20 个“细腻度”级别。级别越高，受限利用率的“细腻度”就越高，调度程序对 RT/FAIR 任务的频率调节就越精确。</li>
<li>但是，也要注意，级别越高，内存消耗就越大。</li>
<li>所以，如果你想让你的 RT/FAIR 任务更“细腻”一些，那么可以使用这个选项。但是，你也要注意内存消耗的增加。</li>
</ul>
<p>这个配置项定义了使用的clamp bucket的数量。每个bucket的范围将是SCHED_CAPACITY_SCALE/UCLAMP_BUCKETS_COUNT。bucket数量越高，它们的粒度就越细，运行时的clamping聚合和跟踪精度就越高。例如，如果使用最小配置值，我们将有5个clamp bucket，每个bucket跟踪20%的利用率。25%的boosted task将在[20..39]% bucket中被refcounted，并将设置bucket clamp effective value为25%。如果第二个30% boosted task应该在同一个CPU上共同调度，那么该任务将在第一个任务的相同bucket中被refcounted，并将提高bucket clamp effective value到30%。当没有更多任务在该bucket中被refcounted时，bucket的clamp effective value将被重置为其名义值（在上面的示例中为20%）。可以为某些任务添加额外的boost/capping margin。例如，在上面的示例中，25%任务将被提升到30%，直到它退出CPU。如果在某些系统上认为这不可接受，那么可以通过增加clamp buckets的数量来减少margin以换取运行时跟踪精度。如果有疑问，请使用默认值。</p>
<h2 id="--memory-placement-aware-numa-scheduler">[ ] Memory placement aware NUMA scheduler</h2>
<p>[ ] Automatically enable NUMA aware memory/task placement</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config NUMA_BALANCING
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Memory placement aware NUMA scheduler&#34;</span>
</span></span><span class="line"><span class="cl">	depends on ARCH_SUPPORTS_NUMA_BALANCING
</span></span><span class="line"><span class="cl">	depends on !ARCH_WANT_NUMA_VARIABLE_LOCALITY
</span></span><span class="line"><span class="cl">	depends on SMP <span class="o">&amp;&amp;</span> NUMA <span class="o">&amp;&amp;</span> MIGRATION <span class="o">&amp;&amp;</span> !PREEMPT_RT
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option adds support <span class="k">for</span> automatic NUMA aware memory/task placement.
</span></span><span class="line"><span class="cl">	  The mechanism is quite primitive and is based on migrating memory when
</span></span><span class="line"><span class="cl">	  it has references to the node the task is running on.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  This system will be inactive on UMA systems.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config NUMA_BALANCING_DEFAULT_ENABLED
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Automatically enable NUMA aware memory/task placement&#34;</span>
</span></span><span class="line"><span class="cl">	default y
</span></span><span class="line"><span class="cl">	depends on NUMA_BALANCING
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  If set, automatic NUMA balancing will be enabled <span class="k">if</span> running on a NUMA
</span></span><span class="line"><span class="cl">	  machine.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>NUMA是一个巧妙的系统，用于将多个中央处理单元(CPU)连接到计算机上任何数量的可用内存。单个NUMA节点通过可伸缩网络(I/O总线)连接，这样CPU就可以系统地访问与其他NUMA节点关联的内存。</p>
</blockquote>
<p>一般电脑都是单cpu,不用选此项。</p>
<blockquote>
<ul>
<li>你是否想让你的系统变得更快？试试这个选项！它会自动将内存和任务调度到合适的 NUMA 节点，从而提高系统性能。你还可以手动选择是否启用这个选项。</li>
<li>当然，如果你的系统不是 NUMA 系统，这个选项就没有用了。所以，请先检查你的系统是否支持 NUMA。</li>
</ul>
</blockquote>
<ul>
<li>NUMA_BALANCING 选项用于启用 NUMA 感知内存/任务调度。它是一个非常原始的机制，基于在任务正在运行的节点上有引用时迁移内存。</li>
<li>NUMA_BALANCING_DEFAULT_ENABLED 选项用于在运行于 NUMA 机器时自动启用 NUMA 感知内存/任务调度。</li>
<li>如果您使用的是 NUMA 系统，建议您勾选这两个选项。这样可以让操作系统自动将内存和任务调度到合适的 NUMA 节点，从而提高系统性能。</li>
</ul>
<p>这是一个关于NUMA的设置，它可以自动地将内存和任务放置在合适的位置。如果你的系统支持NUMA，那么你可以勾选这个选项。这个机制是基于当内存有对应任务的引用时，将内存迁移到任务所在的节点。这个系统不会在UMA系统上运行。</p>
<p>允许自动根据 NUMA 系统的节点分布状况进行进程 / 内存均衡 (方法很原始, 就是简单的内存移动). 这个选项对 UMA 系统无效.</p>
<p>UMA 系统的例子:
(1) <strong>只有一颗物理 CPU(即使是多核)的电脑,</strong>
(2)不支持 &ldquo;虚拟 NUMA&rdquo;, 或 &ldquo;虚拟 NUMA&rdquo; 被禁用的虚拟机(即使所在的物理机是 NUMA 系统)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">❯ numactl --hardware
</span></span><span class="line"><span class="cl">available: <span class="m">1</span> nodes <span class="o">(</span>0<span class="o">)</span>
</span></span><span class="line"><span class="cl">node <span class="m">0</span> cpus: <span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span> <span class="m">9</span> <span class="m">10</span> <span class="m">11</span> <span class="m">12</span> <span class="m">13</span> <span class="m">14</span> <span class="m">15</span> <span class="m">16</span> <span class="m">17</span> <span class="m">18</span> <span class="m">19</span> <span class="m">20</span> <span class="m">21</span> <span class="m">22</span> <span class="m">23</span> <span class="m">24</span> <span class="m">25</span> <span class="m">26</span> <span class="m">27</span> <span class="m">28</span> <span class="m">29</span> <span class="m">30</span> <span class="m">31</span>
</span></span><span class="line"><span class="cl">node <span class="m">0</span> size: <span class="m">31240</span> MB
</span></span><span class="line"><span class="cl">node <span class="m">0</span> free: <span class="m">18065</span> MB
</span></span><span class="line"><span class="cl">node distances:
</span></span><span class="line"><span class="cl">node   <span class="m">0</span> 
</span></span><span class="line"><span class="cl">  0:  <span class="m">10</span> 
</span></span><span class="line"><span class="cl">❯ numactl --show
</span></span><span class="line"><span class="cl">policy: default
</span></span><span class="line"><span class="cl">preferred node: current
</span></span><span class="line"><span class="cl">physcpubind: <span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span> <span class="m">9</span> <span class="m">10</span> <span class="m">11</span> <span class="m">12</span> <span class="m">13</span> <span class="m">14</span> <span class="m">15</span> <span class="m">16</span> <span class="m">17</span> <span class="m">18</span> <span class="m">19</span> <span class="m">20</span> <span class="m">21</span> <span class="m">22</span> <span class="m">23</span> <span class="m">24</span> <span class="m">25</span> <span class="m">26</span> <span class="m">27</span> <span class="m">28</span> <span class="m">29</span> <span class="m">30</span> <span class="m">31</span> 
</span></span><span class="line"><span class="cl">cpubind: <span class="m">0</span> 
</span></span><span class="line"><span class="cl">nodebind: <span class="m">0</span> 
</span></span><span class="line"><span class="cl">membind: <span class="m">0</span> 
</span></span><span class="line"><span class="cl">preferred: 
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>UMA（Uniform Memory Access, 一致性内存访问）：https://en.wikipedia.org/wiki/Uniform_memory_access</li>
<li>NUMA（Non-Uniform Memory Access, 非一致性内存访问）：https://en.wikipedia.org/wiki/Non-uniform_memory_access</li>
</ul>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/336365600">https://zhuanlan.zhihu.com/p/336365600</a></li>
<li><a href="https://baike.baidu.com/item/NUMA/6906025">https://baike.baidu.com/item/NUMA/6906025</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/476411477">https://zhuanlan.zhihu.com/p/476411477</a></li>
<li><a href="https://izsk.me/2022/06/02/System-Understanding-NUMA-Architecture/">https://izsk.me/2022/06/02/System-Understanding-NUMA-Architecture/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/62795773">https://zhuanlan.zhihu.com/p/62795773</a></li>
</ol>
<h2 id="---control-group-support-----">-*- Control Group support  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menuconfig CGROUPS
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Control Group support&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> KERNFS
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option adds support <span class="k">for</span> grouping sets of processes together, <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  use with process control subsystems such as Cpusets, CFS, memory
</span></span><span class="line"><span class="cl">	  controls or device isolation.
</span></span><span class="line"><span class="cl">	  See
</span></span><span class="line"><span class="cl">		- Documentation/scheduler/sched-design-CFS.rst	<span class="o">(</span>CFS<span class="o">)</span>
</span></span><span class="line"><span class="cl">		- Documentation/admin-guide/cgroup-v1/ <span class="o">(</span>features <span class="k">for</span> grouping, isolation
</span></span><span class="line"><span class="cl">					  and resource control<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="http://www.cnblogs.com/lisperl/archive/2012/04/17/2453838.html">Cgroup(Control Group)</a>是一种进程管理机制, 可以针对一组进程进行系统资源的分配和管理, 可用于 Cpusets,CFS(完全公平调度器), 内存管理等子系统. 此外,<strong>systemd 与 Docker/LXC 等容器也依赖于它</strong>。 更多细节可以参考内核的 <a href="http://lxr.linux.no/linux/Documentation/cgroups/cgroups.txt">Documentation/cgroups/cgroups.txt</a> 文件</p>
<blockquote>
<ul>
<li>你是否想让你的系统更加灵活和强大？试试这个选项吧！它可以让你将进程分组，并为每个组分配不同的资源，从而实现对系统资源的更精细控制。</li>
<li>比如，你想让一个组的进程优先使用 CPU，另一组的进程优先使用内存，还有一组的进程只能使用特定的设备，都可以通过控制组来实现。</li>
<li>当然，如果你不确定是否需要这个选项，可以选择不启用。</li>
</ul>
</blockquote>
<p>这是一个关于控制组的设置，它可以将一组进程分组在一起，用于进程控制子系统，例如Cpusets、CFS、内存控制或设备隔离。如果你不确定是否需要这个选项，请选择N。</p>
<h3 id="----favor-dynamic-modification-latency-reduction-by-default">[ ]   Favor dynamic modification latency reduction by default</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_FAVOR_DYNMODS
</span></span><span class="line"><span class="cl">        bool <span class="s2">&#34;Favor dynamic modification latency reduction by default&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="nb">help</span>
</span></span><span class="line"><span class="cl">          This option enables the <span class="s2">&#34;favordynmods&#34;</span> mount option by default
</span></span><span class="line"><span class="cl">          which reduces the latencies of dynamic cgroup modifications such
</span></span><span class="line"><span class="cl">          as task migrations and controller on/offs at the cost of making
</span></span><span class="line"><span class="cl">          hot path operations such as forks and exits more expensive.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>你是否想让你的系统变得更快，但又不想让它变得太繁忙？试试这个选项吧！它会默认启用“favordynmods”挂载选项，从而减少动态修改 cgroup 的延迟，例如任务迁移和控制器开关。但是，这也会使热路径操作，例如 fork 和 exit，变得更昂贵。</p>
</blockquote>
<p>这是一个关于控制组的设置，它可以将一组进程分组在一起，用于进程控制子系统，例如Cpusets、CFS、内存控制或设备隔离。如果你不确定是否需要这个选项，请选择N。</p>
<h3 id="---memory-controller">[*]   Memory controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config MEMCG
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Memory controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_COUNTER
</span></span><span class="line"><span class="cl">	<span class="k">select</span> EVENTFD
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides control over the memory footprint of tasks in a cgroup.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">config MEMCG_KMEM
</span></span><span class="line"><span class="cl">	bool
</span></span><span class="line"><span class="cl">	depends on MEMCG <span class="o">&amp;&amp;</span> !SLOB
</span></span><span class="line"><span class="cl">	default y
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>你是否想让你的系统变得更有纪律？试试这个选项吧！它会为 cgroup 添加内存资源控制器，让你可以控制任务的内存使用量，让它们不能“胡吃海塞”。</li>
<li>但是，这个选项会增加内存消耗，具体来说，在 64 位系统上，每个内存页会增加 40 字节的固定内存。所以，如果你不确定是否需要这个选项，请谨慎使用。</li>
<li>如果你确定需要这个选项，可以选择启用。Docker 依赖于这个选项。</li>
</ul>
</blockquote>
<p>这是一个关于内存资源控制器的设置，它可以为cgroup添加内存资源控制器，包括匿名内存和页面缓存( Documentation/cgroups/memory.txt)。开启此选项后，将会增加关联到每个内存页的固定内存大小，具体在64位系统上是40字节/PAGE_SIZE。仅在你确实明白什么是内存资源控制器（memory resource controller）并且确实需要的情况下才开启此选项。此功能可以通过命令行选项&quot;cgroup_disable=memory&quot;进行关闭。Docker依赖于它。</p>
<h3 id="----io-controller">[ ]   IO controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config BLK_CGROUP
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;IO controller&#34;</span>
</span></span><span class="line"><span class="cl">	depends on BLOCK
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	Generic block IO controller cgroup interface. This is the common
</span></span><span class="line"><span class="cl">	cgroup interface which should be used by various IO controlling
</span></span><span class="line"><span class="cl">	policies.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Currently, CFQ IO scheduler uses it to recognize task groups and
</span></span><span class="line"><span class="cl">	control disk bandwidth allocation <span class="o">(</span>proportional <span class="nb">time</span> slice allocation<span class="o">)</span>
</span></span><span class="line"><span class="cl">	to such task groups. It is also used by bio throttling logic in
</span></span><span class="line"><span class="cl">	block layer to implement upper limit in IO rates on a device.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	This option only enables generic Block IO controller infrastructure.
</span></span><span class="line"><span class="cl">	One needs to also <span class="nb">enable</span> actual IO controlling logic/policy. For
</span></span><span class="line"><span class="cl">	enabling proportional weight division of disk bandwidth in CFQ, <span class="nb">set</span>
</span></span><span class="line"><span class="cl">	<span class="nv">CONFIG_BFQ_GROUP_IOSCHED</span><span class="o">=</span>y<span class="p">;</span> <span class="k">for</span> enabling throttling policy, <span class="nb">set</span>
</span></span><span class="line"><span class="cl">	<span class="nv">CONFIG_BLK_DEV_THROTTLING</span><span class="o">=</span>y.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	See Documentation/admin-guide/cgroup-v1/blkio-controller.rst <span class="k">for</span> more information.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>你是否想让你的系统磁盘 I/O 更加“文明”？试试这个选项吧！它会为 cgroup 添加通用的块 I/O 控制器接口，让你可以让各个任务“安安静静”地使用磁盘资源。</li>
<li>目前，CFQ I/O 调度程序使用它来在不同的 cgroup 之间分配磁盘 I/O 带宽，让它们“轮流”使用磁盘。它还可以用于限制特定块设备的 I/O 速率上限，防止某个任务或组的 I/O 使用量“太过火”。</li>
<li>如果你不确定是否需要这个选项，请谨慎使用。</li>
</ul>
</blockquote>
<p>通用的块 IO 控制器接口, 可以用于实现各种不同的控制策略. 目前, IOSCHED_CFQ 用它来在不同的 cgroup 之间分配磁盘 IO 带宽 (需要额外开启 CONFIG_CFQ_GROUP_IOSCHED), block io throttle 也会用它来针对特定块设备限制 IO 速率上限 (需要额外开启 CONFIG_BLK_DEV_THROTTLING). 更多信息可以参考 &quot; Documentation/cgroups/blkio-controller.txt&quot; 文件.</p>
<p>这是一个关于块IO控制器的设置，它提供了通用的块IO控制器接口，可以用于实现各种不同的控制策略。目前，IOSCHED_CFQ用它来在不同的cgroup之间分配磁盘IO带宽（需要额外开启CONFIG_CFQ_GROUP_IOSCHED），block io throttle也会用它来针对特定块设备限制IO速率上限（需要额外开启CONFIG_BLK_DEV_THROTTLING）。更多信息可以参考&quot;Documentation/cgroups/blkio-controller.txt&quot;文件。</p>
<h3 id="-cpu-controller-----">[*] CPU controller  &mdash;&gt;</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menuconfig CGROUP_SCHED
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;CPU controller&#34;</span>
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This feature lets CPU scheduler recognize task groups and control CPU
</span></span><span class="line"><span class="cl">	  bandwidth allocation to such task groups. It uses cgroups to group
</span></span><span class="line"><span class="cl">	  tasks.
</span></span></code></pre></td></tr></table>
</div>
</div><p>让CPU调度程序可以在不同的cgroup之间分配CPU的带宽</p>
<h4 id="-group-scheduling-for-sched_other-optional">[*] Group scheduling for SCHED_OTHER (Optional)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="k">if</span> CGROUP_SCHED
</span></span><span class="line"><span class="cl">config FAIR_GROUP_SCHED
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Group scheduling for SCHED_OTHER&#34;</span>
</span></span><span class="line"><span class="cl">	depends on CGROUP_SCHED
</span></span><span class="line"><span class="cl">	default CGROUP_SCHED
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>你是否想让你的系统变得更加“公平”？试试这个选项吧！它会在多个 cgroup 之间平均分配 CPU 带宽，让每个任务组都能获得公平的 CPU 资源。
如果你想让你的系统变得更加“和谐”？试试这个选项吧！它还可以防止某个任务组“霸占” CPU，让其他任务也能“分一杯羹”。
当然，这个选项也有一些“副作用”。如果你启用这个选项，可能会影响一些程序的性能。
如果你使用 Docker 或 systemd 的系统，建议你选择“Y”。因为 Docker 和 systemd 都依赖于它。</p>
</blockquote>
<ul>
<li>公平CPU调度策略,也就是在多个cgroup之间平均分配CPU带宽.&quot;<a href="http://linuxtoy.org/archives/small-patch-but-huge-improvement.html">鸡血补丁</a>&ldquo;CONFIG_SCHED_AUTOGROUP(自动分组调度功能)依赖于它.
Docker 依赖于它. systemd 资源控制单元 (resource control unit) 的 CPUShares 功能也依赖于它.</li>
</ul>
<p>这是一个关于公平CPU调度策略的设置，它可以在多个cgroup之间平均分配CPU带宽。</p>
<h4 id="---cpu-bandwidth-provisioning-for-fair_group_sched-optional">[*]   CPU bandwidth provisioning for FAIR_GROUP_SCHED (Optional)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CFS_BANDWIDTH
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;CPU bandwidth provisioning for FAIR_GROUP_SCHED&#34;</span>
</span></span><span class="line"><span class="cl">	depends on FAIR_GROUP_SCHED
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option allows users to define CPU bandwidth rates <span class="o">(</span>limits<span class="o">)</span> <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  tasks running within the fair group scheduler.  Groups with no limit
</span></span><span class="line"><span class="cl">	  <span class="nb">set</span> are considered to be unconstrained and will run with no
</span></span><span class="line"><span class="cl">	  restriction.
</span></span><span class="line"><span class="cl">	  See Documentation/scheduler/sched-bwc.rst <span class="k">for</span> more information.
</span></span></code></pre></td></tr></table>
</div>
</div><p>允许用户为运行在 CONFIG_FAIR_GROUP_SCHED 中的进程定义 CPU 带宽限制. 对于没有定义 CPU 带宽限制的 cgroup 而言, 可以无限制的使用 CPU 带宽. 详情参见 <a href="http://lxr.linux.no/linux/Documentation/scheduler/sched-bwc.txt">Documentation/scheduler/sched-bwc.txt</a> 文件. systemd 资源控制单元 (resource control unit) 的 CPUQuota 功能也依赖于它.</p>
<ul>
<li>你是否想让你的系统变得更加“公平”？试试这个选项吧！它会允许用户为运行在 CONFIG_FAIR_GROUP_SCHED 中的进程定义 CPU 带宽限制，让每个任务组都能获得公平的 CPU 资源。</li>
<li>如果你想让你的系统变得更加“有秩序”？试试这个选项吧！它还可以防止某个任务组滥用 CPU 资源，影响其他任务的运行。</li>
<li>当然，这个选项也有一些“副作用”。如果你启用这个选项，可能会影响一些程序的性能。</li>
<li>如果你使用 systemd 的系统，建议你选择“Y”。因为 systemd 的 CPUQuota 功能依赖于它。</li>
</ul>
<p>这是一个关于CPU带宽限制的设置，它允许用户为运行在CONFIG_FAIR_GROUP_SCHED中的进程定义CPU带宽限制。对于没有定义CPU带宽限制的cgroup而言，可以无限制地使用CPU带宽。如果你需要更多信息，可以查看这里。</p>
<h4 id="--group-scheduling-for-sched_rrfifo-optional">[ ] Group scheduling for SCHED_RR/FIFO (Optional)</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config RT_GROUP_SCHED
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Group scheduling for SCHED_RR/FIFO&#34;</span>
</span></span><span class="line"><span class="cl">	depends on CGROUP_SCHED
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This feature lets you explicitly allocate real CPU bandwidth
</span></span><span class="line"><span class="cl">	  to task groups. If enabled, it will also make it impossible to
</span></span><span class="line"><span class="cl">	  schedule realtime tasks <span class="k">for</span> non-root users <span class="k">until</span> you allocate
</span></span><span class="line"><span class="cl">	  realtime bandwidth <span class="k">for</span> them.
</span></span><span class="line"><span class="cl">	  See Documentation/scheduler/sched-rt-group.rst <span class="k">for</span> more information.
</span></span></code></pre></td></tr></table>
</div>
</div><p>允许用户为 cgroup 分配实时 CPU 带宽, 还可以对非特权用户的实时进程组进行调度. 详情参见  <a href="http://lxr.linux.no/linux/Documentation/scheduler/sched-rt-group.txt">Documentation/scheduler/sched-rt-group.txt</a> 文档. <strong>使用 systemd 的系统应该选 &ldquo;N&rdquo;</strong>。</p>
<ul>
<li>你是否想让你的系统变得更加“公平”？试试这个选项吧！它会允许用户为 cgroup 分配实时 CPU 带宽，让每个任务组都能获得公平的 CPU 资源。</li>
<li>如果你想让你的系统变得更加“刺激”？试试这个选项吧！它还可以对非特权用户的实时进程组进行调度，让他们也能享受到实时调度带来的“快感”。</li>
<li>当然，这个选项也有一些“副作用”。如果你启用这个选项，非特权用户将无法使用实时调度，除非你为他们分配了实时 CPU 带宽。</li>
<li>如果你使用 systemd 的系统，建议你选择“N”。因为 systemd 已经提供了自己的实时调度功能。</li>
</ul>
<p>这是一个关于实时进程组调度的设置，它允许用户为cgroup分配实时CPU带宽，还可以对非特权用户的实时进程组进行调度。如果启用此选项，将无法为非root用户调度实时任务，直到为它们分配实时带宽。</p>
<h3 id="----pids-controller-docker-optional">[ ]   PIDs controller (docker Optional)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_PIDS
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;PIDs controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides enforcement of process number limits in the scope of a
</span></span><span class="line"><span class="cl">	  cgroup. Any attempt to fork more processes than is allowed in the
</span></span><span class="line"><span class="cl">	  cgroup will fail. PIDs are fundamentally a global resource because it
</span></span><span class="line"><span class="cl">	  is fairly trivial to reach PID exhaustion before you reach even a
</span></span><span class="line"><span class="cl">	  conservative kmemcg limit. As a result, it is possible to grind a
</span></span><span class="line"><span class="cl">	  system to halt without being limited by other cgroup policies. The
</span></span><span class="line"><span class="cl">	  PIDs controller is designed to stop this from happening.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  It should be noted that organisational operations <span class="o">(</span>such as attaching
</span></span><span class="line"><span class="cl">	  to a cgroup hierarchy<span class="o">)</span> will *not* be blocked by the PIDs controller,
</span></span><span class="line"><span class="cl">	  since the PIDs limit only affects a process<span class="err">&#39;</span>s ability to fork, not to
</span></span><span class="line"><span class="cl">	  attach to a cgroup.
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<ul>
<li>你是否想让你的系统变得更加“有序”？试试这个选项吧！它会为每个 cgroup 设置一个进程数限制，防止某个 cgroup “生孩子”太多，影响其他 cgroup 的运行。</li>
<li>如果你想让你的系统变得更加“可控”？试试这个选项吧！它还可以防止系统因为进程数过多而“崩溃”。</li>
<li>当然，这个选项也有一些“副作用”。如果你启用这个选项，可能会影响一些程序的运行。</li>
<li>如果你不确定是否需要这个选项，可以选择不启用。</li>
</ul>
</blockquote>
<p>这是一个关于进程数量限制的设置，它可以在cgroup的范围内强制执行进程数量限制。如果尝试fork的进程数超过了cgroup允许的数量，将会失败。
由于PIDs本质上是全局资源，因为在达到甚至保守的kmemcg限制之前，很容易耗尽PIDs。
因此，可能会因为其他cgroup策略的限制而使系统停滞不前。PIDs控制器旨在防止这种情况发生。
需要注意的是，组织操作（例如附加到cgroup层次结构）<em>不会</em>被PIDs控制器阻止，因为PIDs限制只影响进程fork的能力，而不是附加到cgroup的能力。</p>
<p>允许限制同一 cgroup 内所有进程的数量, 超出限制后将无法 fork() 出新进程.</p>
<h3 id="----rdma-controller">[ ]   RDMA controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_RDMA
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;RDMA controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides enforcement of RDMA resources defined by IB stack.
</span></span><span class="line"><span class="cl">	  It is fairly easy <span class="k">for</span> consumers to exhaust RDMA resources, which
</span></span><span class="line"><span class="cl">	  can result into resource unavailability to other consumers.
</span></span><span class="line"><span class="cl">	  RDMA controller is designed to stop this from happening.
</span></span><span class="line"><span class="cl">	  Attaching processes with active RDMA resources to the cgroup
</span></span><span class="line"><span class="cl">	  hierarchy is allowed even <span class="k">if</span> can cross the hierarchy<span class="err">&#39;</span>s limit.
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>你是否想让你的系统变得更加“节俭”？试试这个选项吧！它会为每个 cgroup 设置 RDMA 资源限制，防止某个 cgroup “挥霍” RDMA 资源，影响其他 cgroup 的使用。</li>
<li>如果你想让你的系统变得更加“公平”？试试这个选项吧！它还可以防止某个 cgroup 因为抢占过多 RDMA 资源而“霸占”系统。</li>
<li>当然，这个选项也有一些“副作用”。如果你启用这个选项，可能会影响一些程序的性能。</li>
<li>如果你不确定是否需要这个选项，可以选择不启用。</li>
</ul>
<p>这是一个关于RDMA资源的设置，它可以强制执行由IB堆栈定义的RDMA资源。消费者很容易耗尽RDMA资源，这可能导致其他消费者无法使用资源。RDMA控制器旨在防止这种情况发生。即使进程具有活动的RDMA资源并且可能超过层次结构的限制，也允许将其附加到cgroup层次结构中。</p>
<h3 id="---freezer-controller">[*]   Freezer controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_FREEZER
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Freezer controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides a way to freeze and unfreeze all tasks in a
</span></span><span class="line"><span class="cl">	  cgroup.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  This option affects the ORIGINAL cgroup interface. The cgroup2 memory
</span></span><span class="line"><span class="cl">	  controller includes important in-kernel memory consumers per default.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  If you<span class="err">&#39;</span>re using cgroup2, say N.
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>你是否想让你的系统变得更加“安静”？试试这个选项吧！它可以让你将 cgroup 中的所有任务“冻结”，让它们乖乖地“休息”。</li>
<li>如果你想让你的系统变得更加“可控”？试试这个选项吧！它还可以让你在需要时“唤醒”冻结的任务。</li>
<li>当然，这个选项也有一些“副作用”。如果你启用这个选项，可能会影响一些程序的性能。</li>
<li>如果你使用 cgroup2，建议你选择“N”。因为 cgroup2 的 memory 控制器已经包含了一些重要的内核内存消费者。</li>
</ul>
<p>允许冻结 / 解冻 cgroup 内所有进程.<strong>Docker 依赖于它</strong>.</p>
<p>这是一个关于冷冻控制器的设置，它提供了一种冻结和解冻cgroup中所有任务的方法。如果你使用的是cgroup2，请选择N。</p>
<h3 id="----hugetlb-controller">[ ]   HugeTLB controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_HUGETLB
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;HugeTLB controller&#34;</span>
</span></span><span class="line"><span class="cl">	depends on HUGETLB_PAGE
</span></span><span class="line"><span class="cl">	<span class="k">select</span> PAGE_COUNTER
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides a cgroup controller <span class="k">for</span> HugeTLB pages.
</span></span><span class="line"><span class="cl">	  When you <span class="nb">enable</span> this, you can put a per cgroup limit on HugeTLB usage.
</span></span><span class="line"><span class="cl">	  The limit is enforced during page fault. Since HugeTLB doesn<span class="err">&#39;</span>t
</span></span><span class="line"><span class="cl">	  support page reclaim, enforcing the limit at page fault <span class="nb">time</span> implies
</span></span><span class="line"><span class="cl">	  that, the application will get SIGBUS signal <span class="k">if</span> it tries to access
</span></span><span class="line"><span class="cl">	  HugeTLB pages beyond its limit. This requires the application to know
</span></span><span class="line"><span class="cl">	  beforehand how much HugeTLB pages it would require <span class="k">for</span> its use. The
</span></span><span class="line"><span class="cl">	  control group is tracked in the third page lru pointer. This means
</span></span><span class="line"><span class="cl">	  that we cannot use the controller with huge page less than <span class="m">3</span> pages.
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>你是否想让你的系统变得更加“节制”？试试这个选项吧！它会为每个 cgroup 设置 HugeTLB 页面限制，防止某个 cgroup “挥霍” HugeTLB 页面，影响其他 cgroup 的使用。</li>
<li>如果你想让你的系统变得更加“可控”？试试这个选项吧！它还可以防止某个 cgroup 因为抢占过多 HugeTLB 页面而“霸占”系统。</li>
<li>当然，这个选项也有一些“副作用”。如果你启用这个选项，可能会影响一些程序的性能。</li>
<li>还有一个小缺点是，这个选项要求 HugeTLB 页面至少为 3 页。</li>
</ul>
<p>为cgroup添加对<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/">HugeTLB</a>页的资源控制功能.开启此选项之后,你就可以针对每个cgroup限定其对<a href="http://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/index.html">HugeTLB</a>的使用。
<strong>Docker 依赖于它</strong>.</p>
<p>这是一个关于HugeTLB的设置，它提供了一个cgroup控制器，用于管理HugeTLB页面。启用此选项后，您可以为每个cgroup设置HugeTLB使用限制。限制在页面错误时执行。由于HugeTLB不支持页面回收，在页面错误时强制执行限制意味着，如果应用程序尝试访问超出其限制的HugeTLB页面，则应用程序将收到SIGBUS信号。这需要应用程序事先知道它需要多少HugeTLB页面。控制组在第三页LRU指针中跟踪。这意味着我们不能使用小于3页的大页控制器。</p>
<h3 id="---cpuset-controller">[*]   Cpuset controller</h3>
<pre><code>[ ]     Include legacy /proc/&lt;pid&gt;/cpuset file (NEW)
</code></pre>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CPUSETS
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Cpuset controller&#34;</span>
</span></span><span class="line"><span class="cl">	depends on SMP
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option will <span class="nb">let</span> you create and manage CPUSETs which
</span></span><span class="line"><span class="cl">	  allow dynamically partitioning a system into sets of CPUs and
</span></span><span class="line"><span class="cl">	  Memory Nodes and assigning tasks to run only within those sets.
</span></span><span class="line"><span class="cl">	  This is primarily useful on large SMP or NUMA systems.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="http://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm">CPUSET</a> 支持: 允许将 CPU 和内存进行分组, 并指定某些进程只能运行于特定的分组。Docker 依赖于它。这里有一篇 <a href="http://book.2cto.com/201302/16297.html">CPUSET的用法</a></p>
<p>Include legacy /proc/<pid>/cpuset file：提供过时的 /proc/<pid>/cpuset 文件接口</p>
<h3 id="----device-controller">[ ]   Device controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_DEVICE
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Device controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides a cgroup controller implementing whitelists <span class="k">for</span>
</span></span><span class="line"><span class="cl">	  devices which a process in the cgroup can mknod or open.
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>* Device controller for cgroups
  CONFIG_CGROUP_DEVICE

  允许为cgroup建立设备白名单,这样cgroup内的进程将仅允许对白名单中的设备进行mknod/open操作
</code></pre>
<h3 id="----simple-cpu-accounting-controller">[ ]   Simple CPU accounting controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_CPUACCT
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Simple CPU accounting controller&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides a simple controller <span class="k">for</span> monitoring the
</span></span><span class="line"><span class="cl">	  total CPU consumed by the tasks in a cgroup.
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>* Simple CPU accounting cgroup subsystem
  CONFIG_CGROUP_CPUACCT

  提供一个简单的资源控制器(Resource Controller,用于实现一组任务间的资源共享),以监控cgroup内所有进程的总CPU使用量.
</code></pre>
<h3 id="----perf-controller">[ ]   Perf controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_PERF
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Perf controller&#34;</span>
</span></span><span class="line"><span class="cl">	depends on PERF_EVENTS
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option extends the perf per-cpu mode to restrict monitoring
</span></span><span class="line"><span class="cl">	  to threads which belong to the cgroup specified and run on the
</span></span><span class="line"><span class="cl">	  designated cpu.  Or this can be used to have cgroup ID in samples
</span></span><span class="line"><span class="cl">	  so that it can monitor performance events among cgroups.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N <span class="k">if</span> unsure.
</span></span></code></pre></td></tr></table>
</div>
</div><pre><code>* Enable perf_event per-cpu per-container group (cgroup) monitoring
  CONFIG_CGROUP_PERF

  将per-cpu模式进行扩展,使其可以监控属于特定cgroup并运行于特定CPU上的线程
</code></pre>
<h3 id="-----support-for-ebpf-programs-attached-to-cgroups">-*-   Support for eBPF programs attached to cgroups</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_BPF
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Support for eBPF programs attached to cgroups&#34;</span>
</span></span><span class="line"><span class="cl">	depends on BPF_SYSCALL
</span></span><span class="line"><span class="cl">	<span class="k">select</span> SOCK_CGROUP_DATA
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Allow attaching eBPF programs to a cgroup using the bpf<span class="o">(</span>2<span class="o">)</span>
</span></span><span class="line"><span class="cl">	  syscall <span class="nb">command</span> BPF_PROG_ATTACH.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  In which context these programs are accessed depends on the <span class="nb">type</span>
</span></span><span class="line"><span class="cl">	  of attachment. For instance, programs that are attached using
</span></span><span class="line"><span class="cl">	  BPF_CGROUP_INET_INGRESS will be executed on the ingress path of
</span></span><span class="line"><span class="cl">	  inet sockets.
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="----misc-resource-controller">[ ]   Misc resource controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_MISC
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Misc resource controller&#34;</span>
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides a controller <span class="k">for</span> miscellaneous resources on a host.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Miscellaneous scalar resources are the resources on the host system
</span></span><span class="line"><span class="cl">	  which cannot be abstracted like the other cgroups. This controller
</span></span><span class="line"><span class="cl">	  tracks and limits the miscellaneous resources used by a process
</span></span><span class="line"><span class="cl">	  attached to a cgroup hierarchy.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  For more information, please check misc cgroup section in
</span></span><span class="line"><span class="cl">	  /Documentation/admin-guide/cgroup-v2.rst.
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="----debug-controller">[ ]   Debug controller</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">config CGROUP_DEBUG
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Debug controller&#34;</span>
</span></span><span class="line"><span class="cl">	default n
</span></span><span class="line"><span class="cl">	depends on DEBUG_KERNEL
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  This option enables a simple controller that exports
</span></span><span class="line"><span class="cl">	  debugging information about the cgroups framework. This
</span></span><span class="line"><span class="cl">	  controller is <span class="k">for</span> control cgroup debugging only. Its
</span></span><span class="line"><span class="cl">	  interfaces are not stable.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  Say N.
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="---namespaces-support-----">-*- Namespaces support  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">menuconfig NAMESPACES
</span></span><span class="line"><span class="cl">	bool <span class="s2">&#34;Namespaces support&#34;</span> <span class="k">if</span> EXPERT
</span></span><span class="line"><span class="cl">	depends on MULTIUSER
</span></span><span class="line"><span class="cl">	default !EXPERT
</span></span><span class="line"><span class="cl">	<span class="nb">help</span>
</span></span><span class="line"><span class="cl">	  Provides the way to make tasks work with different objects using
</span></span><span class="line"><span class="cl">	  the same id. For example same IPC id may refer to different objects
</span></span><span class="line"><span class="cl">	  or same user id or pid may refer to different tasks when used in
</span></span><span class="line"><span class="cl">	  different namespaces.
</span></span></code></pre></td></tr></table>
</div>
</div><p>建议勾选。</p>
<h2 id="--checkpointrestore-support">[ ] Checkpoint/restore support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="--automatic-process-group-scheduling">[ ] Automatic process group scheduling</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><p>和<code>Control Group support</code>相关。为每个TTY动态地创建任务分组(cgroup),这样就可以降低高负载情况下的桌面延迟。如果勾选了<code>Control Group support</code>，这条建议开启。</p>
<h2 id="--enable-deprecated-sysfs-features-to-support-old-userspace-tools">[ ] Enable deprecated sysfs features to support old userspace tools</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="---kernel-user-space-relay-support-formerly-relayfs">-*- Kernel-&gt;user space relay support (formerly relayfs)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><p>为某些文件系统从内核往用户空间传递大数据量提供中继支持。根据情况选择。</p>
<h2 id="-initial-ram-filesystem-and-ram-disk-initramfsinitrd-support">[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="----initramfs-source-files">()    Initramfs source file(s)</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="---support-initial-ramdiskramfs-compressed-using-xxx">[*]   Support initial ramdisk/ramfs compressed using xxx</h2>
<p>这几个选项都建议勾选。</p>
<h3 id="---support-initial-ramdiskramfs-compressed-using-gzip">[*]   Support initial ramdisk/ramfs compressed using gzip</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---support-initial-ramdiskramfs-compressed-using-bzip2">[*]   Support initial ramdisk/ramfs compressed using bzip2</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---support-initial-ramdiskramfs-compressed-using-lzma">[*]   Support initial ramdisk/ramfs compressed using LZMA</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---support-initial-ramdiskramfs-compressed-using-xz">[*]   Support initial ramdisk/ramfs compressed using XZ</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---support-initial-ramdiskramfs-compressed-using-lzo">[*]   Support initial ramdisk/ramfs compressed using LZO</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---support-initial-ramdiskramfs-compressed-using-lz4">[*]   Support initial ramdisk/ramfs compressed using LZ4</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h3 id="---support-initial-ramdiskramfs-compressed-using-zstd">[*]   Support initial ramdisk/ramfs compressed using ZSTD</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="--boot-config-support">[ ] Boot config support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="-preserve-cpio-archive-mtimes-in-initramfs">[*] Preserve cpio archive mtimes in initramfs</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="compiler-optimization-level-optimize-for-performance--o2-----">Compiler optimization level (Optimize for performance (-O2))  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="-configure-standard-kernel-features-expert-users-----">[*] Configure standard kernel features (expert users)  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="---enable-kcmp-system-call">-*- Enable kcmp() system call</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="-enable-rseq-system-call">[*] Enable rseq() system call</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="----enabled-debugging-of-rseq-system-call">[ ]   Enabled debugging of rseq() system call</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="--embedded-system">[ ] Embedded system</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><p>嵌入式系统勾选</p>
<h2 id="--pc104-support">[ ] PC/104 support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="kernel-performance-events-and-counters-----">Kernel Performance Events And Counters  &mdash;&gt;</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><h2 id="--profiling-support">[ ] Profiling support</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"></code></pre></td></tr></table>
</div>
</div><pre><code>* Make audit loginuid immutable
  CONFIG_AUDIT_LOGINUID_IMMUTABLE

  审计时使用固定的loginuid.在使用[systemd](http://zh.wikipedia.org/wiki/Systemd)之类的系统上应该开启(login服务由init进程负责重启),在使用[SysVinit](https://wiki.archlinux.org/index.php/SysVinit_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29)或[Upstart](http://wangxu.me/blog/p/tag/init)之类的系统上应该关闭(login服务由系统管理员手动重启).[OpenRC](http://en.wikipedia.org/wiki/OpenRC)就是一个基于SysVinit的系统.
</code></pre>
<p>二．通用设置选项
其中，IPC Namespaces （IPC_NS）子选项表示 IPC 命名空间，命名空间的作用是区别同名的设备。这个选项也是为不同的服务器提供 IPC 的多命名，达到一个 IPC 提供多对象支持的目的。
General setup  &mdash;&gt;</p>
<p>()  Local version - append to kernel release
[<em>]  Automatically append version information to the version string
[</em>]  Support for paging of anonymous memory (swap)</p>
<p>[<em>]  POSIX Message Queues
[</em>]  BSD Process Accounting
[<em>]  BSD Process Accounting version 3 file format
[</em>]  Sysctl support
[ ]  Auditing support</p>
<p>[*]  Support for hot-pluggable devices</p>
<p>[*]  Kernel Userspace Events</p>
<p>[*]  Kernel .config support</p>
<p>[*]  Enable access to .config through /proc/config.gz</p>
<p>()   Initramfs source file(s)</p>
<p>[*]  Configure standard kernel features (for small systems)  &mdash;&gt;</p>
<pre><code>     --- Configure standard kernel features (for small systems)

     [ ]   Load all symbols for debugging/kksymoops

     [ ]    Do an extra kallsyms pass

     [ ]    Enable support for prinlk

     [ ]    BUG()support

     [ ]   Enable full-sinzed data structures for core

     [*]   Enable futex support

     [*]   Enable eventpoll support

     [*]   Optimize for size

     [*]   Use full shmem filesystem

     (0)   Function alignment

     (0)   Label alignment

     (0)   Loop alignment

     (0)   Jump alignment
</code></pre>
<p>Support for paging of anonymous memory (swap)：这是使用交换分区或者交换文件来做为虚拟内存的，当然要选上了。</p>
<p>Sysctl support：这个选项能不重新编译内核修改内核的某些参数和变量，如果你也选择了支持 / proc，将能从 / proc/sys 存取可以影响内核的参数或变量。建议你最好将它选上。</p>
<p>Auditing support：审记支持，用于和内核的某些子模块同时工作，例如 SELinux。只有选择此项及它的子项，才能调用有关审记的系统调用。</p>
<p>Support for hot-pluggable devices：是否支持热插拔的选项，肯定要选上。不然 USB、PCMCIA 等这些设备都用不了。</p>
<p>Kernel Userspace Events：内核中分为系统区和用户区，这里系统区和用户区进行通讯的一种方式，选上。</p>
<p>Kernel .config support：将. config 配置信息保存在内核中，选上它及它的子项使得其它用户能从 / proc 中得到内核的配置。</p>
<p>Configure standard kernel features (for small systems)：这是为了编译某些特殊的内核使用的，通常你可以不选择这一选项，你也不用对它下面的子项操心了。</p>
<p>Load all symbols for debugging/kksymoops：是否装载所有的调试符号表信息，如果你不需要对内核调试，不需要选择此项。</p>
<p>Enable futex support：不选这个内核不一定能正确的运行使用 glibc 的程序，当然要选上。</p>
<p>Enable eventpoll support：不选这个内核将不支持事件轮循的系统调用，最好选上。</p>
<p>Optimize for size：这个选项使 gcc 使用 - Os 的参数而不是 - O2 的参数来优化编译，以获得更小尺寸的内核，建议选上。</p>
<p>Use full shmem filesystem：除非你在很少的内存且不使用交换内存时，才不要选择这项。</p>
<p>后面的这四项都是在编译时内存中的对齐方式，0 表示编译器的默认方式。使用内存对齐能提高程序的运行速度，但是会增加程序对内存的使用量。</p>
<ul>
<li>
<p>Cross-compiler tool prefix
CONFIG_CROSS_COMPILE</p>
<p>交叉编译工具前缀(比如&quot;arm-linux-&ldquo;相当于使用&quot;make CROSS_COMPILE=arm-linux-&ldquo;进行编译).除非你想配置后默认自动进行交叉编译,否则不要使用此选项.</p>
</li>
<li>
<p>Support for paging of anonymous memory (swap)
CONFIG_SWAP</p>
<p>使用交换分区或者交换文件来做为虚拟内存</p>
</li>
<li>
<p>open by fhandle syscalls
CONFIG_FHANDLE</p>
<p>用户程序可以使用句柄(而非文件名)来追踪文件(使用open_by_handle_at(2)/name_to_handle_at(2)系统调用),即使某文件被重命名,用户程序依然可定位那个文件.此特性有助于实现用户空间文件服务器(userspace file server).不确定的选&quot;N&rdquo;,但使用systemd的建议选&quot;Y&rdquo;.</p>
</li>
<li>
<p>Timers subsystem</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-timerm/">Linux内核时钟子系统</a></li>
<li>
<ul>
<li>
<p>Timer tick handling</p>
<ul>
<li>内核时钟滴答处理程序,更多信息可以参考内核源码树下的&rdquo;<a href="http://lxr.linux.no/linux/Documentation/timers/NO_HZ.txt">Documentation/timers/NO_HZ.txt</a>&ldquo;文件</li>
<li>
<ul>
<li>
<p>Periodic timer ticks (constant rate, no dynticks)
CONFIG_HZ_PERIODIC</p>
<p>无论CPU是否需要,都强制按照固定频率不断触发时钟中断.这是最耗电的方式,不推荐使用</p>
</li>
<li>
<p>Idle dynticks system (tickless idle)
CONFIG_NO_HZ_IDLE</p>
<p>CPU在空闲状态时不产生不必要的时钟中断,以使处理器能够在较低能耗状态下运行以节约电力,适合于大多数场合</p>
</li>
<li>
<p>Full dynticks system (tickless)
CONFIG_NO_HZ_FULL</p>
<p><a href="http://www.cnbeta.com/articles/238600.htm">完全无滴嗒</a>:即使CPU在忙碌状态也尽可能关闭所有时钟中断,适用于CPU在同一时间仅运行一个任务,或者用户空间程序极少与内核交互的场合.即使开启此选项,也需要额外设置&quot;nohz_full=?&ldquo;内核命令行参数才能真正生效.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Full dynticks system on all CPUs by default
CONFIG_NO_HZ_FULL_ALL</p>
<p>即使没有设置&quot;nohz_full&quot;引导参数,也默认对所有CPU(boot CPU 除外)开启完全无滴答特性.</p>
</li>
<li>
<p>Old Idle dynticks config
CONFIG_NO_HZ</p>
<p>等价于CONFIG_NO_HZ_IDLE,临时用来兼容老版本内核选项,未来会被删除.</p>
</li>
<li>
<p>High Resolution Timer Support
CONFIG_HIGH_RES_TIMERS</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime4/index.html">高精度定时器</a>(hrtimer)是从2.6.16开始引入,用于取代传统timer wheel(<a href="http://www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime3/index.html">基于jiffies定时器</a>)的时钟子系统.可以降低与内核其他模块的耦合性,还可以提供比1毫秒更高的精度(因为它可以读取HPET/TSC等新型硬件时钟源),可以更好的支持音视频等对时间精度要求较高的应用.建议选&quot;Y&rdquo;.[提示]这里说的&quot;定时器&quot;是指&quot;软件定时器&rdquo;,而不是主板或CPU上集成的<a href="http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime2/index.html">硬件时钟发生器</a>(ACPI PM Timer/HPET Timer/TSC Timer).</p>
</li>
<li>
<p>Export task/process statistics through netlink
CONFIG_TASKSTATS</p>
<ul>
<li></li>
<li>
<ul>
<li>
<p>Enable per-task delay accounting
CONFIG_TASK_DELAY_ACCT</p>
<p>在统计信息中包含进程等候系统资源(cpu,IO同步,内存交换等)所花费的时间</p>
</li>
<li>
<p>Enable extended accounting over taskstats
CONFIG_TASK_XACCT</p>
<ul>
<li>在统计信息中包含进程的更多扩展信息.</li>
<li>
<ul>
<li>
<p>Enable per-task storage I/O accounting
CONFIG_TASK_IO_ACCOUNTING</p>
<p>在统计信息中包含进程在存储设备上的I/O字节数.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>RCU Subsystem</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-rcu/">RCU(Read-Copy Update)子系统</a>.在读多写少的情况下,这是一个高性能的锁机制,对于被RCU保护的共享数据结构,读者不需要获得任何锁就可以访问它(速度非常快),但写者在访问它时首先拷贝一个副本,然后对副本进行修改,最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据,速度非常慢.RCU只适用于读多写少的情况:如网络路由表的查询更新,设备状态表的维护,数据结构的延迟释放以及多径I/O设备的维护等.</li>
<li>
<ul>
<li>
<p>RCU Implementation</p>
<ul>
<li>RCU的实现方式</li>
<li>
<ul>
<li>
<p>Tree-based hierarchical RCU
CONFIG_TREE_RCU</p>
<p>基于树型分层结构的实现.最适用于多CPU的非实时系统.</p>
</li>
<li>
<p>Preemptible tree-based hierarchical RCU
CONFIG_TREE_PREEMPT_RCU</p>
<p>抢占式基于树型分层结构的实现.最适用于那些要求快速响应的多CPU实时系统.</p>
</li>
<li>
<p>UP-only small-memory-footprint RCU
CONFIG_TINY_RCU</p>
<p>最简单的实现,能够大幅降低RCU系统的内存占用.最适用于单CPU的非实时系统.</p>
</li>
<li>
<p>Preemptible UP-only small-memory-footprint RCU
CONFIG_TINY_PREEMPT_RCU</p>
<p>抢占式简单实现,能够大幅降低RCU系统的内存占用.最适用于那些要求快速响应的单CPU实时系统.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Consider userspace as in RCU extended quiescent state
CONFIG_RCU_USER_QS</p>
<p>在内核和用户边界设置钩子函数,将运行在用户态的CPU从全局RCU状态机制中移除,这样就不会在RCU系统中维护此CPU的时钟滴答.除非你想要帮助开发CONFIG_NO_HZ_FULL模块,否则不要打开此选项,而且它还会对性能有不利影响.</p>
</li>
<li>
<p>Force context tracking
CONFIG_CONTEXT_TRACKING_FORCE</p>
<p>默认在内核和用户边界进行探测(上下文跟踪),以便测试依赖于此特性的各种功能(比如用户空间的 RCU extended quiescent state),这个特性目前仅用于调试目的,未来也许会用于为CONFIG_NO_HZ_FULL模块提供支持</p>
</li>
<li>
<p>Tree-based hierarchical RCU fanout value
CONFIG_RCU_FANOUT</p>
<p>这个选项控制着树形RCU层次结构的端点数(fanout),以允许RCU子系统在拥有海量CPU的系统上高效工作.这个值必须至少等于CONFIG_NR_CPUS的1/4次方(4次根号).生产系统上应该使用默认值(64).仅在你想调试RCU子系统时才需要减小此值.</p>
</li>
<li>
<p>Tree-based hierarchical RCU leaf-level fanout value
CONFIG_RCU_FANOUT_LEAF</p>
<p>这个选项控制着树形RCU层次结构的叶子层的端点数(leaf-level fanout).对于期望拥有更高能耗比(更节能)的系统,请保持其默认值(16).对于拥有成千上万个CPU的系统来说,应该考虑将其设为最大值(CONFIG_RCU_FANOUT).</p>
</li>
<li>
<p>Disable tree-based hierarchical RCU auto-balancing
CONFIG_RCU_FANOUT_EXACT</p>
<p>强制按照CONFIG_RCU_FANOUT_LEAF的值,而不是使用自动平衡树结构来实现RCU子系统.目前仅用于调试目的.未来也许会用于增强NUMA系统的性能.</p>
</li>
<li>
<p>Accelerate last non-dyntick-idle CPU&rsquo;s grace periods
CONFIG_RCU_FAST_NO_HZ</p>
<p>即使CPU还在忙碌,也允许进入dynticks-idle状态,并且阻止RCU每4个滴答就唤醒一次该CPU,这样能够更有效的使用电力,同时也拉长了RCU grace period的时间,造成性能降低.如果能耗比对你而言非常重要(你想节省每一分电力),并且你不在乎系统性能的降低(CPU唤醒时间增加),可以开启此选项.台式机和服务器建议关闭此选项.</p>
</li>
<li>
<p>Enable RCU priority boosting
CONFIG_RCU_BOOST</p>
<ul>
<li>允许提升RCU子系统的实时优先级(包括读操作与写操作),以避免RCU操作被阻塞太长时间.如果系统的CPU负载经常很重,或者你需要快速的实时响应系统,那么就选&quot;Y&quot;,否则应该选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Real-time priority to boost RCU readers to
CONFIG_RCU_BOOST_PRIO</p>
<p>允许提升被长时间抢占(阻塞)的RCU读操作的实时优先级到什么程度.取值范围是[1,99].默认值&quot;1&quot;适用于实时应用程序中不包含CPU密集型(CPU-bound)线程的常规场合(例如大多数桌面系统).但是如果你的实时应用程序拥有一个或多个CPU密集型线程,那么可能需要增加这个值,具体可以参考内核帮助的说明.仅在你确实理解了的情况下再改变默认值.</p>
</li>
<li>
<p>Milliseconds to delay boosting after RCU grace-period start
CONFIG_RCU_BOOST_DELAY</p>
<p>在提升RCU读操作的优先级之前,允许有多长时间潜伏期(阻塞),取值范围是[0,3000],单位是毫秒,默认值是&quot;500&quot;.不确定的请使用默认值.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Offload RCU callback processing from boot-selected CPUs
CONFIG_RCU_NOCB_CPU</p>
<p>如果你想帮助调试内核可以开启,否则请关闭.</p>
</li>
<li>
<p>Build-forced no-CBs CPUs</p>
<p>在开启CONFIG_RCU_NOCB_CPU选项的情况下,指定哪些CPU是No-CB CPU,相当于预先设置&quot;rcu_nocbs=&ldquo;内核引导参数.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Kernel .config support
CONFIG_IKCONFIG</p>
<ul>
<li>把内核的配置信息编译进内核中,以后可以通过scripts/extract-ikconfig脚本从内核镜像中提取这些信息</li>
<li>
<ul>
<li>
<p>Enable access to .config through /proc/config.gz
CONFIG_IKCONFIG_PROC</p>
<p>允许通过 /proc/config.gz 文件访问内核的配置信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Kernel log buffer size
CONFIG_LOG_BUF_SHIFT</p>
<p>设置内核日志缓冲区的大小: 12(最小值)=4KB,&hellip;,16=64KB,17=128KB,18=256KB,&hellip;,21(最大值)=2048KB</p>
</li>
<li>
<p>Control Group support
CONFIG_CGROUPS</p>
<ul>
<li></li>
<li>
<ul>
<li>
<p>Example debug cgroup subsystem
CONFIG_CGROUP_DEBUG</p>
<p>导出cgroups框架的调试信息,仅用于调试目的.</p>
</li>
<li>
<p>Resource counters
CONFIG_RESOURCE_COUNTERS</p>
<ul>
<li>为cgroup提供独立于controller资源计数器</li>
<li>
<ul>
<li>
<p>Memory Resource Controller for Control Groups
CONFIG_MEMCG</p>
<ul>
<li>为cgroup添加内存资源控制器,包含匿名内存和页面缓存(<a href="http://lxr.linux.no/linux/Documentation/cgroups/memory.txt">Documentation/cgroups/memory.txt</a>).开启此选项后,将会增加关联到每个内存页fixed memory大小,具体在64位系统上是40bytes/PAGE_SIZE.仅在你确实明白什么是 <a href="http://lxr.linux.no/linux/Documentation/cgroups/memory.txt">memory resource controller</a> 并且确实需要的情况下才开启此选项.此功能可以通过命令行选项&quot;cgroup_disable=memory&quot;进行关闭.</li>
<li>
<ul>
<li>
<p>Memory Resource Controller Swap Extension
CONFIG_MEMCG_SWAP</p>
<ul>
<li>给 <a href="http://lxr.linux.no/linux/Documentation/cgroups/memory.txt">Memory Resource Controller</a> 添加对swap的管理功能.这样就可以针对每个cgroup限定其使用的mem+swap总量.如果关闭此选项, memory resource controller 将仅能限制mem的使用量,而无法对swap进行控制(进程有可能耗尽swap).开启此功能会对性能有不利影响,并且为了追踪swap的使用也会消耗更多的内存(如果swap的页面大小是4KB,那么每1GB的swap需要额外消耗512KB内存),所以在内存较小的系统上不建议开启.</li>
<li>
<ul>
<li>
<p>Memory Resource Controller Swap Extension enabled by default
CONFIG_MEMCG_SWAP_ENABLED</p>
<p>如果开启此选项,那么将默认开启CONFIG_MEMCG_SWAP特性,否则将默认关闭.即使默认开启也可以通过内核引导参数&quot;swapaccount=0&quot;禁止此特性.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Memory Resource Controller Kernel Memory accounting
CONFIG_MEMCG_KMEM</p>
<p>为 Memory Resource Controller 添加对内核对象所占用内存的管理功能.和标准的 Memory Resource Controller 对内存的控制不一样之处在于:这些内核对象所占用的内存是基于每个内存页的,并且可以被swap到硬盘.使用这个功能可以确保cgroup中的进程不会单独耗尽所有内核资源.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Group scheduling for SCHED_RR/FIFO
CONFIG_RT_GROUP_SCHED</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Block IO controller
CONFIG_BLK_CGROUP</p>
<ul>
<li>通用的块IO控制器接口,可以用于实现各种不同的控制策略.目前,IOSCHED_CFQ用它来在不同的cgroup之间分配磁盘IO带宽(需要额外开启CONFIG_CFQ_GROUP_IOSCHED),<a href="http://blog.tao.ma/?p=43">block io throttle</a>也会用它来针对特定块设备限制IO速率上限(需要额外开启CONFIG_BLK_DEV_THROTTLING).更多信息可以参考&rdquo;<a href="http://lxr.linux.no/linux/Documentation/cgroups/blkio-controller.txt">Documentation/cgroups/blkio-controller.txt</a>&ldquo;文件.</li>
<li>
<ul>
<li>
<p>Enable Block IO controller debugging
CONFIG_DEBUG_BLK_CGROUP</p>
<p>仅用于调试 Block IO controller 目的.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Checkpoint/restore support
CONFIG_CHECKPOINT_RESTORE</p>
<p>在内核中添加&quot;检查点/恢复&quot;支持.也就是添加一些辅助的代码用于设置进程的 text, data, heap 段,并且在 /proc 文件系统中添加一些额外的条目.主要用于调试目的.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Namespaces support
CONFIG_NAMESPACES</p>
<ul>
<li><a href="http://www.cnblogs.com/lisperl/archive/2012/05/03/2480316.html">命名空间</a>支持.用于支持基于容器的轻量级虚拟化技术(比如<a href="http://www.cnblogs.com/lisperl/archive/2012/04/15/2450183.html">LXC</a>).</li>
<li>
<ul>
<li>
<p>UTS namespace
CONFIG_UTS_NS</p>
<p>uname() 系统调用的命名空间支持</p>
</li>
<li>
<p>IPC namespace
CONFIG_IPC_NS</p>
<p>进程间通信对象ID的命名空间支持</p>
</li>
<li>
<p>User namespace
CONFIG_USER_NS</p>
<p>允许容器(也就是<a href="http://en.wikipedia.org/wiki/Linux-VServer">VServer</a>)使用user命名空间.如果开启此项,建议同时开启CONFIG_MEMCG和CONFIG_MEMCG_KMEM选项,以允许用户空间使用&quot;memory cgroup&quot;限制非特权用户的内存使用量.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>PID Namespaces
CONFIG_PID_NS</p>
<p>进程PID命名空间支持</p>
</li>
<li>
<p>Network namespace
CONFIG_NET_NS</p>
<p>网络协议栈的命名空间支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Require conversions between uid/gids and their internal representation
CONFIG_UIDGID_STRICT_TYPE_CHECKS</p>
<p>强制将uid/gid转换为内部表示形式,以让那些未对uid/gid进行转换的内核子系统代码也能正常编译.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Automatic process group scheduling
CONFIG_SCHED_AUTOGROUP</p>
<p>每个TTY动态地创建任务分组(cgroup),这样就可以降低高负载情况下的桌面延迟.也就是传说中的桌面&quot;<a href="http://wowubuntu.com/kernel-patch.html">鸡血补丁</a>&quot;,桌面用户建议开启.但服务器建议关闭.</p>
</li>
<li>
<p>Enable deprecated sysfs features to support old userspace tools
CONFIG_SYSFS_DEPRECATED</p>
<ul>
<li>为了兼容旧版本的应用程序而保留过时的sysfs特性.仅当在使用2008年以前的发行版时才需要开启,2009年之后的发行版中必须关闭.</li>
<li>
<ul>
<li>
<p>Enable deprecated sysfs features by default
CONFIG_SYSFS_DEPRECATED_V2</p>
<p>默认开启上述特性</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Kernel-&gt;user space relay support (formerly relayfs)
CONFIG_RELAY</p>
<p>在某些文件系统(比如debugfs)中提供<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-relay/">中继(relay)</a>支持(从内核空间向用户空间传递大批量数据).主要用于调试内核.</p>
</li>
<li>
<p>Initial RAM filesystem and RAM disk (initramfs/initrd) support
CONFIG_BLK_DEV_INITRD</p>
<ul>
<li>初始内存文件系统(<a href="http://linux.chinaunix.net/techdoc/net/2009/06/24/1120335.shtml">initramfs</a>,2.6以上内核的新机制,使用cpio格式,占据的内存随数据的增减自动增减)与初始内存盘(<a href="http://zh.wikipedia.org/wiki/Initrd">initrd</a>,2.4以前内核遗留的老机制,使用loop设备,占据一块固定的内存,需要额外开启CONFIG_BLK_DEV_RAM选项才生效)支持,一般通过lilo/grub的initrd指令加载.更多细节可以参考&quot;<a href="http://lxr.linux.no/linux/Documentation/initrd.txt">Documentation/initrd.txt</a>&ldquo;文件,关于<a href="http://blog.linux.org.tw/~jserv/archives/001954.html">initrd到initramfs的进化</a>(<a href="http://hi.baidu.com/toniya/item/da1a25453b6da135fa8960a6">墙内镜像</a>),可以参考IBM上的两篇文章:<a href="http://www.ibm.com/developerworks/cn/linux/l-k26initrd/">Linux2.6 内核的 Initrd 机制解析</a>和<a href="http://www.ibm.com/developerworks/cn/linux/l-initrd.html">Linux 初始 RAM 磁盘（initrd）概述</a>.</li>
<li>
<ul>
<li>
<p>Initramfs source file(s)
CONFIG_INITRAMFS_SOURCE</p>
<ul>
<li>如果你想<a href="http://www.arm9home.net/read.php?tid=5645">将initramfs镜像直接嵌入内核</a>(比如嵌入式环境或者想使用 EFI stub kernel),而不是通过lilo/grub这样的引导管理器加载,可以使用此选项,否则请保持空白.这个选项指明用来制作initramfs镜像的原料,可以是一个.cpio文件或一个空格分隔的目录与文件列表.细节可以参考&rdquo;<a href="http://lxr.linux.no/linux/Documentation/early-userspace/README">Documentation/early-userspace/README</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>User ID to map to 0 (user root)
INITRAMFS_ROOT_UID</p>
<p>此选项仅在CONFIG_INITRAMFS_SOURCE中包含目录时才有效,将此值设为非零(例如&quot;37&rdquo;),那么所有UID=37的文件在打包到initramfs镜像内时,其UID都将被设为&quot;0&quot;.</p>
</li>
<li>
<p>Group ID to map to 0 (group root)
INITRAMFS_ROOT_GID</p>
<p>此选项仅在CONFIG_INITRAMFS_SOURCE中包含目录时才有效,将此值设为非零(例如&quot;37&quot;),那么所有GID=37的文件在打包到initramfs镜像内时,其GID都将被设为&quot;0&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support initial ramdisks compressed using gzip
CONFIG_RD_GZIP</p>
<p>支持经过gzip压缩的ramdisk或cpio镜像</p>
</li>
<li>
<p>Support initial ramdisks compressed using bzip2
CONFIG_RD_BZIP2</p>
<p>支持经过bzip2压缩的ramdisk或cpio镜像</p>
</li>
<li>
<p>Support initial ramdisks compressed using LZMA
CONFIG_RD_LZMA</p>
<p>支持经过LZMA压缩的ramdisk或cpio镜像</p>
</li>
<li>
<p>Support initial ramdisks compressed using XZ
CONFIG_RD_XZ</p>
<p>支持经过XZ压缩的ramdisk或cpio镜像</p>
</li>
<li>
<p>Support initial ramdisks compressed using LZO
CONFIG_RD_LZO</p>
<p>支持经过LZO压缩的ramdisk或cpio镜像</p>
</li>
<li>
<p>Built-in initramfs compression mode</p>
<p>选择initramfs镜像的压缩格式.&ldquo;gzip&quot;是兼容性最好的格式,但是压缩率却最低.&ldquo;XZ&quot;是目前渐渐流行的格式,压缩率高,解压速度也不慢.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Optimize for size
CONFIG_CC_OPTIMIZE_FOR_SIZE</p>
<p>编译时优化内核尺寸(使用GCC的&rdquo;-Os&quot;而不是&rdquo;-O2&quot;参数编译),这会得到更小的内核,但是运行速度可能会更慢.主要用于嵌入式环境.</p>
</li>
<li>
<p>Configure standard kernel features (expert users)
CONFIG_EXPERT</p>
<ul>
<li>配置标准的内核特性(仅供专家使用).这个选项允许你改变内核的&quot;标准&quot;特性(比如用于需要&quot;非标准&quot;内核的特定环境中),仅在你确实明白自己在干什么的时候才开启.</li>
<li>
<ul>
<li>
<p>Enable 16-bit UID system calls
CONFIG_UID16</p>
<p>允许对UID系统调用进行过时的16-bit包装,建议关闭</p>
</li>
<li>
<p>Sysctl syscall support
CONFIG_SYSCTL_SYSCALL</p>
<p>二进制sysctl接口支持.由于现在流行直接通过/proc/sys以ASCII明码方式修改内核参数(需要开启CONFIG_PROC_SYSCTL选项),所以已经不需要再通过二进制接口去控制内核参数,建议关闭它以减小内核尺寸.</p>
</li>
<li>
<p>Load all symbols for debugging/ksymoops
CONFIG_KALLSYMS</p>
<ul>
<li>装载所有的调试符号表信息,会增大内核体积,仅供调试时选择</li>
<li>
<ul>
<li>
<p>Include all symbols in kallsyms
CONFIG_KALLSYMS_ALL</p>
<p>在<a href="http://blog.csdn.net/diy534/article/details/6941001">/proc/kallsyms</a>中包含内核知道的所有符号,内核将会增大300K,仅在你确实需要的时候再开启</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Enable support for printk
CONFIG_PRINTK</p>
<p>允许内核向终端打印字符信息.如果关闭,内核在初始化过程中将不会输出字符信息,这会导致很难诊断系统故障.仅在你确实不想看到任何内核信息时选&quot;N&quot;.否则请选&quot;Y&quot;.</p>
</li>
<li>
<p>BUG() support
CONFIG_BUG</p>
<p>显示故障和失败条件(BUG和WARN),禁用它将可能导致隐含的错误被忽略.建议仅在嵌入式设备或者无法显示故障信息的系统上关闭</p>
</li>
<li>
<p>Enable ELF core dumps
CONFIG_ELF_CORE</p>
<p>内存转储支持,可以帮助调试ELF格式的程序,用于调试和开发用户态程序</p>
</li>
<li>
<p>Enable PC-Speaker support
CONFIG_PCSPKR_PLATFORM</p>
<p>主板上的<a href="http://blog.csdn.net/raptor/article/details/7636997">蜂鸣器</a>支持.<a href="http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html">主板上的蜂鸣器</a>只能发出或长或短的&quot;滴&quot;或&quot;嘟嘟&quot;声,一般用于系统报警.不要和能够播放音乐的扬声器混淆.如果你的主板上没有就关闭,有的话(开机自检完成后一般能听到&quot;滴&quot;的一声)还是建议开启.</p>
</li>
<li>
<p>Enable full-sized data structures for core
CONFIG_BASE_FULL</p>
<p>在内核中使用全尺寸的数据结构.禁用它将使得某些内核的数据结构减小以节约内存,但是将会降低性能</p>
</li>
<li>
<p>Enable futex support
CONFIG_FUTEX</p>
<p><a href="http://hi.baidu.com/pbskasefcqcfjxr/item/8f0271c5a07d7c52ac00ef12">快速用户空间互斥(fast userspace mutexes)</a>可以使线程串行化以避免竞态条件,也提高了响应速度.禁用它将导致内核不能正确的运行基于glibc的程序</p>
</li>
<li>
<p>Enable eventpoll support
CONFIG_EPOLL</p>
<p><a href="http://blog.csdn.net/sparkliang/article/details/4770655">Epoll</a>系列系统调用(epoll_*)支持,这是当前在Linux下开发大规模并发网络程序(比如Nginx)的热门人选,设计目的是取代既有POSIX select(2)与poll(2)系统接口,建议开启.</p>
</li>
<li>
<p>Enable signalfd() system call
CONFIG_SIGNALFD</p>
<p><a href="http://cpp.ezbty.org/import_doc/linux_manpage/signalfd4.2.html">signalfd()</a>系统调用支持,建议开启.传统的处理信号的方式是注册信号处理函数,由于信号是异步发生的,要解决数据的并发访问和可重入问题.signalfd可以将信号抽象为一个文件描述符,当有信号发生时可以对其read,这样可以将信号的监听放到select/poll/epoll监听队列中.</p>
</li>
<li>
<p>Enable timerfd() system call
CONFIG_TIMERFD</p>
<p><a href="http://blog.csdn.net/walkingman321/article/details/6162055">timerfd()</a>系统调用支持,建议开启.timerfd可以实现定时器功能,将定时器抽象为文件描述符,当定时器到期时可以对其read,这样也可以放到select/poll/epoll监听队列中.更多信息可以参考<a href="http://blog.csdn.net/gdutliuyun827/article/details/8460417">linux新的API signalfd、timerfd、eventfd使用说明</a></p>
</li>
<li>
<p>Enable eventfd() system call
CONFIG_EVENTFD</p>
<p><a href="http://www.cppblog.com/peija/archive/2010/10/07/128941.html">eventfd()</a>系统调用支持,建议开启.eventfd实现了线程之间事件通知的方式,eventfd的缓冲区大小是sizeof(uint64_t),向其write可以递增这个计数器,read操作可以读取,并进行清零.eventfd也可以放到select/poll/epoll监听队列中.当计数器不是0时,有可读事件发生,可以进行读取.</p>
</li>
<li>
<p>Use full shmem filesystem
CONFIG_SHMEM</p>
<p>完全使用shmem来代替ramfs.shmem是基于共享内存的文件系统(可以使用swap),在启用CONFIG_TMPFS后可以挂载为tmpfs供用户空间使用,它比简单的ramfs先进许多.仅在微型嵌入式环境中且没有swap的情况下才可能会需要使用原始的ramfs.</p>
</li>
<li>
<p>Enable AIO support
CONFIG_AIO</p>
<p>开启POSIX异步IO支持.它常常被高性能的多线程程序使用,建议开启</p>
</li>
<li>
<p>Enable PCI quirk workarounds
CONFIG_PCI_QUIRKS</p>
<p>开启针对多种PCI芯片组的错误规避功能,仅在确定你的PCI芯片组确实没有没有任何bug时才关闭此功能.至于究竟哪些芯片组有bug,你可以直接打开&quot;<a href="http://lxr.linux.no/linux/drivers/pci/quirks.c">drivers/pci/quirks.c</a>&ldquo;文件查看.不确定的选&quot;Y&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Embedded system
CONFIG_EMBEDDED</p>
<p>如果你是为嵌入式系统编译内核,可以开启此选项,这样一些高级选项就会显示出来.单独选中此项本身对内核并无任何改变.</p>
</li>
<li>
<p>Kernel Performance Events And Counters
CONFIG_PERF_EVENTS</p>
<ul>
<li>性能相关的事件和计数器支持(既有硬件的支持也有软件的支持).大多数现代CPU都会通过性能计数寄存器对特定类型的硬件事件(指令执行,缓存未命中,分支预测失败)进行计数,同时又丝毫不会减慢内核和应用程序的运行速度.这些寄存器还会在某些事件计数到达特定的阈值时触发中断,从而可以对代码进行性能分析. Linux Performance Event 子系统对上述特性进行了抽象,提供了针对每个进程和每个CPU的计数器,并可以被 tools/perf/ 目录中的&quot;perf&quot;工具使用.</li>
<li>
<ul>
<li>
<p>Debug: use vmalloc to back perf mmap() buffers
CONFIG_DEBUG_PERF_USE_VMALLOC</p>
<p>主要用于调试vmalloc代码.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Enable VM event counters for /proc/vmstat
CONFIG_VM_EVENT_COUNTERS</p>
<p>&ldquo;<a href="http://blog.csdn.net/plusboy/article/details/1528252">/proc/vmstat</a>&ldquo;中包含了从内核导出的虚拟内存的各种统计信息.开启此项后可以显示较详细的信息(包含各种事件计数器),关闭此项则仅仅显示很简略的信息.主要用于调试和统计.</p>
</li>
<li>
<p>Enable SLUB debugging support
CONFIG_SLUB_DEBUG</p>
<p>SLUB调试支持,禁用后可显著降低内核大小,同时/sys/kernel/slab也将不复存在.</p>
</li>
<li>
<p>Disable heap randomization
CONFIG_COMPAT_BRK</p>
<p>禁用堆随机化(heap randomization)功能.堆随机化可以让针对堆溢出的攻击变得困难,但是不兼容那些古董级的二进制程序(2000年以前).如果你不需要使用这些古董程序,那么选&quot;N&rdquo;.</p>
</li>
<li>
<p>Choose SLAB allocator</p>
<ul>
<li>选择内存分配管理器</li>
<li>
<ul>
<li>
<p>SLAB
CONFIG_SLAB</p>
<p>久经考验的slab内存分配器,在大多数情况下都具有良好的适应性.</p>
</li>
<li>
<p>SLUB (Unqueued Allocator)
CONFIG_SLUB</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-slub/">SLUB</a>与SLAB兼容,但通过取消大量的队列和相关开销,简化了slab的结构.特别是在多核时拥有比slab更好的性能和更好的系统可伸缩性.</p>
</li>
<li>
<p>SLOB (Simple Allocator)
CONFIG_SLOB</p>
<p>SLOB针对小型系统设计,做了非常激进的简化,以适用于内存非常有限(小于64M)的嵌入式环境.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Profiling support
CONFIG_PROFILING</p>
<p>添加扩展的性能分析支持,可以被<a href="http://baike.baidu.com/view/2973608.htm">OProfile</a>之类的工具使用.仅用于调试目的.</p>
</li>
<li>
<p>OProfile system profiling
CONFIG_OPROFILE</p>
<ul>
<li><a href="http://blog.csdn.net/yili_xie/article/details/4925648">OProfile性能分析工具</a>支持,仅用于调试目的.</li>
<li>
<ul>
<li>
<p>OProfile multiplexing support
CONFIG_OPROFILE_EVENT_MULTIPLEX</p>
<p><a href="http://lwn.net/Articles/343812/">OProfile multiplexing技术</a>支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Kprobes
CONFIG_KPROBES</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-kprobes.html">Kprobes</a>是一个轻量级的内核调试工具,能在内核运行的几乎任意时间点进行暂停/读取/修改等操作的调试工具.仅供调试使用.</p>
</li>
<li>
<p>Optimize very unlikely/likely branches
CONFIG_JUMP_LABEL</p>
<p>针对内核中某些&quot;几乎总是为真&quot;或者&quot;几乎总是为假&quot;的条件分支判断使用<a href="http://blog.csdn.net/dog250/article/details/6123517">&ldquo;asm goto&rdquo;</a>进行优化(在分支预测失败时会浪费很多时间在回退上,但是这种情况极少发生).很多内核子系统都支持进行这种优化.建议开启.</p>
</li>
<li>
<p>Transparent user-space probes
CONFIG_UPROBES</p>
<p><a href="http://blog.csdn.net/badu_123/article/details/8302642">Uprobes</a>与Kprobes类似,但主要用于用户空间的调试.</p>
</li>
<li>
<p>Enable GCOV-based kernel profiling
CONFIG_GCOV_KERNEL</p>
<ul>
<li>基于<a href="http://gcc.gnu.org/onlinedocs/gcc/Gcov.html">GCC的gcov</a>(<a href="http://blog.linezing.com/2011/03/%E4%BD%BF%E7%94%A8gcov%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E7%9A%84%E6%B5%8B%E8%AF%95">代码覆盖率测试</a>工具)的<a href="http://blog.csdn.net/livelylittlefish/article/details/6382489">代码分析</a>支持,仅用于调试</li>
<li>
<ul>
<li>
<p>Profile entire Kernel
CONFIG_GCOV_PROFILE_ALL</p>
<p>支持对整个内核进行分析.内核体积将会显著增大,并且运行速度显著减慢.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="enable-loadable-module-support-可加载模块支持"><a href=""></a>Enable loadable module support 可加载模块支持</h2>
<ul>
<li>
<p>Enable loadable module support
CONFIG_MODULES</p>
<ul>
<li>打开可加载模块支持,可以通过&quot;make modules_install&quot;把内核模块安装在/lib/modules/中.然后可以使用 modprobe, lsmod, modinfo, insmod, rmmod 等工具进行各种模块操作.</li>
<li>
<ul>
<li>
<p>Forced module loading
CONFIG_MODULE_FORCE_LOAD</p>
<p>允许使用&quot;modprobe &ndash;force&quot;在不校验版本信息的情况下强制加载模块,这绝对是个坏主意!建议关闭.</p>
</li>
<li>
<p>Module unloading
CONFIG_MODULE_UNLOAD</p>
<ul>
<li>允许卸载已经加载的模块</li>
<li>
<ul>
<li>
<p>Forced module unloading
CONFIG_MODULE_FORCE_UNLOAD</p>
<p>允许强制卸载正在使用中的模块(rmmod -f),即使可能会造成系统崩溃.这又是一个坏主意!建议关闭.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Module versioning support
CONFIG_MODVERSIONS</p>
<p>允许使用为其他内核版本编译的模块,可会造成系统崩溃.这同样是个坏主意!建议关闭.</p>
</li>
<li>
<p>Source checksum for all modules
CONFIG_MODULE_SRCVERSION_ALL</p>
<p>为模块添加&quot;srcversion&quot;字段,以帮助模块维护者准确的知道编译此模块所需要的源文件,从而可以校验源文件的变动.仅内核模块开发者需要它.</p>
</li>
<li>
<p>Module signature verification
CONFIG_MODULE_SIG</p>
<ul>
<li>在<a href="http://lwn.net/Articles/470906/">加载模块</a>时检查<a href="http://lwn.net/Articles/511720/">模块签名</a>,详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/module-signing.txt">Documentation/module-signing.txt</a>&ldquo;文件.[!!警告!!]开启此选项后,必须确保模块签名后没有被strip(包括rpmbuild之类的打包工具).</li>
<li>
<ul>
<li>
<p>Require modules to be validly signed
CONFIG_MODULE_SIG_FORCE</p>
<p>仅加载已签名并且密钥正确的模块,拒绝加载未签名或者签名密钥不正确的模块</p>
</li>
<li>
<p>Automatically sign all modules
CONFIG_MODULE_SIG_ALL</p>
<p>在执行&quot;make modules_install&quot;安装模块的时候,自动进行签名.否则你必须手动使用 scripts/sign-file 工具进行签名.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Which hash algorithm should modules be signed with?</p>
<p>选择对模块签名时使用的散列函数.建议使用强度最高的&quot;SHA-512&quot;算法.注意:所依赖的散列算法必须被静态编译进内核.对于&quot;SHA-512&quot;来说,就是CONFIG_CRYPTO_SHA512和CONFIG_CRYPTO_SHA512_SSSE3(如果你的CPU支持SSSE3指令集的话).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="enable-the-block-layer-块设备支持"><a href=""></a>Enable the block layer 块设备支持</h2>
<ul>
<li>
<p>Enable the block layer
CONFIG_BLOCK</p>
<ul>
<li>块设备支持,使用SSD/硬盘/U盘/SCSI/SAS设备者必选.除非你是某些特殊的嵌入式系统,否则没有理由不使用块设备.</li>
<li>
<ul>
<li>
<p>Block layer SG support v4
CONFIG_BLK_DEV_BSG</p>
<p>为块设备启用第四版<a href="http://sg.danny.cz/sg/">SG(SCSI generic</a>)支持.v4相比v3能够支持更复杂的SCSI指令(可变长度的命令描述块,双向数据传输,通用请求/应答协议),而且UDEV也要用它来获取设备的序列号.对于使用systemd的系统来说,必须选&quot;Y&rdquo;.对于不使用systemd的系统,如果你需要通过/dev/bsg/*访问块设备,建议开启此选项,否则(通过/dev/{sd*,st*,sr*})可以关闭.</p>
</li>
<li>
<p>Block layer SG support v4 helper lib
CONFIG_BLK_DEV_BSGLIB</p>
<p>你不需要手动开启此选项,如果有其他模块需要使用,会被自动开启.</p>
</li>
<li>
<p>Block layer data integrity support
CONFIG_BLK_DEV_INTEGRITY</p>
<p>某些块设备可以通过存储/读取额外的信息来保障<a href="http://alanwu.blog.51cto.com/3652632/1093600">端到端的数据完整性</a>,这个选项为文件系统提供了相应的钩子函数来使用这个特性.如果你的设备支持 <a href="http://www.ibm.com/developerworks/cn/aix/library/au-T10E2E/">T10/SCSI Data Integrity Field</a> 或者 T13/ATA External Path Protection 特性,那么可以开启此选项,否则建议关闭.</p>
</li>
<li>
<p>Block layer bio throttling support
CONFIG_BLK_DEV_THROTTLING</p>
<p><a href="http://lwn.net/Articles/403200/">Bio Throttling</a> 支持,也就是允许限制每个cgroup对特定设备的IO速率.细节可以参考&quot;<a href="http://lxr.linux.no/linux/Documentation/cgroups/blkio-controller.txt">Documentation/cgroups/blkio-controller.txt</a>&quot;.</p>
</li>
<li>
<p>Advanced partition selection
CONFIG_PARTITION_ADVANCED</p>
<ul>
<li>如果你想支持各种不同的磁盘分区格式(特别是与UEFI配合使用的<a href="http://www.ibm.com/developerworks/cn/linux/l-gpt/index.html">GPT</a>格式),务必选中此项.</li>
<li>
<ul>
<li>
<p>Acorn partition support
CONFIG_ACORN_PARTITION</p>
<p>Acorn 操作系统使用的分区格式,请根据实际情况选择子项,这里省略</p>
</li>
<li>
<p>Alpha OSF partition support
CONFIG_OSF_PARTITION</p>
<p>Alpha 平台上使用的分区格式</p>
</li>
<li>
<p>Amiga partition table support
CONFIG_AMIGA_PARTITION</p>
<p>AmigaOS 使用的分区格式</p>
</li>
<li>
<p>Atari partition table support
CONFIG_ATARI_PARTITION</p>
<p>Atari OS 使用的分区格式</p>
</li>
<li>
<p>Macintosh partition map support
CONFIG_MAC_PARTITION</p>
<p>苹果的Macintosh平台使用的分区格式</p>
</li>
<li>
<p>PC BIOS (MSDOS partition tables) support
CONFIG_MSDOS_PARTITION</p>
<p>渐成历史垃圾,但目前依然最常见的DOS分区格式.除非你确信不使用此格式,否则必选.其下的子项根据实际情况选择.</p>
</li>
<li>
<p>Windows Logical Disk Manager (Dynamic Disk) support
CONFIG_LDM_PARTITION</p>
<p>使用 Windows Logical Disk Manager 创建的分区格式.参见&quot;<a href="http://lxr.linux.no/linux/Documentation/ldm.txt">Documentation/ldm.txt</a>&quot;</p>
</li>
<li>
<p>SGI partition support
CONFIG_SGI_PARTITION</p>
<p>SGI 平台上使用的分区格式</p>
</li>
<li>
<p>Ultrix partition table support
CONFIG_ULTRIX_PARTITION</p>
<p>DEC/Compaq Ultrix 平台上使用的分区格式</p>
</li>
<li>
<p>Sun partition tables support
CONFIG_SUN_PARTITION</p>
<p>SunOS 平台上使用的分区格式</p>
</li>
<li>
<p>Karma Partition support
CONFIG_KARMA_PARTITION</p>
<p>Rio Karma MP3 player 使用的分区格式</p>
</li>
<li>
<p>EFI GUID Partition support
CONFIG_EFI_PARTITION</p>
<p>代表未来趋势,眼下正大红大紫的EFI <a href="http://www.ibm.com/developerworks/cn/linux/l-gpt/index.html">GPT</a>(<a href="http://zh.wikipedia.org/zh-cn/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8">GUID Partition Table</a>)分区格式.建议开启.如果你在UEFI平台上安装则必须开启.</p>
</li>
<li>
<p>SYSV68 partition table support
CONFIG_SYSV68_PARTITION</p>
<p>Motorola Delta 机器上使用的分区格式</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IO Schedulers</p>
<ul>
<li><a href="http://blog.tao.ma/?p=21">IO调度器</a>(<a href="http://blog.hesey.net/2012/02/linux-io-scheduler.html">另一篇文章</a>)</li>
<li>
<ul>
<li>
<p>Deadline I/O scheduler
CONFIG_IOSCHED_DEADLINE</p>
<p><a href="http://blog.csdn.net/vanbreaker/article/details/8287002">deadline</a>调度器.简洁小巧(只有400+行代码),提供了最小的读取延迟.如果你希望尽快读取磁盘,而不介意写入延迟,那它是最佳选择.通常对于数据库工作负载有最佳的表现.</p>
</li>
<li>
<p>CFQ I/O scheduler
CONFIG_IOSCHED_CFQ</p>
<ul>
<li><a href="http://blog.csdn.net/vanbreaker/article/details/8299491">cfq</a>(<a href="http://blog.csdn.net/vanbreaker/article/details/8308766">Complete Fair Queuing</a>)调度器.努力在各内核线程间公平分配IO资源,适用于系统中存在着大量内核线程同时进行IO请求的情况.但对于只有少数内核线程进行密集IO请求的情况,则会出现明显的性能下降.</li>
<li>
<ul>
<li>
<p>CFQ Group Scheduling support
CONFIG_CFQ_GROUP_IOSCHED</p>
<p>允许将CFQ和cgroup组合使用,也就是将每个cgroup看成一个整体,在各cgroup之间进行IO资源的分配.参见&quot;<a href="http://lxr.linux.no/linux/Documentation/cgroups/blkio-controller.txt">Documentation/cgroups/blkio-controller.txt</a>&ldquo;文件.还可以参考一下《Linux内核精髓》中的&rdquo;<a href="http://book.51cto.com/art/201302/381375.htm">使用Block I/O控制器</a>&ldquo;一章.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BFQ I/O scheduler
CONFIG_IOSCHED_BFQ</p>
<ul>
<li><a href="http://algo.ing.unimo.it/people/paolo/disk_sched/">bfq(Budget Fair Queueing)</a>调度器.这是一个基于CFQ调度器的改进版本,更适合于对交互性要求比较高的场合,比如桌面系统和实时系统.如果静态编译进内核,还支持和cgroup配合,实现分层调度(hierarchical scheduling).</li>
<li>
<ul>
<li>
<p>BFQ hierarchical scheduling support
CONFIG_CGROUP_BFQIO</p>
<p>通过cgroup文件系统接口,允许将BFQ分层使用(类似CONFIG_CFQ_GROUP_IOSCHED),这个子系统的名字是&quot;bfqio&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Default I/O scheduler</p>
<p><a href="http://www.php-oa.com/2010/01/03/linux-io-elevator.html">默认IO调度器</a>.如果上述调度器都是模块,那么将使用最简单的内置NOOP调度器.<a href="http://blog.csdn.net/vanbreaker/article/details/8278358">NOOP(No Operation)</a>调度器只是一个简单的FIFO队列,不对IO请求做任何重新排序处理(但还是会做一定程度的归并),适合于SSD/U盘/内存/SAN(Storage Area Networks)/虚拟机中的硬盘/iSCSI/硬RAID等无需寻道的存储设备,重点是可以节约CPU资源,但不适用于普通硬盘这样的需要依靠磁头来定位的设备.另外,有人说拥有<a href="http://hi.baidu.com/51raid/item/96e688b9217b85d285dd7918">TCQ</a>/<a href="http://blog.sina.com.cn/s/blog_50aa6d5b0100o4hc.html">NCQ</a>技术(能够自动重新排序)的硬盘也适合用NOOP调度器,这个说法其实并不那么合理,但笔者在此不敢断言,希望读者在严谨的测试之后再做定夺.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="processor-type-and-features-中央处理器cpu类型及特性"><a href=""></a>Processor type and features 中央处理器(CPU)类型及特性</h2>
<ul>
<li>
<p>DMA memory allocation support
CONFIG_ZONE_DMA</p>
<p>允许为寻址宽度不足32位的设备(也就是ISA和<a href="http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC</a>总线设备)在<a href="http://www.ibm.com/developerworks/cn/linux/l-memmod/">物理内存</a>的前16MB范围内(也就是传统上x86_32架构的<a href="http://hfli0.blogspot.com/2010/04/why-cannt-we-remove-zonedma-from-linux.html">ZONE_DMA</a>区域)分配内存.不确定的选&quot;Y&quot;.[提示]LPC总线通常和主板上的南桥物理相连,通常连接了一系列的传统设备:BIOS,PS/2键盘,PS/2鼠标,软盘,并口设备,串口设备,某些集成声卡,TPM(可信平台模块),等等.[题外话]<a href="http://blog.nlogn.cn/why-does-x86_64-not-have-zone_highmem/">x86_64已经没有ZONE_HIGHMEM了</a></p>
</li>
<li>
<p>Symmetric multi-processing support
CONFIG_SMP</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-linux-smp/">SMP(对称多处理器)</a>支持,如果你有多个CPU或者使用的是多核CPU就选上.</p>
</li>
<li>
<p>Support x2apic
CONFIG_X86_X2APIC</p>
<p><a href="http://blog.csdn.net/defeattroy/article/details/8988570">x2apic</a>支持.具有这个特性的CPU可以使用32位的APIC ID(可以支持海量的CPU),并且可以使用MSR而不是mmio去访问 local APIC (更加高效).可以通过&quot;grep x2apic /proc/cpuinfo&quot;命令检查你的CPU是否支持这个特性.注意:有时候还需要在BIOS中也开启此特性才真正生效.[提示]在虚拟机中,还需要VMM的支持(例如qemu-kvm).</p>
</li>
<li>
<p>Enable MPS table
CONFIG_X86_MPPARSE</p>
<p>如果是不支持acpi特性的古董级SMP系统就选上.但现今的64位系统早都已经支持acpi了,所以可以安全的关闭.</p>
</li>
<li>
<p>Support for extended (non-PC) x86 platforms
CONFIG_X86_EXTENDED_PLATFORM</p>
<p>支持非标准的PC平台: Numascale NumaChip, ScaleMP vSMP, SGI Ultraviolet. 绝大多数人都遇不见这些平台.</p>
</li>
<li>
<p>Numascale NumaChip
CONFIG_X86_NUMACHIP</p>
<p><a href="http://www.numascale.com/numa_products.html">Numascale NumaChip</a> 平台支持</p>
</li>
<li>
<p>ScaleMP vSMP
CONFIG_X86_VSMP</p>
<p><a href="http://blog.csdn.net/china_world/article/details/6574690">ScaleMP vSMP</a> 平台支持</p>
</li>
<li>
<p>SGI Ultraviolet
CONFIG_X86_UV</p>
<p><a href="http://www.visinfo.com.cn/vis4.html">SGI Ultraviolet</a> 平台支持</p>
</li>
<li>
<p>Intel Low Power Subsystem Support
CONFIG_X86_INTEL_LPSS</p>
<p>为 Intel <a href="http://ark.intel.com/zh-cn/products/codename/37530/Lynx-Point">Lynx Point</a> <a href="http://zh.wikipedia.org/wiki/PCH">PCH</a> 中的 Intel Low Power Subsystem 技术提供支持.这个芯片组主要是为采用LGA1150的<a href="http://zh.wikipedia.org/wiki/Intel_Haswell">Haswell</a>处理器提供支持.</p>
</li>
<li>
<p>Single-depth WCHAN output
CONFIG_SCHED_OMIT_FRAME_POINTER</p>
<p>使用简化的 /proc/&lt;PID&gt;/wchan 值,禁用此选项会使用更加精确的wchan值(可以在&quot;ps -l&quot;结果的WCHAN域看到),但会轻微增加调度器消耗.</p>
</li>
<li>
<p>Linux guest support
CONFIG_HYPERVISOR_GUEST</p>
<ul>
<li>如果这个内核将在<a href="http://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>里面运行就开启,否则就关闭.</li>
<li>
<ul>
<li>
<p>Enable paravirtualization code
CONFIG_PARAVIRT</p>
<ul>
<li>半虚拟化(paravirtualization)支持.</li>
<li>
<ul>
<li>
<p>paravirt-ops debugging
CONFIG_PARAVIRT_DEBUG</p>
<p>仅供调试.<a href="http://www.chenjunlu.com/2013/05/a-common-paravirtualization-interface-paravirt_ops/">paravirt-ops</a>是内核通用的半虚拟化接口.</p>
</li>
<li>
<p>Paravirtualization layer for spinlocks
CONFIG_PARAVIRT_SPINLOCKS</p>
<p>半虚拟化的自旋锁支持.开启之后运行在虚拟机里的内核速度会加快,但是运行在物理CPU上的宿主内核运行效率会降低(最多可能会降低5%).请根据实际情况选择.</p>
</li>
<li>
<p>Xen guest support
CONFIG_XEN</p>
<p><a href="http://zh.wikipedia.org/wiki/Xen">Xen</a>半虚拟化技术支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Enable Xen debug and tuning parameters in debugfs
CONFIG_XEN_DEBUG_FS</p>
<p>为Xen在debugfs中输出各种统计信息和调整选项.对性能有严重影响.仅供调试.</p>
</li>
<li>
<p>KVM Guest support (including kvmclock)
CONFIG_KVM_GUEST</p>
<p><a href="http://wiki.ubuntu.com.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>客户机支持(包括<a href="http://blog.csdn.net/defeattroy/article/details/8849701">kvmclock</a>).</p>
</li>
<li>
<p>Paravirtual steal time accounting
CONFIG_PARAVIRT_TIME_ACCOUNTING</p>
<p>允许进行更细粒度的 task steal time 统计.会造成性能的略微降低.仅在你确实需要的时候才开启.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Memtest
CONFIG_MEMTEST</p>
<p>为内核添加<a href="http://www.memtest86.com/">内存测试</a>功能,也就是添加&quot;memtest&quot;内核引导参数以支持对内存进行&quot;体检&quot;.仅在你确实知道这是什么东西并且确实需要的时候再开启.否则请关闭.</p>
</li>
<li>
<p>Processor family</p>
<p>处理器系列,请按照你实际使用的CPU选择.&ldquo;Generic-x86-64&quot;表示通用于所有x86-64平台,不针对特定类型的CPU进行优化.</p>
</li>
<li>
<p>Supported processor vendors
CONFIG_PROCESSOR_SELECT</p>
<p>支持的CPU厂商,按实际情况选择.</p>
</li>
<li>
<p>Enable DMI scanning
CONFIG_DMI</p>
<p>允许扫描<a href="http://www.symantec.com/zh/cn/security_response/glossary/define.jsp?letter=d&amp;word=dmi-desktop-management-interface">DMI</a>(<a href="http://www.biosrepair.com/pic/pic46.htm">Desktop Management Interface</a>)/<a href="http://blog.csdn.net/zhoudaxia/article/details/5919699">SMBIOS</a>(<a href="https://sites.google.com/site/thebackofdaniel/computer/bios/smbios-introduction">System Management BIOS</a>)以<a href="http://linux-wiki.cn/wiki/Dmidecode">获得机器的硬件配置</a>,从而对已知的bug bios进行规避.具体涉及到哪些机器可参见&quot;drivers/acpi/blacklist.c&quot;文件.除非确定你的机器没有bug,否则请开启此项.</p>
</li>
<li>
<p>GART IOMMU support
CONFIG_GART_IOMMU</p>
<p><a href="http://en.wikipedia.org/wiki/Graphics_address_remapping_table">GART</a> <a href="http://server.zdnet.com.cn/files/all-1836536.htm">IOMMU</a> 支持. 图形地址重映射表(<a href="http://dri.freedesktop.org/wiki/GART/">Graphics Address Remapping Table</a>)可以将物理地址不连续的系统内存映射成看上去连续的图形内存交给GPU使用,是一种挖CPU内存补GPU内存机制,这种机制也可以被认为是一种&quot;伪IOMMU&rdquo;(缺乏地址空间隔离和访问控制).开启此选项以后,在内存大于3G的系统上,传统的32位总线(PCI/AGP)的设备将可以使用完全<a href="http://blog.csdn.net/peasant_lee/article/details/5594753">DMA</a>的方式直接访问原本超出32位寻址范围之外的系统内存区域.具体方法是:通过编程让设备在受GART控制的显存区域工作,然后使用GART将这个地址映射为真实的物理地址(4GB以上)来实现的.USB/声卡/IDE/SATA之类的设备常常需要它.开启此选项之后,除非同时开启了CONFIG_IOMMU_DEBUG选项或者使用了&quot;iommu=force&quot;内核引导参数,否则此特性仅在条件满足的情况下(内存足够大且确有支持GART的设备)激活.建议内存大于3G的系统上选&quot;Y&quot;.</p>
</li>
<li>
<p>IBM Calgary IOMMU support
CONFIG_CALGARY_IOMMU</p>
<ul>
<li>IBM xSeries/pSeries 系列服务器的 <a href="http://bitsup.blogspot.com/2008/03/calgary-iommu-at-what-price.html">Calgary IOMMU</a> 支持.</li>
<li>
<ul>
<li>
<p>Should Calgary be enabled by default?
CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT</p>
<p>开启此选项表示默认启用Calgary特性,关闭此选项表示默认禁用Calgary特性(可以使用&quot;iommu=calgary&quot;内核引导参数开启).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Enable Maximum number of SMP Processors and NUMA Nodes
CONFIG_MAXSMP</p>
<p>让内核支持x86_64平台所能支持的最大SMP处理器数量和最大NUMA节点数量.主要用于调试目的.</p>
</li>
<li>
<p>Maximum number of CPUs
CONFIG_NR_CPUS</p>
<p>支持的最大CPU数量,每个CPU要占8KB的内核镜像,最小有效值是&quot;2&quot;,最大有效值是&quot;512&quot;.注意:对于多核CPU而言,每个核算一个.</p>
</li>
<li>
<p>SMT (Hyperthreading) scheduler support
CONFIG_SCHED_SMT</p>
<p>Intel超线程技术(<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E5%9F%B7%E8%A1%8C%E7%B7%92">HyperThreading</a>)支持.</p>
</li>
<li>
<p>Multi-core scheduler support
CONFIG_SCHED_MC</p>
<p>针对多核CPU进行调度策略优化</p>
</li>
<li>
<p>Reroute for broken boot IRQs
CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS</p>
<p>这是一个对某些<a href="http://article.gmane.org/gmane.linux.acpi.devel/36842">芯片组bug</a>(在某些情况下会发送多余的&quot;<a href="http://lwn.net/Articles/284826/">boot IRQ</a>&quot;)的修复功能.开启此选项之后,仅对有此bug的芯片组生效.要检查哪些芯片组有此bug可以查看&quot;<a href="http://lxr.linux.no/linux/drivers/pci/quirks.c">drivers/pci/quirks.c</a>&ldquo;文件中的&quot;quirk_reroute_to_boot_interrupts_intel&quot;函数.</p>
</li>
<li>
<p>Machine Check / overheating reporting
CONFIG_X86_MCE</p>
<ul>
<li><a href="http://ilinuxkernel.com/?p=303">MCE</a>(<a href="http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&amp;lc=zh-hans&amp;docname=c02691010">Machine Check Exception</a>)支持.让CPU检测到硬件故障(过热/数据错误)时通知内核,以便内核采取相应的措施(如显示一条提示信息或关机等).更多信息可以&quot;man <a href="http://www.mcelog.org/">mcelog</a>&ldquo;看看.可以通过&quot;grep mce /proc/cpuinfo&quot;检查CPU是否支持此特性,若支持建议选中,否则请关闭.当然,如果你对自己的硬件质量很放心,又是桌面系统的话,不选也无所谓.</li>
<li>
<ul>
<li>
<p>Intel MCE features
CONFIG_X86_MCE_INTEL</p>
<p>Intel CPU 支持</p>
</li>
<li>
<p>AMD MCE features
CONFIG_X86_MCE_AMD</p>
<p>AMD CPU 支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Machine check injector support
CONFIG_X86_MCE_INJECT</p>
<p>MCE注入支持,仅用于调试</p>
</li>
<li>
<p>Dell laptop support
CONFIG_I8K</p>
<p>Dell Inspiron 8000 笔记本的 <a href="http://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> 驱动(<a href="http://my.oschina.net/MinGKai/blog/138554">i8k</a>).该驱动可以读取CPU温度和风扇转速,进而帮助<a href="http://people.debian.org/~dz/i8k/">上层工具</a>控制风扇转速.该驱动仅针对 Dell Inspiron 8000 笔记本进行过测试,所以不保证一定能适用于其他型号的Dell笔记本.</p>
</li>
<li>
<p>CPU microcode loading support
CONFIG_MICROCODE</p>
<ul>
<li>CPU的<a href="http://www.whitecell.org/list.php?id=42">微代码更新</a>支持,建议选中.CPU的微代码更新就像是给CPU打补丁.比如在Gentoo下,可以使用&quot;emerge microcode-ctl&quot;安装<a href="http://wiki.gentoo.org/wiki/Intel_microcode">microcode-ctl</a>服务,再把这个服务加入boot运行级即可在每次开机时自动更新CPU微代码.其他Linux系统可以参考<a href="http://bbs.chinaunix.net/thread-2178586-1-1.html">这个帖子</a>.</li>
<li>
<ul>
<li>
<p>Intel microcode loading support
CONFIG_MICROCODE_INTEL</p>
<p><a href="http://www.intel.com/content/www/cn/zh/search.html?context=1047413&amp;tab=767193&amp;keyword=%E5%A4%84%E7%90%86%E5%99%A8%E5%BE%AE%E4%BB%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">Intel CPU 微代码</a>支持</p>
</li>
<li>
<p>AMD microcode loading support
CONFIG_MICROCODE_AMD</p>
<p>AMD CPU 微代码支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Early load microcode
CONFIG_MICROCODE_INTEL_EARLY</p>
<p>支持从initrd镜像首部加载微代码,以便尽可能早的更新CPU微代码.即使在initrd首部并未嵌入微代码也不会造成问题,所以&quot;Y&quot;是安全的.不过你真的需要吗?笔者认为你一般并不需要:)</p>
</li>
<li>
<p>/dev/cpu/*/msr - Model-specific register support
CONFIG_X86_MSR</p>
<p>/dev/cpu/*/msr 设备支持.也就是允许用户空间的特权进程(使用rdmsr与wrmsr指令)访问x86的MSR寄存器(<a href="http://en.wikipedia.org/wiki/Model-specific_register">Model-Specific Register</a>).MSR的作用主要用于调试,程序执行跟踪,性能及状态监控,以及触发特定的CPU特性(依CPU的不同而不同).<a href="http://www.coreboot.org/Msrtool">msrtool</a>工具可以转储出MSR的内容.不确定的可以选&quot;N&rdquo;.</p>
</li>
<li>
<p>/dev/cpu/*/cpuid - CPU information support
CONFIG_X86_CPUID</p>
<p>/dev/cpu/*/cpuid 设备支持.可以通过<a href="http://www.etallen.com/cpuid.html">cpuid</a>命令获得详细的<a href="http://wenku.baidu.com/view/4105c609bb68a98271fefaf8.html">CPU信息</a>(<a href="http://www.mouseos.com/arch/CPUID.html">CPUID</a>).不确定的可以选&quot;N&rdquo;.</p>
</li>
<li>
<p>Enable 1GB pages for kernel pagetables
CONFIG_DIRECT_GBPAGES</p>
<p>允许<a href="http://www.sigma.me/2011/01/22/mem-page-tlb.html">内核页表</a>使用大小为1GB的<a href="http://wiki.debian.org/Hugepages">Hugepages</a>并进行直线映射(linear mapping),需要高端CPU的支持(可以用&quot;grep pdpe1gb /proc/cpuinfo&quot;命令检查).这可以减小<a href="http://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80">页表缓存</a>(<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">Translation Lookaside Buffer</a>)的压力,从而提升系统的性能,这对于拥有海量内存并且运行某些特定应用(PosgreSQL,MySQL,Java,Memcached,KVM,Xen&hellip;)的系统来说比较有意义.如果你的CPU支持,可以选&quot;Y&quot;.</p>
</li>
<li>
<p>Numa Memory Allocation and Scheduler Support
CONFIG_NUMA</p>
<p>开启 <a href="http://www.ibm.com/developerworks/cn/linux/l-numa/index.html">NUMA(Non Uniform Memory Access)</a> 支持.虽然说集成了内存控制器的CPU都属于NUMA架构.但事实上,对于大多数只有一颗物理CPU的个人电脑而言,即使支持NUMA架构,也没必要开启此特性.可以参考<a href="http://www.cnblogs.com/yubo/archive/2010/04/23/1718810.html">SMP/NUMA/MPP体系结构对比</a>.此外,对于不支持&quot;虚拟NUMA&quot;,或&quot;虚拟NUMA&quot;被禁用的虚拟机(即使所在的物理机是NUMA系统),也应该关闭此项.</p>
</li>
<li>
<p>Old style AMD Opteron NUMA detection
CONFIG_AMD_NUMA</p>
<p>因为AMD使用一种旧式的方法读取NUMA配置信息(新式方法是CONFIG_X86_64_ACPI_NUMA),所以如果你使用的是AMD多核CPU,建议开启.不过,即使开启此选项,内核也会优先尝试CONFIG_X86_64_ACPI_NUMA方法,仅在失败后才会使用此方法,所以即使你不能确定CPU的类型也可以安全的选中此项.</p>
</li>
<li>
<p>ACPI NUMA detection
CONFIG_X86_64_ACPI_NUMA</p>
<p>使用基于 ACPI SRAT(System Resource Affinity Table) 技术的NUMA节点探测方法.这也是检测NUMA节点信息的首选方法,建议选中.</p>
</li>
<li>
<p>NUMA emulation
CONFIG_NUMA_EMU</p>
<p>仅供开发调试使用</p>
</li>
<li>
<p>Maximum NUMA Nodes (as a power of 2)
CONFIG_NODES_SHIFT</p>
<p>允许的最大NUMA节点数.需要注意其计算方法:最大允许节点数=2CONFIG_NODES_SHIFT.也就是说这里设置的值会被当做2的指数使用.取值范围是[1,10],也就最多允许1024个节点.</p>
</li>
<li>
<p>Memory model</p>
<p><a href="http://wangcong.org/blog/archives/2043">内存模式</a>.&ldquo;Sparse Memory&quot;主要用来支持内存热插拔,相比其他两个旧有的内存模式,代码复杂性也比较低,而且还拥有一些性能上的优势,对某些架构而言是唯一的可选项.其他两个旧有的内存模式是:&quot;<a href="http://www.technovelty.org/linux/discontiguous-memory.html">Discontiguous Memory</a>&ldquo;和&rdquo;<a href="http://zh.wikipedia.org/wiki/%E5%B9%B3%E9%9D%A2%E8%A8%98%E6%86%B6%E9%AB%94%E6%A8%A1%E5%BC%8F">Flat Memory</a>&rdquo;.</p>
</li>
<li>
<p>Sparse Memory virtual memmap
CONFIG_SPARSEMEM_VMEMMAP</p>
<p>对于64位CPU而言,开启此选项可以简化pfn_to_page/page_to_pfn的操作,从而提高内核的运行效率.但是在32位平台则建议关闭.更多细节可以参考<a href="http://markmail.org/message/x3hpe4sapu4iegga">这个帖子</a>.</p>
</li>
<li>
<p>Enable to assign a node which has only movable memory
CONFIG_MOVABLE_NODE</p>
<p>允许对一个完整的NUMA节点(CPU和对应的内存)进行热插拔.一般的服务器和个人电脑不需要这么高级的特性.</p>
</li>
<li>
<p>Allow for memory hot-add
CONFIG_MEMORY_HOTPLUG</p>
<ul>
<li>支持向运行中的系统添加内存.也就是内存热插支持.</li>
<li>
<ul>
<li>
<p>Allow for memory hot remove
CONFIG_MEMORY_HOTREMOVE</p>
<p>支持从运行中的系统移除内存.也就是内存热拔支持.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Allow for balloon memory compaction/migration
CONFIG_BALLOON_COMPACTION</p>
<p>允许 <a href="http://smilejay.com/2012/11/kvm-ballooning-overview/">balloon memory</a> 压缩/迁移.内存的<a href="http://delxu.blog.51cto.com/975660/288682">Ballooning技术</a>是指虚拟机在运行时动态地调整它所占用的宿主机内存资源,该技术在节约内存和灵活分配内存方面有明显的优势,目前所有主流虚拟化方案都支持这项技术(前提是客户机操作系统中必须安装有相应的balloon驱动).由于内存的动态增加和减少会导致内存过度碎片化,特别是对于2M尺寸的连续大内存页来说更加严重,从而严重降低内存性能.允许balloon内存压缩和迁移可以很好的解决在客户机中使用大内存页时内存过度碎片化问题.如果你打算在虚拟机中使用大内存页(huge page),那么建议开启,否则建议关闭.</p>
</li>
<li>
<p>Allow for memory compaction
CONFIG_COMPACTION</p>
<p>允许对<a href="http://www.dbafan.com/blog/?p=435">大内存页(huge pages)</a>进行<a href="http://lwn.net/Articles/368869/">压缩</a>.主要是为了解决大内存页的碎片问题.建议在使用大内存页的情况下开启此项,否则建议关闭.</p>
</li>
<li>
<p>Page migration
CONFIG_MIGRATION</p>
<p>允许在保持虚拟内存页地址不变的情况下移动其所对应的物理内存页的位置.这主要是为了解决两个问题:(1)在NUMA系统上,将物理内存转移到相应的节点上,以加快CPU与内存之间的访问速度.(2)在分配大内存页的时候,可以避免碎片问题.</p>
</li>
<li>
<p>Enable bounce buffers
CONFIG_BOUNCE</p>
<p>为那些不能直接访问所有内存范围的驱动程序开启<a href="http://blog.csdn.net/force_eagle/article/details/7723772">bounce buffer</a>支持.当CONFIG_ZONE_DMA被开启后,这个选项会被默认开启(当然,你也可以在这里手动关闭).这主要是为了那些不具备<a href="http://blog.csdn.net/force_eagle/article/details/7744896">IOMMU</a>功能的PCI/ISA设备而设,但它对性能有些不利影响.在支持IOMMU的设备上,应该关闭它而是用IOMMU来代替.</p>
</li>
<li>
<p>Enable KSM for page merging
CONFIG_KSM</p>
<p><a href="http://buycloud.com.cn/wordpress/?p=348">KSM</a>(<a href="http://blog.chinaunix.net/uid-20794164-id-3601786.html">Kernel Samepage Merging</a>)支持:周期性的扫描那些被应用程序标记为&quot;可合并&quot;的地址空间,一旦发现有内容完全相同的页面,就将它们合并为同一个页面,这样就可以节约内存的使用,但对性能有不利影响.推荐和内核虚拟机KVM(<a href="http://lxr.linux.no/linux/Documentation/vm/ksm.txt">Documentation/vm/ksm.txt</a>)或者其他支持&quot;MADV_MERGEABLE&quot;特性的应用程序一起使用.KSM并不默认开启,仅在应用程序设置了&quot;MADV_MERGEABLE&quot;标记,并且 /sys/kernel/mm/ksm/run 被设为&quot;1&quot;的情况下才会生效.</p>
</li>
<li>
<p>Low address space to protect from user allocation
CONFIG_DEFAULT_MMAP_MIN_ADDR</p>
<p>2009年,内核曾经爆过一个严重的<a href="http://baoz.net/linux-sockops-wrap-proto-ops-local-root-exploit/">NULL指针漏洞</a>,由于其根源是将NULL指针映射到地址&quot;0&quot;所致,所以从2.6.32版本以后,为了防止此类漏洞再次造成严重后果,特别设置了此选项,用于指定受保护的内存低端地址范围(可以在系统运行时通过 <a href="http://wiki.debian.org/mmap_min_addr">/proc/sys/vm/mmap_min_addr</a>进行调整),这个范围内的地址禁止任何用户态程序的写入,以从根本上堵死此类漏洞可能对系统造成的损害.但内核这种强加的限制,对于需要使用vm86系统调用(用于在保护模式的进程中模拟8086的实模式)或者需要映射此低端地址空间的程序(bitbake,dosemu,qemu,wine,&hellip;)来说,则会造成不兼容,不过目前这些程序的新版本都进行了改进,以适应内核的这种保护.一般情况下,&ldquo;4096&quot;是个明智的选择,或者你也可以保持默认值.</p>
</li>
<li>
<p>Enable recovery from hardware memory errors
CONFIG_MEMORY_FAILURE</p>
<ul>
<li>在具备<a href="http://en.wikipedia.org/wiki/Machine_check_architecture">MCA(Machine Check Architecture)</a>恢复机制的系统上,允许内核在物理内存中的发生数据错误的情况下,依然坚强的纠正错误并恢复正常运行.这需要有相应的硬件(通常是ECC内存)支持.有<a href="http://www.zzec.cn/help/html/?138.html">ECC内存</a>的选,没有的就别选了.</li>
<li>
<ul>
<li>
<p>HWPoison pages injector
CONFIG_HWPOISON_INJECT</p>
<p>仅用于调试.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Transparent Hugepage Support
CONFIG_TRANSPARENT_HUGEPAGE</p>
<ul>
<li>大多数现代计算机体系结构都支持多种不同的<a href="http://en.wikipedia.org/wiki/Page_%28computer_memory%29">内存页面</a>大小(比如x86_64支持4K和2M以及1G[需要cpu-flags中含有&quot;pdpe1gb&rdquo;]).大于4K的内存页被称为&quot;<a href="http://www.ibm.com/developerworks/cn/linux/1305_zhangli_hugepage/">大页</a>&quot;(<a href="https://wiki.debian.org/Hugepages">Hugepage</a>).<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>(<a href="http://zh.wikipedia.org/wiki/%E8%BD%89%E8%AD%AF%E5%BE%8C%E5%82%99%E7%B7%A9%E8%A1%9D%E5%8D%80">页表缓存</a>)是位于CPU内部的<a href="http://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81%E8%A1%A8">分页表</a>(虚拟地址到物理地址的映射表)缓冲区,既高速又很宝贵(尺寸很小).如果系统内存很大(大于4G)又使用4K的内存页,那么分页表将会变得很大而难以在CPU内缓存,从而导致较高的TLB不命中概率,进而降低系统的运行效率.开启大内存页支持之后,就可以使用大页(2M或1G),从而大大缩小分页表的尺寸以大幅提高TLB的命中率,进而<a href="http://kenwublog.com/tune-large-page-for-jvm-optimization">优化系统性能</a>.传统上使用大内存页的方法是通过Hugetlbfs虚拟文件系统(CONFIG_HUGETLBFS),但是hugetlbfs需要专门进行配置以及应用程序的特别支持.所以从2.6.38版本开始引入了<a href="http://lp007819.wordpress.com/2011/03/23/kernel-2-6-38-%E7%89%B9%E6%80%A7-transparent-huge-pages/">THP</a>(<a href="http://blog.chinaunix.net/uid-26489617-id-3205109.html">Transparent Hugepages</a>),目标是替代先前的Hugetlbfs虚拟文件系统(CONFIG_HUGETLBFS).THP允许内核在可能的条件下,透明的(对应用程序来说)<a href="http://lenky.info/2012/03/03/linux%E4%B8%8Bhugetlbpage%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">使用大页</a>(<a href="http://www.dbaleet.org/tag/hugepages/">huge pages</a>)与<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-hugetlb/">HugeTLB</a>,THP不像hugetlbfs那样需要专门进行配置以及应用程序的特别支持.THP将这一切都交给操作系统来完成,也不再需要额外的配置,对于应用程序完全透明,因而可用于更广泛的应用程序.这对于数据库/KVM等需要使用大量内存的应用来说,可以提升其效能,但对于内存较小(4G或更少)的个人PC来说就没啥必要了.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/vm/transhuge.txt">Documentation/vm/transhuge.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Transparent Hugepage Support sysfs defaults</p>
<p>设置 /sys/kernel/mm/transparent_hugepage/enabled 文件的默认值.&ldquo;always&quot;表示总是对所有应用程序启用透明大内存页支持,&ldquo;madvise&quot;表示仅对明确要求该特性的程序启用.建议选&quot;always&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cross Memory Support
CONFIG_CROSS_MEMORY_ATTACH</p>
<p><a href="http://lwn.net/Articles/405284/">交叉内存</a>支持,也就是<a href="http://bookjovi.iteye.com/blog/1229689">process_vm_readv()和process_vm_writev()系统调用</a>支持.从而允许有权限的进程直接读取/写入另外一个进程的地址空间.现在它们只用于<a href="http://www.cnblogs.com/jpcflyer/archive/2012/03/04/2379048.html">openMPI</a>快速进程通信,也可以用于调试程序.未来也许还会有其他用途.</p>
</li>
<li>
<p>Enable cleancache driver to cache clean pages if tmem is present
CONFIG_CLEANCACHE</p>
<p><a href="http://lwn.net/Articles/386090/">Cleancache</a>可以被看作是内存页的&rdquo;<a href="http://memcache.drivehq.com/memparam/Bench/Other/VictimCache.htm">Victim Cache</a>&rdquo;(<a href="http://sse.tongji.edu.cn/arch/arch_course/architecture/chapter4/lecture4/htm/lecture4_6.htm">受害者缓存</a>),当回收内存页时,先不把它清空,而是把其加入到内核不能直接访问的&quot;<a href="http://lwn.net/Articles/340080/">transcendent memory</a>&ldquo;中,这样支持Cleancache的文件系统再次访问这个页时可以直接从&quot;transcendent memory&quot;加载它,从而减少磁盘IO的损耗.目前只有<a href="http://lwn.net/Articles/397574/">zcache</a>和<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>支持&quot;transcendent memory&rdquo;,不过将来会有越来越多的应用支持.开启此项后即使此特性不能得到利用,也仅对性能有微小的影响,所以建议开启.更多细节请参考&quot;<a href="http://lxr.linux.no/linux/Documentation/vm/cleancache.txt">Documentation/vm/cleancache.txt</a>&ldquo;文件.</p>
</li>
<li>
<p>Enable frontswap to cache swap pages if tmem is present
CONFIG_FRONTSWAP</p>
<p><a href="http://lwn.net/Articles/386090/">Frontswap</a>是和Cleancache非常类似的东西,在传统的swap前加一道内存缓冲(同样位于&quot;transcendent memory&quot;中).目的也是减少swap时的磁盘读写.建议开启.</p>
</li>
<li>
<p>Check for low memory corruption
CONFIG_X86_CHECK_BIOS_CORRUPTION</p>
<ul>
<li>低位内存脏数据检查,即使开启此选项,默认也不会开启此功能(需要明确使用&quot;memory_corruption_check=1&quot;内核引导选项).这些脏数据通常被认为是有bug的BIOS引起的,默认每60秒(可以通过memory_corruption_check_period内核参数进行调整)扫描一次0-64k(可以通过memory_corruption_check_size内核参数进行调整)之间的区域.这种检查所占用的开销非常小,基本可以忽略不计.如果始终检查到错误,则可以通过&quot;memmap=&ldquo;内核引导参数来避免使用这段内存.一般没必要选中,如果你对BIOS不放心,带着它试运行一段时间,确认没问题之后再去掉.</li>
<li>
<ul>
<li>
<p>Set the default setting of memory_corruption_check
CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK</p>
<p>设置memory_corruption_check的默认值,选中表示默认开启(相当于使用&quot;memory_corruption_check=1&quot;内核引导选项),不选中表示默认关闭.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Amount of low memory, in kilobytes, to reserve for the BIOS
CONFIG_X86_RESERVE_LOW</p>
<p>为BIOS设置保留的低端地址(默认是64K).内存的第一页(4K)存放的必定是BIOS数据,内核不能使用,所以必须要保留.但是有许多BIOS还会在suspend/resume/热插拔等事件发生的时候使用更多的页(一般在0-64K范围),所以默认保留0-64K范围.如果你确定自己的BIOS不会越界使用内存的话,可以设为&quot;4&rdquo;,否则请保持默认值.但是也有一些很奇葩的BIOS会使用更多的低位内存,这种情况下可以考虑设为&quot;640&quot;以保留所有640K的低位内存区域.</p>
</li>
<li>
<p>MTRR (Memory Type Range Register) support
CONFIG_MTRR</p>
<ul>
<li><a href="http://blog.csdn.net/arethe/article/details/6248448">MTRR</a>(<a href="http://blog.chinaunix.net/uid-25871104-id-3140904.html">Memory type range registers</a>)是CPU内的一组MSR(Model-specific registers),其作用是告诉CPU以哪种模式(write-back/uncachable)存取各内存区段效率最高.这对于AGP/PCI显卡意义重大,因为write-combining技术可以将若干个总线写传输捆绑成一次较大的写传输操作,可以将图像写操作的性能提高2.5倍或者更多.这段代码有着通用的接口,其他CPU的寄存器同样能够使用该功能.简而言之,开启此选项是个明智的选择.</li>
<li>
<ul>
<li>
<p>MTRR cleanup support
CONFIG_MTRR_SANITIZER</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Memory_type_range_register">MTRR cleanup</a>的意思是将MTRR的连续输出转为离散的输出,这样X驱动就可以在其中添加writeback项,算是一种优化措施.建议开启.可以使用&quot;mtrr_chunk_size&quot;来限制最大的连续块尺寸.</li>
<li>
<ul>
<li>
<p>MTRR cleanup enable value (0-1)
CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT</p>
<p>&ldquo;1&quot;表示默认开启CONFIG_MTRR_SANITIZER特性,相当于使用&quot;enable_mtrr_cleanup&rdquo;,&ldquo;0&quot;表示默认关闭CONFIG_MTRR_SANITIZER特性,相当于使用&quot;disable_mtrr_cleanup&rdquo;.建议设为&quot;1&rdquo;.</p>
</li>
<li>
<p>MTRR cleanup spare reg num (0-7)
CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT</p>
<p>这里设定的值等价于使用内核引导参数&quot;mtrr_spare_reg_nr=N&quot;中的&quot;N&quot;.也就是告诉内核reg0N可以被清理或改写(参见&quot;/proc/mtrr&quot;文件).在多数情况下默认值是&quot;1&quot;,其含义是 /proc/mtrr 中的 reg01 将会被映射.一般保持其默认值即可.修改此项的值通常是为了解决某些<a href="http://my-fuzzy-logic.de/blog/index.php?/archives/41-Solving-linux-MTRR-problems.html">MTRR故障</a>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>x86 PAT support
CONFIG_X86_PAT</p>
<p><a href="http://blog.csdn.net/arethe/article/details/6238335">PAT(Page Attribute Table)</a>是对MTRR的补充,且比MTRR更灵活.如果你的CPU支持PAT(grep pat /proc/cpuinfo),那么建议开启.仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>x86 architectural random number generator
CONFIG_ARCH_RANDOM</p>
<p>Intel 从 <a href="http://zh.wikipedia.org/wiki/Intel_Ivy_Bridge">Ivy Bridge</a> 微架构开始(对于Atom来说是从Silvermont开始),在CPU中集成了一个高效的硬件随机数生成器(称为&quot;Bull Mountain&quot;技术),并引入了一个新的x86指令&quot;<a href="http://en.wikipedia.org/wiki/RdRand">RDRAND</a>&quot;,可以非常高效的产生随机数.此选项就是对此特性的支持.</p>
</li>
<li>
<p>Supervisor Mode Access Prevention
CONFIG_X86_SMAP</p>
<p><a href="http://lwn.net/Articles/517475/">SMAP(Supervisor Mode Access Prevention)</a>是Intel从<a href="http://zh.wikipedia.org/wiki/Intel_Haswell">Haswell</a>微架构开始引入的一种新特征,它在CR4寄存器上引入一个新标志位SMAP,如果这个标志为1,内核访问用户进程的地址空间时就会触发一个页错误,目的是为了防止内核因为自身错误意外访问用户空间,这样就可以避免一些内核漏洞所导致的安全问题.但是由于内核在有些时候仍然需要访问用户空间,因此intel提供了两条指令STAC和CLAC用于临时打开/关闭这个功能,反复使用STAC和CLAC会带来一些轻微的性能损失,但考虑到增加的安全性,还是建议开启.</p>
</li>
<li>
<p>EFI runtime service support
CONFIG_EFI</p>
<ul>
<li><a href="http://baike.baidu.com/view/196503.htm">EFI/UEFI</a>支持.如果你打算<a href="http://wiki.gentoo.org/wiki/UEFI_Gentoo_Quick_Install_Guide">在UEFI/EFI平台上安装Linux</a>(2009年之后的机器基本都已经是UEFI规格了),那么就必须开启此项(开启后也依然可以在传统的BIOS机器上启动).<a href="http://wenku.baidu.com/view/b411da6daf1ffc4ffe47ac35.html">UEFI启动流程</a>与传统的BIOS相差很大.虽然Linux受到了所谓&quot;<a href="http://blogs.msdn.com/b/b8_cn/archive/2011/09/27/uefi.aspx">安全启动</a>&ldquo;问题的阻挠(已经<a href="http://news.mydrivers.com/1/254/254690.htm">解决</a>),但是UEFI依然将迅速一统江湖.[提示]在UEFI平台上安装Linux的关键之一是首先要用一个支持UEFI启动的LiveCD以UEFI模式启动机器.</li>
<li>
<ul>
<li>
<p>EFI stub support
CONFIG_EFI_STUB</p>
<p><a href="http://wiki.gentoo.org/wiki/EFI_stub_kernel">EFI stub</a> 支持.如果开启此项,就可以不通过GRUB2之类的引导程序来加载内核,而直接由EFI固件进行加载,这样就可以不必安装引导程序了.不过这是一个看上去很美的特性,由于EFI固件只是简单的加载内核并运行,所以缺点有三:(1)不能在传统的BIOS机器上启动.(2)不能给内核传递引导参数.(3)不能使用intrd.不过,针对后两点的解决办法是:使用CONFIG_CMDLINE和CONFIG_INITRAMFS_SOURCE.更多细节可参考&rdquo;<a href="http://lxr.linux.no/linux/Documentation/x86/efi-stub.txt">Documentation/x86/efi-stub.txt</a>&ldquo;文档.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Enable seccomp to safely compute untrusted bytecode
CONFIG_SECCOMP</p>
<p>允许使用<a href="http://plaintext.blog.edu.cn/2010/553458.html">SECCOMP</a>技术安全地运算非信任代码.通过使用管道或其他进程可用的通信方式作为文件描述符(支持读/写调用),就可以利用SECCOMP把这些应用程序隔离在它们自己的地址空间.这是一种有效的安全沙盒技术.除非你是嵌入式系统,否则不要关闭.</p>
</li>
<li>
<p>Enable -fstack-protector buffer overflow detection
CONFIG_CC_STACKPROTECTOR</p>
<p>开启GCC的&rdquo;-fstack-protector&quot;命令行选项,以使用<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/">GCC中的编译器堆栈保护技术</a>.这样可以有效的防御以堆栈溢出为代表的缓冲区溢出攻击,不过系统的运行速度也会受到一些影响.服务器之类强调安全的场合建议开启,个人PC之类的就不是很有必要了.</p>
</li>
<li>
<p>Timer frequency</p>
<p>内核时钟频率.对于要求快速响应的场合,比如桌面环境,建议使用1000Hz,而对于不需要快速响应的SMP/NUMA服务器,建议使用250Hz或100Hz或300Hz(主要处理多媒体数据).</p>
</li>
<li>
<p>kexec system call
CONFIG_KEXEC</p>
<p>提供<a href="http://www.ibm.com/developerworks/cn/linux/l-kexec/">kexec</a>系统调用,可以<a href="http://www.linuxsir.org/bbs/thread335331.html">不必重启而切换到另一个内核</a>(不一定必须是Linux内核),不过这个特性并不总是那么可靠.如果你不确定是否需要它,那么就是不需要.</p>
</li>
<li>
<p>kernel crash dumps
CONFIG_CRASH_DUMP</p>
<p>当内核崩溃时自动导出运行时信息的功能,主要用于调试目的.更多信息请参考&quot;<a href="http://lxr.linux.no/linux/Documentation/kdump/kdump.txt">Documentation/kdump/kdump.txt</a>&ldquo;文件.</p>
</li>
<li>
<p>kexec jump
CONFIG_KEXEC_JUMP</p>
<p><a href="http://lwn.net/Articles/263286/">kexec jump</a> 支持.这是对CONFIG_KEXEC的增强功能,仅在你确实明白这是干啥的情况下再开启,否则请关闭.</p>
</li>
<li>
<p>Physical address where the kernel is loaded
CONFIG_PHYSICAL_START</p>
<p>加载内核的物理地址.如果内核不是可重定位的(CONFIG_RELOCATABLE=n),那么bzImage会将自己解压到该物理地址并从此地址开始运行,否则,bzImage将忽略此处设置的值,而从引导装载程序将其装入的物理地址开始运行.仅在你确实知道自己是在干什么的情况下才可以改变该值,否则请保持默认.</p>
</li>
<li>
<p>Build a relocatable kernel
CONFIG_RELOCATABLE</p>
<p>使内核可以<a href="http://tsecer.blog.163.com/blog/static/1501817201199871326/">在浮动的物理内存位置加载</a>,主要用于调试目的.仅在你确实知道为什么需要的时候再开启,否则请关闭.</p>
</li>
<li>
<p>Support for hot-pluggable CPUs
CONFIG_HOTPLUG_CPU</p>
<ul>
<li>热插拔CPU支持(通过 /sys/devices/system/cpu 进行控制).</li>
<li>
<ul>
<li>
<p>Set default setting of cpu0_hotpluggable
CONFIG_BOOTPARAM_HOTPLUG_CPU0</p>
<p>开启/关闭此项的意思是设置&quot;cpu0_hotpluggable&quot;的默认值为&quot;on/off&rdquo;.开启此项表示默认将CPU0设置为允许热插拔.</p>
</li>
<li>
<p>Debug CPU0 hotplug
CONFIG_DEBUG_HOTPLUG_CPU0</p>
<p>仅用于调试目的.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Compat VDSO support
CONFIG_COMPAT_VDSO</p>
<p>是否将<a href="http://blog.csdn.net/juana1/article/details/6904932">VDSO</a>(Virtual Dynamic Shared Object)映射到旧式的确定性地址.如果Glibc版本大于等于2.3.3选&quot;N&quot;,否则就选&quot;Y&quot;.</p>
</li>
<li>
<p>Built-in kernel command line
CONFIG_CMDLINE_BOOL</p>
<ul>
<li>将内核引导参数直接编进来.在无法向内核传递引导参数的情况下(比如在嵌入式系统上,或者想使用 EFI stub kernel),这就是唯一的救命稻草了.如果你使用grub之类的引导管理器,那么就可以不需要此特性.</li>
<li>
<ul>
<li>
<p>Built-in kernel command string
CONFIG_CMDLINE</p>
<p>将要编译进内核的引导参数字符串.</p>
</li>
<li>
<p>Built-in command line overrides boot loader arguments
CONFIG_CMDLINE_OVERRIDE</p>
<p>开启此项表示完全忽略引导加载器传递过来的参数,并仅仅只使用CONFIG_CMDLINE所指定的参数.通常情况下建议关闭此项,除非你确定引导加载器在传递内核引导参数的时候不能正常工作.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="power-management-and-acpi-options-电源管理和acpi选项"><a href=""></a>Power management and ACPI options 电源管理和ACPI选项</h2>
<ul>
<li>
<p>Suspend to RAM and standby
CONFIG_SUSPEND</p>
<ul>
<li>&ldquo;休眠到内存&rdquo;(ACPI S3)支持.也就是系统休眠后,除了内存之外,其他所有部件都停止工作,重开机之后可以直接从内存中恢复运行状态.要使用此功能,你需要执行&quot;echo mem &gt; /sys/power/state&quot;命令,还需要在BIOS中开启S3支持,否则可能会有问题.</li>
<li>
<ul>
<li>
<p>Enable freezer for suspend to RAM/standby
CONFIG_SUSPEND_FREEZER</p>
<p>选&quot;Y&quot;.除非你知道自己在做什么</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hibernation (aka &lsquo;suspend to disk&rsquo;)
CONFIG_HIBERNATION</p>
<p>&ldquo;休眠到硬盘&rdquo;(ACPI S4)支持.也就是将内存的内容保存到硬盘(hibernation),所有部件全都停止工作.要使用此功能,你首先需要使用内核引导参数&quot;resume=/dev/swappartition&quot;,然后执行&quot;echo disk &gt; /sys/power/state&quot;命令.如果你不想从先前的休眠状态中恢复,那么可以使用&quot;noresume&quot;内核引导参数.更多信息,可以参考&quot;<a href="http://lxr.linux.no/linux/Documentation/power/swsusp.txt">Documentation/power/swsusp.txt</a>&ldquo;文件.</p>
</li>
<li>
<p>Default resume partition
CONFIG_PM_STD_PARTITION</p>
<p>默认的休眠分区.这个分区必须是swap分区.不过这里设置的值会被明确的内核引导参数中的值覆盖.</p>
</li>
<li>
<p>Opportunistic sleep
CONFIG_PM_AUTOSLEEP</p>
<p>这是一种从<a href="https://lwn.net/Articles/479841/">安卓借鉴过来的休眠方式</a>.这个特性在安卓系统上被称为&quot;suspend blockers&quot;或&quot;wakelocks&rdquo;.这是一种更激进的电源管理模式,以尽可能节约电力为目的.系统默认就处于休眠状态,仅为内存和少数唤醒系统所必须的设备供电,当有任务(唤醒源)需要运行的时候才唤醒相关组件工作,工作完成后又立即进入休眠状态.不过这些特性需要相应的设备驱动程序的支持.目前除了安卓设备,在PC和服务器领域,能够利用此特性的驱动还比较少,不过这是一项非常有前途的电源技术,喜欢尝鲜的可以考虑开启.</p>
</li>
<li>
<p>User space wakeup sources interface
CONFIG_PM_WAKELOCKS</p>
<ul>
<li>允许用户空间的程序通过sys文件系统接口,创建/激活/撤销系统的&quot;唤醒源&quot;.需要与CONFIG_PM_AUTOSLEEP配合使用.</li>
<li>
<ul>
<li>
<p>Maximum number of user space wakeup sources (0 = no limit)
CONFIG_PM_WAKELOCKS_LIMIT</p>
<p>用户空间程序允许使用的&quot;唤醒源&quot;数量,&ldquo;0&quot;表示无限,最大值是&quot;100000&rdquo;.</p>
</li>
<li>
<p>Garbage collector for user space wakeup sources
CONFIG_PM_WAKELOCKS_GC</p>
<p>对&quot;唤醒源&quot;对象使用垃圾回收.主要用于调试目的和Android环境.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Run-time PM core functionality
CONFIG_PM_RUNTIME</p>
<p>允许IO设备(比如硬盘/网卡/声卡)在系统运行时进入省电模式,并可在收到(硬件或驱动产生的)唤醒信号后恢复正常.此功能通常需要硬件的支持.建议在笔记本/嵌入式等需要节约电力的设备上选&quot;Y&quot;.</p>
</li>
<li>
<p>Power Management Debug Support
CONFIG_PM_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>ACPI (Advanced Configuration and Power Interface) Support
CONFIG_ACPI</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%94%B5%E6%BA%90%E6%8E%A5%E5%8F%A3">高级配置与电源接口</a>(<a href="http://www.xiaofeng.org/Article/20090422220.htm">Advanced Configuration and Power Interface</a>)包括了软件和硬件方面的规范,目前已被软硬件厂商广泛支持,并且取代了许多过去的配置与电源管理接口,包括 PnP BIOS (Plug-and-Play BIOS), MPS(CONFIG_X86_MPPARSE), APM(Advanced Power Management) 等.总之,ACPI已经成为x86平台必不可少的组件,如果你没有特别的理由,务必选中此项.</li>
<li>
<ul>
<li>
<p>Deprecated /proc/acpi files
CONFIG_ACPI_PROCFS</p>
<p>过时的 /proc/acpi 接口支持,建议关闭.</p>
</li>
<li>
<p>Deprecated power /proc/acpi directories
CONFIG_ACPI_PROCFS_POWER</p>
<p>过时的 /proc/acpi 接口支持,建议关闭.</p>
</li>
<li>
<p>EC read/write access through /sys/kernel/debug/ec
CONFIG_ACPI_EC_DEBUGFS</p>
<p>仅供调试使用.</p>
</li>
<li>
<p>Deprecated /proc/acpi/event support
CONFIG_ACPI_PROC_EVENT</p>
<p>过时的 /proc/acpi/event 接口支持,建议关闭.</p>
</li>
<li>
<p>AC Adapter
CONFIG_ACPI_AC</p>
<p>允许在外接交流电源和内置电池之间进行切换.</p>
</li>
<li>
<p>Battery
CONFIG_ACPI_BATTERY</p>
<p>允许通过 /proc/acpi/battery 接口查看电池信息.</p>
</li>
<li>
<p>Button
CONFIG_ACPI_BUTTON</p>
<p>允许守护进程通过 /proc/acpi/event 接口捕获power/sleep/lid(合上笔记本)按钮事件,并执行相应的动作,软关机(poweroff)也需要它的支持.</p>
</li>
<li>
<p>Video
CONFIG_ACPI_VIDEO</p>
<p>对主板上的集成显卡提供ACPI支持.注意:仅支持集成显卡.</p>
</li>
<li>
<p>Fan
CONFIG_ACPI_FAN</p>
<p>允许用户层的程序对风扇进行控制(开/关/查询状态)</p>
</li>
<li>
<p>Dock
CONFIG_ACPI_DOCK</p>
<p>支持兼容ACPI规范的扩展坞(比如 IBM Ultrabay 和 Dell Module Bay)支持.</p>
</li>
<li>
<p>Processor
CONFIG_ACPI_PROCESSOR</p>
<p>在支持 ACPI C2/C3 的CPU上,将ACPI安装为idle处理程序.有几种CPU频率调节驱动依赖于它.而且目前的CPU都已经支持ACPI规范,建议开启此项.</p>
</li>
<li>
<p>IPMI
CONFIG_ACPI_IPMI</p>
<p>允许ACPI使用<a href="http://zh.wikipedia.org/wiki/IPMI">IPMI</a>(智能平台管理接口)的请求/应答消息访问BMC(主板管理控制器).IPMI通常出现在服务器中,以允许通过诸如<a href="http://www.ibm.com/developerworks/cn/linux/l-ipmi/">ipmitool</a>这样的工具监视服务器的物理健康特征(温度/电压/风扇状态/电源状态).</p>
</li>
<li>
<p>Processor Aggregator
CONFIG_ACPI_PROCESSOR_AGGREGATOR</p>
<p>支持 ACPI 4.0 加入的处理器聚合器(<a href="http://lwn.net/Articles/355934/">processor Aggregator</a>)功能,以允许操作系统对系统中所有的CPU进行统一的配置和控制.目前只支持逻辑处理器idling功能,其目标是降低耗电量.</p>
</li>
<li>
<p>Thermal Zone
CONFIG_ACPI_THERMAL</p>
<p>ACPI thermal zone 支持.系统温度过高时可以及时调整工作状态以避免你的CPU被烧毁.目前所有CPU都支持此特性.务必开启.参见CONFIG_THERMAL选项.</p>
</li>
<li>
<p>NUMA support
CONFIG_ACPI_NUMA</p>
<p>通过读取系统固件中的ACPI表,获得NUMA系统的CPU及物理内存分布信息.NUMA系统必选.</p>
</li>
<li>
<p>Custom DSDT Table file to include
CONFIG_ACPI_CUSTOM_DSDT_FILE</p>
<p>允许将一个定制过的DSDT编译进内核.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/acpi/dsdt-override.txt">Documentation/acpi/dsdt-override.txt</a>&ldquo;文档.看不懂的请保持空白.</p>
</li>
<li>
<p>ACPI tables override via initrd
CONFIG_ACPI_INITRD_TABLE_OVERRIDE</p>
<p>允许initrd更改 <a href="http://www.cnblogs.com/junzhkevin/archive/2013/02/25/2932801.html">ACPI tables</a> 中的任意内容. ACPI tables 是BIOS提供给OS的硬件配置数据,包括系统硬件的电源管理和配置管理.详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/acpi/initrd_table_override.txt">Documentation/acpi/initrd_table_override.txt</a>&ldquo;文件.</p>
</li>
<li>
<p>Debug Statements
CONFIG_ACPI_DEBUG</p>
<p>详细的ACPI调试信息,不搞开发就别选.</p>
</li>
<li>
<p>PCI slot detection driver
CONFIG_ACPI_PCI_SLOT</p>
<p>将每个PCI插槽都作为一个单独的条目列在 /sys/bus/pci/slots/ 目录中,有助于将设备的物理插槽位置与逻辑的PCI总线地址进行对应.不确定的选&quot;No&rdquo;.</p>
</li>
<li>
<p>Power Management Timer Support
CONFIG_X86_PM_TIMER</p>
<p><a href="http://www.biosren.com/viewthread.php?tid=2895">ACPI PM Timer</a>,简称&quot;ACPI Timer&quot;,是一种集成在主板上的硬件时钟发生器,提供3.579545MHz固定频率.这是比较传统的硬件时钟发生器(HPET则是比较新型的硬件时钟发生器),目前所有的主板都支持,而且是ACPI规范不可分割的部分.除非你确定不需要,否则必选.</p>
</li>
<li>
<p>Container and Module Devices
CONFIG_ACPI_CONTAINER</p>
<p>支持 NUMA节点/CPU/内存 的热插拔. Device ID: ACPI0004, PNP0A05, PNP0A06</p>
</li>
<li>
<p>Memory Hotplug
CONFIG_ACPI_HOTPLUG_MEMORY</p>
<p>内存热插拔支持. Device ID: PNP0C80</p>
</li>
<li>
<p>Smart Battery System
CONFIG_ACPI_SBS</p>
<p><a href="http://baike.baidu.com/view/1938623.htm">智能电池系统</a>(<a href="http://wenku.baidu.com/view/9388cf93daef5ef7ba0d3c7e.html">Smart Battery System</a>)可以让笔记型电脑显示及管理详细精确的电池状态信息.<a href="http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&amp;lc=zh-hans&amp;dlc=zh-hans&amp;docname=c00718292">使用锂电池</a>的笔记本电脑必备利器.但遗憾的是并不是所有笔记本都支持这项特性.</p>
</li>
<li>
<p>Hardware Error Device
CONFIG_ACPI_HED</p>
<p>Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误(通常是已经被纠正的错误).如果你的系统中有设备ID为&quot;PNP0C33&quot;的设备(比如某些Intel芯片组),那么就选上.</p>
</li>
<li>
<p>Allow ACPI methods to be inserted/replaced at run time
CONFIG_ACPI_CUSTOM_METHOD</p>
<p>允许在不断电的情况下直接对ACPI的功能进行删改,包含一定危险性,它允许root任意修改内存中内核空间的内容.仅用于调试.</p>
</li>
<li>
<p>Boottime Graphics Resource Table support
CONFIG_ACPI_BGRT</p>
<p>在 /sys/firmware/acpi/bgrt/ 中显示 ACPI Boottime Graphics Resource Table ,以允许操作系统获取固件中的启动画面(splash).</p>
</li>
<li>
<p>ACPI Platform Error Interface (APEI)
CONFIG_ACPI_APEI</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-apei/">高级平台错误接口(ACPI Platform Error Interface)</a>是<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-ras/">RAS(Reliability, Availability and Serviceability)</a>的一部分,是定义在 ACPI 4.0 规范中的一个面向硬件错误管理的接口,主要是为了统一 firmware/BIOS 和 OS 之间的错误交互机制,使用标准的错误接口进行管理,同时也扩展了错误接口的内容以便实现更加灵活丰富的功能.</li>
<li>
<ul>
<li>
<p>APEI Generic Hardware Error Source
CONFIG_ACPI_APEI_GHES</p>
<p>&ldquo;Firmware First Mode&quot;支持.由于BIOS/FIRMWARE是平台相关的,因此BIOS/FIRMWARE比OS更清楚硬件平台的配置情况,甚至包含各种必须的修正/定制/优化.这样,在&quot;Firmware First&quot;模式下,BIOS/FIRMWARE利用这一优势,可以有针对性的对发生的硬件错误进行分析/处理/分发,也可以更准确的记录错误的现场信息.这样,不但对硬件错误可以做出更准确,更复杂的处理,而且可以降低OS的复杂性和冗余度.建议开启.</p>
</li>
<li>
<p>APEI PCIe AER logging/recovering support
CONFIG_ACPI_APEI_PCIEAER</p>
<p>让 PCIe AER errors 首先通过 APEI firmware 进行报告.</p>
</li>
<li>
<p>APEI memory error recovering support
CONFIG_ACPI_APEI_MEMORY_FAILURE</p>
<p>让 Memory errors 首先通过 APEI firmware 进行报告.</p>
</li>
<li>
<p>APEI Error INJection (EINJ)
CONFIG_ACPI_APEI_EINJ</p>
<p>仅供调试使用.</p>
</li>
<li>
<p>APEI Error Record Serialization Table (ERST) Debug Support
CONFIG_ACPI_APEI_ERST_DEBUG</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SFI (Simple Firmware Interface) Support
CONFIG_SFI</p>
<p>简单固件接口规范(<a href="http://en.wikipedia.org/wiki/Simple_Firmware_Interface">Simple Firmware Interface</a>)使用一种轻量级的简单方法(通过内存中的一张静态表格)从firmware向操作系统传递信息.目前这个规范仅用于第二代 Intel Atom 平台,其核心名称是&rdquo;<a href="http://news.mydrivers.com/1/163/163402.htm">Moorestown</a>&quot;.</p>
</li>
<li>
<p>CPU Frequency scaling
CONFIG_CPU_FREQ</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cpufreq-1/">CPUfreq</a>子系统允许动态改变CPU主频,达到省电和降温的目的.现如今的CPU都已经支持动态频率调整,建议开启.不过,如果你是为虚拟机编译内核,就没有必要开启了,由宿主机内核去控制就OK了.</li>
<li>
<ul>
<li>
<p>CPU frequency translation statistics
CONFIG_CPU_FREQ_STAT</p>
<ul>
<li>通过sysfs文件系统输出CPU频率变化的统计信息</li>
<li>
<ul>
<li>
<p>CPU frequency translation statistics details
CONFIG_CPU_FREQ_STAT_DETAILS</p>
<p>输出更详细的CPU频率变化统计信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Default CPUFreq governor</p>
<p>默认的CPU频率<a href="http://www.ibm.com/developerworks/cn/linux/l-cpufreq-2/">调节策略</a>.不同策略拥有不同的<a href="http://www.ibm.com/developerworks/cn/linux/l-cpufreq-3/">调节效果</a>.</p>
</li>
<li>
<p>&lsquo;performance&rsquo; governor
CONFIG_CPU_FREQ_GOV_PERFORMANCE</p>
<p>&lsquo;性能&rsquo;优先,静态的将频率设置为cpu支持的最高频率</p>
</li>
<li>
<p>&lsquo;powersave&rsquo; governor
CONFIG_CPU_FREQ_GOV_POWERSAVE</p>
<p>&lsquo;节能&rsquo;优先,静态的将频率设置为cpu支持的最低频率</p>
</li>
<li>
<p>&lsquo;userspace&rsquo; governor for userspace frequency scaling
CONFIG_CPU_FREQ_GOV_USERSPACE</p>
<p>既允许手动调整cpu频率,也允许用户空间的程序动态的调整cpu频率(需要额外的调频软件)</p>
</li>
<li>
<p>&lsquo;ondemand&rsquo; cpufreq policy governor
CONFIG_CPU_FREQ_GOV_ONDEMAND</p>
<p>&lsquo;立即响应&rsquo;,周期性的考察CPU负载并自动的动态调整cpu频率(不需要额外的调频软件),适合台式机</p>
</li>
<li>
<p>&lsquo;conservative&rsquo; cpufreq governor
CONFIG_CPU_FREQ_GOV_CONSERVATIVE</p>
<p>&lsquo;保守&rsquo;,和&rsquo;ondemand&rsquo;相似,但是频率的升降是渐变式的(幅度不会很大),更适合用于笔记本/PDA/x86_64环境</p>
</li>
<li>
<p>x86 CPU frequency scaling drivers</p>
<ul>
<li>CPU频率调节器驱动</li>
<li>
<ul>
<li>
<p>Intel P state control
CONFIG_X86_INTEL_PSTATE</p>
<p>Intel CPU 的 P-state 驱动,面向&quot;<a href="http://zh.wikipedia.org/wiki/Sandy_Bridge%E5%BE%AE%E6%9E%B6%E6%A7%8B">Sandy Bridge</a>&quot;/&quot;<a href="http://zh.wikipedia.org/wiki/Intel_Ivy_Bridge">Ivy Bridge</a>&quot;/&quot;<a href="http://zh.wikipedia.org/wiki/Intel_Haswell">Haswell</a>&ldquo;或更新的CPU微架构,可以更好的支持&rdquo;<a href="http://www.expreview.com/13254-all.html">Turbo Boost 2.0</a>&ldquo;技术.</p>
</li>
<li>
<p>Processor Clocking Control interface driver
CONFIG_X86_PCC_CPUFREQ</p>
<p>PCC(Processor Clocking Control)接口支持.此种接口仅对某些HP Proliant系列服务器有意义.更多细节可以参考&rdquo;<a href="http://lxr.linux.no/linux/Documentation/cpu-freq/pcc-cpufreq.txt">Documentation/cpu-freq/pcc-cpufreq.txt</a>&ldquo;文件.</p>
</li>
<li>
<p>ACPI Processor P-States driver
CONFIG_X86_ACPI_CPUFREQ</p>
<ul>
<li>这是首选的驱动(CONFIG_X86_INTEL_PSTATE也依赖于它),同时支持Intel和AMD的CPU.除非你的CPU实在太老,否则必选.</li>
<li>
<ul>
<li>
<p>Legacy cpb sysfs knob support for AMD CPUs
CONFIG_X86_ACPI_CPUFREQ_CPB</p>
<p>为了兼容旧的用户空间程序而设置,建议关闭.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>AMD Opteron/Athlon64 PowerNow!
CONFIG_X86_POWERNOW_K8</p>
<p>过时的驱动,仅为老旧的<a href="http://zh.wikipedia.org/wiki/AMD_K8">K8</a>核心的AMD处理器提供支持.<a href="http://zh.wikipedia.org/wiki/AMD_K10">K10</a>以及更新的CPU应该使用CONFIG_X86_ACPI_CPUFREQ驱动.</p>
</li>
<li>
<p>AMD frequency sensitivity feedback powersave bias
CONFIG_X86_AMD_FREQ_SENSITIVITY</p>
<p>如果你使用 AMD Family 16h 或者更高级别的处理器,同时又使用&quot;ondemand&quot;频率调节器,开启此项可以更有效的进行频率调节(在保证性能的前提下更节能).</p>
</li>
<li>
<p>Intel Enhanced SpeedStep (deprecated)
CONFIG_X86_SPEEDSTEP_CENTRINO</p>
<p>已被时代抛弃的驱动,仅对老旧的迅驰平台 Intel Pentium M 或者 Intel Xeons 处理器有意义.</p>
</li>
<li>
<p>Intel Pentium 4 clock modulation
CONFIG_X86_P4_CLOCKMOD</p>
<p>已被时代抛弃的驱动,仅对支持老旧的Speedstep技术的 Intel Pentium 4 / XEON 处理器有意义.而且即便是在这样的CPU上,因为种种兼容性问题可能导致的不稳定,也不建议开启.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CPU idle PM support
CONFIG_CPU_IDLE</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Idle_%28CPU%29">CPU idle</a> 指令支持,该指令可以让CPU在空闲时&quot;打盹&quot;以节约电力和减少发热.只要是支持ACPI的CPU就应该开启.由于所有64位CPU都已支持ACPI,所以不必犹豫,开启![提示]为虚拟机编译的内核就没有必要开启了,由宿主机内核去控制就OK了.</li>
<li>
<ul>
<li>
<p>Support multiple cpuidle drivers
CONFIG_CPU_IDLE_MULTIPLE_DRIVERS</p>
<p>允许CONFIG_CPU_IDLE为每个不同的CPU使用不同的驱动.仅在你的系统由多个不同型号的CPU组成,并且具有不同的唤醒潜伏时间和状态的时候才需要开启.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cpuidle Driver for Intel Processors
CONFIG_INTEL_IDLE</p>
<p>专用于Intel CPU的cpuidle驱动.而CONFIG_CPU_IDLE则是用于非Intel的CPU.</p>
</li>
<li>
<p>Memory power savings</p>
<ul>
<li>内存节能</li>
<li>
<ul>
<li>
<p>Intel chipset idle memory power saving driver
CONFIG_I7300_IDLE</p>
<p>在某些具备内存节能特性的intel服务器芯片组上,让内存也可以在空闲时通过idle指令&quot;打盹&rdquo;.这些<a href="http://blog.chinaunix.net/uid-15089195-id-3561594.html">芯片组</a>必须具备 <a href="http://tech.sina.com.cn/h/2007-04-18/1957292094.shtml">I/O AT</a> 支持(例如 Intel 7300).同时内存也需要支持此特性.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="bus-options-pci-etc-总线选项"><a href=""></a>Bus options (PCI etc.) 总线选项</h2>
<ul>
<li>
<p>PCI support
CONFIG_PCI</p>
<ul>
<li><a href="http://blog.csdn.net/fudan_abc/article/category/345294">PCI</a>是最重要的内部总线,不但PCI与PCI Express设备依赖于它,而且USB/IDE/SATA/SCSI/火线(IEEE 1394)/PCMCIA/CardBus等各种内部和外部总线也都依赖于它.所以必须选&quot;Y&quot;,除非你知道自己在干什么.</li>
<li>
<ul>
<li>
<p>Support mmconfig PCI config space access
CONFIG_PCI_MMCONFIG</p>
<p>允许通过mmconfig方式访问<a href="http://en.wikipedia.org/wiki/PCI_configuration_space">PCI config space</a>,这种访问方式比传统的IO方式速度更快.建议开启.MMCONFIG的意思是&quot;Memory-Mapped config&quot;,它是PCI Express引入的新<a href="http://blog.csdn.net/fudan_abc/article/details/1888773">总线枚举</a>方式.背景知识:PCI设备都有一组叫做&rsquo;Configuration Space&rsquo;的寄存器,PCI-E设备在PCI的基础上又增加了一组叫做&rsquo;Extended Configuration Space&rsquo;的寄存器.这些寄存器都被映射到了内存中(Memory-Mapped),操作系统理应提供相应的API供设备驱动和诊断程序访问这些&rsquo;Configuration Space&rsquo;.但如果操作系统没有提供Memory-Mapped方式的API的话,这些驱动程序和诊断程序就必须自己根据操作系统的底层规则(IO方式)去访问,这显然就增加了开发难度.这个选项的目的就是提供Memory-Mapped方式的API.</p>
</li>
<li>
<p>Read CNB20LE Host Bridge Windows
CONFIG_PCI_CNB20LE_QUIRK</p>
<p>CNB20LE芯片组PCI热插拔支持.除非你非常明确的知道你需要它,否则请关闭此项.</p>
</li>
<li>
<p>PCI Express support
CONFIG_PCIEPORTBUS</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/PCI_Express">PCI Express</a>是PCI的升级版并在软件层与PCI兼容,其目标是统一电脑内部总线.基本上只要不是古董机,都早已支持PCI-E了.选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>PCI Express Hotplug driver
CONFIG_HOTPLUG_PCI_PCIE</p>
<p>如果你的主板和设备都支持PCI Express热插拔就可以选上.</p>
</li>
<li>
<p>Root Port Advanced Error Reporting support
CONFIG_PCIEAER</p>
<ul>
<li><a href="http://stuff.mit.edu/afs/sipb/contrib/linux/Documentation/PCI/pcieaer-howto.txt">PCI Express Root Port Advanced Error Reporting (AER)</a> 驱动支持.这样,发送到 Root Port 的 Error reporting messages 就会由 PCI Express AER 处理.建议开启.背景知识:PCI Express 定义了两种错误报告范例:(1)baseline,所有PCI-E组件都必须要支持,功能也比较基础.(2)AER(Advanced Error Reporting),功能比较高级,也更可靠,但并不要求所有组件都支持.</li>
<li>
<ul>
<li>
<p>PCI Express ECRC settings control
CONFIG_PCIE_ECRC</p>
<p>允许覆写firmware/bios设置的 PCI Express ECRC(端对端循环冗余校验).建议关闭,除非你确实知道为什么要开启.</p>
</li>
<li>
<p>PCIe AER error injector support
CONFIG_PCIEAER_INJECT</p>
<p>允许 PCI-E AER 注入,仅用于测试目的.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PCI Express ASPM control
CONFIG_PCIEASPM</p>
<ul>
<li>PCI Express <a href="http://baike.baidu.cn/view/2803778.html">ASPM(Active State Power Management)</a> 和 Clock Power Management 支持.这是PCI-E规范制定的一种电源管理方案,可以在设备空闲时采用节电模式.建议开启.ASPM可以在运行时通过 /sys/module/pcie_aspm/parameters/policy 进行开启或关闭.</li>
<li>
<ul>
<li>
<p>Debug PCI Express ASPM
CONFIG_PCIEASPM_DEBUG</p>
<p>仅供调试.</p>
</li>
<li>
<p>Default ASPM policy</p>
<p>默认的ASPM电源管理策略.下面的三个选项:&ldquo;BIOS default&quot;表示使用BIOS中的设置作为默认.&ldquo;Powersave&quot;表示在可能的情况下,默认使用&quot;L0s&quot;和&quot;L1&rdquo;,以尽可能节约电力.&ldquo;Performance&quot;表示禁止使用&quot;L0s&quot;和&quot;L1&rdquo;(即使BIOS开启也同样禁止),以保证最高性能.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Message Signaled Interrupts (MSI and MSI-X)
CONFIG_PCI_MSI</p>
<p>PCI/PCI-E支持三类中断:(1)INTx使用传统的IRQ中断,可以与现行的驱动程序和操作系统兼容.(2)MSI是PCI2.2规范中新增的,通过写入特殊的内存地址来触发和发送中断,该种方式脱离了中断引脚带来的数目限制,并且延迟小/效率高.不过MSI方式将中断全部落在单个CPU上,对多核CPU利用不佳.(3)MSI-X是在PCI3.0规范中新增的,在MSI的基础上,支持更多的消息数量以及独立的消息地址,可以自动在多个CPU上分担中断,更适合多CPU系统.建议开启.开启后,也可以使用&quot;pci=nomsi&quot;内核引导参数关闭MSI特性.</p>
</li>
<li>
<p>PCI Debugging
CONFIG_PCI_DEBUG</p>
<p>将PCI调试信息输出到系统日志里.如果你想诊断PCI设备的故障,可以开启,否则应该关闭.</p>
</li>
<li>
<p>Enable PCI resource re-allocation detection
CONFIG_PCI_REALLOC_ENABLE_AUTO</p>
<p>让内核自动检测&quot;是否需要重新分配PCI资源&rdquo;.即使此项已开启,你依然可以用&quot;pci=realloc=[on|off]&ldquo;来覆盖它.此项仅在已开启CONFIG_PCI_IOV的情况下才有意义.此时,如果BIOS没有为<a href="http://docs.oracle.com/cd/E38902_01/html/E38873/glbzi.html">SR-IOV(Single-Root I/O Virtualization)</a> BAR(基地址寄存器)分配资源,那么内核将会自动对PCI资源进行重新分配.建议与CONFIG_PCI_IOV同开关.</p>
</li>
<li>
<p>PCI Stub driver
CONFIG_PCI_STUB</p>
<p><a href="http://www.powerpcdev.net/blog/index.php/archives/52.html">PCI Stub driver</a> 的作用是将PCI设备跟目前绑定的驱动分离,暂时由其接管,最后再交给虚拟机自己去驱动这个PCI设备.</p>
</li>
<li>
<p>Xen PCI Frontend
CONFIG_XEN_PCIDEV_FRONTEND</p>
<p>如果你使用XEN的半虚拟化技术,并且你的硬件支持IOMMU,那么可以开启此项,否则应该关闭.</p>
</li>
<li>
<p>Interrupts on hypertransport devices
CONFIG_HT_IRQ</p>
<p>允许本地的<a href="http://zh.wikipedia.org/wiki/HyperTransport">HyperTransport</a>设备使用中断.这个一般用于AMD平台,Intel平台不支持这个.</p>
</li>
<li>
<p>PCI IOV support
CONFIG_PCI_IOV</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-pci-passthrough/">PCI I/O Virtualization</a>支持.这需要硬件支持IOMMU技术(AMD-Vi,Intel VT-d).</p>
</li>
<li>
<p>PCI PRI support
CONFIG_PCI_PRI</p>
<p>PCI Page Request Interface 支持.它允许IOMMU之后的设备能够从页错误中恢复过来.这需要硬件支持IOMMU技术(AMD-Vi,Intel VT-d).</p>
</li>
<li>
<p>PCI PASID support
CONFIG_PCI_PASID</p>
<p>PASID(Process Address Space Identifiers)可以被PCI设备用来同时访问多个IO地址空间.这需要硬件支持IOMMU技术(AMD-Vi,Intel VT-d).</p>
</li>
<li>
<p>PCI IO-APIC hotplug support
CONFIG_PCI_IOAPIC</p>
<p>PCI <a href="http://www.ibm.com/developerworks/cn/linux/l-cn-linuxkernelint/">IO-APIC</a> 热插拔支持.</p>
</li>
<li>
<p>ISA-style DMA support
CONFIG_ISA_DMA_API</p>
<p><a href="https://lkml.org/lkml/2011/1/27/326">ISA-style DMA</a>控制器支持.目前基本只有<a href="http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC总线</a>设备需要使用,最常见的是串口,并口,PS/2键盘,<a href="http://zh.wikipedia.org/wiki/Super_I/O">Super I/O</a>芯片(可以使用<a href="http://www.coreboot.org/Superiotool">Superiotool</a>和<a href="http://www.lm-sensors.org/wiki/man/sensors-detect">sensors-detect</a>工具检测).不确定的选&quot;Y&rdquo;.[说明]这是一个历史遗留问题,对于ISA架构,DMA操作是由一个专用的&quot;DMA控制器&quot;(最常见的是<a href="http://en.wikipedia.org/wiki/Intel_8237">Intel 8237</a>)来执行的,但是到了PCI架构,由于每一个PCI设备都可以控制PCI总线(成为&quot;<a href="http://en.wikipedia.org/wiki/Bus_mastering">bus master</a>&quot;)并直接读写系统内存,所以&quot;DMA控制器&quot;又消失了.此选项只是为那些需要&quot;ISA-DMA控制器&quot;的设备提供了兼容性接口(API)而已.</p>
</li>
<li>
<p>PCCard (PCMCIA/CardBus) support
CONFIG_PCCARD</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/PC%E5%8D%A1">PCCard(PCMCIA/CardBus/ExpressCard)</a>接口通常出现在笔记本电脑上,这些接口卡通常大小与信用卡差不多,厚度大约3-5毫米.注意:必须要配合<a href="https://www.kernel.org/pub/linux/utils/kernel/pcmcia/">pcmciautils</a>工具才能正常使用PCMCIA设备.</li>
<li>
<ul>
<li>
<p>16-bit PCMCIA support
CONFIG_PCMCIA</p>
<ul>
<li>老旧的 16-bit PCMCIA 卡支持</li>
<li>
<ul>
<li>
<p>Load CIS updates from userspace
CONFIG_PCMCIA_LOAD_CIS</p>
<p>有些PCMCIA卡需要从用户空间更新CIS(Card Information Structure)之后才能正常工作.开启此项后,内核将可以使用内置的固件加载器和热插拔子系统自动加载CIS,而不再需要用户空间工具的辅助.建议选&quot;Yes&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>32-bit CardBus support
CONFIG_CARDBUS</p>
<p>常见的PCMCIA卡基本上都是32位的<a href="http://zh.wikipedia.org/wiki/CardBus">CardBus</a>与<a href="http://zh.wikipedia.org/wiki/ExpressCard">ExpressCard</a>设备.如果你有这样的卡,就选&quot;Yes&quot;.由于绝大多数的卡都是&quot;yenta-compatible&quot;的,所以一般你还需要选中CONFIG_YENTA项.</p>
</li>
<li>
<p>CardBus yenta-compatible bridge support
CONFIG_YENTA</p>
<p>使用PCMCIA卡的基本上都需要选择这一项,子项是一些拥有自己特定扩展的硬件,请按实际情况选择.</p>
</li>
<li>
<p>{省略的部分请按照自己实际使用的PCMCIA卡选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support for PCI Hotplug
CONFIG_HOTPLUG_PCI</p>
<p>PCI热插拔不仅仅针对PCI和PCI-E设备,也包括<a href="http://zh.wikipedia.org/wiki/CardBus">CardBus</a>与<a href="http://zh.wikipedia.org/wiki/ExpressCard">ExpressCard</a>设备.请按需选择.</p>
</li>
<li>
<ul>
<li>{省略的部分请按照自己实际使用PCI控制器进行选择}</li>
<li>RapidIO support
CONFIG_RAPIDIO</li>
</ul>
<!---->
<ul>
<li><a href="http://baike.baidu.com/view/1237941.htm">RapidIO</a>总线支持.这种总线主要用于嵌入式系统.</li>
<li>
<ul>
<li>
<p>Discovery timeout duration (seconds)
CONFIG_RAPIDIO_DISC_TIMEOUT</p>
<p>等待主机完成枚举(也就是初始化)的超时秒数.</p>
</li>
<li>
<p>Enable RapidIO Input/Output Ports
CONFIG_RAPIDIO_ENABLE_RX_TX_PORTS</p>
<p>开启所有 RapidIO Input/Output 端口.</p>
</li>
<li>
<p>DMA Engine support for RapidIO
CONFIG_RAPIDIO_DMA_ENGINE</p>
<p>使用<a href="http://zhidao.baidu.com/question/467321157.html">DMA引擎</a>(CONFIG_DMADEVICES)进行RapidIO数据传输</p>
</li>
<li>
<p>RapidIO subsystem debug messages
CONFIG_RAPIDIO_DEBUG</p>
<p>将RapidIO调试信息输出到系统日志里.如果你想诊断RapidIO设备的故障,可以开启,否则应该关闭.</p>
</li>
<li>
<p>{省略的部分请按照自己实际使用的控制器进行选择}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="executable-file-formats--emulations-可执行文件格式仿真"><a href=""></a>Executable file formats / Emulations 可执行文件格式/仿真</h2>
<ul>
<li>
<p>Kernel support for ELF binaries
CONFIG_BINFMT_ELF</p>
<p>ELF是最常用的跨平台二进制文件格式,支持动态连接,支持不同的硬件平台,支持不同的操作系统.必选,除非你知道自己在做什么.</p>
</li>
<li>
<p>Write ELF core dumps with partial segments
CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS</p>
<p>如果你打算在此Linux上开发应用程序或者帮助别人调试bug,那么就选&quot;Y&quot;,否则选&quot;N&quot;.注意这里的调试和开发不是指内核调试和开发,是应用程序的调试和开发.</p>
</li>
<li>
<p>Kernel support for scripts starting with #!
CONFIG_BINFMT_SCRIPT</p>
<p>支持以&quot;#!/path/to/interpreter&quot;行开头的脚本.务必&quot;Y&quot;,不要&quot;M&quot;或&quot;N&quot;,除非你知道自己在做什么.</p>
</li>
<li>
<p>Kernel support for MISC binaries
CONFIG_BINFMT_MISC</p>
<p>允许插入二进制封装层到内核中,运行Java,.NET(Mono-based),Python,Emacs-Lisp等语言编写的程序时需要它,DOSEMU也需要它.想要更方便的使用此特性,你还需要使用&quot;mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc&quot;挂载<a href="http://guaneryu.com/blog/?tag=binfmt_misc">binfmt_misc</a>伪文件系统.具体详情可以参考&quot;<a href="http://lxr.linux.no/linux/Documentation/binfmt_misc.txt">Documentation/binfmt_misc.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Enable core dump support
CONFIG_COREDUMP</p>
<p><a href="http://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6">核心转储(core dump)</a>支持.如果你打算在此Linux上开发应用程序或者帮助别人调试bug,那么就选&quot;Y&rdquo;,否则选&quot;N&quot;.注意这里的调试和开发不是指内核调试和开发,是应用程序的调试和开发.</p>
</li>
<li>
<p>IA32 Emulation
CONFIG_IA32_EMULATION</p>
<ul>
<li>允许在64位内核中运行32位代码.除非你打算使用纯64位环境,否则请开启此项.提示:GRUB2支持引导纯64位内核,但是GRUB不支持.</li>
<li>
<ul>
<li>
<p>IA32 a.out support
CONFIG_IA32_AOUT</p>
<p>早期UNIX系统的可执行文件格式(32位),目前已经被ELF格式取代.除非你需要使用古董级的二进制程序.否则请关闭.</p>
</li>
<li>
<p>x32 ABI for 64-bit mode
CONFIG_X86_X32</p>
<p>允许32位程序使用完整的64位寄存器,以减小内存占用(<a href="http://en.wikipedia.org/wiki/Memory_footprint">memory footprint</a>).这可以提高32位程序的运行性能.如果你使用binutils-2.22以上的版本(支持elf32_x86_64),就选&quot;Y&quot;,否则选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="networking-support-网络支持"><a href=""></a>Networking support 网络支持</h2>
<ul>
<li>
<p>Networking options</p>
<ul>
<li>网络选项</li>
<li>
<ul>
<li>
<p>Packet socket
CONFIG_PACKET</p>
<ul>
<li>链路层<a href="http://blog.csdn.net/tqyou85/article/details/3115664">PF_PACKET</a>套接字支持.可以让应用程序(比如:抓包工具<a href="http://zh.wikipedia.org/zh-cn/Tcpdump">tcpdump</a>, DHCP客户端<a href="http://linux.die.net/man/8/dhclient">dhclient</a>)直接与网络设备通讯,而无需使用内核中的其它中介协议.不确定的选&quot;Y&quot;或&quot;M&quot;.</li>
<li>
<ul>
<li>
<p>Packet: sockets monitoring interface
CONFIG_PACKET_DIAG</p>
<p>PF_PACKET套接字监控接口,<a href="http://xikder.blog.51cto.com/1423200/869467">ss</a>这样的诊断工具需要它.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Unix domain sockets
CONFIG_UNIX</p>
<ul>
<li><a href="http://learn.akae.cn/media/ch37s04.html">Unix domain sockets</a> 支持.许多程序都使用它在操作系统内部进行进程间通信(IPC),比如: X Window, syslog, udev 等等.选&quot;Y&quot;,除非你确实知道自己在做什么.</li>
<li>
<ul>
<li>
<p>UNIX: socket monitoring interface
CONFIG_UNIX_DIAG</p>
<p>UNIX套接字监控接口,<a href="http://xikder.blog.51cto.com/1423200/869467">ss</a>这样的工具需要它.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Transformation user configuration interface
CONFIG_XFRM_USER</p>
<p>为<a href="http://zh.wikipedia.org/zh-cn/IPsec">IPsec</a>相关的工具提供<a href="http://manpages.ubuntu.com/manpages/raring/man8/ip-xfrm.8.html">Transformation(XFRM)</a>用户配置接口</p>
</li>
<li>
<p>Transformation sub policy support
CONFIG_XFRM_SUB_POLICY</p>
<p>XFRM子策略支持,不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Transformation migrate database
CONFIG_XFRM_MIGRATE</p>
<p>用于动态的更新 <a href="http://en.wikipedia.org/wiki/IPsec">IPsec</a> <a href="http://en.wikipedia.org/wiki/Security_association">SA(security association)</a> 的定位器(locator).这个特性对于手机这类移动设备来讲至关重要,因为它需要在不同的基站之间迁移.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Transformation statistics
CONFIG_XFRM_STATISTICS</p>
<p>转换统计,这不是<a href="http://network.51cto.com/art/201007/209214.htm">SNMP/MIB</a>规范的内容.用于调试目的.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>PF_KEY sockets
CONFIG_NET_KEY</p>
<ul>
<li><a href="http://cxw06023273.iteye.com/blog/867303">PF_KEYv2 套接字</a>支持(与KAME兼容).PF_KEY协议族主要用来处理SA(安全关联),对SADB(SA数据库)进行管理,主要用在IPsec协议中.<a href="http://wenku.baidu.com/view/e6cc6608763231126edb1107.html">PF_KEY_v2的编程API</a>在<a href="http://tools.ietf.org/html/rfc2367">RFC2367</a>中定义.</li>
<li>
<ul>
<li>
<p>PF_KEY MIGRATE
CONFIG_NET_KEY_MIGRATE</p>
<p>向PF_KEYv2套接字中添加一个 PF_KEY MIGRATE 消息. PF_KEY MIGRATE 消息可用于动态的更新 IPsec SA(security association) 的定位器(locator).这个特性对于手机这类移动设备来讲至关重要,因为它需要在不同的基站之间迁移.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TCP/IP networking
CONFIG_INET</p>
<ul>
<li>TCP/IP协议,必选!</li>
<li>
<ul>
<li>
<p>IP: multicasting
CONFIG_IP_MULTICAST</p>
<p><a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD">IP组播(IP multicasting)</a>支持.指的是一个发送者向一组特定的接收者发送数据,但只需发送一份数据副本.实际应用的场合很少,<a href="http://www.baike.com/wiki/Mbone">MBONE</a>算是其中之一,与RTP等音视频协议相结合也算一种.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IP: advanced router
CONFIG_IP_ADVANCED_ROUTER</p>
<ul>
<li>高级路由支持,需要开启内核的IP转发功能(echo 1 &gt; /proc/sys/net/ipv4/ip_forward)才能正常工作.如果这个Linux系统用作专业的路由器就选上,选上之后还需要按需选择其下的子项.一般的主机不需要这个.</li>
<li>
<ul>
<li>
<p>FIB TRIE statistics
CONFIG_IP_FIB_TRIE_STATS</p>
<p>主要用于测试TRIE性能</p>
</li>
<li>
<p>IP: policy routing
CONFIG_IP_MULTIPLE_TABLES</p>
<p>策略路由</p>
</li>
<li>
<p>IP: equal cost multipath
CONFIG_IP_ROUTE_MULTIPATH</p>
<p>用于基于目的地址的负载均衡</p>
</li>
<li>
<p>IP: verbose route monitoring
CONFIG_IP_ROUTE_VERBOSE</p>
<p>显示冗余的路由监控信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP: kernel level autoconfiguration
CONFIG_IP_PNP</p>
<ul>
<li>在内核启动时自动配置网卡的ip地址/路由表,配置信息来自于以下途径:内核引导参数,<a href="http://baike.baidu.com/view/32782.htm">自举协议(BOOTP)</a>,<a href="http://baike.baidu.com/view/876146.htm">反向地址转换协议(RARP)</a>,<a href="http://zh.wikipedia.org/wiki/DHCP">动态主机配置协议(DHCP)</a>.通常,需要从网络启动的无盘工作站才需要这个东西(此时还需要开启CONFIG_ROOT_NFS),一般的发行版都通过启动脚本(<a href="http://roy.marples.name/projects/dhcpcd/">dhcpcd</a>/<a href="http://www.isc.org/products/DHCP">dhclient</a>/<a href="http://zh.wikipedia.org/zh-cn/Ifconfig">ifconfig</a>)配置网络.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>IP: DHCP support
CONFIG_IP_PNP_DHCP</p>
<p>DHCP协议支持</p>
</li>
<li>
<p>IP: BOOTP support
CONFIG_IP_PNP_BOOTP</p>
<p>BOOTP协议支持</p>
</li>
<li>
<p>IP: RARP support
CONFIG_IP_PNP_RARP</p>
<p>RARP协议支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP: tunneling
CONFIG_NET_IPIP</p>
<p><a href="https://sites.google.com/site/emmoblin/linux-network-1/linux-zhongip-sui-dao">IP隧道</a>,主要目的是为了在TCP/IP网络中传输其他协议的数据包,当然也包括IP数据包(例如用于实现VPN).</p>
</li>
<li>
<p>IP: GRE demultiplexer
CONFIG_NET_IPGRE_DEMUX</p>
<p>GRE demultiplexer 支持.被CONFIG_NET_IPGRE和CONFIG_PPTP所依赖.</p>
</li>
<li>
<p>IP: GRE tunnels over IP
CONFIG_NET_IPGRE</p>
<ul>
<li>基于IP的<a href="http://zkhylt.blog.51cto.com/3638719/771968">通用路由封装</a>(<a href="http://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">Generic Routing Encapsulation</a>)隧道支持.该驱动主要用于对端是Cisco路由器的场合,因为Cisco的路由器特别偏好GRE隧道(而不是CONFIG_NET_IPIP),并且GRE还允许通过隧道对组播进行再分发.</li>
<li>
<ul>
<li>
<p>IP: broadcast GRE over IP
CONFIG_NET_IPGRE_BROADCAST</p>
<p>GRE/IP的一种应用是构建一个广播WAN(<a href="http://baike.baidu.com/view/21956.htm">Wide Area Network</a>),而其看上去却很像一个跑在互联网上的LAN(<a href="http://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">Local Area Network</a>).如果你想要创建这样的网络,那么就选&quot;Y&quot;(还要加上CONFIG_IP_MROUTE).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP: multicast routing
CONFIG_IP_MROUTE</p>
<ul>
<li><a href="http://www.mvn.cn/multicast-details.htm">组播路由</a>支持.实际应用的场合很少,<a href="http://www.baike.com/wiki/Mbone">MBONE</a>算是其中之一,不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>IP: multicast policy routing
CONFIG_IP_MROUTE_MULTIPLE_TABLES</p>
<p>通常,组播路由器上会运行一个单独的用户态守护进程,根据源地址和目的地址来处理数据包.开启此项后,将能同时考虑数据包所带的标记(mark)和所通过的网络接口,并可在用户空间同时运行多个守护进程,每一个进程处理一张路由表.</p>
</li>
<li>
<p>IP: PIM-SM version 1 support
CONFIG_IP_PIMSM_V1</p>
<p>Sparse Mode PIM (Protocol Independent Multicast) version 1 支持. 该协议被Cisco路由器广泛支持,你需要特定的软件(pimd-v1)才能使用它.</p>
</li>
<li>
<p>IP: PIM-SM version 2 support
CONFIG_IP_PIMSM_V2</p>
<p>Sparse Mode PIM (Protocol Independent Multicast) version 2 支持. 该协议的使用并不广泛,你需要特定的软件(pimd 或 gated-5)才能使用它.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP: ARP daemon support
CONFIG_ARPD</p>
<p>通常情况下,内核自身会使用ARP协议解析本地网络中的IP地址与MAC地址的对应关系,并进行缓存.开启此项后,内核将使用用户空间的守护进程进行ARP解析.这主要是为了使用其他的替代解析协议(比如mGRE隧道中的NHRP),或调试目的.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IP: TCP syncookie support
CONFIG_SYN_COOKIES</p>
<p><a href="http://baike.baidu.com/view/6625802.htm">TCP syncookie</a> 支持,这是抵抗<a href="http://www.xfocus.net/articles/200106/208.html">SYN flood</a>攻击的好东西.此特性的开关可以通过&quot;/proc/sys/net/ipv4/tcp_syncookies&quot;文件控制,写入&quot;1&quot;表示开启,写入&quot;0&quot;表示关闭.建议服务器环境开启此项.</p>
</li>
<li>
<p>Virtual (secure) IP: tunneling
CONFIG_NET_IPVTI</p>
<p>虚拟IP隧道.可以和xfrm隧道一起使用,以实现IPSEC安全隧道,并在其上使用路由协议.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IP: AH transformation
CONFIG_INET_AH</p>
<p><a href="http://wenku.baidu.com/view/dd0d200f6c85ec3a87c2c53a.html">IPsec AH</a> 支持.IPsec验证头(AH)可对整个数据包(IP报头与数据)提供身份验证/完整性/抗重播保护.但是它不提供保密性,即它不对数据进行加密.由于这个原因,AH头正在慢慢被ESP头取代.</p>
</li>
<li>
<p>IP: ESP transformation
CONFIG_INET_ESP</p>
<p><a href="http://wenku.baidu.com/view/dd0d200f6c85ec3a87c2c53a.html">IPsec ESP</a> 支持.IPsec封装安全负载(ESP)不仅为IP负载提供身份验证/完整性/抗重播保护,还提供保密性,也就是还对数据进行加密.ESP有两种使用模式:传输模式(ESP不对整个数据包进行签名,只对IP负载(不含IP报头)进行保护)和隧道模式(将原始IP包封装进新的带有ESP头的IP包内,可提供完整的保护).ESP可以独立使用,也可与AH组合使用(越来越少).</p>
</li>
<li>
<p>IP: IPComp transformation
CONFIG_INET_IPCOMP</p>
<p>IP静荷载压缩协议(<a href="http://wenku.baidu.com/view/082419c00c22590102029d2d.html">IP Payload Compression Protocol</a>)(RFC3173)支持.用于支持IPsec</p>
</li>
<li>
<p>IP: IPsec transport mode
CONFIG_INET_XFRM_MODE_TRANSPORT</p>
<p>IPsec传输模式.常用于对等通信,用以提供内网安全.数据包经过了加密但IP头没有加密,因此任何标准设备或软件都可查看和使用IP头</p>
</li>
<li>
<p>IP: IPsec tunnel mode
CONFIG_INET_XFRM_MODE_TUNNEL</p>
<p>IPsec隧道模式.用于提供外网安全(包括虚拟专用网络).整个数据包(数据头和负载)都已经过加密处理且分配有新的ESP头/IP头/验证尾,从而能够隐藏受保护站点的拓扑结构</p>
</li>
<li>
<p>IP: IPsec BEET mode
CONFIG_INET_XFRM_MODE_BEET</p>
<p>IPsec BEET模式.</p>
</li>
<li>
<p>Large Receive Offload (ipv4/tcp)
CONFIG_INET_LRO</p>
<p><a href="http://blog.chinaunix.net/uid-317451-id-92639.html">LRO(Large Receive Offload)</a> (ipv4/tcp) 支持.它通过将多个TCP数据整合在一个skb结构中,并在稍后的某个时刻作为一个大的数据包交付给上层的网络协议栈,以减少上层协议栈处理skb的开销,提高Linux系统接收TCP数据包的能力.目前,主流网卡驱动都已支持此特性.建议开启.不过,<a href="http://en.wikipedia.org/wiki/Large_receive_offload">LRO</a>不应该在路由器上开启,因为它破坏了end-to-end原则,并会对路由性能造成显著的不利影响.</p>
</li>
<li>
<p>INET: socket monitoring interface
CONFIG_INET_DIAG</p>
<ul>
<li>INET(TCP,DCCP,&hellip;) socket 监视接口,一些Linux本地工具(如:包含ss的<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2">iproute2</a>)需要使用它</li>
<li>
<ul>
<li>
<p>UDP: socket monitoring interface
CONFIG_INET_UDP_DIAG</p>
<p>UDP socket 监视接口,一些Linux本地工具(如:包含ss的<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2">iproute2</a>)需要使用它</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TCP: advanced congestion control
CONFIG_TCP_CONG_ADVANCED</p>
<p>高级<a href="http://baike.baidu.com/view/1453183.htm">拥塞控制</a>,子项提供多种<a href="http://blog.csdn.net/zhangskd/article/details/6715751">拥塞控制算法</a>供选用.如果没有特殊需求就别选了,内核会自动将默认的拥塞控制设为&quot;CUBIC&quot;并将&quot;new Reno&quot;作为候补.仅在你确实知道自己需要的情况下选&quot;Y&quot;.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>TCP: MD5 Signature Option support (RFC2385)
CONFIG_TCP_MD5SIG</p>
<p><a href="">RFC2385</a>中描述了一种对TCP会话进行MD5签名的保护机制.目前仅用于保护互联网运营商骨干路由器间的<a href="http://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">BGP</a>会话.一般的路由器/服务器等设备根本不需要这个.</p>
</li>
<li>
<p>The IPv6 protocol
CONFIG_IPV6</p>
<ul>
<li>引领未来的<a href="http://zh.wikipedia.org/wiki/IPv6">IPv6</a>支持.</li>
<li>
<ul>
<li>
<p>IPv6: Privacy Extensions (RFC 3041) support
CONFIG_IPV6_PRIVACY</p>
<p>IPv6利用&quot;<a href="http://tools.ietf.org/html/rfc4862">Stateless Address Autoconfiguration</a>&ldquo;在无DHCP服务器的情况下,产生可用的&quot;临时IPv6地址&rdquo;.而本选项则为这个机制增加&quot;隐私扩展&quot;(<a href="http://tools.ietf.org/html/rfc4941">RFC4941</a>)保护.默认状态下,内核并不生产&quot;临时地址&quot;,需要&quot;echo 2 &gt;/proc/sys/net/ipv6/conf/all/use_tempaddr&quot;才能开启</p>
</li>
<li>
<p>IPv6: Router Preference (RFC 4191) support
CONFIG_IPV6_ROUTER_PREF</p>
<ul>
<li>主机连上IPv6网络后,会发出路由器邀请包(Router Solicitation),路由器则应答路由器公告包(Router Advertisement),其中包含网关地址/IPv6前缀/DNS地址,这样主机就能取得IPv6地址,并连接到互联网上,这就是无状态地址自动分配(StateLess Address AutoConfiguration).&quot;<a href="http://www.ietf.org/rfc/rfc4191.txt">Router Preference</a>&ldquo;是&quot;Router Advertisement&quot;包的可选扩展.它可以改进主机选中路由器的能力,特别是在多归属(<a href="http://blog.chinaunix.net/uid-16459552-id-3761490.html">multi-homed</a>)网络中.不确定的选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>IPv6: Route Information (RFC 4191) support
CONFIG_IPV6_ROUTE_INFO</p>
<p>对&quot;<a href="http://www.ietf.org/rfc/rfc4191.txt">Route Information</a>&ldquo;的实验性支持.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IPv6: Enable RFC 4429 Optimistic DAD
CONFIG_IPV6_OPTIMISTIC_DAD</p>
<p>乐观<a href="http://kapok.blog.51cto.com/517862/130464">重复地址检测</a>(<a href="http://tools.ietf.org/html/rfc4429">Optimistic Duplicate Address Detection</a>)的实验性支持.可以更快的进行自动地址配置.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>IPv6: AH transformation
CONFIG_INET6_AH</p>
<p>IPsec AH 支持.不确定的选&quot;Y&quot;或&quot;M&quot;.AH头正在慢慢被ESP头取代.</p>
</li>
<li>
<p>IPv6: ESP transformation
CONFIG_INET6_ESP</p>
<p>IPsec ESP 支持.不确定的选&quot;Y&quot;或&quot;M&quot;.</p>
</li>
<li>
<p>IPv6: IPComp transformation
CONFIG_INET6_IPCOMP</p>
<p>IPv6静荷载压缩协议(<a href="http://wenku.baidu.com/view/082419c00c22590102029d2d.html">IP Payload Compression Protocol</a>)(RFC3173)支持.用于支持IPsec.不确定的选&quot;Y&quot;或&quot;M&quot;.</p>
</li>
<li>
<p>IPv6: Mobility
CONFIG_IPV6_MIP6</p>
<p><a href="http://wenku.baidu.com/view/13c8a2dc26fff705cc170af2.html">移动IPv6(RFC3775)</a>支持.主要用于移动设备.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IPv6: IPsec transport mode
CONFIG_INET6_XFRM_MODE_TRANSPORT</p>
<p>IPsec传输模式.常用于对等通信,用以提供内网安全.数据包经过了加密但IP头没有加密,因此任何标准设备或软件都可查看和使用IP头.不确定的选&quot;Y&quot;或&quot;M&quot;.</p>
</li>
<li>
<p>IPv6: IPsec tunnel mode
CONFIG_INET6_XFRM_MODE_TUNNEL</p>
<p>IPsec隧道模式.用于提供外网安全(包括虚拟专用网络).整个数据包(数据头和负载)都已经过加密处理且分配有新的ESP头/IP头/验证尾,从而能够隐藏受保护站点的拓扑结构.不确定的选&quot;Y&quot;或&quot;M&quot;.</p>
</li>
<li>
<p>IPv6: IPsec BEET mode
CONFIG_INET6_XFRM_MODE_BEET</p>
<p>IPsec BEET模式.不确定的选&quot;Y&quot;或&quot;M&quot;.</p>
</li>
<li>
<p>IPv6: MIPv6 route optimization mode
CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION</p>
<p><a href="http://man.chinaunix.net/network/Linux_Mobile_IPv6_HowTo/index.htm">移动IPv6(Mobile IPv6)</a>路由优化模式.主要用于移动设备.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IPv6: IPv6-in-IPv4 tunnel (SIT driver)
CONFIG_IPV6_SIT</p>
<ul>
<li>在IPv4网络上建立IPv6隧道.如果你希望可以通过IPv4网络接入一个IPv6网络,可以选&quot;Y&quot;或&quot;M&quot;,否则选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>IPv6: IPv6 Rapid Deployment (6RD)
CONFIG_IPV6_SIT_6RD</p>
<p><a href="http://www.a10networks.com.cn/products/axseries-IPv6_rapid_deployment_6rd.php">IPv6快速部署(6RD)</a>支持.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IPv6: IP-in-IPv6 tunnel (RFC2473)
CONFIG_IPV6_TUNNEL</p>
<p>IPv6-in-IPv6/IPv4-in-IPv6 隧道(<a href="http://wenku.baidu.com/view/8f221d6b1eb91a37f1115c62.html">RFC2473</a>)支持.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IPv6: GRE tunnel
CONFIG_IPV6_GRE</p>
<p>基于IPv6的<a href="http://zkhylt.blog.51cto.com/3638719/771968">通用路由封装</a>(<a href="http://en.wikipedia.org/wiki/Generic_Routing_Encapsulation">Generic Routing Encapsulation</a>)隧道支持.该驱动主要用于对端是Cisco路由器的场合,因为Cisco的路由器特别偏好GRE隧道(而不是CONFIG_IPV6_TUNNEL),并且GRE还允许通过隧道对组播进行再分发.</p>
</li>
<li>
<p>IPv6: Multiple Routing Tables
CONFIG_IPV6_MULTIPLE_TABLES</p>
<ul>
<li><a href="http://blog.csdn.net/oohaha_123/article/details/8597761">多重路由表</a>(<a href="http://www.study-area.org/tips/m_routing.htm">Multiple Routing Tables</a>)支持.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>IIPv6: source address based routing
CONFIG_IPV6_SUBTREES</p>
<p>允许根据源地址或前缀进行路由.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IPv6: multicast routing
CONFIG_IPV6_MROUTE</p>
<ul>
<li>测试性的IPv6<a href="http://www.mvn.cn/multicast-details.htm">组播路由</a>支持.实际应用的场合很少,不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>IPv6: multicast policy routing
CONFIG_IPV6_MROUTE_MULTIPLE_TABLES</p>
<p>通常,组播路由器上会运行一个单独的用户态守护进程,根据源地址和目的地址来处理数据包.开启此项后,将能同时考虑数据包所带的标记(mark)和所通过的网络接口,并可在用户空间同时运行多个守护进程,每一个进程处理一张路由表.</p>
</li>
<li>
<p>IPv6: PIM-SM version 2 support
CONFIG_IPV6_PIMSM_V2</p>
<p>IPv6 PIM multicast routing protocol PIM-SMv2 支持.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NetLabel subsystem support
CONFIG_NETLABEL</p>
<p><a href="http://lwn.net/Articles/204905/">NetLabel</a>子系统支持.NetLabel子系统为诸如CIPSO与RIPSO之类能够在分组信息上添加标签的协议提供支持,看不懂就别选了.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Security Marking
CONFIG_NETWORK_SECMARK</p>
<p>对网络包进行安全标记,类似于nfmark,但主要是为安全目的而设计.看不懂的就别选了</p>
</li>
<li>
<p>Timestamping in PHY devices
CONFIG_NETWORK_PHY_TIMESTAMPING</p>
<p>允许在硬件支持的前提下,为物理层(<a href="http://zh.wikipedia.org/wiki/PHY">PHY</a>)数据包打上时间戳.这会略微增加发送与接收的开销.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Network packet filtering framework (Netfilter)
CONFIG_NETFILTER</p>
<ul>
<li><a href="http://www.ha97.com/4082.html">Netfilter</a>可以对数据包进行过滤和修改,可以作为防火墙(&ldquo;packet filter&quot;或&quot;proxy-based&rdquo;)或网关(NAT)或代理(proxy)或网桥使用.</li>
<li>
<ul>
<li>
<p>Network packet filtering debugging
CONFIG_NETFILTER_DEBUG</p>
<p>仅供开发者调试Netfilter使用</p>
</li>
<li>
<p>Advanced netfilter configuration
CONFIG_NETFILTER_ADVANCED</p>
<ul>
<li>选&quot;Y&quot;将会显示所有模块供用户选择,选&quot;N&quot;则会隐藏一些不常用的模块,并自动将常用模块设为&quot;M&quot;.</li>
<li>
<ul>
<li>
<p>Bridged IP/ARP packets filtering
CONFIG_BRIDGE_NETFILTER</p>
<p>如果你希望使用桥接防火墙就打开它.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Core Netfilter Configuration</p>
<ul>
<li>核心Netfilter配置(当包流过Chain时如果match某个规则那么将由该规则的target来处理,否则将由同一个Chain中的下一个规则进行匹配,若不match所有规则那么最终将由该Chain的policy进行处理)</li>
<li>
<ul>
<li>
<p>Netfilter NFACCT over NFNETLINK interface
CONFIG_NETFILTER_NETLINK_ACCT</p>
<p>允许通过<a href="http://www.netfilter.org/projects/libnfnetlink/">NFNETLINK</a>接口支持<a href="http://netfilter.org/projects/libnetfilter_acct/index.html">NFACCT</a>(记账).</p>
</li>
<li>
<p>Netfilter NFQUEUE over NFNETLINK interface
CONFIG_NETFILTER_NETLINK_QUEUE</p>
<p>允许通过<a href="http://www.netfilter.org/projects/libnfnetlink/">NFNETLINK</a>接口支持<a href="https://home.regit.org/netfilter-en/using-nfqueue-and-libnetfilter_queue/">NFQUEUE</a>(排队).</p>
</li>
<li>
<p>Netfilter LOG over NFNETLINK interface
CONFIG_NETFILTER_NETLINK_LOG</p>
<p>允许通过<a href="http://www.netfilter.org/projects/libnfnetlink/">NFNETLINK</a>接口支持&quot;LOG&quot;(日志).该选项废弃了ipt_ULOG和ebg_ulog机制,并打算在将来废弃基于syslog的ipt_LOG和ip6t_LOG模块.</p>
</li>
<li>
<p>Netfilter connection tracking support
CONFIG_NF_CONNTRACK</p>
<ul>
<li>连接追踪(connection tracking)支持,连接跟踪把所有连接都保存在一个表格内,并将每个包关联到其所属的连接.可用于报文伪装或地址转换,也可用于增强包过滤能力.</li>
<li>
<ul>
<li>
<p>Connection mark tracking support
CONFIG_NF_CONNTRACK_MARK</p>
<p>允许对连接进行标记,与针对单独的包进行标记的不同之处在于它是针对连接流的. CONNMARK target 和 connmark match 需要它的支持.</p>
</li>
<li>
<p>Connection tracking security mark support
CONFIG_NF_CONNTRACK_SECMARK</p>
<p>允许对连接进行安全标记,通常这些标记包(SECMARK)复制到其所属连接(CONNSECMARK),再从连接复制到其关联的包(SECMARK).</p>
</li>
<li>
<p>Connection tracking zones
CONFIG_NF_CONNTRACK_ZONES</p>
<p>&ldquo;<a href="http://lwn.net/Articles/370152/">conntrack zones</a>&ldquo;支持.通常,每个连接需要一个全局唯一标示符,而&quot;conntrack zones&quot;允许在不同zone内的连接使用相同的标识符.</p>
</li>
<li>
<p>Supply CT list in procfs (OBSOLETE)
CONFIG_NF_CONNTRACK_PROCFS</p>
<p>已被废弃,选&quot;N&rdquo;.</p>
</li>
<li>
<p>Connection tracking events
CONFIG_NF_CONNTRACK_EVENTS</p>
<p>连接跟踪事件支持.如果启用这个选项,连接跟踪代码将提供一个&quot;notifier&quot;链,它可以被其它内核代码用来获知连接跟踪状态的改变</p>
</li>
<li>
<p>Connection tracking timeout
CONFIG_NF_CONNTRACK_TIMEOUT</p>
<p>连接跟踪&quot;timeout&quot;扩展.这样你就可以在网络流上通过 CT target 附加超时策略.</p>
</li>
<li>
<p>Connection tracking timestamping
CONFIG_NF_CONNTRACK_TIMESTAMP</p>
<p>时间戳支持.这样你就能在连接建立和断开时打上时间戳.</p>
</li>
<li>
<p>DCCP protocol connection tracking support
CONFIG_NF_CT_PROTO_DCCP</p>
<p><a href="http://zh.wikipedia.org/zh-cn/DCCP">DCCP协议</a>支持.</p>
</li>
<li>
<p>SCTP protocol connection tracking support
CONFIG_NF_CT_PROTO_SCTP</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-sctp/">SCTP协议</a>支持.</p>
</li>
<li>
<p>UDP-Lite protocol connection tracking support
CONFIG_NF_CT_PROTO_UDPLITE</p>
<p><a href="http://net.chinaunix.net/5/2006/12/15/1142339.shtml">UDP-Lite</a>支持.</p>
</li>
<li>
<p>Amanda backup protocol support
CONFIG_NF_CONNTRACK_AMANDA</p>
<p><a href="http://www.amanda.org/">Amanda</a>备份协议支持.</p>
</li>
<li>
<p>FTP protocol support
CONFIG_NF_CONNTRACK_FTP</p>
<p><a href="http://www.cnbeta.com/articles/171754.htm">文件传输协议(FTP)</a>支持.跟踪FTP连接需要额外的帮助程序.</p>
</li>
<li>
<p>H.323 protocol support
CONFIG_NF_CONNTRACK_H323</p>
<p><a href="http://networking.ctocio.com.cn/tips/192/6490692.shtml">H.323协议</a>支持.</p>
</li>
<li>
<p>IRC protocol support
CONFIG_NF_CONNTRACK_IRC</p>
<p><a href="http://zh.wikipedia.org/zh-cn/IRC">IRC</a>扩展协议<a href="http://en.wikipedia.org/wiki/Direct_Client-to-Client">DCC(Direct Client-to-Client Protocol)</a>支持.该协议允许用户之间绕开服务器直接聊天和传输文件.</p>
</li>
<li>
<p>NetBIOS name service protocol support
CONFIG_NF_CONNTRACK_NETBIOS_NS</p>
<p><a href="http://baike.baidu.com/view/491843.htm">NetBIOS</a>协议支持.</p>
</li>
<li>
<p>SNMP service protocol support
CONFIG_NF_CONNTRACK_SNMP</p>
<p><a href="http://baike.baidu.com/view/2899.htm">SNMP</a>协议支持.</p>
</li>
<li>
<p>PPtP protocol support
CONFIG_NF_CONNTRACK_PPTP</p>
<p><a href="http://tools.ietf.org/html/rfc2637">RFC2637</a> <a href="http://baike.baidu.com/view/32771.htm">点对点隧道协议(Point to Point Tunnelling Protocol)</a>协议支持.</p>
</li>
<li>
<p>SANE protocol support
CONFIG_NF_CONNTRACK_SANE</p>
<p><a href="http://www.sane-project.org/">SANE</a>协议支持.</p>
</li>
<li>
<p>SIP protocol support
CONFIG_NF_CONNTRACK_SIP</p>
<p><a href="http://baike.baidu.com/view/51013.htm">SIP</a>协议支持.</p>
</li>
<li>
<p>TFTP protocol support
CONFIG_NF_CONNTRACK_TFTP</p>
<p><a href="http://baike.baidu.com/view/23881.htm">TFTP</a>协议支持.</p>
</li>
<li>
<p>Connection tracking netlink interface
CONFIG_NF_CT_NETLINK</p>
<p>基于<a href="http://blog.csdn.net/dog250/article/details/6425664">netlink</a>的用户接口支持.</p>
</li>
<li>
<p>Connection tracking timeout tuning via Netlink
CONFIG_NF_CT_NETLINK_TIMEOUT</p>
<p>通过<a href="http://www.ibm.com/developerworks/cn/linux/l-kerns-usrs/">Netlink</a>机制支持对连接追踪超时进行细粒度的调节:允许为特定的网络流指定超时策略,而不是使用统一的全局超时策略.</p>
</li>
<li>
<p>Connection tracking helpers in user-space via Netlink
CONFIG_NF_CT_NETLINK_HELPER</p>
<p>通过<a href="http://www.ibm.com/developerworks/cn/linux/l-kerns-usrs/">Netlink</a>机制为用户空间的连接追踪帮助程序提供基础框架.</p>
</li>
<li>
<p>NFQUEUE integration with Connection Tracking
CONFIG_NETFILTER_NETLINK_QUEUE_CT</p>
<p>开启此项后,即使网络包已经在队列(NFQUEUE)中,它依然可以包含连接追踪信息.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Transparent proxying support
CONFIG_NETFILTER_TPROXY</p>
<p>透明代理支持,也就是可以处理非本地的 IPv4 TCP/UDP 套接字.此功能需要配合一些iptables规则和策略路由才能工作.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/networking/tproxy.txt">Documentation/networking/tproxy.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Netfilter Xtables support (required for ip_tables)
CONFIG_NETFILTER_XTABLES</p>
<ul>
<li>如果你打算使用 ip_tables, ip6_tables, arp_tables 之一就必须选上</li>
<li>
<ul>
<li>
<p>nfmark target and match support
CONFIG_NETFILTER_XT_MARK</p>
<p>&ldquo;nfmark&quot;是用户给包打上的一个自定义标记.用于match时,允许基于&quot;nfmark&quot;值对包进行匹配.用于target时,允许在&quot;mangle&quot;表中创建规则以改变包的&quot;nfmark&quot;值.</p>
</li>
<li>
<p>ctmark target and match support
CONFIG_NETFILTER_XT_CONNMARK</p>
<p>&ldquo;ctmark&quot;是用户以连接为组,给同一连接中的所有包打上的自定义标记.用法与&quot;nfmark&quot;相似.</p>
</li>
<li>
<p>set target and match support
CONFIG_NETFILTER_XT_SET</p>
<p>&ldquo;set&quot;是<a href="http://blog.sina.com.cn/s/blog_6bdc95ab0100m58b.html">ipset</a>工具创建的<a href="http://blog.chinaunix.net/uid-21706718-id-3561951.html">IP地址集合</a>.使用match可以对IP地址集合进行匹配,使用target可以对集合中的项进行增加和删除.</p>
</li>
<li>
<p>AUDIT target support
CONFIG_NETFILTER_XT_TARGET_AUDIT</p>
<p>为被drop/accept的包创建审计记录.</p>
</li>
<li>
<p>CHECKSUM target support
CONFIG_NETFILTER_XT_TARGET_CHECKSUM</p>
<p>用于&quot;mangle&quot;表,为缺少校验和的包添加checksum字段的值.主要是为了兼容一些老旧的网络程序(例如某些dhcp客户端).</p>
</li>
<li>
<p>&ldquo;CLASSIFY&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CLASSIFY</p>
<p>允许为包设置优先级,一些<a href="http://edseek.com/~jasonb/articles/traffic_shaping/qdiscs.html">qdiscs</a>排队规则(atm,cbq,dsmark,pfifo_fast,htb,prio)需要使用它</p>
</li>
<li>
<p>&ldquo;CONNMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CONNMARK</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_CONNMARK</p>
</li>
<li>
<p>&ldquo;CONNSECMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CONNSECMARK</p>
<p>针对链接进行安全标记,同时还会将连接上的标记还原到包上(如果链接中的包尚未进行安全标记),通常与 SECMARK target 联合使用</p>
</li>
<li>
<p>&ldquo;CT&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CT</p>
<p>允许为包加上连接追踪相关的参数,比如&quot;event&quot;和&quot;helper&rdquo;.</p>
</li>
<li>
<p>&ldquo;DSCP&rdquo; and &ldquo;TOS&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_DSCP</p>
<p>DSCP target 允许对IPv4/IPv6包头部的DSCP(Differentiated Services Codepoint)字段(常用于Qos)进行修改. TOS target 允许在&quot;mangle&quot;表创建规则以修改IPv4包头的TOS(Type Of Service)字段或IPv6包头的Priority字段.</p>
</li>
<li>
<p>&ldquo;HL&rdquo; hoplimit target support
CONFIG_NETFILTER_XT_TARGET_HL</p>
<p>HL(IPv6)/TTL(IPv4) target 允许更改包头的 hoplimit/time-to-live 值.</p>
</li>
<li>
<p>&ldquo;HMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_HMARK</p>
<p>允许在&quot;raw&quot;和&quot;mangle&quot;表中创建规则,以根据特定范围的哈希计算结果设置&rdquo;<a href="http://wenku.baidu.com/view/b5162f3543323968011c92e0">skbuff</a>&ldquo;标记.</p>
</li>
<li>
<p>IDLETIMER target support
CONFIG_NETFILTER_XT_TARGET_IDLETIMER</p>
<p>每个被匹配的包的定时器都会被强制指定为规则指定的值,当超时发生时会触发一个sysfs文件系统的通知.剩余时间可以通过sysfs读取.</p>
</li>
<li>
<p>&ldquo;LED&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_LED</p>
<p>允许在满足特定条件的包通过的时候,触发LED灯闪烁.比如可以用于控制网卡的状态指示灯仅在有SSH活动的时候才闪烁.</p>
</li>
<li>
<p>LOG target support
CONFIG_NETFILTER_XT_TARGET_LOG</p>
<p>允许向syslog中记录包头信息.</p>
</li>
<li>
<p>&ldquo;MARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_MARK</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MARK</p>
</li>
<li>
<p>&ldquo;NETMAP&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_NETMAP</p>
<p>NETMAP用于实现一对一的静态NAT(地址转换).</p>
</li>
<li>
<p>&ldquo;NFLOG&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_NFLOG</p>
<p>通过nfnetlink_log记录日志.</p>
</li>
<li>
<p>&ldquo;NFQUEUE&rdquo; target Support
CONFIG_NETFILTER_XT_TARGET_NFQUEUE</p>
<p>用于替代老旧的 QUEUE target. 因为NFQUEUE能支持最多65535个队列,而QUEUE只能支持一个.</p>
</li>
<li>
<p>&ldquo;NOTRACK&rdquo; target support (DEPRECATED)
CONFIG_NETFILTER_XT_TARGET_NOTRACK</p>
<p>已被废弃,勿选.</p>
</li>
<li>
<p>&ldquo;RATEEST&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_RATEEST</p>
<p>RATEEST target 允许测量网络流的传输速率.[注: rateest match 允许根据速率进行匹配.]</p>
</li>
<li>
<p>REDIRECT target support
CONFIG_NETFILTER_XT_TARGET_REDIRECT</p>
<p><a href="http://www.linuxtopia.org/Linux_Firewall_iptables/x4508.html">REDIRECT</a>是一种特别的NAT:所有进入的连接都被映射到其入口网卡的地址,这样这些包就会&quot;流入&quot;本机而不是&quot;流过&quot;本机.这主要用于实现透明代理.</p>
</li>
<li>
<p>&ldquo;TEE&rdquo; - packet cloning to alternate destination
CONFIG_NETFILTER_XT_TARGET_TEE</p>
<p>对包进行克隆,并将克隆的副本路由到另一个临近的路由器(<a href="http://www.techopedia.com/definition/2447/next-hop">Next Hop</a>).</p>
</li>
<li>
<p>&ldquo;TPROXY&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TPROXY</p>
<p>类似于REDIRECT,但并不依赖于连接追踪和NAT,也只能用于&quot;mangle&quot;表,用于将网络流量重定向到透明代理.</p>
</li>
<li>
<p>&ldquo;TRACE&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TRACE</p>
<p>允许对包打标记,这样内核就可以记录每一个匹配到的规则.</p>
</li>
<li>
<p>&ldquo;SECMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_SECMARK</p>
<p>允许对包进行安全标记,用于安全子系统</p>
</li>
<li>
<p>&ldquo;TCPMSS&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TCPMSS</p>
<p>允许更改 TCP SYN 包的<a href="http://support.huawei.com/ecommunity/bbs/10156527.html">MSS(Maximum Segment Size)</a>值,通常=MTU-40.</p>
</li>
<li>
<p>&ldquo;TCPOPTSTRIP&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP</p>
<p>允许从TCP包头中剥离所有<a href="http://wenku.baidu.com/view/5c288b51ad02de80d4d84066">TCP选项</a>.</p>
</li>
<li>
<p>&ldquo;addrtype&rdquo; address type match support
CONFIG_NETFILTER_XT_MATCH_ADDRTYPE</p>
<p>根据地址类型进行匹配: UNICAST, LOCAL, BROADCAST, &hellip;</p>
</li>
<li>
<p>&ldquo;bpf&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_BPF</p>
<p><a href="http://blog.csdn.net/dog250/article/details/9103817">BPF(BSD Packet Filter)</a>是一个强大的包匹配模块,用于匹配那些让过滤器返回非零值的包.</p>
</li>
<li>
<p>&ldquo;cluster&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CLUSTER</p>
<p>这个模块可以用于创建网络服务器/防火墙集群,而无需借助价格昂贵的负载均衡设备.通常,在包必须被本节点处理的条件下,这个match返回&quot;true&rdquo;.这样,所有节点都可以看到所有的包,但只有匹配的节点才需要进行处理,这样就将负载进行了分摊.而分摊算法是基于对源地址的哈希值.</p>
</li>
<li>
<p>&ldquo;comment&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_COMMENT</p>
<p>这是一个&quot;伪match&rdquo;,目的是允许你在iptables规则集中加入注释</p>
</li>
<li>
<p>&ldquo;connbytes&rdquo; per-connection counter match support
CONFIG_NETFILTER_XT_MATCH_CONNBYTES</p>
<p>允许针对单个连接内部每个方向(进/出)匹配已经传送的字节数/包数</p>
</li>
<li>
<p>&ldquo;connlabel&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CONNLABEL</p>
<p>允许向连接分配用户自定义的标签名.内核仅存储bit值,而名称和bit之间的对应关系由用户空间处理.与&quot;connmark&quot;的不同之处在于:可以同时为一个连接分配32个标志位(flag bit).</p>
</li>
<li>
<p>&ldquo;connlimit&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CONNLIMIT</p>
<p>允许根据每一个客户端IP地址(或每一段客户端IP地址段)持有的并发连接数进行匹配.</p>
</li>
<li>
<p>&ldquo;connmark&rdquo; connection mark match support
CONFIG_NETFILTER_XT_MATCH_CONNMARK</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_CONNMARK</p>
</li>
<li>
<p>&ldquo;conntrack&rdquo; connection tracking match support
CONFIG_NETFILTER_XT_MATCH_CONNTRACK</p>
<p>通用连接跟踪匹配,是&quot;state&quot;的超集,它允许额外的链接跟踪信息,在需要设置一些复杂的规则(比如网关)时很有用</p>
</li>
<li>
<p>&ldquo;cpu&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CPU</p>
<p>根据处理包所使用的CPU是哪个进行匹配</p>
</li>
<li>
<p>&ldquo;dccp&rdquo; protocol match support
CONFIG_NETFILTER_XT_MATCH_DCCP</p>
<p><a href="http://baike.baidu.com/view/1619398.htm">DCCP</a>是打算取代UDP的新传输协议,它在UDP的基础上增加了流控和拥塞控制机制,面向实时业务</p>
</li>
<li>
<p>&ldquo;devgroup&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_DEVGROUP</p>
<p>允许根据网卡所属的&quot;设备组&quot;进行匹配</p>
</li>
<li>
<p>&ldquo;dscp&rdquo; and &ldquo;tos&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_DSCP</p>
<p>dscp match 允许根据IPv4/IPv6包头的<a href="http://baike.baidu.com/view/98757.htm">DSCP</a>字段进行匹配, tos match 允许根据IPv4包头的<a href="http://baike.baidu.com/view/1047572.htm#5">TOS</a>字段进行匹配</p>
</li>
<li>
<p>&ldquo;ecn&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_ECN</p>
<p>允许根据IPv4 TCP包头的<a href="http://network.51cto.com/art/200901/107005.htm">ECN</a>字段进行匹配</p>
</li>
<li>
<p>&ldquo;esp&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_ESP</p>
<p>允许对<a href="http://zh.wikipedia.org/wiki/IPsec">IPSec</a>包的ESP头中的SPI(安全参数序列)范围进行匹配</p>
</li>
<li>
<p>&ldquo;hashlimit&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_HASHLIMIT</p>
<p>此项的目的是取代&quot;limit&rdquo;,它基于你选定的源/目的地址和/或端口动态创建&quot;limit bucket&quot;哈希表.这样你就可以迅速创建类似这样的匹配规则:(1)为给定的目的地址以每秒10k个包的速度进行匹配;(2)为给定的源地址以每秒500个包的速率进行匹配</p>
</li>
<li>
<p>&ldquo;helper&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_HELPER</p>
<p>加载特定协议的连接跟踪辅助模块,由该模块过滤所跟踪的连接类型的包,比如ip_conntrack_ftp模块</p>
</li>
<li>
<p>&ldquo;hl&rdquo; hoplimit/TTL match support
CONFIG_NETFILTER_XT_MATCH_HL</p>
<p>基于IPv6包头的hoplimit字段,或IPv4包头的time-to-live字段进行匹配</p>
</li>
<li>
<p>&ldquo;iprange&rdquo; address range match support
CONFIG_NETFILTER_XT_MATCH_IPRANGE</p>
<p>根据IP地址范围进行匹配,而普通的iptables只能根据&quot;IP/mask&quot;的方式进行匹配.</p>
</li>
<li>
<p>&ldquo;ipvs&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_IPVS</p>
<p>允许根据包的<a href="http://baike.baidu.com/view/2428775.htm#1">IPVS</a>属性进行匹配</p>
</li>
<li>
<p>&ldquo;length&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_LENGTH</p>
<p>允许对包的长度进行匹配</p>
</li>
<li>
<p>&ldquo;limit&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_LIMIT</p>
<p>允许根据包的进出速率进行规则匹配,常和&quot;LOG target&quot;配合使用以抵抗某些Dos攻击</p>
</li>
<li>
<p>&ldquo;mac&rdquo; address match support
CONFIG_NETFILTER_XT_MATCH_MAC</p>
<p>允许根据以太网的MAC地址进行匹配</p>
</li>
<li>
<p>&ldquo;mark&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_MARK</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MARK</p>
</li>
<li>
<p>&ldquo;multiport&rdquo; Multiple port match support
CONFIG_NETFILTER_XT_MATCH_MULTIPORT</p>
<p>允许对TCP或UDP包同时匹配多个不连续的端口(通常情况下只能匹配单个端口或端口范围)</p>
</li>
<li>
<p>&ldquo;nfacct&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_NFACCT</p>
<p>允许通过nfnetlink_acct使用扩展记账</p>
</li>
<li>
<p>&ldquo;osf&rdquo; Passive OS fingerprint match
CONFIG_NETFILTER_XT_MATCH_OSF</p>
<p>开启<a href="http://en.wikipedia.org/wiki/TCP/IP_stack_fingerprinting">Passive OS Fingerprinting</a>模块,以允许通过进入的TCP SYN包被动匹配远程操作系统.规则和加载程序可以从这里获取:http://www.ioremap.net/projects/osf</p>
</li>
<li>
<p>&ldquo;owner&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_OWNER</p>
<p>基于创建套接字的本地进程身份(user/group)进行匹配,还可以用于检查一个套接字是否确实存在</p>
</li>
<li>
<p>IPsec &ldquo;policy&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_POLICY</p>
<p>基于IPsec policy进行匹配</p>
</li>
<li>
<p>&ldquo;physdev&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_PHYSDEV</p>
<p>允许对进入或离开所经过的物理网口进行匹配</p>
</li>
<li>
<p>&ldquo;pkttype&rdquo; packet type match support
CONFIG_NETFILTER_XT_MATCH_PKTTYPE</p>
<p>允许对封包目的地址类别(广播/组播/直播)进行匹配</p>
</li>
<li>
<p>&ldquo;quota&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_QUOTA</p>
<p>允许对总字节数的限额值进行匹配</p>
</li>
<li>
<p>&ldquo;rateest&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_RATEEST</p>
<p>根据 RATEEST target 评估的速率值进行匹配</p>
</li>
<li>
<p>&ldquo;realm&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_REALM</p>
<p>允许根据iptables中的路由子系统中的realm值进行匹配.它与tc中的CONFIG_NET_CLS_ROUTE4非常类似.</p>
</li>
<li>
<p>&ldquo;recent&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_RECENT</p>
<p><a href="http://snowman.net/projects/ipt_recent/">recent match</a> 用于创建一个或多个最近使用过的地址列表,然后又可以根据这些列表再进行匹配.</p>
</li>
<li>
<p>&ldquo;sctp&rdquo; protocol match support
CONFIG_NETFILTER_XT_MATCH_SCTP</p>
<p>支持根据<a href="http://www.ibm.com/developerworks/cn/linux/l-sctp/">流控制传输协议(SCTP)</a>源/目的端口和&quot;chunk type&quot;进行匹配.</p>
</li>
<li>
<p>&ldquo;socket&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_SOCKET</p>
<p>can be used to match packets for which a TCP or UDP socket lookup finds a valid socket. It can be used in combination with the MARK target and policy routing to implement full featured non-locally bound sockets.</p>
</li>
<li>
<p>&ldquo;state&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_STATE</p>
<p>这是对包进行分类的有力工具,它允许利用连接跟踪信息对连接中处于特定状态的包进行匹配</p>
</li>
<li>
<p>&ldquo;statistic&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_STATISTIC</p>
<p>允许根据一个给定的百分率对包进行周期性的或随机性的匹配</p>
</li>
<li>
<p>&ldquo;string&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_STRING</p>
<p>允许根据包所承载的数据中包含的特定字符串进行匹配</p>
</li>
<li>
<p>&ldquo;tcpmss&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_TCPMSS</p>
<p>允许根据TCP SYN包头中的MSS(最大分段长度)选项的值进行匹配</p>
</li>
<li>
<p>&ldquo;time&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_TIME</p>
<p>根据包的到达时刻(外面进入的包)或者离开时刻(本地生成的包)进行匹配</p>
</li>
<li>
<p>&ldquo;u32&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_U32</p>
<p>&ldquo;u32&quot;允许从包中提取拥有特定mask的最多4字节数据,将此数据移动(shift)特定的位数,然后测试其结果是否位于特定的集合范围内.更多细节可以直接参考内核源码(net/netfilter/xt_u32.c)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP set support
CONFIG_IP_SET</p>
<ul>
<li>为内核添加IP集(IP set)支持,然后就可以使用CONFIG_NETFILTER_XT_SET功能.此特性必须配合用户态工具<a href="http://ipset.netfilter.org/">ipset</a>一起使用.</li>
<li>
<ul>
<li>
<p>Maximum number of IP sets
CONFIG_IP_SET_MAX</p>
<p>默认的最大&quot;set&quot;数,取值范围是[2,65534].此值也可以由ip_set模块的max_sets参数设置.</p>
</li>
<li>
<p>bitmap:ip set support
CONFIG_IP_SET_BITMAP_IP</p>
<p>&ldquo;bitmap:ip&quot;集合类型.根据IP地址范围设定集合.</p>
</li>
<li>
<p>bitmap:ip,mac set support
CONFIG_IP_SET_BITMAP_IPMAC</p>
<p>&ldquo;bitmap:ip,mac&quot;集合类型.根据IP/MAC地址对范围设定集合.</p>
</li>
<li>
<p>bitmap:port set support
CONFIG_IP_SET_BITMAP_PORT</p>
<p>&ldquo;bitmap:port&quot;集合类型.根据端口范围设定集合.</p>
</li>
<li>
<p>hash:ip set support
CONFIG_IP_SET_HASH_IP</p>
<p>&ldquo;hash:ip&quot;集合类型.为多个离散的IP地址设定集合.</p>
</li>
<li>
<p>hash:ip,port set support
CONFIG_IP_SET_HASH_IPPORT</p>
<p>&ldquo;hash:ip,port&quot;集合类型.为多个离散的IP/MAC地址对设定集合.</p>
</li>
<li>
<p>hash:ip,port,ip
CONFIG_IP_SET_HASH_IPPORTIP</p>
<p>&ldquo;hash:ip,port,ip&quot;集合类型.为多个离散的IP/端口/IP三元组设定集合.</p>
</li>
<li>
<p>hash:ip,port,net set support
CONFIG_IP_SET_HASH_IPPORTNET</p>
<p>&ldquo;hash:ip,port,net&quot;集合类型.为多个离散的IP/端口/网段三元组设定集合.</p>
</li>
<li>
<p>hash:net set support
CONFIG_IP_SET_HASH_NET</p>
<p>&ldquo;hash:net&quot;集合类型.为多个离散的网段设定集合</p>
</li>
<li>
<p>hash:net,port set support
CONFIG_IP_SET_HASH_NETPORT</p>
<p>&ldquo;hash:net,port&quot;集合类型.为多个离散的网段/端口对设定集合</p>
</li>
<li>
<p>hash:net,iface set support
CONFIG_IP_SET_HASH_NETIFACE</p>
<p>&ldquo;hash:net,iface&quot;集合类型.为多个离散的网段/网卡接口对设定集合</p>
</li>
<li>
<p>list:set set support
CONFIG_IP_SET_LIST_SET</p>
<p>&ldquo;list:set&quot;集合类型.将多个集合组成一个更大的集合</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP virtual server support
CONFIG_IP_VS</p>
<ul>
<li><a href="http://www.baike.com/wiki/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">IPVS</a>(<a href="http://www.linuxvirtualserver.org/software/ipvs.html">IP Virtual Server</a>)支持.IPVS可以帮助<a href="http://www.linuxvirtualserver.org/zh/lvs1.html">LVS</a>基于多个后端真实服务器创建一个高性能的虚拟服务器.可以使用三种具体的方法实现:NAT,隧道,直接路由(使用较广).</li>
<li>
<ul>
<li>
<p>IPv6 support for IPVS
CONFIG_IP_VS_IPV6</p>
<p>为IPVS添加IPv6支持</p>
</li>
<li>
<p>IP virtual server debugging
CONFIG_IP_VS_DEBUG</p>
<p>为IPVS添加调试支持</p>
</li>
<li>
<p>IPVS connection table size (the Nth power of 2)
CONFIG_IP_VS_TAB_BITS</p>
<p>设置IPVS连接哈希表的大小(2CONFIG_IP_VS_TAB_BITS),取值范围是[8,20],默认值12的意思是哈希表的大小是212=4096项.IPVS连接哈希表使用链表来处理哈希碰撞.使用大的哈希表能够显著减少碰撞几率,特别是哈希表中有成千上万连接的时候.比较恰当的值差不多等于每秒的新建连接数乘以每个连接的平均持续秒数.太小的值会造成太多碰撞,从而导致性能大幅下降;太大的值又会造成占用太多不必要的内存(每个表项8字节+每个连接128字节).该值也可以通过ip_vs模块的conn_tab_bits参数进行设置.</p>
</li>
<li>
<p>TCP load balancing support
CONFIG_IP_VS_PROTO_TCP</p>
<p>TCP传输协议负载均衡支持</p>
</li>
<li>
<p>UDP load balancing support
CONFIG_IP_VS_PROTO_UDP</p>
<p>UDP传输协议负载均衡支持</p>
</li>
<li>
<p>ESP load balancing support
CONFIG_IP_VS_PROTO_ESP</p>
<p>IPSec ESP(Encapsulation Security Payload)传输协议负载均衡支持</p>
</li>
<li>
<p>AH load balancing support
CONFIG_IP_VS_PROTO_AH</p>
<p>IPSec AH(Authentication Header)传输协议负载均衡支持.</p>
</li>
<li>
<p>SCTP load balancing support
CONFIG_IP_VS_PROTO_SCTP</p>
<p>SCTP传输协议负载均衡支持</p>
</li>
<li>
<p>round-robin scheduling
CONFIG_IP_VS_RR</p>
<p>循环分散算法:最简单的调度算法,将连接简单的循环分散到后端服务器上</p>
</li>
<li>
<p>weighted round-robin scheduling
CONFIG_IP_VS_WRR</p>
<p>基于权重的循环分散算法:在循环分散的基础上,权重较高的后端服务器接纳较多的连接</p>
</li>
<li>
<p>least-connection scheduling
CONFIG_IP_VS_LC</p>
<p>最少连接算法:将连接优先分配到活动连接最少的后端服务器</p>
</li>
<li>
<p>weighted least-connection scheduling
CONFIG_IP_VS_WLC</p>
<p>基于权重的最少连接算法:结合考虑活动连接数与服务器权重</p>
</li>
<li>
<p>locality-based least-connection scheduling
CONFIG_IP_VS_LBLC</p>
<p>基于目的IP的最少连接算法(常用于缓存集群):优先根据目的IP地址将连接分配到特定的后端,仅在这些后端过载时(活动连接数大于其权重)才分散到其他后端.</p>
</li>
<li>
<p>locality-based least-connection with replication scheduling
CONFIG_IP_VS_LBLCR</p>
<p>与LBLC类似,不同之处在于:前端负载均衡器会像NAT一样同时记住客户端IP与后端的对应关系,并在新的连接到来的时候,复用这个对应关系.</p>
</li>
<li>
<p>destination hashing scheduling
CONFIG_IP_VS_DH</p>
<p>目标地址哈希表算法:简单的根据静态设定的目标IP地址哈希表将连接分发到后端</p>
</li>
<li>
<p>source hashing scheduling
CONFIG_IP_VS_SH</p>
<p>源地址哈希表算法:简单的根据静态设定的源IP地址哈希表将连接分发到后端</p>
</li>
<li>
<p>shortest expected delay scheduling
CONFIG_IP_VS_SED</p>
<p>最小期望延迟算法:将连接分配到根据期望延迟公式((Ci+1)/Ui)算得的延迟最小的后端.&ldquo;i&quot;是后端服务器编号,&ldquo;Ci&quot;是该服务器当前的连接数,&ldquo;Ui&quot;是该服务器的权重.</p>
</li>
<li>
<p>never queue scheduling
CONFIG_IP_VS_NQ</p>
<p>无排队算法:这是一个两阶段算法,如果有空闲服务器,就直接分发到空闲服务器(而不是等待速度最快的服务器),如果没有空闲服务器,就分发到期望延迟最小的服务器(SED算法).</p>
</li>
<li>
<p>IPVS source hashing table size (the Nth power of 2)
CONFIG_IP_VS_SH_TAB_BITS</p>
<p>将源IP地址映射到后端服务器所使用的哈希表的大小(2CONFIG_IP_VS_SH_TAB_BITS),取值范围是[4,20],默认值8的意思是哈希表的大小是28=256项.理想的大小应该是所有后端的权重乘以后端总数?</p>
</li>
<li>
<p>FTP protocol helper
CONFIG_IP_VS_FTP</p>
<p>FTP协议连接追踪帮助</p>
</li>
<li>
<p>Netfilter connection tracking
CONFIG_IP_VS_NFCT</p>
<p>Netfilter连接追踪支持</p>
</li>
<li>
<p>SIP persistence engine
CONFIG_IP_VS_PE_SIP</p>
<p>基于SIP Call-ID提供持久连接支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP: Netfilter Configuration</p>
<ul>
<li>针对IPv4的Netfilter配置</li>
<li>
<ul>
<li>
<p>IPv4 connection tracking support (required for NAT)
CONFIG_NF_CONNTRACK_IPV4</p>
<ul>
<li>IPv4链接跟踪.可用于包伪装或地址转换,也可用于增强包过滤能力</li>
<li>
<ul>
<li>
<p>proc/sysctl compatibility with old connection tracking
CONFIG_NF_CONNTRACK_PROC_COMPAT</p>
<p>用于兼容老旧的连接追踪用户态程序</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IP tables support (required for filtering/masq/NAT)
CONFIG_IP_NF_IPTABLES</p>
<ul>
<li>要用iptables就肯定要选上</li>
<li>
<ul>
<li>
<p>&ldquo;ah&rdquo; match support
CONFIG_IP_NF_MATCH_AH</p>
<p>允许对IPSec包头的AH字段进行匹配</p>
</li>
<li>
<p>&ldquo;ecn&rdquo; match support
CONFIG_IP_NF_MATCH_ECN</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MATCH_ECN</p>
</li>
<li>
<p>&ldquo;rpfilter&rdquo; reverse path filter match support
CONFIG_IP_NF_MATCH_RPFILTER</p>
<p>对进出都使用同一个网络接口的包进行匹配</p>
</li>
<li>
<p>&ldquo;ttl&rdquo; match support
CONFIG_IP_NF_MATCH_TTL</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_MATCH_HL</p>
</li>
<li>
<p>Packet filtering
CONFIG_IP_NF_FILTER</p>
<ul>
<li>定义filter表,以允许对包进行过滤</li>
<li>
<ul>
<li>
<p>REJECT target support
CONFIG_IP_NF_TARGET_REJECT</p>
<p>允许返回一个ICMP错误包而不是简单的丢弃包</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ULOG target support
CONFIG_IP_NF_TARGET_ULOG</p>
<p>反对使用该选项,因为它已经被CONFIG_NETFILTER_NETLINK_LOG代替</p>
</li>
<li>
<p>IPv4 NAT
CONFIG_NF_NAT_IPV4</p>
<ul>
<li>允许进行伪装/端口转发以及其它的NAT功能,仅在你需要使用iptables中的nat表时才需要选择</li>
<li>
<ul>
<li>
<p>MASQUERADE target support
CONFIG_IP_NF_TARGET_MASQUERADE</p>
<p>SNAT是指在数据包从网卡发送出去的时候,把数据包中的源地址部分替换为指定的IP,这样,接收方就认为数据包的来源是被替换的那个IP的主机.伪装(MASQUERADE)是一种特殊类型的SNAT:MASQUERADE是用发送数据的网卡上的IP来替换源IP,用于那些IP不固定的场合(比如拨号或者通过DHCP分配)</p>
</li>
<li>
<p>NETMAP target support
CONFIG_IP_NF_TARGET_NETMAP</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_TARGET_NETMAP.</p>
</li>
<li>
<p>REDIRECT target support
CONFIG_IP_NF_TARGET_REDIRECT</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_TARGET_REDIRECT.</p>
</li>
<li>
<p>Basic SNMP-ALG support
CONFIG_NF_NAT_SNMP_BASIC</p>
<p>为<a href="http://baike.baidu.com/view/2899.htm">SNMP</a>荷载实现ALG(Application Layer Gateway)支持(<a href="http://www.rfc-base.org/txt/rfc-2962.txt">RFC2962</a>).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Packet mangling
CONFIG_IP_NF_MANGLE</p>
<ul>
<li>在iptables中启用mangle表以便对包进行各种修改,常用于改变包的路由</li>
<li>
<ul>
<li>
<p>CLUSTERIP target support
CONFIG_IP_NF_TARGET_CLUSTERIP</p>
<p>CLUSTERIP target 允许你无需使用昂贵的负载均衡设备也能创建廉价的负载均衡集群</p>
</li>
<li>
<p>ECN target support
CONFIG_IP_NF_TARGET_ECN</p>
<p>用于mangle表,可以去除IPv4包头的<a href="http://blog.sina.com.cn/s/blog_6cf9802d0100xtwv.html">ECN(Explicit Congestion Notification)</a>位,主要用于在保持ECN功能的前提下,去除网络上的&quot;ECN黑洞&rdquo;.</p>
</li>
<li>
<p>&ldquo;TTL&rdquo; target support
CONFIG_IP_NF_TARGET_TTL</p>
<p>这只是一个兼容旧配置的选项,等价于CONFIG_NETFILTER_XT_TARGET_HL.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>raw table support (required for NOTRACK/TRACE)
CONFIG_IP_NF_RAW</p>
<p>在iptables中添加一个raw表,该表在netfilter框架中非常靠前,并在PREROUTING和OUTPUT链上有钩子,从而可以对收到的数据包在连接跟踪前进行处理</p>
</li>
<li>
<p>Security table
CONFIG_IP_NF_SECURITY</p>
<p>在iptables中添加一个security表,以支持<a href="http://baike.baidu.com/view/4420215.htm">强制访问控制(Mandatory Access Control)</a>策略</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ARP tables support
CONFIG_IP_NF_ARPTABLES</p>
<ul>
<li><a href="http://baike.baidu.com/view/3908213.htm">arptables</a>支持</li>
<li>
<ul>
<li>
<p>ARP packet filtering
CONFIG_IP_NF_ARPFILTER</p>
<p>ARP包过滤.对于进入和离开本地的ARP包定义一个filter表,在桥接的情况下还可以应用于被转发的ARP包</p>
</li>
<li>
<p>ARP payload mangling
CONFIG_IP_NF_ARP_MANGLE</p>
<p>允许对ARP包的荷载部分进行修改,比如修改源和目标物理地址</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IPv6: Netfilter Configuration</p>
<p>针对IPv6的Netfilter配置.其子项内容类似于IPv4,需要的话可以参考前面IPv4的Netfilter配置进行选择</p>
</li>
<li>
<p>DECnet: Netfilter Configuration</p>
<p>针对<a href="http://baike.baidu.com/view/1449756.htm">DECnet</a>的Netfilter配置</p>
</li>
<li>
<p>Ethernet Bridge tables (ebtables) support
CONFIG_BRIDGE_NF_EBTABLES</p>
<p>针对以太网桥的<a href="http://www.oschina.net/p/ebtables">ebtables</a> Netfilter配置</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The DCCP Protocol
CONFIG_IP_DCCP</p>
<p>数据报拥塞控制协议(<a href="http://zh.wikipedia.org/wiki/DCCP">Datagram Congestion Control Protocol</a>)在UDP的基础上增加了流控和拥塞控制机制,使数据报协议能够更好地用于流媒体业务的传输</p>
</li>
<li>
<p>The SCTP Protocol
CONFIG_IP_SCTP</p>
<p><a href="http://zh.wikipedia.org/wiki/%E6%B5%81%E6%8E%A7%E5%88%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">流控制传输协议</a>(<a href="http://www.ibm.com/developerworks/cn/linux/l-sctp/">Stream Control Transmission Protocol</a>)是一种新兴的传输层协议.TCP协议一次只能连接一个IP地址而在<a href="http://www.cnblogs.com/qlee/archive/2011/07/13/2105717.html">SCTP</a>协议一次可以连接多个IP地址且可以自动平衡网络负载,一旦某一个IP地址失效会自动将网络负载转移到其他IP地址上</p>
</li>
<li>
<p>The RDS Protocol
CONFIG_RDS</p>
<p><a href="http://network.51cto.com/art/200711/60157.htm">可靠数据报套接字(Reliable Datagram Sockets)协议</a>支持.</p>
</li>
<li>
<p>The TIPC Protocol
CONFIG_TIPC</p>
<p>透明内部进程间通信协议(<a href="http://zh.wikipedia.org/wiki/TIPC">Transparent Inter Process Communication</a>),以共享内存为基础实现任务和资源的调度,专门用于集群内部通信</p>
</li>
<li>
<p>Asynchronous Transfer Mode (ATM)
CONFIG_ATM</p>
<p>异步传输模式(<a href="http://baike.baidu.com/view/817251.htm">ATM</a>)支持.主要用于高速LAN和WAN.目前已经日薄西山了.</p>
</li>
<li>
<p>Layer Two Tunneling Protocol (L2TP)
CONFIG_L2TP</p>
<p><a href="http://baike.baidu.com/view/32692.htm">第二层隧道协议</a>(RFC2661)支持</p>
</li>
<li>
<p>802.1d Ethernet Bridging
CONFIG_BRIDGE</p>
<p><a href="http://baike.baidu.com/view/2019315.htm">802.1d</a>以太网桥</p>
</li>
<li>
<p>802.1Q/802.1ad VLAN Support
CONFIG_VLAN_8021Q</p>
<p><a href="http://baike.baidu.com/view/116899.htm">802.1Q</a>虚拟局域网</p>
</li>
<li>
<p>DECnet Support
CONFIG_DECNET</p>
<p><a href="http://baike.baidu.com/view/1449756.htm">DECnet</a>协议</p>
</li>
<li>
<p>ANSI/IEEE 802.2 LLC type 2 Support
CONFIG_LLC2</p>
<p>PF_LLC类型套接字支持.也就是<a href="http://baike.baidu.com/view/193847.htm">IEEE 802.2 LLC 2</a></p>
</li>
<li>
<p>The IPX protocol
CONFIG_IPX</p>
<p><a href="http://baike.baidu.com/view/32700.htm">IPX协议</a>是由Novell公司提出的运行于OSI模型第三层的协议,具有可路由的特性,IPX的地址分为网络地址和主机地址,网络地址由管理员分配,主机地址为MAC地址.由于IP协议的广泛使用,IPX的应用早已日薄西山.</p>
</li>
<li>
<p>Appletalk protocol support
CONFIG_ATALK</p>
<p><a href="http://baike.baidu.com/view/25115.htm">Appletalk</a>是苹果公司创建的一组网络协议,仅用于苹果系列计算机.</p>
</li>
<li>
<p>CCITT X.25 Packet Layer
CONFIG_X25</p>
<p><a href="http://www.baike.com/wiki/x.25">CCITT X.25</a>协议集支持.</p>
</li>
<li>
<p>LAPB Data Link Driver
CONFIG_LAPB</p>
<p><a href="http://baike.baidu.com/view/1147867.htm">LAPB</a>协议支持.</p>
</li>
<li>
<p>Phonet protocols family
CONFIG_PHONET</p>
<p>PhoNet是Nokia开发的面相数据包的通信协议,仅用于Nokia maemo/meego产品.</p>
</li>
<li>
<p>IEEE Std 802.15.4 Low-Rate Wireless Personal Area Networks support
CONFIG_IEEE802154</p>
<ul>
<li><a href="http://blog.csdn.net/zwlforever/article/details/6340366">IEEE Std 802.15.4</a> 定义了一个低速率/低功耗/低复杂度的短距离个人无线网络规范.主要用于物联网中的传感器/交换器之类设备之间的互联.</li>
<li>
<ul>
<li>
<p>6lowpan support over IEEE 802.15.4
CONFIG_IEEE802154_6LOWPAN</p>
<p>在IEEE 802.15.4上支持IPv6压缩.</p>
</li>
<li>
<p>Generic IEEE 802.15.4 Soft Networking Stack (mac802154)
CONFIG_MAC802154</p>
<p>为SoftMAC设备(仅实现了PHY层)实现硬件独立的<a href="http://blog.csdn.net/zwlforever/article/details/6340366">IEEE Std 802.15.4</a>协议栈.使用HardMAC设备的用户应该选&quot;N&rdquo;.[注意]这里的实现既未经过认证,也未进行充分的兼容性测试.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>QoS and/or fair queueing
CONFIG_NET_SCHED</p>
<p><a href="http://zh.wikipedia.org/zh-cn/QoS">QoS</a>(<a href="http://baike.baidu.com/view/20897.htm">Quality of Service</a>)支持.当内核有多个包需要通过网络发送的时候,它需要决定哪个包先发,那个包后发,哪个包丢弃.这就是包调度算法.关闭此项表示内核使用最简单的FIFO算法,开启此项后就可以使用多种不同的调度算法(需要配合用户层工具<a href="">iproute2+tc</a>).QoS还用于支持<a href="http://diffserv.sourceforge.net/">diffserv</a>(Differentiated Services)和<a href="http://baike.baidu.com/view/876124.htm">RSVP</a>(Resource Reservation Protocol)功能.包调度的状态信息可以从&rdquo;/proc/net/psched&quot;文件中获取.仅在你确实需要的时候选&quot;Y&rdquo;.</p>
</li>
<li>
<p>Data Center Bridging support
CONFIG_DCB</p>
<p><a href="http://zh.community.dell.com/techcenter/b/weblog/archive/2011/08/30/ready-for-the-dcb-coming.aspx">DCB(Data Center Bridging)</a>支持.数据中心桥接是一组可增强传统以太网功能,以管理通信的功能,尤其适用于网络通信流量和传输率都很高的环境中.光纤通道可专用于承载此类型的通信.但是,如果使用专用链路来仅提供光纤通道通信,则成本可能会很高.因此,更多情况下使用以太网光纤通道.DCB功能可满足光纤通道对遍历以太网时包丢失的敏感度要求.DCB允许对等方基于优先级区分通信.通过区分优先级,可确保在主机之间发生拥塞时,保持较高优先级通信的包完整性.使用DCB交换协议,通信主机可以交换会影响高速网络通信的配置信息.然后,对等方可对公用配置进行协商,确保通信流不中断,同时防止高优先级包出现包丢失.这些功能都需要底层的网卡支持.一般网卡都是不支持的.所以不确定的可以选&quot;N&rdquo;.</p>
</li>
<li>
<p>DNS Resolver support
CONFIG_DNS_RESOLVER</p>
<p>内核DNS解析支持.用于支持CONFIG_AFS_FS/CONFIG_CIFS/CONFIG_CIFS_SMB2模块.此功能需要用户态程序&rdquo;/sbin/dns.resolve&quot;和配置文件&rdquo;/etc/request-key.conf&quot;的支持.更多信息参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/networking/dns_resolver.txt">Documentation/networking/dns_resolver.txt</a>&ldquo;文档,不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>B.A.T.M.A.N. Advanced Meshing Protocol
CONFIG_BATMAN_ADV</p>
<p>B.A.T.M.A.N.(更好的移动无线网络方案)是一种用于 multi-hop ad-hoc <a href="http://baike.baidu.com/view/1215700.htm">mesh</a> 网络的路由协议.它是一种去中心化分布式无线Adhoc模式,特别适用于自然灾害等紧急情况下,创建临时的无线网络.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Open vSwitch
CONFIG_OPENVSWITCH</p>
<p><a href="http://bengo.blog.51cto.com/4504843/791213/">Open vSwitch</a> 是一个多层虚拟交换标准.此选项提供了内核级的高速转发功能(需要配合用户态守护进程ovs-vswitchd来实现).</p>
</li>
<li>
<p>Virtual Socket protocol
CONFIG_VSOCKETS</p>
<ul>
<li>这是一个类似于TCP/IP的协议,用于虚拟机之间以及虚拟机与宿主之间的通信.开启此项后,还需要从子项中选择适用于特定虚拟化技术的传输协议.</li>
<li>
<ul>
<li>
<p>VMware VMCI transport for Virtual Sockets
CONFIG_VMWARE_VMCI_VSOCKETS</p>
<p>适用于VMware虚拟化技术的VMCI传输协议支持.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NETLINK: mmaped IO
CONFIG_NETLINK_MMAP</p>
<p>基于内存映射机制的 <a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a> IO 支持.这样可以避免在用户空间与内存空间之间复制数据,从而提升操作速度.建议开启.</p>
</li>
<li>
<p>NETLINK: socket monitoring interface
CONFIG_NETLINK_DIAG</p>
<p>NETLINK socket 监视接口.<a href="http://xikder.blog.51cto.com/1423200/869467">ss</a>这样的诊断工具需要它.</p>
</li>
<li>
<p>Network priority cgroup
CONFIG_NETPRIO_CGROUP</p>
<p>Cgroup子系统支持:基于每个网络接口为每个进程分配网络使用优先级.</p>
</li>
<li>
<p>Network testing</p>
<p>网络测试,仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Amateur Radio support
CONFIG_HAMRADIO</p>
<p>业余无线电支持.供无线电爱好者进行自我训练/相互通讯/技术研究</p>
</li>
<li>
<p>CAN bus subsystem support
CONFIG_CAN</p>
<p><a href="http://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8D%80%E5%9F%9F%E7%B6%B2%E8%B7%AF">CAN(Controller Area Network)</a>是一个低速串行通信协议.被广泛地应用于工业自动化/船舶/医疗设备/工业设备等嵌入式领域.更多信息参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/networking/can.txt">Documentation/networking/can.txt</a>&ldquo;文件.</p>
</li>
<li>
<p>IrDA (infrared) subsystem support
CONFIG_IRDA</p>
<p><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E5%A4%96%E9%80%9A%E8%AE%AF%E6%8A%80%E6%9C%AF">红外线通讯技术</a>支持,主要用于嵌入式环境,某些老旧的笔记本上也可能会有红外接口.</p>
</li>
<li>
<p>Bluetooth subsystem support
CONFIG_BT</p>
<ul>
<li><a href="http://www.cppblog.com/iuranus/archive/2008/12/14/69391.html">蓝牙</a>支持.蓝牙目前已经基本取代红外线,成为嵌入式设备/智能设备/笔记本的标配近距离(小于10米)通信设备.在Linux上通常使用来自<a href="http://www.bluez.org/">BlueZ</a>的hciconfig和bluetoothd工具操作蓝牙通信.</li>
<li>
<ul>
<li>
<p>RFCOMM protocol support
CONFIG_BT_RFCOMM</p>
<ul>
<li>虚拟串口协议(<a href="http://baike.baidu.com/view/493704.htm">RFCOMM</a>)是一个面向连接的流传输协议,提供<a href="http://baike.baidu.com/view/112004.htm">RS232</a>控制和状态信号,从而模拟串口的功能.它被用于支持拨号网络,<a href="http://blog.csdn.net/yangwenchao1983/article/details/4583140">OBEX(Object Exchange)</a>,以及某些蓝牙程序(例如文件传输).</li>
<li>
<ul>
<li>
<p>RFCOMM TTY support
CONFIG_BT_RFCOMM_TTY</p>
<p>允许在RFCOMM通道上模拟<a href="http://baike.baidu.com/view/749979.htm">TTY</a>终端</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>BNEP protocol support
CONFIG_BT_BNEP</p>
<ul>
<li>蓝牙网络封装协议(Bluetooth Network Encapsulation Protocol)可以在蓝牙上运行其他网络协议(TCP/IP). <a href="http://windows.microsoft.com/zh-cn/windows7/what-is-a-bluetooth-personal-area-network-pan">Bluetooth PAN</a>(Personal Area Network)需要它的支持.</li>
<li>
<ul>
<li>
<p>Multicast filter support
CONFIG_BT_BNEP_MC_FILTER</p>
<p>组播支持</p>
</li>
<li>
<p>Protocol filter support
CONFIG_BT_BNEP_PROTO_FILTER</p>
<p>协议过滤器支持</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CMTP protocol support
CONFIG_BT_CMTP</p>
<p>CMTP(CAPI消息传输协议)用于支持已在上世纪被淘汰的ISDN设备.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>HIDP protocol support
CONFIG_BT_HIDP</p>
<p>人机接口设备协议(Human Interface Device Protocol)用于支持各种人机接口设备(比如鼠标/键盘/耳机等).</p>
</li>
<li>
<p>Bluetooth device drivers</p>
<ul>
<li>各种蓝牙设备驱动</li>
<li>
<ul>
<li>
<p>HCI USB driver
CONFIG_BT_HCIBTUSB</p>
<p>使用USB接口的蓝牙设备支持</p>
</li>
<li>
<p>HCI SDIO driver
CONFIG_BT_HCIBTSDIO</p>
<p>使用<a href="http://zh.wikipedia.org/wiki/Secure_Digital#SDIO_.E4.BB.8B.E7.BB.8D">SDIO</a>接口的蓝牙设备支持</p>
</li>
<li>
<p>HCI UART driver
CONFIG_BT_HCIUART</p>
<ul>
<li>使用串口的蓝牙设备支持.此外,基于<a href="http://baike.baidu.com/view/245027.htm">UART</a>的蓝牙<a href="http://baike.baidu.com/view/591980.htm">PCMCIA</a>和<a href="http://baike.baidu.com/view/3832.htm">CF</a>设备也需要此模块的支持.</li>
<li>
<ul>
<li>
<p>UART (H4) protocol support
CONFIG_BT_HCIUART_H4</p>
<p>大多数使用UART接口的蓝牙设备(包括PCMCIA和CF卡)都使用这个协议.</p>
</li>
<li>
<p>BCSP protocol support
CONFIG_BT_HCIUART_BCSP</p>
<p>基于CSR(Cambridge Silicon Radio)公司的BlueCore系列芯片的蓝牙设备(包括PCMCIA和CF卡)支持</p>
</li>
<li>
<p>Atheros AR300x serial support
CONFIG_BT_HCIUART_ATH3K</p>
<p>基于Atheros AR300x系列芯片的蓝牙设备支持</p>
</li>
<li>
<p>HCILL protocol support
CONFIG_BT_HCIUART_LL</p>
<p>基于Texas Instruments公司的BRF芯片的蓝牙设备支持</p>
</li>
<li>
<p>Three-wire UART (H5) protocol support
CONFIG_BT_HCIUART_3WIRE</p>
<p>Three-wire UART (H5) 协议假定UART通信可能存在各种错误,从而使得CTS/RTS引脚线变得可有可无.看不懂就可以不选.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HCI VHCI (Virtual HCI device) driver
CONFIG_BT_HCIVHCI</p>
<p>模拟蓝牙设备支持.主要用于开发</p>
</li>
<li>
<p>{大多数蓝牙设备并不需要特定的独立驱动,此处省略的独立驱动仅是为了驱动那些不严格遵守蓝牙规范的芯片}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>RxRPC session sockets
CONFIG_AF_RXRPC</p>
<p>RxRPC会话套接字支持(仅包括传输部分,不含表示部分).CONFIG_AFS_FS依赖于它.不确定的选&quot;N&rdquo;.详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/networking/rxrpc.txt">Documentation/networking/rxrpc.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Wireless
CONFIG_WIRELESS</p>
<ul>
<li>无线网络支持.</li>
<li>
<ul>
<li>
<p>cfg80211 - wireless configuration API
CONFIG_CFG80211</p>
<ul>
<li><a href="http://wireless.kernel.org/en/developers/Documentation/cfg80211">cfg80211</a>是<a href="http://www.crifan.com/files/doc/docbook/linux_wireless/release/htmls/ch05_linux_wireless_lan_80211.html">Linux无线局域网</a>(<a href="http://zh.wikipedia.org/zh/IEEE_802.11">802.11</a>)配置接口,是使用WiFi的前提.注意:&quot;<a href="http://baike.baidu.com/view/3941.htm">WiFi</a>&ldquo;是一个无线网路通信技术的品牌,由WiFi联盟所持有.目的是改善基于IEEE 802.11标准的无线网路产品之间的互通性.现时一般人会把WiFi及IEEE 802.11混为一谈,甚至把WiFi等同于无线网路(WiFi只是无线网络的一种).</li>
<li>
<ul>
<li>
<p>nl80211 testmode command
CONFIG_NL80211_TESTMODE</p>
<p>仅供调试和特殊目的使用.</p>
</li>
<li>
<p>enable developer warnings
CONFIG_CFG80211_DEVELOPER_WARNINGS</p>
<p>仅供调试开发使用</p>
</li>
<li>
<p>cfg80211 regulatory debugging
CONFIG_CFG80211_REG_DEBUG</p>
<p>仅供调试开发使用</p>
</li>
<li>
<p>cfg80211 certification onus
CONFIG_CFG80211_CERTIFICATION_ONUS</p>
<p>仅在你确实明白此项含义的情况下,才考虑选&quot;Y&rdquo;,否则请选&quot;N&rdquo;.</p>
</li>
<li>
<p>enable powersave by default
CONFIG_CFG80211_DEFAULT_PS</p>
<p>默认开启省电模式.可能会导致某些设计拙劣的网络程序掉线.建议开启.详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/power/pm_qos_interface.txt">Documentation/power/pm_qos_interface.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>cfg80211 DebugFS entries
CONFIG_CFG80211_DEBUGFS</p>
<p>仅供调试</p>
</li>
<li>
<p>use statically compiled regulatory rules database
CONFIG_CFG80211_INTERNAL_REGDB</p>
<p>由于绝大多数发行版都含有<a href="http://wireless.kernel.org/en/developers/Regulatory/CRDA">CRDA</a>软件包,所以绝大多数人应该选&quot;N&rdquo;.如果你确实需要选&quot;Y&rdquo;,那么请认真阅读&quot;net/wireless/db.txt&quot;文件.</p>
</li>
<li>
<p>cfg80211 wireless extensions compatibility
CONFIG_CFG80211_WEXT</p>
<p>为那些老旧的用户空间程序提供兼容性,建议关闭.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>lib80211 debugging messages
CONFIG_LIB80211_DEBUG</p>
<p>仅供调试</p>
</li>
<li>
<p>Generic IEEE 802.11 Networking Stack (mac80211)
CONFIG_MAC80211</p>
<p>独立于硬件的通用<a href="http://wenku.baidu.com/view/7df7eb7f27284b73f24250e5.html">IEEE 802.11</a>协议栈模块(mac80211).它是驱动开发者用来编写softMAC无线设备驱动的框架,softMAC设备允许用软件实现帧的管理(包括解析和产生80211无线帧),从而让系统能更好的控制硬件,现在大多数的无线网卡都是softMAC设备.不确定的选&quot;Y&rdquo;.</p>
</li>
<li>
<p>PID controller based rate control algorithm
CONFIG_MAC80211_RC_PID</p>
<p>基于<a href="http://baike.baidu.com/view/104644.htm">比例-积分-微分控制器</a>(<a href="http://wireless.kernel.org/en/developers/Documentation/mac80211/RateControl/PID">PID controller</a>)的发送速率(TX rate)控制算法.用于CONFIG_MAC80211模块.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Minstrel
CONFIG_MAC80211_RC_MINSTREL</p>
<ul>
<li><a href="http://wireless.kernel.org/en/developers/Documentation/mac80211/RateControl/minstrel">minstrel</a>发送速率(TX rate)控制算法.用于CONFIG_MAC80211模块.这是首选的算法,不确定的选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Minstrel 802.11n support
CONFIG_MAC80211_RC_MINSTREL_HT</p>
<p><a href="http://lwn.net/Articles/376765/">minstrel_ht</a>发送速率(TX rate)控制算法.适用于<a href="http://baike.baidu.com/view/32843.htm">802.11n</a>规范.不确定的选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Default rate control algorithm</p>
<p>默认发送速率(TX rate)控制算法.相当于mac80211模块&quot;ieee80211_default_rc_algo&quot;参数的值.建议选择&quot;Minstrel&quot;算法.</p>
</li>
<li>
<p>Enable mac80211 mesh networking (pre-802.11s) support
CONFIG_MAC80211_MESH</p>
<p><a href="http://baike.baidu.com/view/1720501.htm">802.11s</a>草案是无线网状网络(Mesh Networking)的延伸与增补标准(amendment).它扩展了IEEE 802.11 MAC(介质访问控制)标准,定义了利用自我组态的多点跳跃拓朴(multi-hop topologies),进行无线感知(radio-aware metrics),以支援广播/组播/单播传送网络封包的架构与协定.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable LED triggers
CONFIG_MAC80211_LEDS</p>
<p>允许在接受/发送数据时触发无线网卡的LED灯闪烁.</p>
</li>
<li>
<p>Export mac80211 internals in DebugFS
CONFIG_MAC80211_DEBUGFS</p>
<p>在DebugFS中显示mac80211模块内部状态的扩展信息,仅用于调试目的.</p>
</li>
<li>
<p>Trace all mac80211 debug messages
CONFIG_MAC80211_MESSAGE_TRACING</p>
<p>跟踪所有mac80211模块的调试信息,仅用于调试目的.</p>
</li>
<li>
<p>Select mac80211 debugging features
CONFIG_MAC80211_DEBUG_MENU</p>
<p>仅供调试</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>WiMAX Wireless Broadband support
CONFIG_WIMAX</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E4%BA%92%E9%80%9A%E5%BE%AE%E6%B3%A2%E5%AD%98%E5%8F%96">WiMAX</a>(IEEE 802.16)协议支持.随着2010年英特尔放弃WiMAX以及LTE在4G市场成了唯一的主流标准,WiMAX的电信运营商也逐渐向LTE转移,WiMAX论坛也于2012年将TD-LTE纳入WiMAX2.1规范,一些WiMAX运营商也开始将设备升级为TD-LTE.</li>
<li>
<ul>
<li>
<p>WiMAX debug level
CONFIG_WIMAX_DEBUG_LEVEL</p>
<p>设置允许使用的最大调试信息详细等级,推荐使用默认值&quot;8&quot;,设为&quot;0&quot;表示允许使用所有调试信息.运行时默认禁止使用调试信息,但可通过sysfs文件系统中的debug-levels文件开启调试信息.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>RF switch subsystem support
CONFIG_RFKILL</p>
<ul>
<li>为了节约电力,很多无线网卡和蓝牙设备都有内置的射频开关(<a href="http://blog.csdn.net/angelbosj/article/details/7247651">RF switche</a>)用于开启和关闭设备(通过<a href="https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Power_Management_Guide/RFKill.html">rfkill</a>命令).建议选&quot;Y&quot;.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/rfkill.txt">Documentation/rfkill.txt</a>&ldquo;文档</li>
<li>
<ul>
<li>
<p>RF switch input support
CONFIG_RFKILL_INPUT</p>
<p>这是个反对使用的特性,一般情况下建议关闭.但是某些笔记本无线网卡的开关是由按钮控制的,在这些笔记本上建议开启.</p>
</li>
<li>
<p>Generic rfkill regulator driver
CONFIG_RFKILL_REGULATOR</p>
<p>通用射频开关驱动.这是最通用的驱动,其射频开关连接在电压调节器(voltage regulator)上.依赖于CONFIG_REGULATOR框架.</p>
</li>
<li>
<p>GPIO RFKILL driver
CONFIG_RFKILL_GPIO</p>
<p>通用GPIO射频开关驱动.仅用于嵌入式环境,其射频开关连接在<a href="http://baike.baidu.com/view/980829.htm">GPIO</a>总线上,比如NVIDIA的<a href="http://baike.baidu.com/view/1660634.htm">Tegra</a>和三星的<a href="http://baike.baidu.com/view/5821967.htm">Exynos 4</a>智能手机SoC芯片.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Plan 9 Resource Sharing Support (9P2000)
CONFIG_NET_9P</p>
<p>实验性的支持<a href="http://zh.wikipedia.org/wiki/%E8%B2%9D%E7%88%BE%E5%AF%A6%E9%A9%97%E5%AE%A4%E4%B9%9D%E8%99%9F%E8%A8%88%E7%95%AB">Plan 9</a>的<a href="http://zh.wikipedia.org/wiki/9P">9P2000</a>协议.</p>
</li>
<li>
<p>CAIF support
CONFIG_CAIF</p>
<p>除非你为Android/MeeGo系统编译内核,并且需要使用PF_CAIF类型的socket,否则请选&quot;N&rdquo;.</p>
</li>
<li>
<p>Ceph core library
CONFIG_CEPH_LIB</p>
<p>仅在你需要使用<a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/">Ceph</a>分布式文件系统,或者<a href="http://www.alidata.org/archives/1589">rados</a>块设备(rbd)时选&quot;Y&quot;.否则应选&quot;N&quot;.</p>
</li>
<li>
<p>NFC subsystem support
CONFIG_NFC</p>
<p><a href="http://zh.wikipedia.org/wiki/%E8%BF%91%E5%A0%B4%E9%80%9A%E8%A8%8A">NFC</a>(<a href="http://baike.baidu.com/view/917495.htm">近场通信</a>)子系统.这些设备主要用于智能手机之类的嵌入式领域.</p>
</li>
</ul>
<h2 id="device-drivers-设备驱动程序"><a href=""></a>Device Drivers 设备驱动程序</h2>
<ul>
<li>
<p>Generic Driver Options</p>
<ul>
<li>驱动程序通用选项</li>
<li>
<ul>
<li>
<p>path to uevent helper
CONFIG_UEVENT_HELPER_PATH</p>
<p>早年的内核(切换到基于netlink机制之前),在发生<a href="http://blog.chinaunix.net/uid-22590270-id-3304271.html">uevent</a>事件(通常是热插拔)时,需要调用用户空间程序(通常是&quot;/sbin/hotplug&quot;),以帮助完成uevent事件的处理.此选项就是用于设定这个帮助程序的路径.由于目前的发行版都已不再需要此帮助程序,所以请保持空白.</p>
</li>
<li>
<p>Maintain a devtmpfs filesystem to mount at /dev
CONFIG_DEVTMPFS</p>
<ul>
<li>devtmpfs是一种基于CONFIG_TMPFS的文件系统(与proc和sys有几分相似).在系统启动过程中,随着各个设备的初始化完成,内核将会自动在devtmpfs中创建相应的设备节点(使用默认的文件名和权限)并赋予正确的主次设备号.更进一步,在系统运行过程中,随着各种设备插入和拔除,内核也同样会自动在devtmpfs中创建和删除的相应的设备节点(使用默认的文件名和权限)并赋予正确的主次设备号.如果将devtmpfs挂载到&quot;/dev&quot;目录(通常是系统启动脚本),那么便拥有了一个全自动且全功能的&quot;/dev&quot;目录,而且用户空间程序(通常是<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-udev/">udevd</a>)还可以对其中的内容进行各种修改(增删节点,改变权限,创建符号链接).目前的发行版和各种嵌入式系统基本都依赖于此,除非你知道自己在做什么,否则请选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Automount devtmpfs at /dev, after the kernel mounted the rootfs
CONFIG_DEVTMPFS_MOUNT</p>
<p>在内核挂载根文件系统的同时,立即自动将devtmpfs挂载到&quot;/dev&quot;目录.因为此时init进程都还尚未启动,所以这就确保在进入用户空间之前,所有设备文件就都已经准备完毕.开启此选项相当于设置内核引导参数&quot;devtmpfs.mount=1&quot;,关闭此选项相当于设置内核引导参数&quot;devtmpfs.mount=0&quot;.开启此项后,你就可以放心的使用&quot;init=/bin/sh&quot;直接进入救援模式,而不必担心&quot;/dev&quot;目录空无一物.注意:此选项并不影响基于initramfs的启动,此种情况下,devtmpfs必须被手动挂载.所以,如果你的系统使用initrd或者有专门的启动脚本用于挂载&quot;/dev&quot;目录(大多数发行版都有这样的脚本),或者你看了前面的解释,还是不确定,那就选&quot;N&quot;.对于实在想要使用&quot;init=/bin/sh&quot;直接进入救援模式的人来说,还是使用&quot;init=/bin/sh devtmpfs.mount=1&quot;吧!</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Select only drivers that don&rsquo;t need compile-time external firmware
CONFIG_STANDALONE</p>
<p>只显示那些编译时不需要额外固件支持的驱动程序,除非你有某些怪异硬件,否则请选&quot;Y&quot;.</p>
</li>
<li>
<p>Prevent firmware from being built
CONFIG_PREVENT_FIRMWARE_BUILD</p>
<p>不编译固件(firmware).固件一般是随硬件的驱动程序提供的,仅在更新固件的时候才需要重新编译.建议选&quot;Y&quot;.</p>
</li>
<li>
<p>Userspace firmware loading support
CONFIG_FW_LOADER</p>
<ul>
<li>用户空间固件加载支持.如果内核自带的模块需要它,它将会被自动选中.但某些内核树之外的模块也可能需要它,这时候就需要你根据实际情况手动开启了.</li>
<li>
<ul>
<li>
<p>Include in-kernel firmware blobs in kernel binary
CONFIG_FIRMWARE_IN_KERNEL</p>
<p>内核源码树中包含了许多驱动程序需要的二进制固件(blob),推荐的方法是通过&quot;make firmware_install&quot;将&quot;firmware&quot;目录中所需的固件复制到系统的&quot;/lib/firmware/&ldquo;目录中,然后由用户空间帮助程序在需要的时候进行加载.开启此项后,将会把所需的&quot;blob&quot;直接编译进内核,这样就可以无需用户空间程序的帮助,而直接使用这些固件了(例如:当根文件系统依赖于此类固件,而你又不想使用initrd的时候).每个需要此类二进制固件的驱动程序,都会有一个&quot;Include firmware for xxx device&quot;的选项,如果此处选&quot;Y&rdquo;,那么这些选项都将被隐藏.建议选&quot;N&quot;.</p>
</li>
<li>
<p>External firmware blobs to build into the kernel binary
CONFIG_EXTRA_FIRMWARE</p>
<p>指定要额外编译进内核的二进制固件(blob).此选项的值是一个空格分隔的固件文件名字符串,这些文件必须位于CONFIG_EXTRA_FIRMWARE_DIR目录中(其默认值是内核源码树下的&quot;firmware&quot;目录).</p>
</li>
<li>
<p>Firmware blobs root directory
CONFIG_EXTRA_FIRMWARE_DIR</p>
<p>指定CONFIG_EXTRA_FIRMWARE中列出的文件位于哪个目录.默认值是当前内核源码树下的&quot;firmware&quot;目录.若有需要,你也可以修改成其他目录(例如&quot;/lib/firmware/&quot;).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Fallback user-helper invocation for firmware loading
CONFIG_FW_LOADER_USER_HELPER</p>
<p>在内核自己直接加载固件失败后,作为补救措施,调用用户空间帮助程序(通常是udev)再次尝试加载.通常这个动作是不必要的,因此应该选&quot;N&quot;.仅在某些特殊的固件位于非标准位置时,才需要选&quot;Y&quot;.</p>
</li>
<li>
<p>Driver Core verbose debug messages
CONFIG_DEBUG_DRIVER</p>
<p>让驱动程序核心在系统日志中产生冗长的调试信息,仅供调试</p>
</li>
<li>
<p>Managed device resources verbose debug messages
CONFIG_DEBUG_DEVRES</p>
<p>为内核添加一个&quot;devres.log&quot;引导参数.当被设为非零值时,将会打印出设备资源管理驱动(devres)的调试信息.仅供调试使用.</p>
</li>
<li>
<p>Contiguous Memory Allocator
CONFIG_CMA</p>
<p>在使用ARM等嵌入式Linux系统的时候,GPU,Camera,HDMI等都需要预留大量连续内存,这部分内存平时不用,但是传统的做法又必须先预留着.而通过<a href="http://blog.csdn.net/21cnbao/article/details/7309757">连续内存分配器</a>(<a href="http://lwn.net/Articles/447405/">Contiguous Memory Allocator</a>)可以做到不预留内存,仅在需要的时候才将大块的连续物理内存分配给相应的驱动程序.这个机制对于那些不支持I/O map和scatter-gather的设备很有作用.详情参见&quot;include/linux/dma-contiguous.h&quot;文件,不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Bus devices</p>
<p>总线设备.此类设备仅出现在ARM平台.</p>
</li>
<li>
<p>Connector - unified userspace &lt;-&gt; kernelspace linker
CONFIG_CONNECTOR</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-connector/index.html">统一的用户空间和内核空间连接器</a>,工作在netlink socket协议的顶层.连接器是非常便利的用户态与内核态的通信方式,内核开发者在编写内核子系统或模块时可以采用这种方式方便地进行用户态与内核态的数据交换.内核有两个连接器应用实例:一个是进程事件连接器,另一个是CIFS文件系统.另外还有一个<a href="http://hily.me/blog/2008/10/gentoo_splash/">给Gentoo装上启动画面</a>的例子.</li>
<li>
<ul>
<li>
<p>Report process events to userspace
CONFIG_PROC_EVENTS</p>
<p>提供一个向用户空间报告进程事件(fork,exec,id变化(uid,gid,suid))的连接器.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Memory Technology Device (MTD) support
CONFIG_MTD</p>
<p><a href="http://www.linux-mtd.infradead.org/faq/general.html">MTD</a>子系统是一个<a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%96%83%E8%A8%98%E6%86%B6%E9%AB%94%E8%BD%89%E6%8F%9B%E5%B1%A4">闪存转换层</a>.其主要目的是提供一个介于闪存硬件驱动程序与高级应用程序之间的抽象层,以简化闪存设备的驱动.注意:MTD常用于嵌入式系统,而我们常见的U盘/MMC卡/SD卡/CF卡等移动存储设备以及固态硬盘(SSD),虽然也叫&quot;flash&quot;,但它们并不是使用MTD技术的存储器.仅在你需要使用主设备号为31的MTD块设备(/dev/romX,/dev/rromX,/dev/flashX,/dev/rflashX),或者主设备号为90的MTD字符设备(/dev/mtdX,/dev/mtdrX)时选&quot;Y&quot;,否则选&quot;N&quot;.</p>
</li>
<li>
<p>Parallel port support
CONFIG_PARPORT</p>
<p>25针并口(<a href="http://baike.baidu.com/view/79689.htm">LPT接口</a>)支持.古董级的打印机或扫描仪可能使用这种接口.目前已被淘汰.</p>
</li>
<li>
<p>Plug and Play support
CONFIG_PNP</p>
<ul>
<li><a href="http://baike.baidu.com/view/33701.htm">即插即用</a>(PnP)支持.选&quot;Y&quot;表示让Linux为PnP设备分配中断和I/O端口(需要在BIOS中开启&quot;PnP OS&quot;),选&quot;N&quot;则表示让BIOS来分配(需要在BIOS中关闭&quot;PnP OS&quot;).建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>PNP debugging messages
CONFIG_PNP_DEBUG_MESSAGES</p>
<p>允许使用&quot;pnp.debug&quot;内核参数在系统启动过程中输出PnP设备的调试信息,建议选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Block devices
CONFIG_BLK_DEV</p>
<ul>
<li>块设备,建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Normal floppy disk support
CONFIG_BLK_DEV_FD</p>
<p>通用<a href="http://baike.baidu.com/view/9006.htm">软驱</a>支持.已被时代抛弃的设备</p>
</li>
<li>
<p>Parallel port IDE device support
CONFIG_PARIDE</p>
<p>通过并口与计算机连接的IDE设备,比如某些老旧的外接光驱或硬盘之类.此类设备早就绝种了</p>
</li>
<li>
<p>Block Device Driver for Micron PCIe SSDs
CONFIG_BLK_DEV_PCIESSD_MTIP32XX</p>
<p><a href="http://www.expreview.com/25252.html">Micron P320/P325/P420/P425 系列固态硬盘</a>支持</p>
</li>
<li>
<p>Compaq SMART2 support
CONFIG_BLK_CPQ_DA</p>
<p>基于 Compaq SMART2 控制器的磁盘阵列卡</p>
</li>
<li>
<p>Compaq Smart Array 5xxx support
CONFIG_BLK_CPQ_CISS_DA</p>
<p>基于 Compaq Smart 控制器的磁盘阵列卡</p>
</li>
<li>
<p>SCSI tape drive support for Smart Array 5xxx
CONFIG_CISS_SCSI_TAPE</p>
<p>在基于 Compaq Smart 控制器的磁盘阵列卡上使用的磁带机</p>
</li>
<li>
<p>Mylex DAC960/DAC1100 PCI RAID Controller support
CONFIG_BLK_DEV_DAC960</p>
<p>Mylex DAC960, AcceleRAID, eXtremeRAID PCI RAID 控制器.很古董的设备了.</p>
</li>
<li>
<p>Micro Memory MM5415 Battery Backed RAM support
CONFIG_BLK_DEV_UMEM</p>
<p>一种使用电池做后备电源的内存,但被用作块设备,可以像硬盘一样被分区</p>
</li>
<li>
<p>Loopback device support
CONFIG_BLK_DEV_LOOP</p>
<ul>
<li>loop是指拿文件来模拟块设备(/dev/loopX),比如可以将一个iso9660镜像文件当成文件系统来挂载.建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Number of loop devices to pre-create at init time
CONFIG_BLK_DEV_LOOP_MIN_COUNT</p>
<p>系统预先初始化的loop设备个数.此值可以通过内核引导参数&quot;loop.max_loop&quot;修改.如果你使用<a href="https://www.kernel.org/pub/linux/utils/util-linux/">util-linux</a>-2.21以上版本,建议设为&quot;0&quot;(loop设备将通过/dev/loop-control动态创建),否则保持默认值即可.</p>
</li>
<li>
<p>Cryptoloop Support
CONFIG_BLK_DEV_CRYPTOLOOP</p>
<p>使用系统提供的CryptoAPI对loop设备加密.注意:因为不能在Cryptoloop上创建日志型文件系统(CONFIG_DM_CRYPT模块可以),所以Cryptoloop已经逐渐淡出了.建议选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DRBD Distributed Replicated Block Device support
CONFIG_BLK_DEV_DRBD</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-drbd/">DRBD(Distributed Replicated Block Device)</a>是一种分布式储存系统.<a href="http://www.drbd.org/">DBRD</a>处于文件系统之下,比文件系统更加靠近操作系统内核及IO栈.DRBD类似RAID1磁盘阵列,只不过RAID1是在同一台电脑内,而DRBD是透过网络.注意:为了进行连接认证,你还需要选中CONFIG_CRYPTO_HMAC以及相应的哈希算法.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>DRBD fault injection
CONFIG_DRBD_FAULT_INJECTION</p>
<p>模拟IO错误,以用于测试DRBD的行为.主要用于调试目的</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Network block device support
CONFIG_BLK_DEV_NBD</p>
<p>让你的电脑成为网络块设备的客户端,也就是可以挂载远程服务器通过TCP/IP网络提供的块设备(/dev/ndX).提示:这与NFS或Coda没有任何关系.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/blockdev/nbd.txt">Documentation/blockdev/nbd.txt</a>&quot;.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>NVM Express block device
CONFIG_BLK_DEV_NVME</p>
<p><a href="http://news.mydrivers.com/1/187/187633.htm">NVM Express</a>是专门针对PCI-E接口高性能固态硬盘的标准规范.有了这一标准,操作系统厂商只需要编写一种驱动,就可以支持不同厂商的不同PCI-E SSD设备,以解决目前PCI-E SSD产品形态与规格五花八门,缺乏通用性和互用性的问题.</p>
</li>
<li>
<p>OSD object-as-blkdev support
CONFIG_BLK_DEV_OSD</p>
<p>允许将一个单独的 <a href="http://www.51cto.com/art/200608/30308.htm">SCSI OSD(Object-Based Storage Devices)</a> 对象当成普通的块设备来使用.举例来说,你可以在OSD设备上创建一个2G大小的对象,然后通过本模块将其模拟成一个2G大小的块设备使用.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Promise SATA SX8 support
CONFIG_BLK_DEV_SX8</p>
<p>基于Promise公司的SATA SX8控制器的RAID卡</p>
</li>
<li>
<p>RAM block device support
CONFIG_BLK_DEV_RAM</p>
<ul>
<li>内存中的虚拟磁盘,大小固定.详情参阅&quot;<a href="http://lxr.linux.no/linux/Documentation/blockdev/ramdisk.txt">Documentation/blockdev/ramdisk.txt</a>&quot;.由于其功能比CONFIG_TMPFS弱许多,使用上也不方便,所以除非你有明确的理由,否则应该选&quot;N&quot;,并转而使用CONFIG_TMPFS.</li>
<li>
<ul>
<li>
<p>Default number of RAM disks
CONFIG_BLK_DEV_RAM_COUNT</p>
<p>默认RAM disk的数量.请保持默认值,除非你知道自己在做什么.</p>
</li>
<li>
<p>Default RAM disk size (kbytes)
CONFIG_BLK_DEV_RAM_SIZE</p>
<p>默认RAM disk的大小.请保持默认值,除非你知道自己在做什么.</p>
</li>
<li>
<p>Support XIP filesystems on RAM block device
CONFIG_BLK_DEV_XIP</p>
<p>XIP(eXecute In Place)支持(指应用程序可以直接在flash闪存内运行,不必再把代码读到系统RAM中).一般用于嵌入式设备.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Packet writing on CD/DVD media
CONFIG_CDROM_PKTCDVD</p>
<ul>
<li>CD/DVD刻录机支持.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/cdrom/packet-writing.txt">Documentation/cdrom/packet-writing.txt</a>&ldquo;文档</li>
<li>
<ul>
<li>
<p>Free buffers for data gathering
CONFIG_CDROM_PKTCDVD_BUFFERS</p>
<p>用于收集写入数据的缓冲区个数(每个占用64Kb内存),缓冲区越多性能越好.</p>
</li>
<li>
<p>Enable write caching
CONFIG_CDROM_PKTCDVD_WCACHE</p>
<p>为CD-R/W设备启用写入缓冲,目前这是一个比较危险的选项.建议关闭.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ATA over Ethernet support
CONFIG_ATA_OVER_ETH</p>
<p>以太网ATA设备(<a href="http://zh.wikipedia.org/wiki/ATA_over_Ethernet">ATA over Ethernet</a>)支持.</p>
</li>
<li>
<p>Xen virtual block device support
CONFIG_XEN_BLKDEV_FRONTEND</p>
<p>XEN虚拟块设备前端驱动.此驱动用于与实际驱动块设备的后端驱动(通常位于domain0)通信.</p>
</li>
<li>
<p>Xen block-device backend driver
CONFIG_XEN_BLKDEV_BACKEND</p>
<p>XEN块设备后端驱动(通常位于domain0)允许内核将实际的块设备通过高性能的共享内存接口导出给其他客户端的前端驱动(通常位于非domain0)使用.</p>
</li>
<li>
<p>Virtio block driver
CONFIG_VIRTIO_BLK</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>虚拟块设备驱动.它可以用于<a href="http://wiki.ubuntu.org.cn/Kvm%E6%95%99%E7%A8%8B">KVM</a>或<a href="http://zh.wikipedia.org/zh-cn/Xen">XEN</a>这类基于<a href="http://lguest.ozlabs.org/">lguest</a>或<a href="http://wiki.qemu.org/Main_Page">QEMU</a>的VMM(Virtual Machine Monitor).</p>
</li>
<li>
<p>Very old hard disk (MFM/RLL/IDE) driver
CONFIG_BLK_DEV_HD</p>
<p>又老又旧的MFM/RLL/ESDI硬盘驱动.无需犹豫,选&quot;N&rdquo;.</p>
</li>
<li>
<p>Rados block device (RBD)
CONFIG_BLK_DEV_RBD</p>
<p><a href="http://www.alidata.org/archives/1589">rados</a>块设备(rbd)支持.它可以与分布式文件系统<a href="http://www.ibm.com/developerworks/cn/linux/l-ceph/">Ceph</a>合作,也能独立工作.</p>
</li>
<li>
<p>IBM FlashSystem 70/80 PCIe SSD Device Driver
CONFIG_BLK_DEV_RSXX</p>
<p>IBM FlashSystem 70/80 PCIe SSD 驱动</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Misc devices</p>
<ul>
<li>杂项设备</li>
<li>
<ul>
<li>
<ul>
<li>{省略的部分请按照实际的硬件状况进行选择}</li>
<li>Integrated Circuits ICS932S401
CONFIG_ICS932S401</li>
</ul>
<p><a href="http://lwn.net/Articles/306320/">IDT ICS932S401</a> 系列时钟频率控制芯片支持(可能会出现在某些主板上).</p>
</li>
<li>
<p>Enclosure Services
CONFIG_ENCLOSURE_SERVICES</p>
<p>SES(<a href="http://wenku.baidu.com/view/dd358de86294dd88d0d26bec.html">SCSI Enclosure Services</a>)是一项目前大多数移动硬盘盒/硬盘托架/电脑主板都支持的硬件控制命令服务,SES可以让主机端透过SCSI命令去控制外接盒内的电源/冷却装置以及其他与数据传输无关的东西.要使用这项技术,外置硬盘盒和主机上的SCSI/ATA芯片都需要支持SES技术才OK.</p>
</li>
<li>
<p>VMware Balloon Driver
CONFIG_VMWARE_BALLOON</p>
<p>VMware物理内存balloon驱动.参见CONFIG_BALLOON_COMPACTION选项.</p>
</li>
<li>
<p>Generic on-chip SRAM driver
CONFIG_SRAM</p>
<p>许多<a href="http://baike.baidu.com/view/882467.htm">SoC系统</a>都有芯片内嵌的<a href="http://baike.baidu.com/view/423438.htm">SRAM</a>.开启此项后,就可以声明将此段内存范围交给通用内存分配器(<a href="http://blog.csdn.net/g_salamander/article/details/8562424">genalloc</a>)管理.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>EEPROM support</p>
<p><a href="http://baike.baidu.com/view/93707.htm">EEPROM</a>主要用于保存主板或板卡的BIOS,如果你想通过此Linux系统刷写BIOS可以考虑开启相应的子项.不确定的全部选&quot;N&quot;.</p>
</li>
<li>
<p>Intel Management Engine Interface
CONFIG_INTEL_MEI</p>
<p><a href="http://software.intel.com/en-us/business-client">Intel芯片组管理引擎</a>,介于固件和系统驱动之间,类似于一种接口(Interface),帮助系统和固件之间交互.如果你的芯片组位于&quot;CONFIG_INTEL_MEI_ME&quot;中,可以选&quot;Y&quot;,不过其实也没有多少实际意义.</p>
</li>
<li>
<p>ME Enabled Intel Chipsets
CONFIG_INTEL_MEI_ME</p>
<p>请根据帮助中列出的芯片组对照实际情况选择.</p>
</li>
<li>
<p>VMware VMCI Driver
CONFIG_VMWARE_VMCI</p>
<p><a href="http://pubs.vmware.com/vmci-sdk/VMCI_intro.html">VMware VMCI</a>(Virtual Machine Communication Interface)是一个在host和guest之间以及同一host上的guest和guest之间进行高速通信的虚拟设备.VMCI主要是提供一个接口让guest内的程序来调用,通过这个接口能在一个主机上的多个虚拟机之间进行直接的通信,而且无需经过更上层的其他途径,这样将有效地降低网络通信所产生的开支,但是这需要修改虚拟机上的软件,所以VMCI只适用于对虚拟机间通信要求非常高的情况.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ATA/ATAPI/MFM/RLL support (DEPRECATED)
CONFIG_IDE</p>
<p>已被废弃的IDE硬盘和ATAPI光驱等接口的驱动(已被CONFIG_ATA取代).选&quot;N&quot;,除非你确实知道自己在干什么.</p>
</li>
<li>
<p>SCSI device support</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-scsi-subsystem/">SCSI子系统</a></li>
<li>
<ul>
<li>
<p>RAID Transport Class
CONFIG_RAID_ATTRS</p>
<p>这只是用来得到RAID信息以及将来可能用于配置RAID方式的一个类.不管你的系统使用的是哪种RAID,都可以放心的关闭此项.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>SCSI device support
CONFIG_SCSI</p>
<p><a href="http://wenku.baidu.com/view/517ac1bfc77da26925c5b0bb.html">SCSI协议</a>支持.有任何SCSI/SAS/SATA/USB/Fibre Channel/FireWire设备之一就必须选上.选&quot;Y&quot;.</p>
</li>
<li>
<p>SCSI target support
CONFIG_SCSI_TGT</p>
<p>内核态的通用<a href="http://wangxu.me/blog/p/586">SCSI Target</a>实现(原<a href="http://linux-iscsi.org/wiki/Target">LIO</a>项目).SCSI子系统使用了一种客户机-服务器(C/S)模型.通常,一台计算机是这个模型中的客户机(称为&quot;initiator&quot;),向目标(target)发起块操作请求,这个&quot;target&quot;通常是一个存储设备(例如一块硬盘).此模块的功能是将一台计算机变成一个&quot;target&quot;(就像一个普通的硬盘一样),响应其他&quot;initiator&quot;节点的操作请求,从而让&quot;target&quot;能够提供更加高级的功能:复制,自动精简配置,重复数据删除,高可用性,自动备份等.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>legacy /proc/scsi/ support
CONFIG_SCSI_PROC_FS</p>
<p>过时的/proc/scsi/接口.某些老旧的刻录程序可能需要它,建议选&quot;N&quot;.</p>
</li>
<li>
<p>SCSI disk support
CONFIG_BLK_DEV_SD</p>
<p>使用SCSI/SAS/SATA/PATA/USB/Fibre Channel存储设备的必选.选&quot;Y&quot;.</p>
</li>
<li>
<p>SCSI tape support
CONFIG_CHR_DEV_ST</p>
<p>通用SCSI磁带驱动</p>
</li>
<li>
<p>SCSI OnStream SC-x0 tape support
CONFIG_CHR_DEV_OSST</p>
<p>专用于OnStream SC-x0/USB-x0/DI-x0的SCSI磁带/USB盘驱动</p>
</li>
<li>
<p>SCSI CDROM support
CONFIG_BLK_DEV_SR</p>
<ul>
<li>通过SCSI/FireWire/USB/SATA/IDE接口连接的DVD/CD驱动器(基本上涵盖了所有常见的接口).</li>
<li>
<ul>
<li>
<p>Enable vendor-specific extensions (for SCSI CDROM)
CONFIG_BLK_DEV_SR_VENDOR</p>
<p>仅在某些古董级的SCSI CDROM设备上才需要:NEC/TOSHIBA cdrom, HP Writers</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SCSI generic support
CONFIG_CHR_DEV_SG</p>
<p><a href="http://sg.danny.cz/sg/">通用SCSI协议</a>(/dev/sg*)支持.也就是除硬盘/光盘/磁带之外的SCSI设备(例如光纤通道).这些设备还需要额外的用户层工具支持才能正常工作.例如:<a href="http://www.sane-project.org/">SANE</a>,<a href="http://cdrecord.berlios.de/private/cdrecord.html">Cdrtools</a>,<a href="http://cdrdao.sourceforge.net/">CDRDAO</a>,<a href="http://www.xiph.org/paranoia/">Cdparanoia</a></p>
</li>
<li>
<p>SCSI media changer support
CONFIG_CHR_DEV_SCH</p>
<p>SCSI介质转换设备(SCSI Medium Changer device)是一种控制多个SCSI介质的转换器(例如在多个磁带/光盘之间进行切换),常用于控制磁带库或者CD自动点歌机(jukeboxes).此种设备会在/proc/scsi/scsi中以&quot;Type: Medium Changer&quot;列出.控制此类设备的用户层工具包是<a href="http://linux.bytesex.org/misc/changer.html">scsi-changer</a>.更多细节参见&quot;<a href="http://lxr.linux.no/linux/Documentation/scsi/scsi-changer.txt">Documentation/scsi/scsi-changer.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>SCSI Enclosure Support
CONFIG_SCSI_ENCLOSURE</p>
<p>&ldquo;Enclosure&quot;是一种用于管理SCSI设备的背板装置.比如移动硬盘盒就是一种常见的&quot;Enclosure&quot;设备.此项主要用于向用户层报告一些&quot;Enclosure&quot;设备的状态,这些状态对于SCSI设备的正常运行并非必须.此项依赖于CONFIG_ENCLOSURE_SERVICES选项.</p>
</li>
<li>
<p>Probe all LUNs on each SCSI device
CONFIG_SCSI_MULTI_LUN</p>
<p>默认强制在每个SCSI设备上探测所有的逻辑设备数量(Logical Unit Number),其值会被该模块的内核引导参数&quot;max_luns&quot;覆盖.只在一个SCSI设备上有多个逻辑设备时才需要选它,一般的SCSI设备并不需要.一个SCSI设备上有多个逻辑设备的典型例子:多口USB读卡器,CD点唱机(jukebox),处于&quot;mass storage&quot;模式的智能手机,量产为多个设备后的U盘.注意:此项并不影响符合SCSI-3或更高标准的设备,因为这些设备会明确的向内核报告逻辑设备数.</p>
</li>
<li>
<p>Verbose SCSI error reporting (kernel size +=12K)
CONFIG_SCSI_CONSTANTS</p>
<p>以易读的方式报告SCSI错误,内核将会增大12K</p>
</li>
<li>
<p>SCSI logging facility
CONFIG_SCSI_LOGGING</p>
<p>启用SCSI日志(默认并不开启,需要&quot;echo [bitmask] &gt; /proc/sys/dev/scsi/logging_level&rdquo;),可用于跟踪和捕获SCSI设备的错误.关于[bitmask]的说明可以查看&quot;drivers/scsi/scsi_logging.h&quot;文件.</p>
</li>
<li>
<p>Asynchronous SCSI scanning
CONFIG_SCSI_SCAN_ASYNC</p>
<p>异步扫描的意思是,在内核引导过程中,SCSI子系统可以在不影响其他子系统引导的同时进行SCSI设备的探测(包括同时在多个总线上进行检测),这样可以加快系统的引导速度.但是如果SCSI设备驱动被编译为模块,那么异步扫描将会导致内核引导出现问题(解决方法是加载scsi_wait_scan模块,或者使用&quot;scsi_mod.scan=sync&quot;内核引导参数).不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>SCSI Transports</p>
<ul>
<li>SCSI接口类型,下面的子项可以全不选,内核中若有其他部分依赖它,会自动选上</li>
<li>
<ul>
<li>
<p>Parallel SCSI (SPI) Transport Attributes
CONFIG_SCSI_SPI_ATTRS</p>
<p>传统的并行SCSI(Ultra320/160之类),已逐渐被淘汰</p>
</li>
<li>
<p>FiberChannel Transport Attributes
CONFIG_SCSI_FC_ATTRS</p>
<ul>
<li><a href="http://baike.baidu.com/view/15247.htm">光纤通道</a>接口</li>
<li>
<ul>
<li>
<p>SCSI target support for FiberChannel Transport Attributes
CONFIG_SCSI_FC_TGT_ATTRS</p>
<p>为光纤通道添加&quot;target&quot;模式驱动</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>iSCSI Transport Attributes
CONFIG_SCSI_ISCSI_ATTRS</p>
<p><a href="http://zh.wikipedia.org/wiki/ISCSI">iSCSI</a>协议是利用TCP/IP网络传送SCSI命令和数据的I/O技术</p>
</li>
<li>
<p>SAS Transport Attributes
CONFIG_SCSI_SAS_ATTRS</p>
<p>串行SCSI传输属性支持(<a href="http://storage.chinaunix.net/stor/raid/2008/05/22/1114713.shtml">SAS</a>对于SPI的关系犹如SATA对于IDE),这是目前的主流接口</p>
</li>
<li>
<p>SAS Domain Transport Attributes
CONFIG_SCSI_SAS_LIBSAS</p>
<ul>
<li>为使用了<a href="http://biz.chinabyte.com/24/2435024_4.shtml">SAS Domain</a>架构的驱动程序提供帮助.SAS Domain即整个SAS交换构架,由&quot;SAS device&quot;和&quot;SAS expander device&quot;组成,其中Device又区分为Initiator和Target,它们可以直接对接起来,也可以经过Expander进行连接,Expander起到通道交换或者端口扩展的作用.看不懂就说明你不需要它.</li>
<li>
<ul>
<li>
<p>ATA support for libsas (requires libata)
CONFIG_SCSI_SAS_ATA</p>
<p>在libsas中添加ATA支持,从而让libata和libsas协同工作.</p>
</li>
<li>
<p>Support for SMP interpretation for SAS hosts
CONFIG_SCSI_SAS_HOST_SMP</p>
<p>在libsas中添加SMP解释器,以允许主机支持SAS SMP协议.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SRP Transport Attributes
CONFIG_SCSI_SRP_ATTRS</p>
<ul>
<li>SCSI <a href="http://wiki.mbalib.com/wiki/RDMA">RDMA</a> 协议(SCSI RDMA Protocol)通过将SCSI数据传输阶段映射到Infiniband远程直接内存访问(Remote Direct Memory Access)操作加速了SCSI协议.</li>
<li>
<ul>
<li>
<p>SCSI target support for SRP Transport Attributes
CONFIG_SCSI_SRP_TGT_ATTRS</p>
<p>为SRP添加&quot;target&quot;模式驱动</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SCSI low-level drivers
CONFIG_SCSI_LOWLEVEL</p>
<ul>
<li>底层SCSI驱动程序</li>
<li>
<ul>
<li>
<p>iSCSI Initiator over TCP/IP
CONFIG_ISCSI_TCP</p>
<p><a href="http://zh.wikipedia.org/wiki/ISCSI">iSCSI</a>协议利用TCP/IP网络在&quot;initiator&quot;与&quot;targets&quot;间传送SCSI命令和数据.此选项便是iSCSI initiator驱动.相关的用户层工具/文档/配置示例,可以在<a href="http://open-iscsi.org/">open-iscsi</a>找到.</p>
</li>
<li>
<p>iSCSI Boot Sysfs Interface
CONFIG_ISCSI_BOOT_SYSFS</p>
<p>通过sysfs向用户空间显示iSCSI的引导信息.</p>
</li>
<li>
<ul>
<li>{此处省略的部分按照实际使用的控制器进行选择}</li>
<li>VMware PVSCSI driver support
CONFIG_VMWARE_PVSCSI</li>
</ul>
<p>VMware半虚拟化的SCSI HBA控制器</p>
</li>
<li>
<p>Microsoft Hyper-V virtual storage driver
CONFIG_HYPERV_STORAGE</p>
<p>微软的Hyper-V虚拟存储控制器</p>
</li>
<li>
<p>Intel(R) C600 Series Chipset SAS Controller
CONFIG_SCSI_ISCI</p>
<p>Intel C600 系列芯片组 6Gb/s SAS控制器</p>
</li>
<li>
<p>virtio-scsi support
CONFIG_SCSI_VIRTIO</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">virtio</a>虚拟HBA控制器</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PCMCIA SCSI adapter support
CONFIG_SCSI_LOWLEVEL_PCMCIA</p>
<p>通过PCMCIA卡与计算机连接的SCSI设备</p>
</li>
<li>
<p>SCSI Device Handlers
CONFIG_SCSI_DH</p>
<p>针对某些特定SCSI设备的驱动,具体子项请按照实际使用的控制器进行选择</p>
</li>
<li>
<p>OSD-Initiator library
CONFIG_SCSI_OSD_INITIATOR</p>
<ul>
<li><a href="http://xanpeng.github.io/linux/2012/12/30/object-storage.html">OSD(Object-Based Storage Device)</a>协议是一个T10 SCSI命令集,和SCSI处于同一级别,也跟SCSI很类似,分成osd-initiator/osd-target两部分,用于<a href="http://www.ibm.com/developerworks/cn/linux/l-ofs/index.html">对象存储文件系统</a>,此选项实现了<a href="http://lwn.net/Articles/305860/">OSD-Initiator库</a>(libosd.ko).更多细节参见&quot;<a href="http://lxr.linux.no/linux/Documentation/scsi/osd.txt">Documentation/scsi/osd.txt</a>&ldquo;文件.看不懂就说明你不需要.[提示]此选项依赖于CONFIG_CRYPTO_SHA1和CONFIG_CRYPTO_HMAC模块.</li>
<li>
<ul>
<li>
<p>OSD Upper Level driver
CONFIG_SCSI_OSD_ULD</p>
<p>提供OSD上层驱动(也就是向用户层提供/dev/osdX设备).从而允许用户层控制OSD设备(比如挂载基于OSD的<a href="http://www.ibm.com/developerworks/cn/linux/l-nilfs-exofs/">exofs文件系统</a>).</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Serial ATA and Parallel ATA drivers
CONFIG_ATA</p>
<ul>
<li>SATA与PATA(IDE)设备.桌面级PC以及低端服务器的硬盘基本都是此种接口</li>
<li>
<ul>
<li>
<p>Verbose ATA error reporting
CONFIG_ATA_VERBOSE_ERROR</p>
<p>输出详细的ATA命令描述信息.大约会让内核增大6KB.禁用它将会导致调试ATA设备错误变得困难.</p>
</li>
<li>
<p>ATA ACPI Support
CONFIG_ATA_ACPI</p>
<ul>
<li>与ATA相关的ACPI对象支持.这些对象与性能/安全/电源管理等相关.不管你使用的是IDE硬盘还是SATA硬盘,都建议开启(可以使用内核引导参数&quot;libata.noacpi=1&quot;关闭).</li>
<li>
<ul>
<li>
<p>SATA Zero Power Optical Disc Drive (ZPODD) support
CONFIG_SATA_ZPODD</p>
<p>这是<a href="http://news.mydrivers.com/1/199/199581.htm">SATA-3.1</a>版规范新增的节能相关内容,用新的电源管理策略降低了整个系统的电力需求,可以让处于空闲状态的光驱耗电量近乎于零.这需要主板和光驱两者都支持SATA-3.1规范才行.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SATA Port Multiplier support
CONFIG_SATA_PMP</p>
<p>SATA端口复用器(<a href="http://www.360doc.com/content/12/0424/16/5073814_206190083.shtml">Port Multiplier</a>)是一个定义在SATA规范里面的可以选择的功能,可以把一个活动主机连接多路复用至多个设备连接,相当于一个SATA HUB.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>AHCI SATA support
CONFIG_SATA_AHCI</p>
<p>AHCI SATA 支持.这是最佳的SATA模式(NCQ功能依赖于它).某些主板还需要在BIOS中将硬盘明确设为AHCI模式.使用SATA硬盘者必选&quot;Y&quot;.[提示]由于各厂商芯片组内的SATA控制器都遵循同一种规范,所以并不需要各种各样针对不同SATA控制器的驱动,就这一个驱动基本就能通吃所有SATA控制器了,这比丰富多彩的网卡驱动省事多了.</p>
</li>
<li>
<p>Platform AHCI SATA support
CONFIG_SATA_AHCI_PLATFORM</p>
<p>这是用于嵌入式系统的与AHCI接口兼容的SATA驱动.并不是常见的芯片组中的SATA控制器驱动.不确定的选&quot;N&quot;.</p>
</li>
<li>
<ul>
<li>{此处省略几个特殊且不常见的SATA控制器驱动}</li>
<li>ATA SFF support (for legacy IDE and PATA)
CONFIG_ATA_SFF</li>
</ul>
<!---->
<ul>
<li>使用SATA硬盘的用户可无视此项,选&quot;N&quot;即可.对于依然使用老旧的IDE/PATA硬盘的用户而言,按照实际情况在子项中选择相应的控制器驱动即可.</li>
<li>
<ul>
<li>
<ul>
<li>{此处省略几个罕见的Pacific/Promise芯片组}</li>
<li>ATA BMDMA support
CONFIG_ATA_BMDMA</li>
</ul>
<p>这是IDE控制器的事实标准.除了上世纪的古董外,绝大多数芯片组都遵守这个标准,选&quot;Y&quot;,然后从子项中选择恰当的芯片组/控制器.</p>
</li>
<li>
<ul>
<li>{此处省略的PIO-only SFF芯片组都是早就绝迹的老古董}</li>
<li>ACPI firmware driver for PATA
CONFIG_PATA_ACPI</li>
</ul>
<p>通过ACPI BIOS去操作IDE控制器.仅用于某些比较奇特的IDE控制器.选&quot;N&quot;.</p>
</li>
<li>
<p>Generic ATA support
CONFIG_ATA_GENERIC</p>
<p>这是通用的IDE控制器驱动.如果你无法确定IDE控制器的具体型号(比如需要面对未知的硬件状况),或者不想使用针对特定芯片组的IDE驱动,就选&quot;Y&quot;吧.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Multiple devices driver support (RAID and LVM)
CONFIG_MD</p>
<ul>
<li>多设备支持(<a href="http://zh.wikipedia.org/zh-cn/RAID">RAID</a>和<a href="https://wiki.archlinux.org/index.php/LVM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">LVM</a>).RAID和LVM的功能是使用多个物理设备组建成一个单独的逻辑设备</li>
<li>
<ul>
<li>
<p>RAID support
CONFIG_BLK_DEV_MD</p>
<ul>
<li>&ldquo;<a href="http://www.tldp.org/HOWTO/html_single/Software-RAID-HOWTO/">Software RAID</a>&quot;(需要使用<a href="https://www.kernel.org/pub/linux/utils/raid/mdadm/">mdadm</a>工具)支持.也就是&rdquo;<a href="http://molinux.blog.51cto.com/2536040/516008">软RAID</a>&quot;.使用硬件RAID卡的用户并不需要此项.</li>
<li>
<ul>
<li>
<p>Autodetect RAID arrays during kernel boot
CONFIG_MD_AUTODETECT</p>
<p>在内核启动过程中自动检测RAID模式.如果你没有使用RAID,那么选中此项将会让内核在启动过程中增加几秒延迟.如果你使用了&quot;raid=noautodetect&quot;内核引导参数关闭了自动检测,或者此处选了&quot;N&quot;,那么你必须使用&quot;md=???&ldquo;内核引导参数明确告诉内核RAID模式及配置.</p>
</li>
<li>
<p>Linear (append) mode
CONFIG_MD_LINEAR</p>
<p>线性模式(简单的将一个分区追加在另一个分区之后),一般不使用这种模式.</p>
</li>
<li>
<p>RAID-0 (striping) mode
CONFIG_MD_RAID0</p>
<p>RAID-0(等量分割)模式,可以获取最高性能,但是却损害了可靠性,一般也不使用这种模式.</p>
</li>
<li>
<p>RAID-1 (mirroring) mode
CONFIG_MD_RAID1</p>
<p>RAID-1(镜像)模式.包含内核的引导分区只能使用这种模式.</p>
</li>
<li>
<p>RAID-10 (mirrored striping) mode
CONFIG_MD_RAID10</p>
<p>RAID 1+0 模式</p>
</li>
<li>
<p>RAID-4/RAID-5/RAID-6 mode
CONFIG_MD_RAID456</p>
<p>RAID-4/RAID-5/RAID-6 模式</p>
</li>
<li>
<p>Multipath I/O support
CONFIG_MD_MULTIPATH</p>
<p>多路IO支持是指在服务器和存储设备之间使用冗余的物理路径组件创建&quot;逻辑路径&rdquo;,如果这些组件发生故障并造成路径失败,多路径逻辑将为I/O使用备用路径以使应用程序仍然可以访问其数据.该选项已废弃,并已被CONFIG_DM_MULTIPATH所取代.选&quot;N&quot;.</p>
</li>
<li>
<p>Faulty test module for MD
CONFIG_MD_FAULTY</p>
<p>用于MD(Multi-device)的缺陷测试模块,仅用于调试.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Block device as cache
CONFIG_BCACHE</p>
<ul>
<li>将一个块设备用作其他块设备的缓存(<a href="https://wiki.archlinux.org/index.php/Bcache">Bcache</a>).此缓存使用btree(平衡树)索引,并专门为SSD进行了优化.仅在你打算<a href="http://www.expreview.com/25399.html">使用高速SSD作为普通硬盘的缓存</a>时才需要此功能.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/bcache.txt">Documentation/bcache.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Bcache debugging
CONFIG_BCACHE_DEBUG</p>
<p>仅供内核开发者调试使用</p>
</li>
<li>
<p>Extended runtime checks
CONFIG_BCACHE_EDEBUG</p>
<p>仅供内核开发者调试使用</p>
</li>
<li>
<p>Debug closures
CONFIG_BCACHE_CLOSURES_DEBUG</p>
<p>仅供内核开发者调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Device mapper support
CONFIG_BLK_DEV_DM</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/">Device-mapper</a>是一个底层的卷管理器,提供了一种从逻辑设备到物理设备的映射框架,用户可以很方便的根据自己的需要制定实现存储资源的管理策略.它不像RAID那样工作在设备层,而是通过块和扇区的映射机制,将不同磁盘的不同部分组合成一个大的块设备供用户使用.<a href="https://wiki.archlinux.org/index.php/LVM_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">LVM2</a>和<a href="http://en.wikipedia.org/wiki/Enterprise_Volume_Management_System">EVMS</a>都依赖于它.此外,那些集成在南桥(例如ICH8R/ICH9R/ICH10R系列等)中所谓的&quot;硬RAID&rdquo;(准确的称呼应该是&quot;<a href="http://wenku.baidu.com/view/195a16eae009581b6bd9eb1b.html">Device Mapper RAID</a>&quot;,又称为&quot;Fake RAID&quot;/&ldquo;BIOS RAID&rdquo;)也依赖于它.</li>
<li>
<ul>
<li>
<p>Device mapper debugging support
CONFIG_DM_DEBUG</p>
<p>仅供内核开发者调试使用</p>
</li>
<li>
<p>Crypt target support
CONFIG_DM_CRYPT</p>
<p>此模块允许你创建一个经过透明加密的逻辑设备(使用<a href="http://code.google.com/p/cryptsetup/">cryptsetup</a>工具),要使用加密功能,除此项外,还需要在&quot;Cryptographic API&quot;里选中相应的加密算法,例如CONFIG_CRYPTO_AES.更多文档请参考<a href="http://code.google.com/p/cryptsetup/wiki/FrequentlyAskedQuestions">LUKS FAQ</a>.</p>
</li>
<li>
<p>Snapshot target
CONFIG_DM_SNAPSHOT</p>
<p>允许卷管理器为DM设备创建可写的快照(定格于特定瞬间的一个设备虚拟映像).<a href="http://blog.chinaunix.net/uid-8650524-id-6166.html">LVM2 Snapshot</a>需要它的支持.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/device-mapper/snapshot.txt">Documentation/device-mapper/snapshot.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Thin provisioning target
CONFIG_DM_THIN_PROVISIONING</p>
<ul>
<li>&ldquo;<a href="http://en.wikipedia.org/wiki/Thin_provisioning">Thin provisioning</a>&quot;(某些地方翻译为&quot;精简配置&rdquo;)的意思是允许分配给所有用户的总存储容量超过实际的存储容量(使用<a href="https://github.com/jthornber/thin-provisioning-tools">thin-provisioning-tools</a>工具).例如给100个用户分配空间,每个用户最大允许10G空间,共计需要1000G空间.但实际情况是95%的用户都只使用了不到1G的空间,那么实际准备1000G空间就是浪费.有了&quot;thin provisioning&quot;的帮助,你实际只需要准备150G的空间就可以了,之后,可以随着用户需求的增加,添加更多的实际存储容量,从而减少存储投资和避免浪费.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/device-mapper/thin-provisioning.txt">Documentation/device-mapper/thin-provisioning.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Keep stack trace of thin provisioning block lock holders
CONFIG_DM_DEBUG_BLOCK_STACK_TRACING</p>
<p>仅用于调试目的</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cache target
CONFIG_DM_CACHE</p>
<ul>
<li><a href="http://www.oschina.net/p/dm-cache">dm-cache</a>通过将频繁使用的热点数据缓存到一个容量较小但性能很高的存储设备上,从而提升块设备的性能.它支持<a href="http://blog.csdn.net/string19820108/article/details/7327552">writeback和writethrough</a>两种模式,并可以使用多种<a href="http://wangxu.me/blog/p/787">缓存策略(policy)</a>以判断哪些是热点数据以及哪些数据需要从缓存中移除.更多详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/device-mapper/cache.txt">Documentation/device-mapper/cache.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>MQ Cache Policy
CONFIG_DM_CACHE_MQ</p>
<p>MQ缓存策略.这是目前唯一真正可用的缓存策略.</p>
</li>
<li>
<p>Cleaner Cache Policy
CONFIG_DM_CACHE_CLEANER</p>
<p>Cleaner简单的把所有数据都同步写入到原始设备上,相当于关闭缓存.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mirror target
CONFIG_DM_MIRROR</p>
<p>允许对逻辑卷进行镜像,同时实时数据迁移工具<a href="http://francs3.blog.163.com/blog/static/40576727201223134340630/">pvmove</a>也需要此项的支持.</p>
</li>
<li>
<p>RAID 1/4/5/6/10 target
CONFIG_DM_RAID</p>
<p>RAID 1/4/5/6/10 支持.即使使用ICH8R/ICH9R/ICH10R这样的南桥,也不推荐使用&quot;Device Mapper RAID&quot;(既无性能优势又依赖于特定硬件),应该直接使用更成熟的CONFIG_BLK_DEV_MD模块.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mirror userspace logging
CONFIG_DM_LOG_USERSPACE</p>
<p>device-mapper用户空间日志功能由内核模块和用户空间程序两部分组成,此选项是内核模块(API定义于&quot;linux/dm-dirty-log.h&quot;文件).不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Zero target
CONFIG_DM_ZERO</p>
<p>&ldquo;Zero target&quot;类似于&rdquo;/dev/zero&quot;,所有的写入都被丢弃,所有的读取都可以得到无限多个零.可用于某些恢复场合.</p>
</li>
<li>
<p>Multipath target
CONFIG_DM_MULTIPATH</p>
<ul>
<li><a href="http://wenku.it168.com/d_000497278.shtml">设备映射多路径</a>(DM-Multipath)支持.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>I/O Path Selector based on the number of in-flight I/Os
CONFIG_DM_MULTIPATH_QL</p>
<p>这是一个动态负载均衡路径选择器:选择当前正在处理中的I/O数量最小的通路.</p>
</li>
<li>
<p>I/O Path Selector based on the service time
CONFIG_DM_MULTIPATH_ST</p>
<p>这是一个动态负载均衡路径选择器:选择完成此I/O操作预期时间最少的通路.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I/O delaying target
CONFIG_DM_DELAY</p>
<p>对读/写操作进行延迟,并可将其发送到不同的设备.仅用于测试DM子系统.</p>
</li>
<li>
<p>DM uevents
CONFIG_DM_UEVENT</p>
<p>为DM事件透过<a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a>向用户层的udevd发出uevent通知,这样就允许udevd在&quot;/dev/&ldquo;目录中执行相应的操作.</p>
</li>
<li>
<p>Flakey target
CONFIG_DM_FLAKEY</p>
<p>模拟间歇性的I/O错误,以用于调试DM子系统.</p>
</li>
<li>
<p>Verity target support
CONFIG_DM_VERITY</p>
<p>Verity target 可以创建一个只读的逻辑设备,然后根据预先生成的哈希校验和(存储在其他设备上),校验底层设备上的数据正确性.要使此模块正常工作,还需要在&quot;Cryptographic API&quot;部分选中相应的哈希算法.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Generic Target Core Mod (TCM) and ConfigFS Infrastructure
CONFIG_TARGET_CORE</p>
<p>通用TCM存储引擎与ConfigFS虚拟文件系统(/sys/kernel/config)支持.看不懂就说明你不需要.</p>
</li>
<li>
<p>Fusion MPT device support
CONFIG_FUSION</p>
<p><a href="http://storage.chinaunix.net/stor/other/2006/04/05/1109749.shtml">Fusion MPT</a>(Message Passing Technology) 是 LSI Logic 公司为了更容易实现SCSI和光纤通道而提出的技术,支持Ultra320 SCSI/光纤通道/SAS.</p>
</li>
<li>
<p>IEEE 1394 (FireWire) support</p>
<p>火线(<a href="http://baike.baidu.com/view/117006.htm">IEEE 1394</a>)是苹果公司开发的串行接口,类似于USB,但PC上并不常见,算得上是个没有未来的技术了.</p>
</li>
<li>
<p>I2O device support
CONFIG_I2O</p>
<p><a href="http://wenwen.soso.com/z/q59111011.htm">智能输入输出</a>(<a href="http://baike.baidu.com/view/272945.htm">Intelligent Input/Output</a>)架构让硬件驱动分成了两部分:OSM(特定于操作系统)+HDM(特定于硬件,与操作系统无关).由于<a href="http://i2o.shadowconnect.com/index.php">I2O设备</a>上集成有专用的I/O处理器,从而加快I/O速度(因为避免了CPU的参与).I2O属于已被废弃的技术,目前能见到的此类设备都属于老古董了.</p>
</li>
<li>
<p>Macintosh device drivers
CONFIG_MACINTOSH_DRIVERS</p>
<p>苹果的Macintosh电脑上的专有设备驱动</p>
</li>
<li>
<p>Network device support
CONFIG_NETDEVICES</p>
<ul>
<li>网络设备.除非你不想连接任何网络,否则必选&quot;Y&rdquo;.</li>
<li>
<ul>
<li>
<p>Network core driver support
CONFIG_NET_CORE</p>
<ul>
<li>如果你不想使用任何高级网络功能(拨号网络/EQL/VLAN/bridging/bonding/光纤通道/<a href="http://www.ibm.com/developerworks/cn/linux/l-virtual-networking/">虚拟网络</a>等),仅仅是一般性质的联网(普通服务器,通过路由器或者局域网上网的常规个人电脑),可以选&quot;N&quot;.此外,某些网卡的驱动会依赖于其下的CONFIG_MII子项(会被自动选中).</li>
<li>
<ul>
<li>
<p>Bonding driver support
CONFIG_BONDING</p>
<p>链路聚合技术拥有多个不同的称谓:Linux称为&quot;Bonding&quot;,IEEE称为&quot;<a href="http://baike.baidu.com/view/1996279.htm">802.3ad</a>&quot;,Sun称为&quot;Trunking&quot;,Cisco称为&quot;<a href="http://baike.baidu.com/view/320130.htm">Etherchannel</a>&quot;.该技术可以将多个以太网通道聚合为一个单独的虚拟适配器,例如将两块网卡聚合成一个逻辑网卡,可以用来实现负载均衡或硬件冗余.</p>
</li>
<li>
<p>Dummy net driver support
CONFIG_DUMMY</p>
<p>Dummy网络接口本质上是一个可以配置IP地址的bit-bucket(位桶,所有发送到此设备的流量都将被湮灭),以使应用程序看上去正在和一个常规的网络接口进行通信.使用<a href="http://zh.wikipedia.org/wiki/%E4%B8%B2%E8%A1%8C%E7%BA%BF%E8%B7%AFIP%E5%8D%8F%E8%AE%AE">SLIP</a>(小猫拨号,目前应该已经绝迹了)或<a href="http://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">PPP</a>(常用于<a href="http://zh.wikipedia.org/wiki/PPPoE">PPPoE</a> ADSL)的用户需要它</p>
</li>
<li>
<p>EQL (serial line load balancing) support
CONFIG_EQUALIZER</p>
<p>串行线路的负载均衡.如果有两个MODEM和两条SLIP/PPP线路,该选项可以让你同时使用这两个通道以达到双倍速度(网络的对端也要支持EQL技术).曾经昙花一现的<a href="http://baike.baidu.com/view/51012.htm">ISDN</a>就这项技术的一个实例.</p>
</li>
<li>
<p>Fibre Channel driver support
CONFIG_NET_FC</p>
<p>光纤通道(Fibre Channel)是一种高速网络串行协议,主要用于存储局域网(SAN),它与SCSI协议兼容,并意在取代SCSI.与传统的SCSI技术相比,除了提供更高的数据传输速度,更远的传输距离,更多的设备连接支持,更稳定的性能,更简易的安装以外,最重要的是支持最新的网络区域存储(SAN)技术.如果你的机器上有光纤通道卡(FC卡),除了需要开启此项外,还需要开启相应的FC卡驱动,以及CONFIG_CHR_DEV_SG选项.</p>
</li>
<li>
<p>Generic Media Independent Interface device support
CONFIG_MII</p>
<p><a href="http://baike.baidu.com/view/229282.htm">媒体独立接口</a>(<a href="http://www.cndzz.com/download/4105_0/102212.html">Media Independent Interface</a>)又称介质无关接口,是<a href="http://baike.baidu.com/view/203586.htm">IEEE-802.3</a>(规定了以太网相关协议的具体内容)定义的以太网行业标准.它包括一个数据接口,以及一个位于<a href="http://www.360doc.com/content/11/1020/23/1317564_157853470.shtml">MAC和PHY</a>之间的控制接口.[提示]大多数以太网卡都有MII收发器,其驱动都依赖于此项,也会自动选中此项.</p>
</li>
<li>
<p>Intermediate Functional Block support
CONFIG_IFB</p>
<p><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/ifb">IFB</a>是一个中间层驱动,可以用来灵活的配置资源共享.更多信息参见iproute2文档.看不懂就说明你不需要.</p>
</li>
<li>
<p>Ethernet team driver support
CONFIG_NET_TEAM</p>
<p>允许通过&quot;ip link add link [ address MAC ] [ NAME ] type team&quot;命令,将多个以太网卡(称为&quot;port&quot;)组合在一起,创建一个虚拟的&quot;<a href="https://fedoraproject.org/wiki/Features/TeamDriver">team</a>&ldquo;网络设备,其目的是取代传统的&quot;Bonding&rdquo;(CONFIG_BONDING)驱动.&ldquo;ip&quot;是iproute2包中的一个命令.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>MAC-VLAN support
CONFIG_MACVLAN</p>
<ul>
<li>MAC-VLAN是通过MAC地址来划分<a href="http://baike.baidu.com/view/21837.htm">VLAN</a>的方式,在Linux则用来给网卡添加多个MAC地址.你可以使用&quot;ip link add link &lt;real dev&gt; [ address MAC ] [ NAME ] type macvlan&quot;命令创建一个虚拟的&quot;macvlan&quot;设备(系统会自动打开网卡的<a href="http://baike.baidu.com/view/2521757.htm">混杂模式</a>),然后就可以在同一个物理网卡上虚拟出多个以太网口.</li>
<li>
<ul>
<li>
<p>MAC-VLAN based tap driver
CONFIG_MACVTAP</p>
<p>基于MAC-VLAN接口的tap(虚拟以太网设备)字符设备(<a href="http://blog.csdn.net/kl222/article/details/8513593">macvtap</a>)驱动,旨在简化虚拟化的桥接网络,目的是替代<a href="http://baike.baidu.com/view/8570754.htm">TUN/TAP</a>和Bridge内核模块.可以通过与创建macvlan设备相同的&quot;ip&quot;命令创建一个虚拟的&quot;macvtap&quot;设备,并通过<a href="http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP">TAP</a>用户空间接口进行访问.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Virtual eXtensible Local Area Network (VXLAN)
CONFIG_VXLAN</p>
<p>&ldquo;<a href="http://hb.qq.com/a/20111010/000076.htm">vxlan</a>&ldquo;虚拟接口可以在第三层网络上创建第二层网络(跨多个物理IP子网的虚拟二层子网),是一种在UDP中封装MAC的简单机制,主要用于虚拟化环境下的隧道虚拟网络(tunnel virtual network).</p>
</li>
<li>
<p>Network console logging support
CONFIG_NETCONSOLE</p>
<ul>
<li>网络控制台(netconsole)的作用是通过网络记录内核日志信息.详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/networking/netconsole.txt">Documentation/networking/netconsole.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>Dynamic reconfiguration of logging targets
CONFIG_NETCONSOLE_DYNAMIC</p>
<p>允许通过configfs导出的用户空间接口,在运行时更改日志目标(网口, IP地址, 端口号, MAC地址).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Netpoll traffic trapping
CONFIG_NETPOLL_TRAP</p>
<p><a href="http://www.360doc.com/content/11/1023/09/7975692_158366329.shtml">netpoll</a>的目的是让内核在网络和I/O子系统尚不能完整可用时,依然能发送和接收数据包.主要用于网络控制台(netconsole)和远程内核调试(KGDBoE)中.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Virtual Ethernet over NTB
CONFIG_NTB_NETDEV</p>
<p>PCI-E非透明桥(CONFIG_NTB)上的虚拟网卡.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>RapidIO Ethernet over messaging driver support
CONFIG_RIONET</p>
<p>在标准的<a href="http://www.big-bit.com/news/ic_29514.html">RapidIO</a>通信方式上发送以太网数据包.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Universal TUN/TAP device driver support
CONFIG_TUN</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-tuntap/">TUN/TAP</a>可以为用户空间提供包的接收和发送服务,可以用来虚拟一张网卡或点对点通道.当程序打开&quot;/dev/net/tun&quot;设备时,驱动程序就会注册相应的<a href="http://blog.csdn.net/wangxing1018/article/details/3510118">&ldquo;tunX&quot;或&quot;tapX&rdquo;</a>网络设备,当程序关闭&quot;/dev/net/tun&quot;设备时,驱动程序又会删除相应的&quot;tunX&quot;或&quot;tapX&quot;网络设备以及所有与之相关联的路由.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/networking/tuntap.txt">Documentation/networking/tuntap.txt</a>&ldquo;文档.看不懂就表明你不需要.</p>
</li>
<li>
<p>Virtual ethernet pair device
CONFIG_VETH</p>
<p>该驱动提供了一个本地以太网隧道(设备会被成对的创建).</p>
</li>
<li>
<p>Virtio network driver
CONFIG_VIRTIO_NET</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">virtio</a>虚拟网卡驱动.可以用于<a href="http://www.linuxeden.com/html/sysadmin/20090630/66492.html">lguest</a>或者基于<a href="http://zh.wikipedia.org/wiki/QEMU">QEMU</a>的虚拟机管理程序(例如KVM/Xen).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ARCnet support
CONFIG_ARCNET</p>
<p><a href="http://baike.baidu.com/view/630530.htm">ARCnet</a>是1977年由Datapoint公司开发的一种局域网技术,它采用令牌总线方案来管理LAN上工作站和其他设备之间的共享线路,主要用于工业控制领域中.</p>
</li>
<li>
<p>ATM drivers
CONFIG_ATM_DRIVERS</p>
<p>可怜的ATM(异步传输模式),曾经在90年代风靡一时,现在已经消失的无影无踪了.</p>
</li>
<li>
<ul>
<li>{这里省略几个专用于Android/MeeGo系统的PF_CAIF类型套接字相关的选项}</li>
<li>Distributed Switch Architecture drivers</li>
</ul>
<p>分布式交换架构驱动,其子项都是Marvell系列以太网交换机芯片组的驱动</p>
</li>
<li>
<p>Ethernet driver support
CONFIG_ETHERNET</p>
<ul>
<li>最常见的以太网卡驱动</li>
<li>
<ul>
<li>
<ul>
<li>{省略的部分请按照实际的硬件状况进行选择,这里仅以两个常见公司的以太网芯片为例进行说明}</li>
<li>AMD devices
CONFIG_NET_VENDOR_AMD</li>
</ul>
<!---->
<ul>
<li>AMD出品的以太网控制芯片</li>
<li>
<ul>
<li>
<p>AMD PCnet32 PCI support
CONFIG_PCNET32</p>
<p>这是VMware/VirtualBox虚拟机中常用的网卡</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Broadcom devices
CONFIG_NET_VENDOR_BROADCOM</p>
<ul>
<li>博通(Broadcom)公司的网卡</li>
<li>
<ul>
<li>
<p>Broadcom 440x/47xx ethernet support
CONFIG_B44</p>
<p>Broadcom 44xx/47xx 10/100M PCI</p>
</li>
<li>
<p>Broadcom NetXtremeII support
CONFIG_BNX2</p>
<p>NetXtreme II 1 Gigabit ( BCM5706/5708/5709/5716 )</p>
</li>
<li>
<p>Broadcom CNIC support
CONFIG_CNIC</p>
<p>NetXtremeII 系列网卡的<a href="http://www.sansky.net/article/2007-11-17-toe-technology-and-the-working-principle-of-toe-nic.html">TCP减负引擎</a>(<a href="http://en.wikipedia.org/wiki/TCP_offload_engine">TCP Offload Engine</a>)特性支持.不过,<a href="http://www.cnblogs.com/pandaeye/archive/2013/05/20/3089635.html">TOE并不适合高连接数/小文件的Web服务器类应用</a>,它的主要目的是和IP存储协议(iSCSI/NFS)一起使用.[注意]TOE与&quot;Large Receive Offload&quot;是两个不同的东西,不要混淆.</p>
</li>
<li>
<p>Broadcom Tigon3 support
CONFIG_TIGON3</p>
<p>这是最流行的驱动,其涵盖的型号特别多,但是&quot;Tigon3&quot;的名称却非常具有迷惑性.简单说来,除了B44,BNX2,BNX2X中明确列出的型号外,其他型号用的都是这个驱动.</p>
</li>
<li>
<p>Broadcom NetXtremeII 10Gb support
CONFIG_BNX2X</p>
<ul>
<li>NetXtreme II 10 Gigabit ( BCM57710/57711/57711E/57712/57800/57810 )</li>
<li>
<ul>
<li>
<p>Broadcom 578xx and 57712 SR-IOV support
CONFIG_BNX2X_SRIOV</p>
<p>支持578xx/57712的<a href="http://blog.sina.com.cn/s/blog_582a1a4b0100zvnh.html">单根I/O虚拟化</a>(Single Root IOV)技术</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>FDDI driver support
CONFIG_FDDI</p>
<p><a href="http://baike.baidu.com/view/876931.htm">光纤分布式数据接口</a>(FDDI)</p>
</li>
<li>
<p>HIPPI driver support
CONFIG_HIPPI</p>
<p><a href="http://baike.baidu.com/view/5423623.htm">高性能并行接口</a>(HIgh Performance Parallel Interface)是一个在短距离内高速传送大量数据的点对点协议.常用于集群和超级计算机.</p>
</li>
<li>
<p>General Instruments Surfboard 1000
CONFIG_NET_SB1000</p>
<p>SURFboard 1000 插卡式Cable Medem(ISA接口),这玩意早就绝种了</p>
</li>
<li>
<p>PHY Device support and infrastructure
CONFIG_PHYLIB</p>
<p>数据链路层芯片简称为MAC控制器,物理层芯片简称之为PHY,通常的网卡把MAC和PHY的功能做到了一颗芯片中,但也有一些仅含PHY的&quot;软网卡&rdquo;.此选项就是对这些&quot;软网卡&quot;的支持.请根据实际情况选择其下的子项.</p>
</li>
<li>
<p>Micrel KS8995MA 5-ports 10/100 managed Ethernet switch
CONFIG_MICREL_KS8995MA</p>
<p><a href="http://www.micrel.com.cn/">Micrel</a> KS8995MA 5端口 10/100M 以太网交换芯片</p>
</li>
<li>
<p>PLIP (parallel port) support
CONFIG_PLIP</p>
<p><a href="http://fanqiang.chinaunix.net/a3/b2/20010421/173510_b.html">PLIP</a>(Parallel Line Internet Protocol)用于将两台电脑通过并口进行联网,组成一个简单的客户机/服务器结构.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/networking/PLIP.txt">Documentation/networking/PLIP.txt</a>&quot;.现在的电脑都使用网卡进行互联,并口早就经被丢进历史的垃圾箱了.</p>
</li>
<li>
<p>PPP (point-to-point protocol) support
CONFIG_PPP</p>
<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE">点对点协议</a>(<a href="http://www.cnblogs.com/zmkeil/archive/2013/05/02/3055518.html">Point to Point Protocol</a>)是SLIP的继任者,使用PPP需要用户层程序<a href="http://www.cnblogs.com/simonshi/archive/2010/04/23/1718984.html">pppd</a>的帮助.PPP实际上有两个版本:基于普通模拟电话线的&quot;异步PPP&quot;和基于数字线路(例如ISDN线路)的&quot;同步PPP&quot;.<a href="http://wiki.ubuntu.org.cn/ADSL%EF%BC%88PPPOE%EF%BC%89%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97">使用电脑直接拨号的 PPPoE ADSL 用户</a>需要此项.</li>
<li>
<ul>
<li>
<p>PPP BSD-Compress compression
CONFIG_PPP_BSDCOMP</p>
<p>为PPP提供BSD(等价于LZW压缩算法,没有gzip高效)压缩算法支持,需要通信双方的支持才有效.大多数ISP都不支持此算法.</p>
</li>
<li>
<p>PPP Deflate compression
CONFIG_PPP_DEFLATE</p>
<p>为PPP提供Deflate(等价于gzip压缩算法)压缩算法支持,需要通信双方的支持才有效.这是比BSD更好的算法(压缩率更高且无专利障碍).</p>
</li>
<li>
<p>PPP filtering
CONFIG_PPP_FILTER</p>
<p>允许对通过PPP接口的包进行过滤.仅在你需要使用pppd的pass-filter/active-filter选项时才需要开启.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>PPP MPPE compression (encryption)
CONFIG_PPP_MPPE</p>
<p>为PPP提供MPPE加密协议支持,它被用于微软的P2P隧道协议中.此特性需要<a href="https://wiki.archlinux.org/index.php/Microsoft_VPN_client_setup_with_pptpclient_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">PPTP Client</a>工具的支持.</p>
</li>
<li>
<p>PPP multilink support
CONFIG_PPP_MULTILINK</p>
<p>多重链路协议(RFC1990)允许你将多个线路(物理的或逻辑的)组合为一个PPP连接一充分利用带宽,这不但需要pppd的支持,还需要ISP的支持</p>
</li>
<li>
<p>PPP over ATM
CONFIG_PPPOATM</p>
<p>在ATM上跑的PPP.果断&quot;N&quot;.</p>
</li>
<li>
<p>PPP over Ethernet
CONFIG_PPPOE</p>
<p>这就是ADSL用户最常见的PPPoE,也就是在以太网上跑的PPP协议.这需要<a href="http://www.roaringpenguin.com/pppoe">RP-PPPoE</a>工具的帮助</p>
</li>
<li>
<p>PPP over IPv4 (PPTP)
CONFIG_PPTP</p>
<p><a href="http://zh.wikipedia.org/zh-cn/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0">点对点隧道协议</a>(<a href="http://baike.baidu.com/view/32771.htm">Point-to-Point Tunneling Protocol</a>)是一种主要用于VPN的数据链路层网络协议.此功能需要<a href="http://accel-pptp.sourceforge.net/">ACCEL-PPTP</a>工具的支持.</p>
</li>
<li>
<p>PPP over L2TP
CONFIG_PPPOL2TP</p>
<p><a href="http://zh.wikipedia.org/zh-cn/%E7%AC%AC%E4%BA%8C%E5%B1%82%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">第二层隧道协议</a>(<a href="http://baike.baidu.com/view/32692.htm">L2TP</a>)是一种通过UDP隧道传输PPP流量的技术,对于VPN用户来说,<a href="http://www.h3c.com.cn/MiniSite/Technology_Circle/Technology_Column/ICG/ICG_Technology/201004/671383_97665_0.htm">L2TP VPN</a>是比PPTP VPN的更好解决方案.</p>
</li>
<li>
<p>PPP support for async serial ports
CONFIG_PPP_ASYNC</p>
<p>基于普通模拟电话线或标准异步串口(COM1,COM2)的&quot;异步PPP&quot;支持. PPPoE ADSL 使用的就是这个.不能与下面的CONFIG_PPP_SYNC_TTY同时并存.</p>
</li>
<li>
<p>PPP support for sync tty ports
CONFIG_PPP_SYNC_TTY</p>
<p>基于同步tty设备(比如SyncLink适配器)的&quot;同步PPP&quot;支持.常用于高速租用线路(比如T1/E1).不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SLIP (serial line) support
CONFIG_SLIP</p>
<p>一个在串行线上(例如电话线)传输IP数据报的TCP/IP协议.最原始的通过电话线拨号上网就用这个协议,如今基本绝迹了.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>CSLIP compressed headers
CONFIG_SLIP_COMPRESSED</p>
<p>CSLIP协议基于SLIP,但比SLIP快,它将TCP/IP头(而非数据)进行压缩传送,需要通信双方的支持才有效</p>
</li>
<li>
<p>Keepalive and linefill
CONFIG_SLIP_SMART</p>
<p>让SLIP驱动支持RELCOM linefill和keepalive监视,这在信号质量比较差的模拟线路上是个好主意</p>
</li>
<li>
<p>Six bit SLIP encapsulation
CONFIG_SLIP_MODE_SLIP6</p>
<p>这种线路非常罕见,选&quot;N&quot;.</p>
</li>
<li>
<p>USB Network Adapters</p>
<p>USB网络适配器</p>
</li>
<li>
<p>Wireless LAN
CONFIG_WLAN</p>
<ul>
<li><a href="http://wireless.kernel.org/en/users/Drivers">无线网卡</a></li>
<li>
<ul>
<li>
<ul>
<li>{省略的部分请按照实际的硬件状况进行选择,这里仅以Intel公司的主流无线网卡为例进行说明}</li>
<li>Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate-N (iwlwifi)
CONFIG_IWLWIFI</li>
</ul>
<!---->
<ul>
<li>这是目前主流Intel无线网卡的驱动.此驱动依赖于<a href="http://intellinuxwireless.org/">二进制uCode微代码</a>,它通常被安装到&quot;/lib/firmware&quot;目录,不过你最好亲自用眼睛检查一下&quot;/etc/hotplug/firmware.agent&quot;脚本中的&quot;FIRMWARE_DIR&quot;变量的设置是否正确.</li>
<li>
<ul>
<li>
<p>Intel Wireless WiFi DVM Firmware support
CONFIG_IWLDVM</p>
<p>DVM固件支持(这也是当前唯一可用的固件).选&quot;Y/M&quot;.</p>
</li>
<li>
<p>Intel Wireless WiFi MVM Firmware support
CONFIG_IWLMVM</p>
<p>MVM固件支持(这是专用于7000系列无线网卡的固件).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Debugging Options</p>
<p>仅供调试使用,其下所有选项都选&quot;N&quot;.</p>
</li>
<li>
<p>iwlwifi experimental P2P support
CONFIG_IWLWIFI_P2P</p>
<p>iwlwifi驱动实验性的P2P支持.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>WiMAX Wireless Broadband devices</p>
<p>WiMAX无线设备</p>
</li>
<li>
<p>Wan interfaces support
CONFIG_WAN</p>
<p><a href="http://baike.baidu.com/view/21956.htm">广域网</a>(Wide Area Network)网卡支持.这种网卡很罕见.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IEEE 802.15.4 drivers
CONFIG_IEEE802154_DRIVERS</p>
<p><a href="http://baike.baidu.com/view/1915042.htm">IEEE 802.15.4</a>描述了低速率无线个人局域网的物理层和媒体接入控制协议</p>
</li>
<li>
<p>Xen network device frontend driver
CONFIG_XEN_NETDEV_FRONTEND</p>
<p>XEN半虚拟化网络设备前端驱动(通常是被&quot;domain 0&quot;导出的)</p>
</li>
<li>
<p>Xen backend network device
CONFIG_XEN_NETDEV_BACKEND</p>
<p>XEN半虚拟化网络设备后端驱动,通常被用在&quot;domain 0&quot;内核上,用于向其他domain导出半虚拟化网络设备.</p>
</li>
<li>
<p>VMware VMXNET3 ethernet driver
CONFIG_VMXNET3</p>
<p>VMware vmxnet3 虚拟以太网卡驱动</p>
</li>
<li>
<p>Microsoft Hyper-V virtual network driver
CONFIG_HYPERV_NET</p>
<p>Microsoft <a href="http://baike.baidu.com/view/1359943.htm">Hyper-V</a> 虚拟以太网卡驱动</p>
</li>
<li>
<p>ISDN support
CONFIG_ISDN</p>
<p>上世纪在ADSL流行之前曾经有过短暂流行,但现在已经绝迹了</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Input device support</p>
<ul>
<li>输入设备</li>
<li>
<ul>
<li>
<p>Generic input layer (needed for keyboard, mouse, &hellip;)
CONFIG_INPUT</p>
<ul>
<li>通用输入层.只要你有任何输入设备(键盘,鼠标,手写板,触摸板,游戏杆,方向盘,游戏键盘&hellip;),就必须选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Support for memoryless force-feedback devices
CONFIG_INPUT_FF_MEMLESS</p>
<p>游戏玩家使用的<a href="http://baike.baidu.com/view/351163.htm">力反馈</a>设备,例如: <a href="http://www.chiphell.com/forum.php?mod=viewthread&amp;tid=94160">Logitech WingMan Force 3D 飞行摇杆</a>,<a href="http://www.dansdata.com/images/tmsticks/fsdp480.jpg">ThrustMaster FireStorm Dual Power 2</a>.如果你有此类设备,除了本项之外,还需要开启特定于硬件的驱动.</p>
</li>
<li>
<p>Polled input device skeleton
CONFIG_INPUT_POLLDEV</p>
<p>使用轮询机制的输入设备支持,此项主要是为源码树之外的驱动准备的,内核自带的驱动若有需要会自动选中.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Sparse keymap support library
CONFIG_INPUT_SPARSEKMAP</p>
<p>使用&quot;sparse keymap&quot;的输入设备支持,此项主要是为源码树之外的驱动准备的,内核自带的驱动若有需要会自动选中.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Matrix keymap support library
CONFIG_INPUT_MATRIXKMAP</p>
<p>使用&quot;matrix keymap&quot;的输入设备支持,此项主要是为源码树之外的驱动准备的,内核自带的驱动若有需要会自动选中.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Mouse interface
CONFIG_INPUT_MOUSEDEV</p>
<ul>
<li>鼠标接口(/dev/input/mouseX,/dev/input/mice).用鼠标的必选.[提示]如果系统上有多个鼠标,那么,mouseX对应单个特定的鼠标,而mice则是所有鼠标的集合(所有鼠标的事件都会被发送到这个设备文件中).</li>
<li>
<ul>
<li>
<p>Provide legacy /dev/psaux device
CONFIG_INPUT_MOUSEDEV_PSAUX</p>
<p>仍然支持传统的/dev/psaux接口,这是为兼容老旧的程序而设置.选&quot;N&quot;.</p>
</li>
<li>
<p>Horizontal screen resolution
CONFIG_INPUT_MOUSEDEV_SCREEN_X</p>
<p>作为鼠标使用的数字化转换器(digitizer)或<a href="http://www.youliv.com/products/700187.aspx">手写板</a>(graphic tablet)需要知道X window的水平分辩率.一般可理解为显示屏的水平分辨率.</p>
</li>
<li>
<p>Vertical screen resolution
CONFIG_INPUT_MOUSEDEV_SCREEN_Y</p>
<p>作为鼠标使用的数字化转换器(digitizer)或<a href="http://www.zgcprice.org/pic/multipic/l/041500555/0415005550031_634109858768281250.jpg">手写板</a>(graphic tablet)需要知道X window的垂直分辩率.一般可理解为显示屏的垂直分辨率.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Joystick interface
CONFIG_INPUT_JOYDEV</p>
<p>游戏杆(<a href="http://en.wikipedia.org/wiki/Joystick">joystick</a>)和游戏键盘(<a href="http://en.wikipedia.org/wiki/Gamepad">gamepad</a>)支持(/dev/input/jsX)</p>
</li>
<li>
<p>Event interface
CONFIG_INPUT_EVDEV</p>
<p>将所有的输入设备事件都通过&quot;/dev/input/eventX&quot;以一种通用的方式进行处理.Xorg需要使用此接口.不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>Event debugging
CONFIG_INPUT_EVBUG</p>
<p>将所有输入设备的动作(键盘按下,鼠标移动等)都记录到系统日志当中.主要用于调试,同时也会带来安全漏洞(键盘输入中很可能包含你的密码).选&quot;N&quot;.</p>
</li>
<li>
<p>Keyboards
CONFIG_INPUT_KEYBOARD</p>
<ul>
<li>键盘驱动</li>
<li>
<ul>
<li>
<p>AT keyboard
CONFIG_KEYBOARD_ATKBD</p>
<p>标准AT键盘或者<a href="http://baike.baidu.com/view/1110237.htm">PS/2</a>键盘.[提示]除了台式机PS/2接口上的键盘外,许多笔记本的键盘其实也是PS/2键盘.使用USB键盘或者ADB键盘(旧式苹果键盘)的可以选&quot;N&quot;.</p>
</li>
<li>
<p>{此处被省略的键盘都很罕见,基本上不必考虑}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Mice
CONFIG_INPUT_MOUSE</p>
<ul>
<li>鼠标驱动</li>
<li>
<ul>
<li>
<p>PS/2 mouse
CONFIG_MOUSE_PS2</p>
<p>标准的两键或三键的<a href="http://zh.wikipedia.org/wiki/PS/2%E6%8E%A5%E5%8F%A3">PS/2</a>鼠标,同时兼容Microsoft/Logitech/Genius生产的带有滚轮或者额外按键的PS/2鼠标.使用Synaptics/ALPS/Elantech触摸板的用户还可以看看其<a href="http://xorg.freedesktop.org/archive/individual/driver/">专用的X驱动</a>,这些驱动可以提供更多的高级功能.使用USB鼠标的可以选&quot;N&quot;.其下的子项是针对各厂商特定产品的扩展协议支持.按需选择即可.[提示]除了台式机PS/2接口上的鼠标外,许多笔记本的触摸板其实也是PS/2鼠标.</p>
</li>
<li>
<p>{此处被省略的鼠标都很罕见,基本上不必考虑}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Joysticks/Gamepads</p>
<p>游戏杆,6自由度摇杆,游戏键盘,方向盘,射击武器&hellip;等各种游戏装置</p>
</li>
<li>
<p>Tablets
CONFIG_INPUT_TABLET</p>
<p>平板输入设备</p>
</li>
<li>
<p>Touchscreens
CONFIG_INPUT_TOUCHSCREEN</p>
<p>触摸屏输入设备</p>
</li>
<li>
<p>Miscellaneous devices
CONFIG_INPUT_MISC</p>
<ul>
<li>其他杂项输入设备</li>
<li>
<ul>
<li>
<p>PC Speaker support
CONFIG_INPUT_PCSPKR</p>
<p>标准<a href="http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html">蜂鸣器</a>.建议开启.</p>
</li>
<li>
<p>{此处被省略的其他设备都很罕见,基本上不必考虑}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hardware I/O ports</p>
<ul>
<li>硬件I/O端口</li>
<li>
<ul>
<li>
<p>Serial I/O support
CONFIG_SERIO</p>
<ul>
<li>串行I/O硬件支持.标准AT键盘,PS/2鼠标,串口鼠标,Sun键盘,游戏杆,6自由度摇杆等设备都依赖于它.不确定的选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>i8042 PC Keyboard controller
CONFIG_SERIO_I8042</p>
<p>标准AT键盘,PS/2鼠标,这两种设备需要它的支持.</p>
</li>
<li>
<p>Serial port line discipline
CONFIG_SERIO_SERPORT</p>
<p>RS232串口(COM).串口鼠标,游戏杆,6自由度摇杆等设备都依赖于它.</p>
</li>
<li>
<p>ct82c710 Aux port controller
CONFIG_SERIO_CT82C710</p>
<p>一种德州仪器TravelMate笔记本上使用QuickPort接口的鼠标</p>
</li>
<li>
<p>Parallel port keyboard adapter
CONFIG_SERIO_PARKBD</p>
<p>并口键盘适配器,用于将AT/XT键盘或PS/2鼠标转接到并口上.非常罕见.</p>
</li>
<li>
<p>PCI PS/2 keyboard and PS/2 mouse controller
CONFIG_SERIO_PCIPS2</p>
<p>接在移动式扩展坞(Docking station)上的PS/2键盘或鼠标</p>
</li>
<li>
<p>PS/2 driver library
CONFIG_SERIO_LIBPS2</p>
<p>为PS/2接口上的设备提供驱动(比如PS/2鼠标和标准AT键盘)</p>
</li>
<li>
<p>Raw access to serio ports
CONFIG_SERIO_RAW</p>
<p>以raw方式访问serio接口(echo -n &ldquo;serio_raw&rdquo; &gt; /sys/bus/serio/devices/serioX/drvctl),例如i8042键盘控制器的AUX端口.看不懂的就别选了.</p>
</li>
<li>
<p>Altera UP PS/2 controller
CONFIG_SERIO_ALTERA_PS2</p>
<p>Altera University Program PS/2 端口支持.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>TQC PS/2 multiplexer
CONFIG_SERIO_PS2MULT</p>
<p>TQC板上的PS/2端口复用器(multiplexer)</p>
</li>
<li>
<p>ARC PS/2 support
CONFIG_SERIO_ARC_PS2</p>
<p>ARC FPGA 平台上的PS/2控制器</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Gameport support
CONFIG_GAMEPORT</p>
<p>15针电脑游戏接口(<a href="http://en.wikipedia.org/wiki/Game_port">Gameport</a>).<a href="http://content.answcdn.com/main/content/img/CDE/_PCPORTS.JPG">图</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Character devices</p>
<ul>
<li><a href="http://baike.baidu.com/view/1913432.htm">字符设备</a></li>
<li>
<ul>
<li>
<p>Enable TTY
CONFIG_TTY</p>
<ul>
<li>字符终端和串口都需要<a href="http://baike.baidu.com/view/749979.htm">TTY</a>的支持.选&quot;Y&quot;,除非你知道自己在干什么.[提示]你想<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-termi-hanzi/index.html">在控制台上显示汉字</a>吗?试试<a href="https://blog.xind.in/blog/2013/01/22/cjktty-kernel-patch-for-linux-console-with-cjk-characters-support/">CJKTTY</a>补丁吧!</li>
<li>
<ul>
<li>
<p>Virtual terminal
CONFIG_VT</p>
<ul>
<li><a href="http://baike.baidu.com/view/694267.htm">虚拟终端</a>可以在一个物理终端设备上虚拟出多个&quot;显示器+键盘&quot;的组合(可以使用&quot;Alt+Fn&quot;组合键在多个虚拟终端间切换).除非是嵌入式系统,否则必选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Enable character translations in console
CONFIG_CONSOLE_TRANSLATIONS</p>
<p>在虚拟控制台(console)上支持字体映射和Unicode转换.建议选&quot;Y&quot;.</p>
</li>
<li>
<p>Support for console on virtual terminal
CONFIG_VT_CONSOLE</p>
<p>内核默认将第一个虚拟终端(/dev/tty0)用作系统控制台(可以通过&quot;console=tty3&quot;这样的参数去修改),将诸如模块错误/内核错误/启动信息之类的警告信息发送到这里,而且以单用户模式登录时也需要使用这个控制台.除非是嵌入式系统,否则必选&quot;Y&quot;.</p>
</li>
<li>
<p>Support for binding and unbinding console drivers
CONFIG_VT_HW_CONSOLE_BINDING</p>
<p>虚拟终端是通过控制台驱动程序与物理终端交互的,但在某些系统上可以使用多个控制台驱动程序(如framebuffer控制台驱动程序),该选项使得你可以选择其中之一.如果你需要使用多个控制台驱动,可以选&quot;Y&quot;,不确定的选&quot;N&quot;.参见&quot;<a href="http://lxr.linux.no/linux/Documentation/console/console.txt">Documentation/console/console.txt</a>&ldquo;和&rdquo;<a href="http://lxr.linux.no/linux/Documentation/fb/fbcon.txt">Documentation/fb/fbcon.txt</a>&ldquo;获取更多细节.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Unix98 PTY support
CONFIG_UNIX98_PTYS</p>
<ul>
<li>伪终端(PTY)是指一个&quot;软件终端&rdquo;,它是由slave(等价于一个物理终端)和master(被一个诸如xterms之类的进程用来读写slave设备)两部分组成的软设备.需要使用telnet或ssh远程登录者必选.</li>
<li>
<ul>
<li>
<p>Support multiple instances of devpts
CONFIG_DEVPTS_MULTIPLE_INSTANCES</p>
<p>允许多个&quot;devpts&quot;文件系统实例(使用&quot;-o newinstance&quot;挂载选项),以允许相互隔离的PTY命名空间(比如在虚拟化容器中).不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Legacy (BSD) PTY support
CONFIG_LEGACY_PTYS</p>
<p>使用过时的BSD风格的/dev/ptyxx作为master,/dev/ttyxx作为slave,这个方案有一些安全问题,选&quot;N&quot;.</p>
</li>
<li>
<p>Non-standard serial port support
CONFIG_SERIAL_NONSTANDARD</p>
<p>非标准串口支持.这样的设备非常罕见,选&quot;N&quot;.</p>
</li>
<li>
<p>HSDPA Broadband Wireless Data Card - Globe Trotter
CONFIG_NOZOMI</p>
<p>一种PCMCIA接口的<a href="http://baike.baidu.com/view/10159.htm">HSDPA</a>(WCDMA) 3G 无线上网卡</p>
</li>
<li>
<p>Multi-Tech multiport card support
CONFIG_ISI</p>
<p><a href="http://www.multi-tech.com.hk/">Multi-Tech</a>公司生产的多端口卡(拥有多个串口)实验性支持.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>HDLC line discipline support
CONFIG_N_HDLC</p>
<p>Microgate SyncLink.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>GSM MUX line discipline support
CONFIG_N_GSM</p>
<p>GSM MUX(多路复用器)支持.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Trace data router for MIPI P1149.7 cJTAG standard
CONFIG_TRACE_ROUTER</p>
<p>仅用于调试内含modem设备的手机系统.</p>
</li>
<li>
<p>Trace data sink for MIPI P1149.7 cJTAG standard
CONFIG_TRACE_SINK</p>
<p>仅用于调试内含modem设备的手机系统.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>KCopy</p>
<ul>
<li>内核Copy</li>
<li>
<ul>
<li>
<p>Memory-to-memory copies using kernel assist
CONFIG_KCOPY</p>
<p>高性能的进程间内存复制(可以减少一次向共享内存的复制动作).主要用于高性能并行计算领域,比如基于<a href="http://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E5%82%B3%E9%81%9E%E4%BB%8B%E9%9D%A2">消息传递接口</a>(<a href="http://wenku.baidu.com/view/ee8bf3390912a216147929f3.html">Message Passing Interface</a>)协议的开发的并行程序.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>/dev/kmem virtual device support
CONFIG_DEVKMEM</p>
<p>&ldquo;/dev/kmem&quot;虚拟设备是内核看到的虚拟内存的全镜像,可以用来访问内核内存.一般可以用来查看内核变量或者用作rootkit之类(!危险!).仅供调试,不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Serial drivers</p>
<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串口</a>(COM)驱动.串口在台式机主板上正在逐渐消亡,而在笔记本和服务器上早就已经绝迹了.大多数人应该将所有子项都选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>8250/16550 and compatible serial support
CONFIG_SERIAL_8250</p>
<ul>
<li>这是标准<a href="http://zh.wikipedia.org/zh-cn/%E4%B8%B2%E8%A1%8C%E7%AB%AF%E5%8F%A3">串口(COM)</a>驱动.只要你想使用串口,就必选此项.不过,大多数人应该选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Support 8250_core.* kernel options
CONFIG_SERIAL_8250_DEPRECATED_OPTIONS</p>
<p>选&quot;N&quot;.</p>
</li>
<li>
<p>8250/16550 PNP device support
CONFIG_SERIAL_8250_PNP</p>
<p>即插即用串口支持,不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>Console on 8250/16550 and compatible serial port
CONFIG_SERIAL_8250_CONSOLE</p>
<p>将串口当做系统控制台(接受所有内核消息,单用户模式登录)使用(需要使用&quot;console=ttyS1&quot;参数).仅在没有显示接口嵌入式设备上有用.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DMA support for 16550 compatible UART controllers
CONFIG_SERIAL_8250_DMA</p>
<p>与标准8250/16650兼容的<a href="http://baike.baidu.com/view/245027.htm">通用异步收发传输器</a>(<a href="http://zh.wikipedia.org/wiki/UART">Universal Asynchronous Receiver/Transmitter</a>)的<a href="http://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96">DMA</a>支持.在嵌入式设计中,UART用来主机与辅助设备通信,如汽车音响与外接AP之间的通信,与PC机通信包括与监控调试器和其它器件(如EEPROM)通信.不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>8250/16550 PCI device support
CONFIG_SERIAL_8250_PCI</p>
<p>PCI串口支持.选&quot;N&quot;表示仅支持传统的标准串口.</p>
</li>
<li>
<p>8250/16550 PCMCIA device support
CONFIG_SERIAL_8250_CS</p>
<p>16-bit PCMCIA串口支持.选&quot;N&quot;表示仅支持传统的标准串口.</p>
</li>
<li>
<p>Maximum number of 8250/16550 serial ports
CONFIG_SERIAL_8250_NR_UARTS</p>
<p>允许的最大串口数量,保持默认值即可.</p>
</li>
<li>
<p>Number of 8250/16550 serial ports to register at runtime
CONFIG_SERIAL_8250_RUNTIME_UARTS</p>
<p>内核在启动时注册的串口数量(可以通过&quot;8250.nr_uarts&quot;参数修改),保持默认即可.</p>
</li>
<li>
<p>Extended 8250/16550 serial driver options
CONFIG_SERIAL_8250_EXTENDED</p>
<ul>
<li>非标准的串口驱动选项(例如HUB6,中断共享,多端口,超过4个COM口).不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Support more than 4 legacy serial ports
CONFIG_SERIAL_8250_MANY_PORTS</p>
<p>如果你的板子上有超过4个COM接口就选&quot;Y&quot;.</p>
</li>
<li>
<p>Support for sharing serial interrupts
CONFIG_SERIAL_8250_SHARE_IRQ</p>
<p>有些板子上集成了共享IRQ的硬件支持.如果有就选&quot;Y&quot;.</p>
</li>
<li>
<p>Autodetect IRQ on standard ports (unsafe)
CONFIG_SERIAL_8250_DETECT_IRQ</p>
<p>让内核去猜串口的IRQ号.不安全,选&quot;N&quot;.</p>
</li>
<li>
<p>Support RSA serial ports
CONFIG_SERIAL_8250_RSA</p>
<p>RSA串口.看不懂的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support for Synopsys DesignWare 8250 quirks
CONFIG_SERIAL_8250_DW</p>
<p>Synopsys DesignWare APB UART 中非标准特性的支持.</p>
</li>
<li>
<p>Medfield High Speed UART support
CONFIG_SERIAL_MFD_HSU</p>
<p><a href="http://baike.baidu.com/view/5112631.htm">Medfield</a>是Intel以x86为架构开发的SoC手机芯片.</p>
</li>
<li>
<p>{此处被省略的都是非标准的串口设备,按实际情况选择即可}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TTY driver to output user messages via printk
CONFIG_TTY_PRINTK</p>
<p>通过&quot;/dev/ttyprintk&quot;设备使用printk发送用户消息.用于在内核中嵌入用户消息.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Parallel printer support
CONFIG_PRINTER</p>
<p>并口打印机</p>
</li>
<li>
<p>Support for user-space parallel port device drivers
CONFIG_PPDEV</p>
<p>用户空间的原始并口设备(/dev/parportN)支持,这样用户空间的程序就可以用原始模式直接访问并口(相当于并口版本的CONFIG_CHR_DEV_SG).并口打印机/CD-ROM/硬盘都不依赖于此项,所以大部分人可以关闭该选项.</p>
</li>
<li>
<p>Xen Hypervisor Console support
CONFIG_HVC_XEN</p>
<ul>
<li>XEN虚拟控制台设备驱动</li>
<li>
<ul>
<li>
<p>Xen Hypervisor Multiple Consoles support
CONFIG_HVC_XEN_FRONTEND</p>
<p>如果你需要多个虚拟控制台,可以选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Virtio console
CONFIG_VIRTIO_CONSOLE</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>虚拟控制台设备驱动.此外,该驱动还可以作为普通的串口设备(/dev/vportNpX),用于客户机和宿主机之间的通信.<a href="http://www.linux-kvm.org/page/Virtio">Virtio</a>的目标是为各种半虚拟化的<a href="http://www.ibm.com/developerworks/cn/linux/l-hypervisor/">虚拟机管理程序</a>(特别是<a href="http://smilejay.com/kvm_theory_practice/">KVM</a>)提供一组通用的模拟设备.</p>
</li>
<li>
<p>IPMI top-level message handler
CONFIG_IPMI_HANDLER</p>
<ul>
<li><a href="http://blog.csdn.net/yuxiaohui78/article/details/7585280">智能平台管理接口</a>(<a href="http://baike.baidu.com/view/1595174.htm">Intelligent Platform Management Interface</a>)是标准的传感器(温度,电压,风扇,电源,机箱入侵)管理规范.IPMI的核心是专用的基板管理控制器(BMC)硬件,BMC并不依赖于服务器的CPU/BIOS/OS,是一个独立在系统内运行的管理子系统,只要有BMC与IPMI固件便可工作.BMC通常是一个安装在服务器主板上的独立的板卡(也有少数服务器主板内置).IPMI良好的独立特性便克服了以往基于操作系统的管理方式所受的限制,例如操作系统不响应或未加载的情况下,仍然可以进行开关机等操作.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/IPMI.txt">Documentation/IPMI.txt</a>&ldquo;文档.此项技术主要用于服务器领域,个人PC和笔记本上是没有的.</li>
<li>
<ul>
<li>
<p>Generate a panic event to all BMCs on a panic
CONFIG_IPMI_PANIC_EVENT</p>
<ul>
<li>当内核panic(发生紧急情况)时,IPMI消息处理器将会向每一个已注册的底板管理控制器(BMC)接口生成一个描述该panic的IPMI事件,这些事件可以引发日志记录/报警/重启/关机等动作.</li>
<li>
<ul>
<li>
<p>Generate OEM events containing the panic string
CONFIG_IPMI_PANIC_STRING</p>
<p>当发生紧急情况(panic)时,IPMI消息处理器将会产生OEM类型(f0)的事件</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Device interface for IPMI
CONFIG_IPMI_DEVICE_INTERFACE</p>
<p>为IPMI消息处理器提供一个IOCTL接口以便用户空间进程也可以使用IPMI,目前支持 poll() 和 select()</p>
</li>
<li>
<p>IPMI System Interface handler
CONFIG_IPMI_SI</p>
<p>向系统提供接口(KCS,SMIC),建议选&quot;Y&rdquo;.</p>
</li>
<li>
<p>IPMI Watchdog Timer
CONFIG_IPMI_WATCHDOG</p>
<p>启用IPMI Watchdog定时器.如果硬件有这种功能,推荐选&quot;Y&quot;.</p>
</li>
<li>
<p>IPMI Poweroff
CONFIG_IPMI_POWEROFF</p>
<p>允许通过IPMI消息处理器关闭机器</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hardware Random Number Generator Core support
CONFIG_HW_RANDOM</p>
<ul>
<li>硬件随机数发生器设备(/dev/hw_random)支持.此设备并不会直接向内核的随机数发生器填充(这是&quot;<a href="http://linux.die.net/man/8/rngd">rngd</a>&ldquo;守护进程的职责).详情参见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/hw_random.txt">Documentation/hw_random.txt</a>&ldquo;文档.不确定的选&quot;Y&rdquo;.</li>
<li>
<ul>
<li>
<p>Timer IOMEM HW Random Number Generator support
CONFIG_HW_RANDOM_TIMERIOMEM</p>
<p>Technologic Systems 的TS-7800单板计算机,这是一个嵌入式设备.</p>
</li>
<li>
<p>Intel HW Random Number Generator support
CONFIG_HW_RANDOM_INTEL</p>
<p>Intel基于i8xx芯片组的硬件随机数发生器</p>
</li>
<li>
<p>AMD HW Random Number Generator support
CONFIG_HW_RANDOM_AMD</p>
<p>AMD基于76x芯片组的硬件随机数发生器</p>
</li>
<li>
<p>Atmel Random Number Generator support
CONFIG_HW_RANDOM_ATMEL</p>
<p>Atmel AT91 硬件随机数发生器</p>
</li>
<li>
<p>VIA HW Random Number Generator support
CONFIG_HW_RANDOM_VIA</p>
<p>VIA芯片组的硬件随机数发生器</p>
</li>
<li>
<p>VirtIO Random Number Generator support
CONFIG_HW_RANDOM_VIRTIO</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>虚拟的硬件随机数发生器</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>EXYNOS HW random number generator support
CONFIG_HW_RANDOM_EXYNOS</p>
<p>基于<a href="http://baike.baidu.com/view/5821967.htm">EXYNOS</a>的SOC嵌入式系统上的硬件随机数发生器</p>
</li>
<li>
<p>TPM HW Random Number Generator support
CONFIG_HW_RANDOM_TPM</p>
<p><a href="http://baike.baidu.com/view/1130324.htm">可信赖平台模块</a>(<a href="http://baike.baidu.com/view/687208.htm">Trusted Platform Module</a>)提供的硬件随机数发生器</p>
</li>
<li>
<p>/dev/nvram support
CONFIG_NVRAM</p>
<p>直接存取主板上&quot;CMOS RAM&quot;的接口,太危险!建议选&quot;N&quot;.</p>
</li>
<li>
<p>Siemens R3964 line discipline
CONFIG_R3964</p>
<p>与使用西门子R3964协议的设备同步通信,除非你有一些诸如PLC之类的特殊设备,否则别选</p>
</li>
<li>
<p>Applicom intelligent fieldbus card support
CONFIG_APPLICOM</p>
<p>Applicom international公司生产的用于现场总线(fieldbus)的连接卡.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>PCMCIA character devices</p>
<p>PCMCIA接口的字符设备</p>
</li>
<li>
<p>ACP Modem (Mwave) support
CONFIG_MWAVE</p>
<p>IBM Thinkpad上的一种软猫,古董产品</p>
</li>
<li>
<p>RAW driver (/dev/raw/rawN)
CONFIG_RAW_DRIVER</p>
<p><a href="http://czmmiao.iteye.com/blog/1587170">裸设备</a>的含义是将一个原始块设备(可以是一整块磁盘,也可以是一个分区)当做一个线性的字节流来访问.它是一种没有经过格式化,不经过操作系统缓存,也不能通过文件系统来访问的特殊字符设备.与FreeBSD不同,Linux反对使用裸设备,且被列入了废除计划(建议的做法是使用&quot;O_DIRECT&quot;标志打开对应的块设备文件,例如&quot;/dev/hda1&quot;).不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>HPET - High Precision Event Timer
CONFIG_HPET</p>
<ul>
<li>高精度事件定时器(<a href="http://en.wikipedia.org/wiki/High_Precision_Event_Timer">HPET Timer</a>),又被称为&quot;Multimedia Timer&quot;,是一种取代传统&quot;ACPI Timer&quot;(CONFIG_X86_PM_TIMER)的硬件时钟发生器,提供14.31818MHz固定频率.2007年以后的芯片组一般都支持(有的主板还需要在BIOS里面明确开启HPET支持),建议开启.</li>
<li>
<ul>
<li>
<p>Allow mmap of HPET
CONFIG_HPET_MMAP</p>
<p>允许对HPET寄存器进行映射.但是某些包含HPET硬件寄存器的页中同时还含有其他不该暴露给用户的信息,在此种情况下,需要选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hangcheck timer
CONFIG_HANGCHECK_TIMER</p>
<p>宕机检测定时器周期性地检查系统任务调度程序以确定系统的运行状况,如果超过阈值,计算机将重新启动.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>TPM Hardware Support
CONFIG_TCG_TPM</p>
<ul>
<li>基于硬件的<a href="http://baike.baidu.com/view/1130324.htm">可信赖平台模块</a>(<a href="http://baike.baidu.com/view/687208.htm">Trusted Platform Module</a>),它实际上是一个含有密码运算部件和存储部件的小芯片上的系统,由CPU,存储器,I/O,密码运算器,随机数产生器和嵌入式操作系统等部件组成.使用此功能需要<a href="http://sourceforge.net/projects/trousers/">TrouSerS</a>工具的帮助.</li>
<li>
<ul>
<li>
<p>TPM Interface Specification 1.2 Interface
CONFIG_TCG_TIS</p>
<p>TCG TIS 1.2 TPM 规范支持</p>
</li>
<li>
<p>TPM Interface Specification 1.2 Interface (I2C - Infineon)
CONFIG_TCG_TIS_I2C_INFINEON</p>
<p>仅需要对Infineon的TPM设备选&quot;Y&quot;.</p>
</li>
<li>
<p>National Semiconductor TPM Interface
CONFIG_TCG_NSC</p>
<p>仅需要对National的TPM设备选&quot;Y&quot;.</p>
</li>
<li>
<p>Atmel TPM Interface
CONFIG_TCG_ATMEL</p>
<p>仅需要对Atmel的TPM设备选&quot;Y&quot;.</p>
</li>
<li>
<p>Infineon Technologies TPM Interface
CONFIG_TCG_INFINEON</p>
<p>仅需要对Infineon的TPM设备(SLD 9630 TT 1.1 或 SLB 9635 TT 1.2)选&quot;Y&quot;.此驱动支持的<a href="http://www.trust.rub.de/projects/linux-device-driver-infineon-tpm/">硬件列表</a>.</p>
</li>
<li>
<p>STMicroelectronics ST33 I2C TPM
CONFIG_TCG_ST33_I2C</p>
<p><a href="http://www.st.com/web/cn/home.html">意法半导体</a>(STMicroelectronics)出品的I2C总线的TPM安全芯片.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Telecom clock driver for ATCA SBC
CONFIG_TELCLOCK</p>
<p>没见过这种硬件,选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I2C support
CONFIG_I2C</p>
<ul>
<li>I2C与SMBus支持.I2C(读着&quot;I-squared-C&quot;)是用于<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E7%89%87%E6%9C%BA">单片机</a>(又称&quot;微控制器&quot;)的低速串行总线协议,它为<a href="http://zhidao.baidu.com/question/221932968.html">微控制器</a>(Microcontroller)与各种不同的低速设备通信提供了一种廉价的总线(因为只需要使用两个引脚,称为&quot;2线&quot;),因此广泛的应用于嵌入式环境.<a href="http://baike.baidu.com/view/1835675.htm">SMBus</a>(System Management Bus)差不多相当于是I2C的子集,常用于硬件监控(电压/风扇转速/温度/电池等)以及内存模块的配置(使用I2C EEPROM),因此所有PC主板都依赖于SMBus协议.系统硬件监控工具<a href="http://www.lm-sensors.org/">lm_sensors</a>和<a href="http://www.lm-sensors.org/wiki/I2CTools">i2c-tools</a>依赖于此模块,硬件传感器和&quot;Video For Linux&quot;也需要该模块的支持.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/i2c/summary">Documentation/i2c/summary</a>&ldquo;文档及整个&quot;i2c&quot;文件夹.不确定的选&quot;Y&rdquo;.</li>
<li>
<ul>
<li>
<p>Enable compatibility bits for old user-space
CONFIG_I2C_COMPAT</p>
<p>为了与 lm-sensors 3.1.2 之前的版本兼容而设置.某些2011年之前版本的i2c相关程序也需要此兼容性.</p>
</li>
<li>
<p>I2C device interface
CONFIG_I2C_CHARDEV</p>
<p>I2C设备通常都是由内核控制的,但此选项可以向用户空间提供I2C设备接口,以允许用户空间的程序通过/dev/i2c-*字符设备文件使用I2C总线.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/i2c/dev-interface">Documentation/i2c/dev-interface</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>I2C bus multiplexing support
CONFIG_I2C_MUX</p>
<ul>
<li>多路复用I2C总线支持.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Multiplexer I2C Chip support</p>
<p>I2C多路复用芯片,其下的子项按实际情况选择就OK了</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Autoselect pertinent helper modules
CONFIG_I2C_HELPER_AUTO</p>
<ul>
<li>有一些I2C驱动程序需要&quot;I2C algorithm&quot;的帮助才能工作.而&quot;I2C算法&quot;本质上是I2C接口的纯软件抽象.开启此项后,如有需要,则会自动选上这些算法,而无需你再手动选择.推荐选&quot;Y&quot;.仅在你想使用额外的算法时,才选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>SMBus-specific protocols
CONFIG_I2C_SMBUS</p>
<p>SMBus特有的扩展支持.目前唯一实际支持的扩展是SMBus报警协议.建议选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I2C Algorithms</p>
<p>I2C算法,子项可以全不选,若有其他部分依赖其子项时,会自动选上</p>
</li>
<li>
<p>I2C Hardware Bus support</p>
<ul>
<li>I2C硬件支持</li>
<li>
<ul>
<li>
<p>*** PC SMBus host controller drivers ***</p>
<p>这部分按照主板芯片组的实际情况选择就OK了</p>
</li>
<li>
<p>SMBus Control Method Interface
CONFIG_I2C_SCMI</p>
<p><a href="http://wenku.baidu.com/view/f3e3550a763231126edb112a.html">SMBus控制方法接口</a>(Control Method Interface)是SMBus的ACPI接口.用于在ACPI环境中使用SMBus设备.不确定的选&quot;M&quot;(i2c-scmi).</p>
</li>
<li>
<p>{其余被省略的都是用于嵌入式系统或者额外的I2C/SMBus扩展卡,按实际情况选择即可}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I2C/SMBus Test Stub
CONFIG_I2C_STUB</p>
<p>用于帮助开发SMBus client驱动(特别是某些传感器芯片).详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/i2c/i2c-stub">Documentation/i2c/i2c-stub</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>I2C Core debugging messages
CONFIG_I2C_DEBUG_CORE</p>
<p>向系统日志中传递大量的I2C Core调试信息.仅用于调试I2C设备故障</p>
</li>
<li>
<p>I2C Algorithm debugging messages
CONFIG_I2C_DEBUG_ALGO</p>
<p>向系统日志中传递大量的I2C Algorithm调试信息.仅用于调试I2C设备故障</p>
</li>
<li>
<p>I2C Bus debugging messages
CONFIG_I2C_DEBUG_BUS</p>
<p>向系统日志中传递大量的I2C Bus调试信息.仅用于调试I2C设备故障</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SPI support
CONFIG_SPI</p>
<p>串行外设接口(Serial Peripheral Interface)是一种标准的四线同步双向串行总线.<a href="http://wenku.baidu.com/view/99164c1dfad6195f312ba6e4.html">SPI类似于I2C</a>,但比I2C的&quot;2线&quot;稍微复杂一些,SPI需要4个引脚(&ldquo;4线&rdquo;),不但传输速率比I2C更高,还能实现全双工通信.大多数SPI设备不支持动态设备检测,有些甚至是只读或者只写的.SPI常用于微控制器(Microcontroller)与外围设备(RTC,传感器,EEPROM,FLASH,解/编码器,模数转换器,数字信号处理器)之间的通信,MMC和SD卡也可以通过SPI协议访问,而MMC接口的DataFlash卡则必须通过SPI才能访问.仅用于嵌入式环境,PC平台上没有这样的设备.</p>
</li>
<li>
<p>Qualcomm MSM SSBI bus support
CONFIG_SSBI</p>
<p><a href="http://www.qualcomm.cn/snapdragon/processors">高通(Qualcomm)骁龙</a>系列智能手机处理器内嵌的单线串行总线接口(Single-wire Serial Bus Interface)</p>
</li>
<li>
<p>HSI support
CONFIG_HSI</p>
<p>高速同步串行接口(<a href="http://www.mipi.org/specifications/high-speed-synchronous-serial-interface-hsi">High speed synchronous Serial Interface</a>)是移动产业处理器接口(<a href="http://zh.wikipedia.org/wiki/MIPI">MIPI</a>)联盟的高速同步接口工作组发布的一项技术规范.MIPI(Mobile Industry Processor Interface)是2003年由ARM,Nokia,ST,TI等公司成立的一个联盟,目的是把手机内部的接口(如摄像头,显示屏接口,射频/基带接口等)标准化,从而减少手机设计的复杂程度和增加设计灵活性.MIPI联盟下面有不同的工作组,分别定义了一系列的手机内部接口标准,比如摄像头接口CSI,显示接口DSI,射频接口DigRF,麦克风/扬声器接口SLIMbus等.统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组,更改设计和功能时更加快捷方便.目前,MIPI联盟的董事成员包括英特尔,摩托罗拉,诺基亚,三星,意法半导体,德州仪器.</p>
</li>
<li>
<p>PPS support
CONFIG_PPS</p>
<p>秒脉冲(Pulse Per Second)是GPS天线的一项功能,用于获取GPS卫星的授时.PPS的精度可以到纳秒级,而且没有累积误差.</p>
</li>
<li>
<p>PTP clock support
CONFIG_PTP_1588_CLOCK</p>
<p><a href="http://wenku.baidu.com/view/004716040740be1e650e9a49">精密时间协议</a>(<a href="http://en.wikipedia.org/wiki/Precision_Time_Protocol">Precision Time Protocol</a>)是<a href="http://baike.baidu.com/view/1885838.htm">IEEE 1588</a>定义的一种基于以太网的高精度时间同步协议.PTP采用硬件与软件结合设计,可以提供比纯软件方式的NTP(网络时间协议)高的多的精度(微秒级).与GPS授时相比,在提供和GPS相同的精度情况下,PTP不需要为每个设备安装GPS那样昂贵的组件,只需要一个高精度的本地时钟和提供高精度时钟戳的部件,成本较低.一般的PC和服务器上没有PTP硬件.</p>
</li>
<li>
<p>GPIO Support
CONFIG_GPIOLIB</p>
<ul>
<li>每个芯片都会有至少一个引脚(PIN),像CPU或者芯片组这种复杂的芯片,其引脚会有成白上千个,这些PIN就是芯片与外部沟通的渠道,每个PIN都会有它特定的功能.<a href="http://baike.baidu.com/view/980829.htm">GPIO</a>(<a href="http://en.wikipedia.org/wiki/General-purpose_input/output">General Purpose I/O</a>)就是芯片上的一种通用功能的引脚,其功能可由使用者通过编程的方式自定义(所谓&quot;可编程引脚&quot;),比如使用两条PIN就可以组成I2C,使用4条PIN就可以组成SPI.嵌入式系统经常需要控制结构简单但数量众多的外部设备(比如LED的亮与灭),使用传统的串口或者并口就太&quot;大炮打蚊子&quot;,而GPIO则非常适合用于控制此类数量众多的简单设备.GPIO在嵌入式设备中使用广泛,但PC平台的芯片组大多也集成有GPIO引脚.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/gpio/gpio.txt">Documentation/gpio/gpio.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Debug GPIO calls
CONFIG_DEBUG_GPIO</p>
<p>仅供调试使用</p>
</li>
<li>
<p>/sys/class/gpio/&hellip; (sysfs interface)
CONFIG_GPIO_SYSFS</p>
<p>为GPIO设备添加sysfs接口.主要用于调试和问题排查.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Generic memory-mapped GPIO controller support (MMIO platform device)
CONFIG_GPIO_GENERIC_PLATFORM</p>
<p>这是最简单的GPIO控制器驱动(<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform总线</a>驱动),仅支持单独一个&quot;data&quot;寄存器,用于读/写GPIO的状态.不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>{这里被省略的部分,按主板上实际集成的芯片选择即可}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dallas&rsquo;s 1-wire support
CONFIG_W1</p>
<p>Dallas公司发明的单总线是比I2C更简单的总线,仅使用一个引脚(1-wire),使用Master-Slave结构,用于连接慢速的单引脚设备,比如<a href="http://baike.baidu.com/view/2521664.htm">iButton</a>和热传感器.主要用于嵌入式系统.</p>
</li>
<li>
<p>Power supply class support
CONFIG_POWER_SUPPLY</p>
<ul>
<li>允许用户空间程序通过sysfs/uevent接口对电源(电池,交流电,USB)进行监控.建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Power supply debug
CONFIG_POWER_SUPPLY_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Generic PDA/phone power driver
CONFIG_PDA_POWER</p>
<p>通用的PDA/phone电源切换驱动.用于在内部电池和外部电源(AC/USB)之间进行切换.</p>
</li>
<li>
<p>Generic battery support using IIO
CONFIG_GENERIC_ADC_BATTERY</p>
<p>为使用IIO总线(CONFIG_IIO)的电池提供的通用驱动</p>
</li>
<li>
<p>Test power driver
CONFIG_TEST_POWER</p>
<p>仅供测试使用</p>
</li>
<li>
<p>SBS Compliant gas gauge
CONFIG_BATTERY_SBS</p>
<p>与<a href="http://baike.baidu.com/view/1938623.htm">智能电池系统</a>(<a href="http://www.chinacpec.com/news/display.php?aid=88">Smart Battery System</a>)规范兼容的气压计(集成在电池组中)支持.</p>
</li>
<li>
<p>GPIO charger
CONFIG_CHARGER_GPIO</p>
<p>支持充电器通过GPIO引脚报告其在线状态.</p>
</li>
<li>
<p>Board level reset or power off
CONFIG_POWER_RESET</p>
<p>允许通过操作板载的主电源,关闭或重启整个系统.</p>
</li>
<li>
<p>{这里被省略的部分,按实际电池控制芯片选择即可}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adaptive Voltage Scaling class support
CONFIG_POWER_AVS</p>
<p>自适应电压调节(Adaptive Voltage Scaling)技术能够动态的对设备工作电压进行精细的调整,拥有比<a href="http://baike.baidu.com/view/7861420.htm">DVFS</a>更佳的电力利用效率,是一种降低功耗与优化性能并举的电源与性能管理技术.AVS在OMAP设备上也被称为&quot;<a href="http://yanqin.spaces.eepw.com.cn/articles/article/item/50555">SmartReflex</a>&quot;.目前仅用于嵌入式领域.</p>
</li>
<li>
<p>Hardware Monitoring support
CONFIG_HWMON</p>
<ul>
<li>当前主板大多都有一个监控硬件温度/电压/风扇转速等状况的设备,请按照主板实际使用的芯片选择相应的子项.如果你不知道究竟需要使用哪个驱动,可以使用<a href="http://www.coreboot.org/Superiotool">Superiotool</a>和<a href="http://www.lm-sensors.org/wiki/man/sensors-detect">sensors-detect</a>工具进行检测.另外,该功能还需要CONFIG_I2C的支持.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/hwmon/userspace-tools">Documentation/hwmon/userspace-tools</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Hardware Monitoring Chip debugging messages
CONFIG_HWMON_DEBUG_CHIP</p>
<p>在系统日志中输出大量的I2C调试信息,仅用于故障调试</p>
</li>
<li>
<ul>
<li>{被省略的部分,按实际的硬件监控芯片选择即可}</li>
<li>GPIO fan
CONFIG_SENSORS_GPIO_FAN</li>
</ul>
<p>连接在GPIO引脚上的风扇</p>
</li>
<li>
<p>PMBus support
CONFIG_PMBUS</p>
<p><a href="http://baike.baidu.com/view/2526981.htm">电源管理总线</a>(Power Management Bus)是一种基于SMBus(CONFIG_I2C)的开放标准的数字电源管理协议,可以用于配置/监控/操作电源变换器,目前全球有<a href="http://smiforum.org/members.html">超过40个IC厂商</a>提供<a href="http://pmbus.org/products.html">满足PMBus标准的产品</a>.最新的<a href="http://pmbus.org/docs/20130815PMBus+(tm)_PLUS_Announce.pdf">PMBus+ 1.3</a>标准增加AVS(CONFIG_POWER_AVS)支持,可以动态控制设备的工作电压.根据你的实际硬件状况选择子项.</p>
</li>
<li>
<p>ACPI 4.0 power meter
CONFIG_SENSORS_ACPI_POWER</p>
<p>将<a href="http://www.acpi.info/">ACPI</a> 4.0(2009年6月发布)中定义的瓦特表(用于测量功耗)当做硬件监控设备导出到用户空间.需要固件支持ACPI 4.0规范,并且有一个瓦特表.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>ASUS ATK0110
CONFIG_SENSORS_ATK0110</p>
<p>许多华硕主板都有这种ACPI硬件监控接口.此驱动可以通过主板固件读取风扇/电压/温度信息.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Generic Thermal sysfs driver
CONFIG_THERMAL</p>
<ul>
<li>为ACPI规范中定义的&quot;thermal&quot;(发热控制)提供一个通用的sysfs接口,以方便与诸如温度传感器和风扇之类的设备通信.由于目前所有PC和服务器都已支持ACPI,并且发热控制也越来越重要,所以建议选&quot;Y&quot;.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/thermal/sysfs-api.txt">Documentation/thermal/sysfs-api.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Default Thermal governor</p>
<p>选择默认的热调节器,建议选&quot;step_wise&rdquo;.</p>
</li>
<li>
<p>Fair-share thermal governor
CONFIG_THERMAL_GOV_FAIR_SHARE</p>
<p>此调节器根据设备对所属区域的&quot;贡献&quot;(contribution)进行调节.</p>
</li>
<li>
<p>Step_wise thermal governor
CONFIG_THERMAL_GOV_STEP_WISE</p>
<p>此调节器以线性方式进行调节,也就是每次调节都只在紧邻的两档之间进行切换.</p>
</li>
<li>
<p>User_space thermal governor
CONFIG_THERMAL_GOV_USER_SPACE</p>
<p>此调节器让用户空间程序去决定如何调节</p>
</li>
<li>
<p>generic cpu cooling support
CONFIG_CPU_THERMAL</p>
<p>通用的CPU降温机制(通过降低频率来实现,而不是通过ACPI接口).显然通过ACPI接口是更好的机制,所以建议选&quot;N&quot;.</p>
</li>
<li>
<p>Thermal emulation mode support
CONFIG_THERMAL_EMULATION</p>
<p>&ldquo;Thermal&quot;模拟.仅供调试使用,切勿用于生产系统!!</p>
</li>
<li>
<p>Intel PowerClamp idle injection driver
CONFIG_INTEL_POWERCLAMP</p>
<p>Intel <a href="http://lwn.net/Articles/528124/">PowerClamp</a> 驱动通过利用<a href="http://zh.wikipedia.org/wiki/Intel_Nehalem">Nehalem</a>之后的CPU支持的&quot;package-level C-state&quot;特性,强制为在线的CPU注入&quot;idle&quot;指令(通过&rdquo;/sys/class/thermal/&ldquo;接口设定&quot;idle&quot;百分比),以确保CPU的功耗不会超过特定的阈值(发热量也就不会超过特定的阈值).这样刻意的降低系统性能峰值还有一个好处,那就是相对于传统的动态频率调节技术而言,能够达到更高的每瓦特性能.详见<a href="http://lxr.linux.no/linux/Documentation/thermal/intel_powerclamp.txt">Documentation/thermal/intel_powerclamp.txt</a>文档.如果你对节能和限制发热量特别在意,同时又不在乎系统峰值性能的降低,可以选&quot;Y&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Watchdog Timer Support
CONFIG_WATCHDOG</p>
<ul>
<li>选&quot;Y&quot;并选中下面相应的驱动之后,再创建一个主/次设备号为10/130的字符设备&quot;/dev/watchdog&quot;,即可拥有一只<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-watchdog/">看门狗</a>.其工作原理是:当/dev/watchdog设备被打开后,如果<a href="http://ibiblio.org/pub/Linux/system/daemons/watchdog/">喂狗守护进程</a>超过60秒没有喂狗(写入&quot;/dev/watchdog&quot;),那么底层的看门狗硬件将会触发整个机器硬重启(相当于按下面板上的&quot;RESET&quot;按钮).这对于提高服务器的在线率来说意义重大.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/watchdog/watchdog-api.txt">Documentation/watchdog/watchdog-api.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>WatchDog Timer Driver Core
CONFIG_WATCHDOG_CORE</p>
<p>看门狗核心驱动,它为所有特定于具体硬件的看门狗驱动提供了统一的框架和&rdquo;/dev/watchdog&quot;接口(未来还会包括sysfs接口).使用看门狗的必选.</p>
</li>
<li>
<p>Disable watchdog shutdown on close
CONFIG_WATCHDOG_NOWAYOUT</p>
<p>默认情况下(此项=&ldquo;N&rdquo;)如果喂狗进程关闭&quot;/dev/watchdog&quot;文件,那么表示停止看门狗功能.开启此项后,看门狗一旦启用就不能被停止(即使关闭&quot;/dev/watchdog&quot;文件也不会停止).</p>
</li>
<li>
<p>Software watchdog
CONFIG_SOFT_WATCHDOG</p>
<p>内核提供的&quot;软看门狗&quot;.使用它不需要有任何硬件的支持,但可靠性不如硬件看门狗,仅能应对喂狗进程的崩溃,不能应对内核本身的崩溃.在某些情况下(例如Oracle数据库),CONFIG_HANGCHECK_TIMER是比&quot;软看门狗&quot;更好的选择.</p>
</li>
<li>
<p>{此处省略的看门狗硬件请按照实际使用的芯片进行选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sonics Silicon Backplane support
CONFIG_SSB</p>
<p>SSB(Sonics Silicon Backplane)是一种仅在嵌入式环境中使用的总线.</p>
</li>
<li>
<p>Broadcom specific AMBA
CONFIG_BCMA</p>
<p>Broadcom特有的<a href="http://blog.163.com/meteora_wzh/blog/static/369626752007102752315710/">AMBA</a>(Advanced Microcontroller Bus Architecture)总线支持.仅用于嵌入式环境</p>
</li>
<li>
<p>Multifunction device drivers</p>
<ul>
<li>MFD(多功能设备)的含义是&quot;在单个芯片上集成多个功能(GPIO,触摸屏,键盘,电流调节,电源管理&hellip;)&quot;.此种芯片通常通过一个或多个IRQ线和低速数据总线(SPI/I2C/GPIO)与主CPU进行通信.对于主系统来说,它们通过数据总线显示为一个单独的MFD设备.但透过MFD框架,又可以拥有多个相互独立的子设备(子功能).MFD多用于嵌入式环境.</li>
<li>
<ul>
<li>
<p>Intel ICH LPC
CONFIG_LPC_ICH</p>
<p><a href="http://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC</a>(Low Pin Count)总线是Intel于1998年发布的一个旨在取代传统ISA总线的接口规范,用于连接南桥和<a href="http://zh.wikipedia.org/wiki/Super_I/O">Super I/O</a>芯片(用于连接低速外设:串口,并口,PS/2键鼠,软盘控制器,TPM(可信平台模块),温度传感器,风扇速度监测器)以及Flash芯片(BIOS).以往南桥必须保留ISA总线,以连接老旧的ISA插槽和<a href="http://www.esupport.com/techsupport/award/superio.php">Super I/O芯片</a>(可以使用<a href="http://www.coreboot.org/Superiotool">Superiotool</a>和<a href="http://www.lm-sensors.org/wiki/man/sensors-detect">sensors-detect</a>工具检测)以及Flash芯片.但是ISA需要占用大量针脚,主板的线路设计也比较复杂.随着ISA插槽的消失,LPC就顺理成章的出现了,它与ISA在软件层面是类似的,同时LPC工作速率由PCI总线速率同步驱动,但是引脚数大大降低,以方便在拥挤的现代主板上布局,这也是取名&quot;Low Pin Count&quot;的原因.此选项支持几乎所有Intel芯片组的LPC总线,以方便其他驱动控制MFD(目前仅有GPIO和watchdog).具体支持的芯片可以查看&quot;drivers/mfd/lpc_ich.c&quot;文件.</p>
</li>
<li>
<p>Intel SCH LPC
CONFIG_LPC_SCH</p>
<p>用于 Intel Atom 处理器的 Intel SCH(System Controller Hub) LPC 总线支持.目前仅支持SMBus和GPIO.</p>
</li>
<li>
<p>{此处省略的硬件请按照实际使用的芯片进行选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Voltage and Current Regulator Support
CONFIG_REGULATOR</p>
<p>通用的电压与电流调节器框架.除了提供通用的电压与电流调节接口外,还能通过sysfs向用户空间提供电压与电流的状态信息.目的在于通过动态调节电压和电流,降低能耗,延长电池寿命.建议笔记本用户选&quot;Y&quot;.</p>
</li>
<li>
<p>Multimedia support
CONFIG_MEDIA_SUPPORT</p>
<ul>
<li>多媒体设备:摄像头,视频采集,模拟电视,数字电视,机顶盒,收音机,遥控器,数字视频广播(DVB)&hellip;内核多媒体子系统由<a href="http://linuxtv.org/">LinuxTV</a>项目负责维护.</li>
<li>
<ul>
<li>
<p>Cameras/video grabbers support
CONFIG_MEDIA_CAMERA_SUPPORT</p>
<p>摄像头,视频采集卡</p>
</li>
<li>
<p>Analog TV support
CONFIG_MEDIA_ANALOG_TV_SUPPORT</p>
<p>模拟电视信号接收器,包括那些既能接收模拟信号又能接收数字信号的电视卡</p>
</li>
<li>
<p>Digital TV support
CONFIG_MEDIA_DIGITAL_TV_SUPPORT</p>
<p>数字电视信号接收器,包括那些既能接收模拟信号又能接收数字信号的电视卡</p>
</li>
<li>
<p>AM/FM radio receivers/transmitters support
CONFIG_MEDIA_RADIO_SUPPORT</p>
<p>AM/FM无线电接收机和发射机,包括那些带有收音机功能的电视卡</p>
</li>
<li>
<p>Remote Controller support
CONFIG_MEDIA_RC_SUPPORT</p>
<p>基于红外线/射频的遥控器,用于控制视频采集卡或者电视卡.大多数电视卡和视频采集卡都需要它的支持,即使这些卡实际并不需要遥控器.</p>
</li>
<li>
<p>Media Controller API
CONFIG_MEDIA_CONTROLLER</p>
<p>此API用于查询多媒体设备内部的拓扑结构,并进行动态配置.主要用于嵌入式环境中的摄像头配置.</p>
</li>
<li>
<p>V4L2 sub-device userspace API
CONFIG_VIDEO_V4L2_SUBDEV_API</p>
<p>此API用于配置视频的格式/尺寸/帧率.主要用于嵌入式环境中的摄像头配置.</p>
</li>
<li>
<p>Enable advanced debug functionality on V4L2 drivers
CONFIG_VIDEO_ADV_DEBUG</p>
<p>开启<a href="http://baike.baidu.com/view/5494174.htm">V4L2</a>驱动程序的高级调试特性,不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable old-style fixed minor ranges on drivers/video devices
CONFIG_VIDEO_FIXED_MINOR_RANGES</p>
<p>仅在你使用mknod而不是udev进行设备管理时才需要开启.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>V4L2 int device (DEPRECATED)
CONFIG_VIDEO_V4L2_INT_DEVICE</p>
<p>仅用于旧式的图像传感器驱动(omap24xxcam和tcm825x),反对使用此项.选&quot;N&quot;.</p>
</li>
<li>
<p>DVB Network Support
CONFIG_DVB_NET</p>
<p><a href="http://zh.wikipedia.org/wiki/DVB">DVB</a>(<a href="http://baike.baidu.com/view/73510.htm#sub5082257">数字视频广播</a>)是一系列国际公认的数字电视标准.此项提供了DVB网络(DVB标准的一部分)支持,可用于数字机顶盒(Set-Top-Box)的自动固件升级以及通过DVB卡访问互联网.</p>
</li>
<li>
<p>maximum number of DVB/ATSC adapters
CONFIG_DVB_MAX_ADAPTERS</p>
<p>最大允许的<a href="http://www.eefocus.com/pixela/blog/08-03/144874_3fa2b.html">DVB/ATSC</a>电视卡数量.取值范围是[1,255],但经过测试的范围是[4,32].不确定的请保持默认值&quot;8&quot;.</p>
</li>
<li>
<p>Dynamic DVB minor allocation
CONFIG_DVB_DYNAMIC_MINORS</p>
<p>为DVB设备节点动态分配次设备号,这样每张DVB卡就可以拥有最多4个同类型的设备(例如demux(分离器)和frontend(前端)).此特性需要udev的支持.</p>
</li>
<li>
<p>Compile Remote Controller keymap modules
CONFIG_RC_MAP</p>
<p>将各种遥控器的keymap表编译进内核.这些表都很小,但是如果你不打算使用遥控器,或者更喜欢使用<a href="http://linuxtv.org/downloads/v4l-utils/">v4l-utils</a>包内的<a href="http://manpages.ubuntu.com/manpages/natty/man1/ir-keytable.1.html">ir-keytable</a>工具从用户空间加载这些表,可以选&quot;N&quot;.</p>
</li>
<li>
<p>Remote controller decoders
CONFIG_RC_DECODERS</p>
<p>遥控器解码器.其下的子项是各种不同的遥控通信协议.</p>
</li>
<li>
<p>Remote Controller devices
CONFIG_RC_DEVICES</p>
<p>各种遥控器产品.其下子项按实际的厂商和型号选择即可.</p>
</li>
<li>
<p>Media USB Adapters
CONFIG_MEDIA_USB_SUPPORT</p>
<ul>
<li>各种USB总线的多媒体设备</li>
<li>
<ul>
<li>
<p>USB Video Class (UVC)
CONFIG_USB_VIDEO_CLASS</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/USB%E8%A6%96%E9%A0%BB%E9%A1%9E%E5%88%A5">UVC</a>(<a href="http://en.wikipedia.org/wiki/USB_video_device_class">USB Video Class</a>)是一个开放的通用USB视频捕获标准.目前大多数摄像头都是UVC摄像头,也就是俗称的&quot;免驱摄像头&quot;.所有符合UVC规格的硬件都可以使用<a href="http://linux-uvc.berlios.de/">通用UVC驱动程序</a>,而无需再使用专用驱动.</li>
<li>
<ul>
<li>
<p>UVC input events device support
CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV</p>
<p>某些UVC摄像头上会带有按钮(常用于开关LED灯/拍照),此选项可以将此按钮注册为一个输入设备,以用于报告按钮事件.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>GSPCA based webcams
CONFIG_USB_GSPCA</p>
<p>基于GSPCA框架的摄像头驱动(依赖于CONFIG_VIDEO_V4L2),这是<a href="http://news.mydrivers.com/1/82/82885.htm">一位60岁的法国医生的杰作</a>.该驱动适用于大多数常见的非UVC摄像头.具体支持的芯片列表可以查看&quot;<a href="http://lxr.linux.no/linux/Documentation/video4linux/gspca.txt">Documentation/video4linux/gspca.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>{此处省略的非GSPCA摄像头,电视卡,电视棒等其他硬件请按照实际使用的芯片进行选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Media PCI Adapters
CONFIG_MEDIA_PCI_SUPPORT</p>
<p>各种PCI/PCIe总线的多媒体设备</p>
</li>
<li>
<p>V4L platform devices
CONFIG_V4L_PLATFORM_DRIVERS</p>
<ul>
<li>特定于平台的V4L(Video For Linux)设备,这些设备不是通过USB/PCI这样的总线连接的.一般用于单片机之类的嵌入式环境.</li>
<li>
<ul>
<li>
<p>SoC camera support
CONFIG_SOC_CAMERA</p>
<ul>
<li>所谓&quot;SoC Camera&quot;是指那些不通过PCI或USB总线连接的摄像头(例如通过I2C直接与SoC数据总线连接).此选项为这类摄像头提供了通用的支持.</li>
<li>
<ul>
<li>
<p>platform camera support
CONFIG_SOC_CAMERA_PLATFORM</p>
<p>仅用于调试目的</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>{此处省略的部分请按照实际使用的芯片进行选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Memory-to-memory multimedia devices
CONFIG_V4L_MEM2MEM_DRIVERS</p>
<p>使用系统内存作为源和目标缓存(Memory-to-memory)的多媒体设备.一般的采集输出驱动仅将系统内存用于源或目标缓存之一.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Media test drivers
CONFIG_V4L_TEST_DRIVERS</p>
<p>仅用于调试目的.</p>
</li>
<li>
<p>Siano SMS1xxx based MDTV via SDIO interface
CONFIG_SMS_SDIO_DRV</p>
<p>使用<a href="http://bbs.ednchina.com/BLOG_ARTICLE_198217.HTM">SDIO</a>接口的一种移动数字电视(MDTV)卡,基于<a href="http://www.ic72.com/technology/circuit_info_104158.html">Siano SMS1xxx</a>芯片.主要用于嵌入式设备</p>
</li>
<li>
<p>ISA and parallel port devices
CONFIG_MEDIA_PARPORT_SUPPORT</p>
<p>使用ISA或并口的多媒体设备,古董级别的设备</p>
</li>
<li>
<p>Radio Adapters
CONFIG_RADIO_ADAPTERS</p>
<p>AM/FM无线电广播接收设备</p>
</li>
<li>
<p>FireDTV and FloppyDTV
CONFIG_DVB_FIREDTV</p>
<p><a href="http://www.digital-everywhere.com/">Digital Everywhere</a>生产的FireWire(IEEE 1394)接口的DVB电视接收卡</p>
</li>
<li>
<p>Cypress firmware helper routines
CONFIG_CYPRESS_FIRMWARE</p>
<p><a href="http://baike.baidu.com/view/1367502.htm">Cypress</a>(<a href="http://china.cypress.com/">赛普拉斯</a>)多媒体产品的固件加载帮助程序.</p>
</li>
<li>
<p>Enable Remote Controller support for Siano devices
CONFIG_SMS_SIANO_RC</p>
<p><a href="http://www.siano-ms.com/CN/">Siano</a>多媒体设备遥控器</p>
</li>
<li>
<p>Enable debugfs for smsdvb
CONFIG_SMS_SIANO_DEBUGFS</p>
<p>仅供调试使用,当前仅可用于Siano USB设备</p>
</li>
<li>
<p>Autoselect ancillary drivers (tuners, sensors, i2c, frontends)
CONFIG_MEDIA_SUBDRV_AUTOSELECT</p>
<p>为多媒体设备驱动自动选择所有相关的辅助驱动(tuner[调谐器],sensor[传感器],视频编/解码器以及前端),以免去手动选择的麻烦.通常这是个好主意,建议选&quot;Y&quot;.但是对于某些嵌入式环境来说,却希望去掉部分有用的辅助驱动以保持内核尽可能短小,这时应该选&quot;N&quot;.</p>
</li>
<li>
<p>I2C module for IR
CONFIG_VIDEO_IR_I2C</p>
<p>大多数板子都通过GPIO总线连接红外线芯片,但少数板子却使用I2C总线连接.此项即是对I2C总线连接的红外线芯片提供支持.</p>
</li>
<li>
<p>Encoders, decoders, sensors and other helper chips</p>
<p>编码器,解码器,传感器,混频器&hellip;等辅助芯片</p>
</li>
<li>
<p>Sensors used on soc_camera driver</p>
<p>用于&quot;SoC Camera&quot;(CONFIG_SOC_CAMERA)的各种传感器</p>
</li>
<li>
<p>Customize TV tuners</p>
<p>各种专用的电视调谐器</p>
</li>
<li>
<p>Customise DVB Frontends</p>
<p>各种专用的数字电视前端</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Graphics support</p>
<ul>
<li>图形设备/显卡支持.对于不需要使用图形界面以及不需要进行图形渲染的用户来说,以下所有选项都应该选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>/dev/agpgart (AGP Support)
CONFIG_AGP</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Graphics_address_remapping_table">GART</a>(<a href="http://blog.csdn.net/zkami/article/details/3576809">图形地址重映射表</a>)可以看做一种被各种显卡(不只是<a href="http://zh.wikipedia.org/wiki/AGP">AGP</a>显卡,还包括<a href="http://zh.wikipedia.org/wiki/PCI_Express">PCI-E</a>显卡与<a href="http://baike.baidu.com/view/9082.htm">集成显卡</a>以及<a href="http://baike.baidu.com/view/4503595.htm">核心显卡</a>)使用的&quot;伪<a href="http://server.zdnet.com.cn/files/all-1836536.htm">IOMMU</a>&quot;(参见CONFIG_GART_IOMMU选项),它将物理地址不连续的系统内存映射成连续的&quot;显存&quot;供GPU使用.当物理显存容量不够时(大多数集成显卡甚至根本没有物理显存),GART允许通过DMA(<a href="http://blog.csdn.net/wzhwho/article/details/5638045">直接内存访问</a>)方式将这部分&quot;显存&quot;用于<a href="http://zh.wikipedia.org/wiki/%E6%9D%90%E8%B4%A8%E8%B4%B4%E5%9B%BE">纹理贴图</a>,<a href="http://www.cnblogs.com/jiahuafu/archive/2011/02/19/1958467.html">Z轴缓冲</a>,<a href="http://baike.baidu.com/view/736358.htm">ALPHA混合</a>,<a href="http://en.wikipedia.org/wiki/Polygon_mesh">多边形网格</a>生成&hellip;等各种3D操作.如果没有GART支持,<a href="http://zh.wikipedia.org/zh-cn/OpenGL">OpenGL</a>直接渲染将会变得特别慢.<a href="http://liyanrui.is-programmer.com/2009/2/7/glx-notes.7061.html">GLX</a>与<a href="http://www.linuxgraphics.cn/xwindow/dri_intro.html">DRI</a>(CONFIG_DRM)也依赖于此.简而言之,需要使用图形化界面的人都应该选&quot;Y&quot;.不需要图形界面的用户应该选&quot;N&quot;.[注意]对于使用304或更老版本的nVidia闭源驱动的用户,如果使用的是<a href="http://us.download.nvidia.com/XFree86/Linux-x86/304.108/README/configuringagp.html">某些老旧的芯片组</a>,那么此处应该选&quot;N&quot;.因为在这些特定的芯片组上,闭源驱动自己的agpgart实现(<a href="http://en.wikipedia.org/wiki/NvAGP">NvAGP</a>)是更好的选择.[提示]老版本的AMD/ATI/NVIDIA闭源驱动都曾经有自己的agpgart实现,但在新版本中都已经被移除.而Intel显卡一直使用的都是内核的agpgart实现.</li>
<li>
<ul>
<li>
<p>AMD Opteron/Athlon64 on-CPU GART support
CONFIG_AGP_AMD64</p>
<p>该项仅适用于如下AMD处理器:(1)<a href="http://zh.wikipedia.org/wiki/AMD_K8">AMD K8</a>微架构CPU[cpu family : 15] (2)<a href="http://en.wikipedia.org/wiki/AMD_10h">AMD K10</a>微架构CPU[cpu family : 16] (3)<a href="http://zh.wikipedia.org/wiki/AMD_Bulldozer">AMD 推土机</a>微架构CPU[cpu family : 21 并且 model: 小于15].[提示]除了前面列出的三种CPU外,其他AMD处理器(例如A4/A6/A8系列APU)并不需要此选项.具体支持的CPU可以查看&quot;arch/x86/kernel/amd_nb.c&quot;文件中的&quot;AMD_NB_GART&quot;常量的使用.</p>
</li>
<li>
<p>Intel 440LX/BX/GX, I8xx and E7x05 chipset support
CONFIG_AGP_INTEL</p>
<p>该项仅适用于:(1)某些<a href="http://en.wikipedia.org/wiki/List_of_Intel_chipsets">Intel芯片组</a>(440LX/BX/GX, 8xx系列, E7205/E7505/E7221, 9xx系列, 所有3/4系列). (2)全部<a href="http://en.wikipedia.org/wiki/Intel_GMA">Intel集成显卡</a>(包括<a href="http://zh.wikipedia.org/wiki/Intel_HD_Graphics">Intel核心显卡</a>).具体支持的芯片组和集显可以查看&quot;drivers/char/agp/intel-*&ldquo;系列文件.[提示]如果你使用的既不是此处所列的芯片组(例如<a href="http://en.wikipedia.org/wiki/Intel_Xeon_chipsets">Xeon芯片组</a>或者<a href="http://en.wikipedia.org/wiki/List_of_Intel_chipsets#5.2F6.2F7.2F8_Series_chipsets">5/6/7/8系列芯片组</a>)也不是Intel的集成显卡(例如AMD/nVidia独立显卡),那么应该选&quot;N&rdquo;.</p>
</li>
<li>
<p>SiS chipset support
CONFIG_AGP_SIS</p>
<p>该项仅适用于<a href="http://zh.wikipedia.org/wiki/%E7%9F%BD%E7%B5%B1%E7%A7%91%E6%8A%80">SiS</a>芯片组,但不包括上世纪古董级的SiS 5591/5592芯片组.</p>
</li>
<li>
<p>VIA chipset support
CONFIG_AGP_VIA</p>
<p>该项仅适用于<a href="http://zh.wikipedia.org/wiki/%E5%A8%81%E7%9B%9B%E9%9B%BB%E5%AD%90">VIA</a>芯片组.具体支持的芯片组型号可以查看&quot;drivers/char/agp/via-agp.c&quot;中的&quot;via_agp_device_ids&quot;数组.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>VGA Arbitration
CONFIG_VGA_ARB</p>
<ul>
<li>图形设备是通过I/O或内存的特定地址范围进行访问的.大多数现代的显卡都允许对这个范围进行重新定位,但是某些基于PCI的&quot;传统&quot;VGA设备仍然使用&quot;硬编码&quot;的地址范围,无法对其进行重新定位.如果系统上有多个这样的&quot;传统&quot;VGA设备,就会造成地址冲突,这时候就需要进行<a href="http://www.x.org/wiki/VgaArbiter/">VGA仲裁</a>.此选项主要用于处理多个显卡(比如集成显卡和独立显卡)之间的切换.如果你的系统上有多个显卡,可以选&quot;Y&quot;,否则应该选&quot;N&quot;.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/vgaarbiter.txt">Documentation/vgaarbiter.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Maximum number of GPUs
CONFIG_VGA_ARB_MAX_GPUS</p>
<p>最多允许支持多少个显卡</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Laptop Hybrid Graphics - GPU switching support
CONFIG_VGA_SWITCHEROO</p>
<p>支持多个显卡之间的切换(通常是在集显和独显之间),这项技术有多个不同的名称:&quot;<a href="http://www.amd.com/cn/products/technologies/ati-hybrid-graphics/Pages/ati-hybrid-graphics.aspx">Hybrid Graphics</a>&rdquo;,&quot;<a href="http://baike.baidu.com/view/2165615.htm">PowerXpress</a>&quot;,&quot;<a href="http://baike.baidu.com/view/1632721.htm">HybridPower</a>&quot;.这项特性主要用于笔记本,台式机一般不支持.</p>
</li>
<li>
<p>Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)
CONFIG_DRM</p>
<ul>
<li><a href="http://blog.csdn.net/datangsoc/article/details/5900025">DRI</a>(<a href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure">Direct Rendering Infrastructure</a>)允许应用程序以高效安全的方式直接访问GPU,主要用于硬件3D加速.桌面用户建议选&quot;Y&quot;.[提示]KMS+DRI2+GEM+UXA+<a href="http://linuxtoy.org/archives/gnome-to-wayland-roadmap.html">Wayland</a>是<a href="http://muses2006.blog.163.com/blog/static/11436549520094411927792/">Linux图形革命</a>的基石,这里还有两篇需要越墙的文章可以帮助加深对Linux图形技术的理解:(1)<a href="http://huanhaoadam.wordpress.com/2010/03/03/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E7%99%BE%E5%9B%9B%E5%8D%81%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Exorg%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86/">关于Xorg的一些整理</a>,(2)<a href="http://www.linuxgraphics.cn/xwindow/some_concepts_of_xorg.html">厘清了xorg里的一些概念</a>.</li>
<li>
<ul>
<li>
<p>Allow to specify an EDID data set instead of probing for it
CONFIG_DRM_LOAD_EDID_FIRMWARE</p>
<p><a href="http://zh.wikipedia.org/wiki/EDID">EDID</a>(<a href="http://blog.csdn.net/zhouzhuan2008/article/details/8072745">扩展显示器识别数据</a>)是一种<a href="http://zh.wikipedia.org/wiki/VESA">VESA(视频电子标准协会)</a>制定的标准数据格式,其中包含有关显示器的各种参数:供应商信息,最大图像尺寸,颜色设置,厂商预设置,频率范围,显示器名,序列号字符串等等.EDID保存在显示器的PROM或EEPROM中,显卡或<a href="http://www.polypux.org/projects/read-edid/">read-edid</a>一般通过I2C总线使用DDC协议进行读取.但是在某些脑残的硬件(显示器或显卡)上却不能正确获取EDID数据.此选项就是为了解决这个问题而设置的.此选项可以允许从&quot;/lib/firmware/&ldquo;目录加载EDID数据,或者将EDID数据在编译时直接嵌入内核.不确定的选&quot;N&rdquo;.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/EDID/HOWTO.txt">Documentation/EDID/HOWTO.txt</a>&ldquo;文档.[提示]EDID的继任者是<a href="http://wenku.baidu.com/view/ee4dcfc608a1284ac850439e">DisplayID</a>,但目前DisplayID尚未被广泛应用.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I2C encoder or helper chips</p>
<ul>
<li>I2C编码器或辅助芯片</li>
<li>
<ul>
<li>
<p>Chrontel ch7006 TV encoder
CONFIG_DRM_I2C_CH7006</p>
<p><a href="http://www.chrontel.com/index.php/ch7006-tv-encoder">Chrontel ch7006</a> 电视解码器支持.某些nVidia显卡上有这个芯片.此选项仅对NVIDIA显卡开源驱动(<a href="http://nouveau.freedesktop.org/wiki/">nouveau</a>)有意义.</p>
</li>
<li>
<p>Silicon Image sil164 TMDS transmitter
CONFIG_DRM_I2C_SIL164</p>
<p><a href="http://www.siliconimage.com/solutions/pc/hdmi-dvi-tx/">Silicon Image SIL164</a> <a href="http://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E5%8C%96%E5%82%B3%E8%BC%B8%E5%B7%AE%E5%88%86%E8%A8%8A%E8%99%9F">最小化传输差分信号</a>(<a href="http://www.dzsc.com/data/html/2009-6-16/76874.html">TMDS</a>)发送器,用于实现<a href="http://zh.wikipedia.org/wiki/DVI">DVI</a>信号的合成和发送.TMDS不如<a href="http://zh.wikipedia.org/wiki/%E4%BD%8E%E9%9B%BB%E5%A3%93%E5%B7%AE%E5%88%86%E4%BF%A1%E8%99%9F">LVDS</a>应用广泛,仅在某些nVidia显卡上有出现.</p>
</li>
<li>
<p>NXP Semiconductors TDA998X HDMI encoder
CONFIG_DRM_I2C_NXP_TDA998X</p>
<p><a href="http://www.cn.nxp.com/">NXP(恩智浦)</a> TDA998X <a href="http://zh.wikipedia.org/wiki/HDMI">HDMI</a> 发射器.用于实现<a href="http://diy.pconline.com.cn/display/study_screen/1102/2348992_all.html">HDMI</a>信号的合成和发送.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>3dfx Banshee/Voodoo3+
CONFIG_DRM_TDFX</p>
<p><a href="http://baike.baidu.com/view/993916.htm">3dfx</a> Banshee/Voodoo3+ 系列古董显卡</p>
</li>
<li>
<p>ATI Rage 128
CONFIG_DRM_R128</p>
<p><a href="http://baike.baidu.com/view/1493224.htm">ATI Rage 128</a> 系列古董显卡</p>
</li>
<li>
<p>ATI Radeon
CONFIG_DRM_RADEON</p>
<ul>
<li>Radeon系列显卡开源驱动(<a href="http://wiki.x.org/wiki/radeon/">radeon</a>).[提示]R600及更新的GPU需要额外的固件/微代码(<a href="http://git.exherbo.org/summer/packages/firmware/radeon-ucode/">radeon-ucode</a>)的帮助才能使用开源驱动.如果你打算在R600及更新的GPU上使用此开源驱动,那么建议选&quot;M&quot;而不是&quot;Y&rdquo;.因为&quot;Y&quot;需要将微代码(通常位于&quot;/lib/firmware/radeon/&ldquo;目录)一起编译进内核(使用CONFIG_EXTRA_FIRMWARE=&ldquo;radeon/<a href="http://wiki.gentoo.org/wiki/Radeon#Firmware">GPU-MODEL</a>.bin&rdquo;).[注意]如果你打算使用目前尚不支持<a href="https://wiki.archlinux.org/index.php/Kernel_Mode_Setting_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">KMS</a>的Radeon闭源驱动(<a href="http://support.amd.com/US/GPUDOWNLOAD/Pages/index.aspx">Catalyst/fglrx</a>),那么此项必须选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>Enable userspace modesetting on radeon (DEPRECATED)
CONFIG_DRM_RADEON_UMS</p>
<p>禁用KMS支持.目的是为了兼容远古版本的DDX驱动.除非你有充足的理由,否则请选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Nouveau (nVidia) cards
CONFIG_DRM_NOUVEAU</p>
<ul>
<li>nVidia系列显卡开源驱动(<a href="http://nouveau.freedesktop.org/wiki/">nouveau</a>).[注意]如果你打算使用也许永远不会支持<a href="http://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E8%AE%BE%E5%AE%9A">KMS</a>的nVidia闭源驱动(<a href="http://www.nvidia.com/object/unix.html">nvidia-drivers</a>),那么此项必须选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Maximum debug level
CONFIG_NOUVEAU_DEBUG</p>
<p>最大调试级别,也就是最高允许显示的调试信息详细程度.取值范围是[0,7],数字越大,在内核中编入的调试信息就越多,建议设为&quot;4&quot;,过大的级别会导致驱动运行缓慢.</p>
</li>
<li>
<p>Default debug level
CONFIG_NOUVEAU_DEBUG_DEFAULT</p>
<p>默认调试级别,必须小于等于CONFIG_NOUVEAU_DEBUG的值.数字越大,输出的调试信息就越详细,建议设为&quot;2&quot;,过大的级别会导致驱动运行缓慢.</p>
</li>
<li>
<p>Support for backlight control
CONFIG_DRM_NOUVEAU_BACKLIGHT</p>
<p>允许调整显示器背光亮度,主要用于液晶显示屏等使用背光技术的显示器.建议选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Intel I810
CONFIG_DRM_I810</p>
<p>专为古董级Intel集成显卡(i810/i815)准备的驱动</p>
</li>
<li>
<p>Intel 8xx/9xx/G3x/G4x/HD Graphics
CONFIG_DRM_I915</p>
<ul>
<li>Intel <a href="http://en.wikipedia.org/wiki/Intel_GMA">GMA</a>(芯片组集成显卡)与<a href="http://zh.wikipedia.org/wiki/Intel_HD_Graphics">HD Graphics</a>(核心集成显卡)开源驱动(<a href="https://01.org/linuxgraphics/">intel</a>).除了个别老古董(i810/i815)与基于PowerVR的芯片(Atom z5xx)之外,此驱动支持所有Intel集成显卡(包括Atom中的集成显卡).[提示]<a href="http://linuxtoy.org/archives/compare-linux-driver-support-between-three-major-gpus.html">三大主流显卡厂商对Linux的驱动支持</a>,Intel是最彻底的,官方只提供开源驱动.</li>
<li>
<ul>
<li>
<p>Enable modesetting on intel by default
CONFIG_DRM_I915_KMS</p>
<p>默认开启<a href="http://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E8%AE%BE%E5%AE%9A">KMS</a>(<a href="https://wiki.archlinux.org/index.php/Kernel_Mode_Setting_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">Kernel Mode Setting</a>)特性,作用是可以在内核级别(而不是用户级别)设置显示分辨率和颜色深度.KMS使用了更新的技术,可以减少失真,增强3D性能,甚至可以使用内核的节能功能.KMS是大势所趋,只要用户层软件不太旧(2010年之后),都建议开启.[注意]开启此项后,应该:(1)关闭CONFIG_FB_INTEL选项并禁止加载任何framebuffer驱动(包括CONFIG_FB_UVESA),(2)取消内核引导参数&quot;vga=xxx&quot;和&quot;video=xxx&quot;,(3)必须开启CONFIG_FRAMEBUFFER_CONSOLE选项.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Matrox g200/g400
CONFIG_DRM_MGA</p>
<p>Matrox G200, G400, G450 系列古董显卡</p>
</li>
<li>
<p>SiS video cards
CONFIG_DRM_SIS</p>
<p>SiS 630 系列古董显卡</p>
</li>
<li>
<p>Via unichrome video cards
CONFIG_DRM_VIA</p>
<p>Via unichrome 系列古董显卡</p>
</li>
<li>
<p>Savage video cards
CONFIG_DRM_SAVAGE</p>
<p>Savage3D/4/SuperSavage/Pro/Twister 系列古董显卡</p>
</li>
<li>
<p>DRM driver for VMware Virtual GPU
CONFIG_DRM_VMWGFX</p>
<ul>
<li>VMware SVGA2 虚拟显卡驱动.支持3D加速,支持KMS.如果你打算在VMware内使用图形化界面,建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Enable framebuffer console under vmwgfx by default
CONFIG_DRM_VMWGFX_FBCON</p>
<p>如果你使用的VMware Tools不太旧就选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Intel GMA5/600 KMS Framebuffer
CONFIG_DRM_GMA500</p>
<p>Intel基于Poulsbo架构的集成显卡实验性支持.此类显卡并不常见,仅用于Atom z5xx系列处理器.</p>
</li>
<li>
<p>DisplayLink
CONFIG_DRM_UDL</p>
<p><a href="http://baike.baidu.com/view/1485403.htm">DisplayLink</a>是一个通过USB接口实现显示器连接到电脑的连接技术,可以非常简单的连接电脑和多个显示设备,常用于通过USB接口扩展虚拟的电脑的桌面.目前DisplayLink技术最多可以支持<a href="http://publish.it168.com/2008/0825/20080825015701.shtml">6台显示器同时显示</a>32位色彩的任意分辨率画面.</p>
</li>
<li>
<p>AST server chips
CONFIG_DRM_AST</p>
<p>AST系列显卡实验性支持.此种显卡仅出现在服务器环境.</p>
</li>
<li>
<p>Kernel modesetting driver for MGA G200 server engines
CONFIG_DRM_MGAG200</p>
<p>MGA G200服务器芯片组的KMS支持.[注意]仅用于服务器芯片,不要用于桌面芯片!</p>
</li>
<li>
<p>Cirrus driver for QEMU emulated device
CONFIG_DRM_CIRRUS_QEMU</p>
<p>这是<a href="http://www.ibm.com/developerworks/cn/linux/l-qemu/">QEMU</a>虚拟的cirrus显卡KMS驱动.千万不要用于真正的物理cirrus显卡.</p>
</li>
<li>
<p>QXL virtual GPU
CONFIG_DRM_QXL</p>
<p>用于<a href="http://os.51cto.com/art/201104/255032.htm">SPICE</a>的虚拟桌面的QXL虚拟显卡(cirrus)KMS支持.</p>
</li>
<li>
<p>Lowlevel video output switch controls
CONFIG_VIDEO_OUTPUT_CONTROL</p>
<p>底层视频输出开关控制(通过sysfs接口).这是ACPI视频控制所依赖的功能,也被许多显卡驱动所依赖.选&quot;Y&quot;.</p>
</li>
<li>
<p>Support for frame buffer devices
CONFIG_FB</p>
<ul>
<li><a href="http://baike.baidu.com/view/1040793.htm">帧缓冲</a>(<a href="http://bbs.chinaunix.net/thread-1932291-1-1.html">framebuffer</a>)设备(/dev/fb*)是一种对图形硬件的抽象,它把屏幕上的所有像素点都直接映射到一段线性的内存空间,这样就为软件提供了访问图形硬件的统一接口,这些软件不需要了解硬件的底层细节(例如寄存器),只要简单的改变相应内存位置的值,就能改变屏幕上显示的内容(颜色/亮度等).Xorg的高度可移植性也就根源于此.图形界面用户必选.</li>
<li>
<ul>
<li>
<p>Enable firmware EDID
CONFIG_FIRMWARE_EDID</p>
<p><a href="http://zh.wikipedia.org/wiki/EDID">EDID</a>(<a href="http://av.imaschina.com/issue/t_obs/2010/5476.html">扩展显示器识别数据</a>)保存在显示器的PROM或EEPROM中,显卡或<a href="http://www.polypux.org/projects/read-edid/">read-edid</a>一般通过I2C总线使用DDC协议进行读取.但是在某些脑残的硬件(显示器或显卡)上却不能正确获取EDID数据.此选项就是为了解决这个问题而设置的(参见CONFIG_DRM_LOAD_EDID_FIRMWARE).开启此项后,将允许三种驱动(nvidiafb,i810fb,savagefb)通过Video BIOS获取EDID.建议选&quot;N&quot;,仅在你确实遭遇EDID读取失败,并且确实需要使用nvidiafb/i810fb/savagefb驱动的时候才需要考虑选&quot;Y&quot;.[提示]EDID的继任者是<a href="http://wenku.baidu.com/view/ee4dcfc608a1284ac850439e">DisplayID</a>,但目前DisplayID尚未被广泛应用.</p>
</li>
<li>
<p>Framebuffer foreign endianness support
CONFIG_FB_FOREIGN_ENDIAN</p>
<p>如果你想混合使用不同<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节序</a>的主板和显卡(在Little-Endian主板上使用Big-Endian显卡,或者相反),可以选&quot;Y&quot;.绝大多数人都应该选&quot;N&quot;.除非你确实知道自己在做什么.</p>
</li>
<li>
<p>Enable Video Mode Handling Helpers
CONFIG_FB_MODE_HELPERS</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Generalized_Timing_Formula">GTF</a>和EDID解析程序来帮助处理显示模式,建议选&quot;N&quot;,若有其他选项依赖于它时,会自动选上.</p>
</li>
<li>
<p>Enable Tile Blitting Support
CONFIG_FB_TILEBLITTING</p>
<p>此项仅对matroxfb驱动有意义,建议选&quot;N&quot;,若有其他选项依赖于它时,会自动选上</p>
</li>
<li>
<p>{虽然此处省略的各种Framebuffer驱动提供了对图形硬件的统一抽象,让Xorg不必与硬件直接对话,但这些Framebuffer驱动仅能提供2D功能,在如今3D硬件加速和视频硬件解码早已铺天盖地的情况下,让Xorg直接与GPU硬件对话才更符合潮流,而传统的Framebuffer驱动(CONFIG_FB_*)反而成为了绊脚石,不但没有必要与新的DRI驱动(CONFIG_DRM_*)共存,而且还会相互冲突.所以切勿选中这里省略的任何Framebuffer驱动.除非你确实知道自己在做什么.}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Exynos Video driver support
CONFIG_EXYNOS_VIDEO</p>
<p>三星基于ARM构的<a href="http://baike.baidu.com/view/5821967.htm">EXYNOS</a>处理器内置显卡</p>
</li>
<li>
<p>Backlight &amp; LCD device support
CONFIG_BACKLIGHT_LCD_SUPPORT</p>
<ul>
<li>背光与液晶支持.</li>
<li>
<ul>
<li>
<p>Lowlevel LCD controls
CONFIG_LCD_CLASS_DEVICE</p>
<p>液晶(LCD)底层控制框架.用于控制对比度和LCD开关(而不是背光亮度).选中此项后还需要从子项中选择特定于硬件的驱动.这些LCD硬件目前仅用于智能手机/平板电脑等嵌入式环境.</p>
</li>
<li>
<p>Lowlevel Backlight controls
CONFIG_BACKLIGHT_CLASS_DEVICE</p>
<ul>
<li>背光(Backlight)底层控制框架.用于控制背光源的亮度和开关.选中此项后还需要从子项中选择特定于硬件的驱动.</li>
<li>
<ul>
<li>
<p>Generic PWM based Backlight Driver
CONFIG_BACKLIGHT_PWM</p>
<p>液晶显示器(包括台式机和笔记本)的<a href="http://www.zhihu.com/question/21127560">背光亮度调整方式</a>有两种:(1)<a href="http://www.cnledw.com/knowledge/detail-21714.htm">PWM调光</a>,(2)非PWM调光.目前主流的液晶显示器基本上都是PWM调光,仅有少数是<a href="http://www.chiphell.com/thread-650884-1-1.html">非PWM调光型号</a>(而且越来越少).</p>
</li>
<li>
<p>Apple Backlight Driver
CONFIG_BACKLIGHT_APPLE</p>
<p>基于Intel处理器的苹果Macbook笔记本和iMac台式机显示器背光控制</p>
</li>
<li>
<p>{其它省略的驱动仅用于智能手机/平板电脑等嵌入式环境}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Console display driver support</p>
<ul>
<li>控制台显示驱动.每个人都需要.</li>
<li>
<ul>
<li>
<p>VGA text console
CONFIG_VGA_CONSOLE</p>
<ul>
<li>VGA文本控制台,必选.除非你知道自己在做什么</li>
<li>
<ul>
<li>
<p>Enable Scrollback Buffer in System RAM
CONFIG_VGACON_SOFT_SCROLLBACK</p>
<ul>
<li>标准的VGA控制台回滚缓冲区位于VGA RAM中,但是其空间非常小,并且是固定的.开启此项后,就可以在内存中开辟更大的屏幕回滚缓冲区,这将允许你回滚更多的屏幕(Shift+PageUp),但是控制台的速度会略有下降.经常使用文本控制台的可以选&quot;Y&quot;,不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Scrollback Buffer Size (in KB)
CONFIG_VGACON_SOFT_SCROLLBACK_SIZE</p>
<p>在内存中开辟的屏幕回滚缓冲区大小.每个80x25屏幕需要4KB内存</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Framebuffer Console support
CONFIG_FRAMEBUFFER_CONSOLE</p>
<ul>
<li>基于Framebuffer的控制台驱动.KMS特性依赖于它.桌面用户建议开启(使用了CONFIG_DRM_*的用户必须开启)</li>
<li>
<ul>
<li>
<p>Map the console to the primary display device
CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY</p>
<p>选&quot;Y&quot;表示自动将控制台映射到&quot;主&quot;显卡,选&quot;N&quot;表示自动将控制台映射到第一个加载的显卡驱动.无论是否选中此项,都可以通过&quot;fbcon=map:N&quot;内核引导参数更改映射关系.仅在系统拥有多个显卡时此选项才有意义.参见&quot;<a href="http://lxr.linux.no/linux/Documentation/fb/fbcon.txt">Documentation/fb/fbcon.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Framebuffer Console Rotation
CONFIG_FRAMEBUFFER_CONSOLE_ROTATION</p>
<p>显示画面旋转,由于是纯软件方式实现,所以会大大降低显示速度,除非你确实需要,否则建议选&quot;N&rdquo;.</p>
</li>
<li>
<p>Support for the Framebuffer Console Decorations
CONFIG_FB_CON_DECOR</p>
<p>允许在控制台上显示<a href="http://linux-wiki.cn/images/b/bf/Debian_bootsplash.jpg">背景图像</a>,例如在系统启动时,在一堆滚动的字符背后显示漂亮的<a href="http://fatcat.ftj.agh.edu.pl/~przyboro/other/kon.png">背景图像</a>.当然,要实现这个功能,还需要用户空间程序的帮助.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/fb/fbcondecor.txt">Documentation/fb/fbcondecor.txt</a>&ldquo;文档以及<a href="http://wiki.gentoo.org/wiki/Fbsplash">fbsplash</a>的wiki页.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Select compiled-in fonts
CONFIG_FONTS</p>
<ul>
<li>选择内嵌到内核中的字体(点阵字库,仅包含<a href="http://images.cnblogs.com/cnblogs_com/skynet/201105/2011050311372042.png">ASCII字符</a>和<a href="http://images.cnblogs.com/cnblogs_com/skynet/201105/201105031137219627.png">扩展ASCII字符</a>,共256个).选&quot;N&quot;表示内嵌自动选择的默认字体,选&quot;Y&quot;表示可以手动选择内嵌的字体.[提示]可到drivers/video/console目录下找到相应的&quot;font_*.c&quot;文件,将其中的&quot;0&quot;全部替换为空格,即可看到点阵字符.</li>
<li>
<ul>
<li>
<p>VGA 8x8 font
CONFIG_FONT_8x8</p>
<p>这是传统上高分辨率(高于80x50)下使用的字体.因为点阵太小,所以显示的字体质量非常低劣.</p>
</li>
<li>
<p>VGA 8x16 font
CONFIG_FONT_8x16</p>
<p>这是传统上的标准字体(用于80x25),也是默认内嵌的字体,最为常见.建议选&quot;Y&rdquo;.</p>
</li>
<li>
<p>{其它字体省略}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Bootup logo
CONFIG_LOGO</p>
<p>启动时显示linux的logo(一幅企鹅图像),企鹅的数量表示内核检测到的CPU数目,喜欢炫一下的就选吧.子项是三种不同质量的图片,分别是黑白,16色,224色.按需选择.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sound card support
CONFIG_SOUND</p>
<ul>
<li>声卡支持</li>
<li>
<ul>
<li>
<p>Preclaim OSS device numbers
CONFIG_SOUND_OSS_CORE_PRECLAIM</p>
<p>开启此项后,只要OSS支持被开启,无论相应的模块是否被加载,内核都会预先声明所有OSS设备号.当其中一个设备被打开时,将会尝试使用&quot;sound-slot/service-*&ldquo;与&quot;char-major-*&ldquo;两种别名去加载相应的模块.关闭此项后, 内核将仅声明实际使用中的OSS设备号.当打开一个不存在的设备时,将会仅尝试使用标准的&quot;char-major-*&ldquo;别名去加载相应的模块.由于&quot;sound-slot/service-*&ldquo;将会在未来移除,此选项仅是一个为了兼容性而保留的过渡选项,未来会被移除(相当于设为&quot;N&rdquo;).</p>
</li>
<li>
<p>Advanced Linux Sound Architecture
CONFIG_SND</p>
<ul>
<li><a href="http://blog.csdn.net/absurd/article/details/1323006">ALSA</a>(高级Linux声音架构)是内核默认的声音子系统.ALSA除了提供了声音设备的驱动,还提供了一个用户空间的函数库,这样用户空间程序就可以通过统一的API使用驱动功能,而不必直接与内核驱动交互.[吐槽]<a href="https://www.deleak.com/blog/2010/05/17/linux-audio-explained/">Linux音频系统</a>,比意大利面条更混乱的系统!</li>
<li>
<ul>
<li>
<p>Sequencer support
CONFIG_SND_SEQUENCER</p>
<ul>
<li><a href="http://baike.baidu.com/view/7969.htm">MIDI</a><a href="http://baike.baidu.com/view/494975.htm">音序器</a>支持,如果你是MIDI玩家,请选&quot;Y&rdquo;,但如果你不知道MIDI是什么,请选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>Sequencer dummy client
CONFIG_SND_SEQ_DUMMY</p>
<p>除非你要同时连接到多个MIDI设备或应用程序,否则请不要选中</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>OSS Mixer API
CONFIG_SND_MIXER_OSS</p>
<p>模拟OSS混音器API(/dev/mixer*),某些老旧的程序仍然使用它,建议不选</p>
</li>
<li>
<p>OSS PCM (digital audio) API
CONFIG_SND_PCM_OSS</p>
<ul>
<li>模拟OSS数字音频(<a href="http://blog.csdn.net/DroidPhone/article/details/6308006">PCM</a>)API(/dev/dsp*),某些老旧的程序仍然使用它,建议不选.</li>
<li>
<ul>
<li>
<p>OSS PCM (digital audio) API - Include plugin system
CONFIG_SND_PCM_OSS_PLUGINS</p>
<p>让ALSA模拟的 OSS PCM API 支持channel/format/rate的转换.选&quot;N&rdquo;,除非你确实知道为什么要选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>OSS Sequencer API
CONFIG_SND_SEQUENCER_OSS</p>
<p>模拟OSS音序器(/dev/sequencer,/dev/music),某些老旧的程序仍然使用它,建议不选</p>
</li>
<li>
<p>HR-timer backend support
CONFIG_SND_HRTIMER</p>
<ul>
<li>允许将高精度定时器(CONFIG_HIGH_RES_TIMERS)用作ALSA高精度时间源,建议选中</li>
<li>
<ul>
<li>
<p>Use HR-timer as default sequencer timer
CONFIG_SND_SEQ_HRTIMER_DEFAULT</p>
<p>将高精度定时器(HR-timer)当作默认的时序脉冲发生器时间源,建议选中</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dynamic device file minor numbers
CONFIG_SND_DYNAMIC_MINORS</p>
<p>动态分配ALSA设备的次设备号.如果你有8个以上的声卡,可以选&quot;Y&quot;,否则应该选&quot;N&quot;.</p>
</li>
<li>
<p>Support old ALSA API
CONFIG_SND_SUPPORT_OLD_API</p>
<p>支持已被废弃的老旧版本的ALSA PCM API,选&quot;N&quot;.</p>
</li>
<li>
<p>Verbose procfs contents
CONFIG_SND_VERBOSE_PROCFS</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Verbose printk
CONFIG_SND_VERBOSE_PRINTK</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Debug
CONFIG_SND_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Generic sound devices
CONFIG_SND_DRIVERS</p>
<ul>
<li>通用声音设备</li>
<li>
<ul>
<li>
<p>PC-Speaker support (READ HELP!)
CONFIG_SND_PCSP</p>
<p>如果你有声卡,务必选&quot;N&quot;.如果你的系统没有声卡,仅在认真阅读了帮助之后,确实知道自己在干什么的情况下,才可以开启此项.</p>
</li>
<li>
<p>Dummy (/dev/null) soundcard
CONFIG_SND_DUMMY</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Generic loopback driver (PCM)
CONFIG_SND_ALOOP</p>
<p><a href="http://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E7%B7%A8%E7%A2%BC%E8%AA%BF%E8%AE%8A">PCM</a>环回(loopback)设备非常类似于网卡的环回接口(127.0.0.1),它会将输入的音频流原封不动的返回给用户空间.PCM回环设备常用来将A程序输出的音频流作为B程序的输入(A以写模式打开环回设备,而B以读模式打开),比如用B程序记录A程序的输出,或做进一步的处理.</p>
</li>
<li>
<p>Virtual MIDI soundcard
CONFIG_SND_VIRMIDI</p>
<p>虚拟<a href="http://zh.wikipedia.org/wiki/MIDI">MIDI</a>驱动,允许将使用原始MIDI设备的应用程序连接到音序器客户端,如果你不知道MIDI是什么就选&quot;N&quot;.</p>
</li>
<li>
<ul>
<li>{此处省略几种MIDI设备(事实上大部分人都没有这些设备)}</li>
<li>AC97 Power-Saving Mode
CONFIG_SND_AC97_POWER_SAVE</li>
</ul>
<!---->
<ul>
<li><a href="http://baike.baidu.com/view/117423.htm">AC97</a>(Audio Codec 97)自动节能模式支持.在此模式下,如果音频设备闲置超过&quot;/sys/module/snd_ac97_codec/parameters/power_save&quot;设定的秒数(&ldquo;0&quot;表示关闭节能模式),那么驱动程序将会关闭音频设备以节约电力.建议选&quot;Y&rdquo;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/sound/alsa/powersave.txt">Documentation/sound/alsa/powersave.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Default time-out for AC97 power-save mode
CONFIG_SND_AC97_POWER_SAVE_DEFAULT</p>
<p>默认的超时秒数,也就是&rdquo;/sys/module/snd_ac97_codec/parameters/power_save&quot;的默认值.&ldquo;0&quot;表示关闭节能模式.建议设为&quot;10&quot;这个久经考验的合理数字.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>ISA sound devices
CONFIG_SND_ISA</p>
<p>基于ISA总线的声卡,已经绝种了.</p>
</li>
<li>
<p>PCI sound devices
CONFIG_SND_PCI</p>
<ul>
<li>基于PCI总线的声卡,绝大多数声卡都是PCI接口</li>
<li>
<ul>
<li>
<ul>
<li>{此处省略的声卡按实际情况选择即可(都是些比较旧的AC97声卡)}</li>
<li>Intel HD Audio
CONFIG_SND_HDA_INTEL</li>
</ul>
<!---->
<ul>
<li>符合<a href="http://acc.pconline.com.cn/vocality/study_vocality/0801/1212973_all.html">Intel HD Audio</a>规范的声卡是目前的主流声卡.如果选&quot;M&rdquo;,那么下面的每个驱动也都会被编译成模块,如果选&quot;Y&quot;,那么下面的每个驱动也都会直接编译进内核.</li>
<li>
<ul>
<li>
<p>Pre-allocated buffer size for HD-audio driver
CONFIG_SND_HDA_PREALLOC_SIZE</p>
<p>为HD-audio驱动程序预先分配的缓冲区大小(kB),较大的值拥有更好的性能,例如对于使用<a href="http://zh.wikipedia.org/zh-cn/PulseAudio">PulseAudio</a>声音服务器的系统来说,推荐使用&quot;4096&quot;.默认值&quot;64&quot;仅仅是为了历史兼容的原因.[提示]ALSA+PulseAudio是目前的主流搭配.</p>
</li>
<li>
<p>Build hwdep interface for HD-audio driver
CONFIG_SND_HDA_HWDEP</p>
<p>为HD-audio驱动添加hwdep接口.仅用于调试目的</p>
</li>
<li>
<p>Support digital beep via input layer
CONFIG_SND_HDA_INPUT_BEEP</p>
<ul>
<li>为HD-audio驱动添加数字蜂鸣(beep)接口.如果你的主板没有<a href="http://www.help315.com.cn/ask/htmldata/detail/2010/03/04/93.html">蜂鸣器</a>(不是能够播放音乐的扬声器),可以考虑选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Digital beep registration mode (0=off, 1=on)
CONFIG_SND_HDA_INPUT_BEEP_MODE</p>
<p>设为&quot;0&quot;表示默认禁用数字蜂鸣接口,设为&quot;1&quot;表示默认启用数字蜂鸣接口.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support jack plugging notification via input layer
CONFIG_SND_HDA_INPUT_JACK</p>
<p>通过输入层支持<a href="http://zh.wikipedia.org/wiki/JACK_Audio_Connection_Kit">JACK</a>插件通知.JACK是一个比PulseAudio更专业的声音服务器,重点是低延迟,是专业音频软件(例如:<a href="http://zh.wikipedia.org/wiki/Ardour_%28%E8%BD%AF%E4%BB%B6%29">Ardour</a>,Rezound,LinuxSampler)首选的音频服务器.如果你打算使用JACK,可以选&quot;Y&quot;.[提示]如果要<a href="http://tonychee1989.diandian.com/about-jack-audio-connection-kit">将JACK和PulseAudio一起使用</a>,需要安装PulseAudio的JACK支持模块.</p>
</li>
<li>
<p>Support initialization patch loading for HD-audio
CONFIG_SND_HDA_PATCH_LOADER</p>
<p>仅用于调试目的</p>
</li>
<li>
<ul>
<li>{此处省略的HD-audio声卡按实际情况选择即可.[提示]如果CONFIG_SND_HDA_INTEL被编译为模块,这里的每一个驱动也都会被编译成模块.}</li>
<li>Build HDMI/DisplayPort HD-audio codec support
CONFIG_SND_HDA_CODEC_HDMI</li>
</ul>
<p>在HD-audio驱动中添加<a href="http://diy.pconline.com.cn/display/study_screen/1102/2348992_all.html">HDMI和DisplayPort</a>支持.如果你需要使用<a href="http://tv.ea3w.com/20/206229_all.html">HDMI/DisplayPort</a>接口,可以选&quot;Y&quot;.</p>
</li>
<li>
<p>Enable generic HD-audio codec parser
CONFIG_SND_HDA_GENERIC</p>
<p>通用HD-audio编解码器(<a href="http://zh.wikipedia.org/wiki/%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8">codec</a>)支持,必选.</p>
</li>
<li>
<p>Default time-out for HD-audio power-save mode
CONFIG_SND_HDA_POWER_SAVE_DEFAULT</p>
<p>HD-audio自动节能模式默认的超时秒数.&ldquo;0&quot;表示关闭节能模式.建议设为&quot;10&quot;这个久经考验的合理数字.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/sound/alsa/powersave.txt">Documentation/sound/alsa/powersave.txt</a>&ldquo;文档与CONFIG_SND_AC97_POWER_SAVE_DEFAULT选项.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SPI sound devices
CONFIG_SND_SPI</p>
<p>基于SPI总线的声卡,仅出现在嵌入式设备上</p>
</li>
<li>
<p>USB sound devices
CONFIG_SND_USB</p>
<p>基于USB总线的声卡,主要是外接声卡,并不常用</p>
</li>
<li>
<p>FireWire sound devices
CONFIG_SND_FIREWIRE</p>
<p>基于IEEE-1394/FireWire/iLink总线的声卡,主要用于苹果的产品</p>
</li>
<li>
<p>PCMCIA sound devices
CONFIG_SND_PCMCIA</p>
<p>基于PCMCIA接口的声卡,主要是外接声卡,并不常用</p>
</li>
<li>
<p>ALSA for SoC audio support
CONFIG_SND_SOC</p>
<p>SoC系统音频设备支持,重点是节能支持.仅用于嵌入式设备</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Open Sound System (DEPRECATED)
CONFIG_SOUND_PRIME</p>
<p>OSS早已被废弃(已被ALSA取代).选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HID support</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Human_interface_device">HID</a>(<a href="http://wenku.baidu.com/view/7fd4df21192e45361066f5f2.html">人机接口设备</a>)是一种定义计算机如何与人类交互的规范,常与USB或蓝牙搭配使用,常见的设备有:键盘,鼠标,触摸板,游戏杆,遥控器,蓝牙耳机,游戏手柄,手写板,等等.不过HID设备不一定要有人机接口,只要符合HID规范,就是HID设备.</li>
<li>
<ul>
<li>
<p>HID bus support
CONFIG_HID</p>
<ul>
<li><a href="http://www.usb.org/developers/hidpage/">HID</a>(human interface device)总线及通用HID层.要使用HID设备就必须开启.[提示]PS/2接口的鼠标和键盘不是HID设备,USB或蓝牙接口的才是HID设备.</li>
<li>
<ul>
<li>
<p>Battery level reporting for HID devices
CONFIG_HID_BATTERY_STRENGTH</p>
<p>为那些支持power_supply类的HID电池,向用户空间报告电池的剩余电量(可以通过<a href="http://upower.freedesktop.org/">upower</a>工具显示).</p>
</li>
<li>
<p>/dev/hidraw raw HID device support
CONFIG_HIDRAW</p>
<p>如果你想支持那些严格说来并不属于人机交互设备的硬件(使用额外的/dev/hidraw接口),例如显示控制装置(monitor control)或不间断电源(UPS),可以选&quot;Y&quot;.与CONFIG_USB_HIDDEV选项(/dev/hiddev)相比,/dev/hidraw设备直接无视一切hid事件(既不解析也不查找),这样就允许应用程序直接处理和操作原始的hid事件,从而避免使用用户层libhid/libusb库.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/hid/hidraw.txt">Documentation/hid/hidraw.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>User-space I/O driver support for HID subsystem
CONFIG_UHID</p>
<p>HID子系统需要两种驱动:(1)&ldquo;HID I/O Driver&quot;是特定于硬件的驱动,直接与底层总线交互,并向&quot;HID Device Driver&quot;提供了一致接口用于收发HID数据.(2)&ldquo;HID Device Driver&quot;是硬件无关的通用驱动,其任务是按照HID规范解析和处理来自于&quot;HID I/O Driver&quot;的HID数据,并将组装好的数据通过&quot;HID I/O Driver&quot;提供的统一接口发送给底层硬件.开启此项后,将允许在用户空间实现&quot;HID I/O Driver&rdquo;.不确定的选&quot;N&rdquo;.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/hid/uhid.txt">Documentation/hid/uhid.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Generic HID driver
CONFIG_HID_GENERIC</p>
<p>HID总线通用驱动,也就是前面说的&quot;HID Device Driver&rdquo;.它实现了对各种常见<a href="http://wenku.baidu.com/view/e9a54a3467ec102de2bd89ff.html">HID协议</a>的支持:键盘,鼠标,游戏杆,手写板,数字画板.不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>Special HID drivers</p>
<ul>
<li>各种不严格遵守HID协议的&quot;HID Device Driver&quot;</li>
<li>
<ul>
<li>
<ul>
<li>{此处省略的硬件按实际情况选择即可}</li>
<li>Lenovo ThinkPad USB Keyboard with TrackPoint
CONFIG_HID_LENOVO_TPKBD</li>
</ul>
<p>带有&quot;小红帽(TrackPoint)&ldquo;的联想(Lenovo)<a href="http://www.thinkpads.com/2009/08/31/finally-photos-of-new-thinkpad-usb-trackpoint-keyboard/">ThinkPad USB键盘</a>.</p>
</li>
<li>
<p>Logitech devices
CONFIG_HID_LOGITECH</p>
<p>某些并不完全遵从HID标准的罗技(Logitech)外设</p>
</li>
<li>
<p>HID Multitouch panels
CONFIG_HID_MULTITOUCH</p>
<p>HID<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E9%BB%9E%E8%A7%B8%E6%8E%A7">多点触控</a>(<a href="http://en.wikipedia.org/wiki/Multi-touch">Multitouch</a>)板的通用支持</p>
</li>
<li>
<p>HID Sensors framework support
CONFIG_HID_SENSOR_HUB</p>
<p>HID传感器支持框架.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/hid/hid-sensor.txt">Documentation/hid/hid-sensor.txt</a>&ldquo;文档</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>USB HID support</p>
<ul>
<li>基于USB接口的HID设备,这是目前最常见的HID设备</li>
<li>
<ul>
<li>
<p>USB HID transport layer
CONFIG_USB_HID</p>
<p>特定于USB接口的&quot;HID I/O Driver&rdquo;.用于和USB总线上的硬件进行交互.只要你想使用任何基于USB接口的HID设备(键盘,鼠标,游戏杆,手写板,手绘板,不间断电源(UPS),显示控制装置(monitor control),等等),就必须选&quot;Y&quot;.[例外]在嵌入式环境中使用的HIDBP(HID Boot Protocol)键盘和鼠标不在此列,而且两者也不能共存.</p>
</li>
<li>
<p>PID device support
CONFIG_HID_PID</p>
<p><a href="http://zh.wikipedia.org/wiki/PID%E6%8E%A7%E5%88%B6%E5%99%A8">PID</a>兼容的力反馈设备,例如:<a href="http://bak1.beareyes.com.cn/2/lib/200102/28/20010228026.htm">Microsoft Sidewinder Force Feedback 2</a></p>
</li>
<li>
<p>/dev/hiddev raw HID device support
CONFIG_USB_HIDDEV</p>
<p>如果你想支持那些严格说来并不属于人机交互设备的硬件(使用额外的/dev/usb/hiddevX[char 180:96~111]接口),例如显示控制装置(monitor control)或不间断电源(UPS),可以选&quot;Y&quot;.参见CONFIG_HIDRAW选项.</p>
</li>
<li>
<p>USB HID Boot Protocol drivers</p>
<p>如果你有绝对的把握确信不为自己的键盘和鼠标使用常规的HID驱动,而要使用Boot Protocol模式的HID驱动(常见于嵌入式环境)就选吧</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I2C HID support</p>
<ul>
<li>基于I2C总线的HID设备</li>
<li>
<ul>
<li>
<p>HID over I2C transport layer
CONFIG_I2C_HID</p>
<p>特定于I2C总线的&quot;HID I/O Driver&quot;.用于和I2C总线上的硬件进行交互.只要你想使用任何基于I2C总线的HID设备(键盘,触摸板,触摸屏,等等),就必须选&quot;Y&quot;.I2C-HID主要用于嵌入式设备.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>USB support
CONFIG_USB_SUPPORT</p>
<ul>
<li><a href="http://www.crifan.com/files/doc/docbook/usb_basic/release/html/usb_basic.html">通用串行总线</a>(<a href="http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E4%B8%B2%E8%A1%8C%E7%B8%BD%E7%B7%9A">Universal Serial Bus</a>)的目标是统一电脑的外设接口.目前几乎找不到没有USB接口的电脑,而且各种智能设备也大多带有USB接口.不要犹豫,选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Support for Host-side USB
CONFIG_USB</p>
<ul>
<li>主机端(Host-side)USB支持.通用串行总线(USB)是一个串行总线子系统规范,它比传统的串口速度更快并且特性更丰富(供电,热插拔,最多可接127个设备等),其目标是统一PC外设接口.USB总体上呈现一种树型结构,USB的&quot;Host&quot;(主设备)被称为&quot;根&quot;(也可以理解为是主板上的USB控制器),USB的&quot;Slave&quot;(从设备)被称为&quot;叶子&quot;,而内部的节点则称为&quot;hub&quot;(集线器).只要使用任何USB设备都必须选中此项.另外,你还需要从下面选中至少一个HCD(Host Controller Driver),比如适用于USB1.1的&quot;UHCI HCD support&quot;或&quot;OHCI HCD support&quot;,适用于USB2.0的&quot;EHCI HCD (USB 2.0) support&quot;.如果你拿不准的话把他们都选中一般也不会出问题.如果你的系统有设备端的USB接口(也就是你的系统可以作为&quot;叶子&quot;使用),请到&quot;USB Gadget&quot;中进行选择.</li>
<li>
<ul>
<li>
<p>USB verbose debug messages
CONFIG_USB_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>USB announce new devices
CONFIG_USB_ANNOUNCE_NEW_DEVICES</p>
<p>在syslog中记录每个新接入系统的USB设备的详细标识信息(idVendor,idProduct,Manufacturer,Product,SerialNumber),主要用于系统调试.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable USB persist by default
CONFIG_USB_DEFAULT_PERSIST</p>
<p>根据USB规范,当USB总线被挂起(休眠)后,它必须继续提供挂起电流(1-5毫安),以确保USB设备能保持其内部状态,并且USB集线器(HUB)能够检测连接变化(设备插入和拔出).这在技术上被称为&quot;电力会话&quot;(power session).如果一个USB设备的电力会话被中断,那么系统必须按照该设备已经被拔出进行处理,这是一种保守的做法,因为没有挂起电流,计算机不可能知道外围设备究竟发生了什么变化:也许依然保持连接,也许已经被拔出并在同一端口上插入了一个新设备.系统必须做最坏的打算.默认情况下,Linux的行为符合USB规范的要求.当整个电脑进入休眠状态(例如挂起到硬盘)时,包括USB总线在内所有总线都将掉电,然后当系统被唤醒,所有USB设备都会被当做在休眠前就已经被拔出来处理.这样做始终是安全的,并且也是&quot;官方正确&quot;的做法.对于大多数USB设备来说,这样做没有任何问题,但是对于USB存储设备(例如移动硬盘/U盘)来说,如果在休眠前有尚未卸载的文件系统(特别是根文件系统),当系统被唤醒之后,由于无法访问该文件系统,系统可能会立即崩溃!其实不只有掉电,只要&quot;power session&quot;被中断(例如BIOS在唤醒过程中重置了USB控制器),都会导致这种故障.此选项(USB-persist)就是为了解决这个问题而设置的,虽然解决的不甚完美(参见&quot;<a href="http://lxr.linux.no/linux/Documentation/usb/persist.txt">Documentation/usb/persist.txt</a>&quot;),但是依然推荐选&quot;Y&quot;,除非你确实有选&quot;N&quot;的理由.当然,最保险的做法是在休眠之前先卸载所有USB设备上的文件系统,而如果根文件系统位于USB设备上,就根本不使用任何休眠功能(不论是挂起到硬盘还是挂起到内存).</p>
</li>
<li>
<p>Dynamic USB minor allocation
CONFIG_USB_DYNAMIC_MINORS</p>
<p>动态分配USB设备的次设备号(仅限于主设备号为180的字符设备[通常位于&quot;/dev/usb/&ldquo;目录下]).除非你有超过16个同类型(仅限:打印机,鼠标,扫描仪)的USB设备,否则应选&quot;N&rdquo;.[提示]即使你有100个U盘或者USB移动硬盘,也不需要开启此项,因为他们不是&quot;主设备号为180的字符设备&quot;.</p>
</li>
<li>
<p>OTG support
CONFIG_USB_OTG</p>
<p>传统上,码照相机,手机,打印机,播放器,移动硬盘等设备之间要交换数据,都要作为PC的外围设备,在PC的控制下进行数据交换.一旦离开了PC,由于没有一个设备能够充当PC的&quot;Host&quot;角色,所以无法直接通信.<a href="http://baike.baidu.com/view/146799.htm">USB-OTG</a>(On-The-Go)就是为了解决这个问题而诞生的,它是USB2.0规格的补充标准,支持&quot;双角色&quot;设备(既可以当Host,也可以当Slave),从而实现外围设备之间的数据传送.例如,将数码相机直接连接到打印机上将相片打印出来.仅在你的主板上有<a href="http://upload.wikimedia.org/wikipedia/commons/4/44/Mini-AB-Receptacle.jpg">Mini-AB</a>/<a href="http://upload.wikimedia.org/wikipedia/commons/7/71/USB_Micro-AB_receptacle.jpg">Micro-AB</a>接口(目前仅用于嵌入式设备)时才需要选&quot;Y&quot;.</p>
</li>
<li>
<p>Rely on OTG Targeted Peripherals List
CONFIG_USB_OTG_WHITELIST</p>
<p>将&quot;otg_whitelist.h&quot;文件用作&quot;OTG Targeted Peripherals List&quot;(外设白名单),白名单之外的USB外设将按照OTG规范的要求不被枚举(也就是初始化).同样,&ldquo;Embedded Host&quot;也只支持限定的外设.如果选&quot;N&rdquo;,那么白名单之外的外设也同样会被枚举(但会产生一个警告),这将大大方便嵌入式产品的开发.</p>
</li>
<li>
<p>Disable external hubs
CONFIG_USB_OTG_BLACKLIST_HUB</p>
<p>选&quot;Y&quot;将禁止枚举(也就是初始化)外部USB集线器(HUB).这样,OTG主机就可以通过省去对外部集线器的支持,降低系统软硬件的成本.</p>
</li>
<li>
<p>USB Monitor
CONFIG_USB_MON</p>
<p>选&quot;Y&quot;后,将可以捕获特定USB外设与USB主控器之间的数据流量,<a href="http://biot.com/usbdump/">usbdump</a>和<a href="http://www.linuxcertif.com/man/8/usbmon/">usbmon</a>工具依赖于此项.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/usb/usbmon.txt">Documentation/usb/usbmon.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Enable Wireless USB extensions
CONFIG_USB_WUSB</p>
<p>主机端的<a href="http://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%80%9A%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%AF%E6%B5%81%E6%8E%92">WUSB</a>(<a href="http://network.51cto.com/art/201111/300392.htm">无线USB</a>)支持.</p>
</li>
<li>
<p>Support WUSB Cable Based Association (CBA)
CONFIG_USB_WUSB_CBAF</p>
<ul>
<li>WUSB CBA(Cable Based Association)是一项保障主机和WUSB设备之间通信安全的技术.如果你的WUSB设备在建立无线连接前必须先建立有线连接,可以选&quot;Y&rdquo;.</li>
<li>
<ul>
<li>
<p>Enable CBA debug messages
CONFIG_USB_WUSB_CBAF_DEBUG</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Cypress C67x00 HCD support
CONFIG_USB_C67X00_HCD</p>
<p><a href="http://china.cypress.com/?id=167">Cypress</a> C67x00 (<a href="http://china.cypress.com/?id=187">EZ-Host</a>/<a href="http://china.cypress.com/?id=188">EZ-OTG</a>) USB 1.1 &ldquo;双角色&quot;控制器</p>
</li>
<li>
<p>xHCI HCD (USB 3.0) support
CONFIG_USB_XHCI_HCD</p>
<ul>
<li><a href="http://baike.baidu.com/view/9007709.htm">xHCI</a>(<a href="http://en.wikipedia.org/wiki/Extensible_Host_Controller_Interface">eXtensible Host Controller Interface</a>)就是当下大红大紫的<a href="http://www.expreview.com/20142-all.html">USB3.0</a>(SuperSpeed USB)主机控制器规范.[提示]因为xHCI移除了EHCI中为兼容USB1.1而引入的&quot;Companion&quot;模式,所以仅用一个单独的xHCI驱动就可以兼容所有USB3.0/2.0/1.1外设.也就是说,开启此项之后,就不需要再额外开启EHCI/OHCI/UHCI选项了.</li>
<li>
<ul>
<li>
<p>Debugging for the xHCI host controller
CONFIG_USB_XHCI_HCD_DEBUGGING</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>EHCI HCD (USB 2.0) support
CONFIG_USB_EHCI_HCD</p>
<p><a href="http://baike.baidu.com/view/1678341.htm">EHCI</a>(Enhanced Host Controller Interface)就是渐成昨日黄花的USB2.0(HighSpeed USB)主机控制器规范.[提示]因为EHCI通过&quot;Companion&quot;模式来支持USB1.1设备,所以一般还需要额外再开启OHCI或UHCI选项(除非你不想兼容任何USB1.1设备).详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/usb/ehci.txt">Documentation/usb/ehci.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Root Hub Transaction Translators
CONFIG_USB_EHCI_ROOT_HUB_TT</p>
<p>带有USB2.0接口的主板上都有一个&quot;根集线器&rdquo;(Root Hub)以允许在无需额外购买hub的情况下就可以提供多个USB插口,而大多数主板还在其中集成了事务转换(Transaction Translator)功能,这样就不需要再额外使用一个OHCI或UHCI控制器来兼容USB1.1,建议选&quot;Y&quot;,除非你不想兼容任何USB1.1设备.</p>
</li>
<li>
<p>Improved Transaction Translator scheduling
CONFIG_USB_EHCI_TT_NEWSCHED</p>
<p>如果你有一个USB2.0 hub并且某些接在这个hub上的USB1.1设备不能正常工作(显示&rsquo;cannot submit datapipe: error -28&rsquo;或&rsquo;error -71&rsquo;错误),可以考虑选&quot;Y&quot;.</p>
</li>
<li>
<p>Generic EHCI driver for a platform device
CONFIG_USB_EHCI_HCD_PLATFORM</p>
<p>通用<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform</a>设备的EHCI驱动.仅用于嵌入式环境.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>OHCI HCD support
CONFIG_USB_OHCI_HCD</p>
<p>OHCI(Open Host Controller Interface)是主要用于嵌入式环境的USB1.1(LowSpeed/FullSpeed USB)主机控制器规范.</p>
</li>
<li>
<p>UHCI HCD (most Intel and VIA) support
CONFIG_USB_UHCI_HCD</p>
<p>UHCI(Universal Host Controller Interface)是主要用于PC环境的USB1.1(LowSpeed/FullSpeed USB)主机控制器规范.</p>
</li>
<li>
<ul>
<li>{此处省略的USB控制器请按照实际硬件状况选择(基本上都仅用于嵌入式环境)}</li>
<li>Wireless USB Host Controller Interface (WHCI) driver
CONFIG_USB_WHCI_HCD</li>
</ul>
<p>WHCI(<a href="http://zh.wikipedia.org/wiki/%E7%84%A1%E7%B7%9A%E9%80%9A%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%AF%E6%B5%81%E6%8E%92">Wireless USB</a> Host Controller Interface)是<a href="http://baike.baidu.com/view/1621053.htm">无线USB</a>主机控制器规范.目前市场上带有WUSB主控器的主板很少.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Host Wire Adapter (HWA) driver
CONFIG_USB_HWA_HCD</p>
<p>USB接口的3G/4G<a href="http://baike.baidu.com/view/46275.htm">无线上网卡</a>(通常需要搭配SIM卡使用),常见制式有:WCDMA/LTE/HSPA等.</p>
</li>
<li>
<p>BCMA usb host driver
CONFIG_USB_HCD_BCMA</p>
<p>BCMA(Broadcom specific AMBA)总线上的EHCI/OCHI主机控制器支持.仅用于嵌入式环境.</p>
</li>
<li>
<p>SSB usb host driver
CONFIG_USB_HCD_SSB</p>
<p>BCMA(Broadcom specific AMBA)总线上的EHCI/OCHI主机控制器支持.仅用于嵌入式环境.</p>
</li>
<li>
<p>Inventra Highspeed Dual Role Controller (TI, ADI, &hellip;)
CONFIG_USB_MUSB_HDRC</p>
<p>一系列基于<a href="http://www.mentor.com/">Mentor Graphics</a>公司silicon <a href="http://zh.wikipedia.org/wiki/IP%E6%A0%B8">IP核</a>的USB控制器.仅用于嵌入式环境.</p>
</li>
<li>
<p>Renesas USBHS controller
CONFIG_USB_RENESAS_USBHS</p>
<p>一系列基于<a href="http://cn.renesas.com/">Renesas</a>公司USBHS <a href="http://zh.wikipedia.org/wiki/IP%E6%A0%B8">IP核</a>的USB控制器.仅用于嵌入式环境.</p>
</li>
<li>
<p>USB Modem (CDC ACM) support
CONFIG_USB_ACM</p>
<p>USB接口的猫或ISDN适配器,基本没人用的东西.</p>
</li>
<li>
<p>USB Printer support
CONFIG_USB_PRINTER</p>
<p>USB接口的打印机,这是主流的打印机</p>
</li>
<li>
<p>USB Wireless Device Management support
CONFIG_USB_WDM</p>
<p>为符合<a href="http://justmei.blog.163.com/blog/static/1160998532010321112522467/">CDC</a>(Communication Device CIass)和<a href="http://baike.baidu.com/view/397907.htm">WMC</a>(Wireless Mobile Communication)标准的手机提供WMC设备管理支持,这样你可以在这些手机上使用<a href="http://zh.wikipedia.org/wiki/%E6%B5%B7%E6%96%AF%E5%91%BD%E4%BB%A4%E9%9B%86">AT命令</a>(被所有调制解调器制造商采用的一个调制解调器命令语言).</p>
</li>
<li>
<p>USB Test and Measurement Class support
CONFIG_USB_TMC</p>
<p><a href="http://www.eet-china.com/ART_8800424718_675277_TA_b4a8c334.HTM">USBTMC</a>(USB Test and Measurement Class)协议支持.主要适用于测试仪器的USB通信开发.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>USB Mass Storage support
CONFIG_USB_STORAGE</p>
<ul>
<li>USB存储设备(U盘,USB硬盘,USB软盘,USB光盘,USB磁带,<a href="http://baike.baidu.com/view/26952.htm">记忆棒</a>,数码相机,<a href="http://baike.baidu.com/view/6239.htm">读卡器</a>等等).该选项依赖于CONFIG_SCSI和CONFIG_BLK_DEV_SD选项.选&quot;Y&quot;,除非你确实知道自己在干什么.</li>
<li>
<ul>
<li>
<p>USB Mass Storage verbose debug
CONFIG_USB_STORAGE_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>{省略的部分请按照自己实际使用的硬件选择(事实上大部分人都没有这些设备)}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>USB Mustek MDC800 Digital Camera support
CONFIG_USB_MDC800</p>
<p>一款上世纪生产的数码相机</p>
</li>
<li>
<p>Microtek X6USB scanner support
CONFIG_USB_MICROTEK</p>
<p>几款上世纪生产的扫描仪</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DesignWare USB3 DRD Core Support
CONFIG_USB_DWC3</p>
<p>基于DesignWare USB3 IP核的USB3.0控制器.仅用于嵌入式环境.</p>
</li>
<li>
<p>ChipIdea Highspeed Dual Role Controller
CONFIG_USB_CHIPIDEA</p>
<p>基于ChipIdea silicon IP核的USB2.0控制器.仅用于嵌入式环境.</p>
</li>
<li>
<p>USS720 parport driver
CONFIG_USB_USS720</p>
<p>一种USB转并口的转换设备.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>USB Serial Converter support
CONFIG_USB_SERIAL</p>
<p>USB-串口转换支持:(1)USB-串口转换器,(2)连接在USB口上的串口设备.详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/usb/usb-serial.txt">Documentation/usb/usb-serial.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<ul>
<li>{此处省略的各种杂七杂八的USB设备,要么是老古董,要么是很罕见,不确定的可以全部选&quot;N&quot;}</li>
<li>USB testing driver
CONFIG_USB_TEST</li>
</ul>
<p>仅供调试使用</p>
</li>
<li>
<p>USB DSL modem support
CONFIG_USB_ATM</p>
<p>USB DSL modem 已经是绝迹的古董猫了</p>
</li>
<li>
<p>USB Physical Layer drivers
CONFIG_USB_PHY</p>
<p>这类设备仅在嵌入式系统上存在</p>
</li>
<li>
<p>USB Gadget Support
CONFIG_USB_GADGET</p>
<p>USB是一个主/从协议,一个主机最多控制127个外设,其结构是非对称的,所以你无法把一个&quot;到主机&quot;的插头连接到外设上.Linux既可以在USB主机上运行,也可以在USB外设上运行.外设USB控制器可以是单独的芯片,也可以是集成在CPU中的微控制器,而常见的主机端控制器通常集成在芯片组的南桥中(xHCI/EHCI/OHCI/UHCI).如果你打算在外设中运行Linux,那么就必须开启此项,然后还需要为外设段的总线控制器配置一个硬件驱动,以及一个用于外设协议的&quot;配件驱动&quot;.不过对于大多数人来说,并不将Linux运行于外设端,因此可以放心的选&quot;N&quot;.仅那些嵌入式设备(例如智能手机)上运行的Linux才可能由此需求.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ultra Wideband devices
CONFIG_UWB</p>
<p><a href="http://baike.baidu.com/view/5958.htm">UWB</a>(<a href="http://zh.wikipedia.org/wiki/%E8%B6%85%E5%AF%AC%E9%A0%BB">Ultra Wideband</a>)是一种高带宽,低能耗,点对点,抗干扰性能强的无载波通信技术.UWB在较宽的频谱(3.1-10.6GHz)上,使用极低的功率(约为蓝牙的1/20),以时间间隔极短(小于1ns)的脉冲信号进行通信.UWB主要应用于室内通信(2米范围内实现480Mbps速率,10米范围内实现110Mbps速率),例如<a href="http://news.mydrivers.com/1/130/130214.htm">作为WUSB(Wireless USB)协议的传输层</a>.如果你有UWB无线控制器,可以选&quot;Y&quot;,不确定的选&quot;N&quot;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/usb/WUSB-Design-overview.txt">Documentation/usb/WUSB-Design-overview.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>MMC/SD/SDIO card support
CONFIG_MMC</p>
<ul>
<li><a href="http://baike.baidu.com/view/8802.htm">MMC</a>(<a href="http://zh.wikipedia.org/wiki/%E5%A4%9A%E5%AA%92%E9%AB%94%E8%A8%98%E6%86%B6%E5%8D%A1">MultiMediaCard</a>)/<a href="http://baike.baidu.com/view/2228.htm">SD</a>(<a href="http://zh.wikipedia.org/wiki/SD%E5%8D%A1">Secure Digital</a>)/<a href="http://baike.baidu.com/view/1456746.htm">SDIO</a>(<a href="http://wenku.baidu.com/view/187c0ad1240c844769eaee19">Secure Digital I/O</a>)主机控制器</li>
<li>
<ul>
<li>
<p>MMC debugging
CONFIG_MMC_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Assume MMC/SD cards are non-removable (DANGEROUS)
CONFIG_MMC_UNSAFE_RESUME</p>
<p>假定在系统休眠的过程中,所有MMC/SD/SDIO卡依然插在各自的插槽上没有变动.也许只有嵌入式系统才可以做这样的假定.不确定的选&quot;N&rdquo;.参见CONFIG_USB_DEFAULT_PERSIST选项.</p>
</li>
<li>
<p>MMC host clock gating
CONFIG_MMC_CLKGATE</p>
<p>尝试激进的&quot;gate the clock to the MMC card&quot;(啥意思?).这样当MMC卡不使用的时候,就可以进入节电状态.主机控制器必须支持此特性.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>MMC block device driver
CONFIG_MMC_BLOCK</p>
<ul>
<li>MMC块设备驱动.基本上MMC卡都是作为块设备(就像U盘一样)使用.所以只要使用MMC卡就应该开启.</li>
<li>
<ul>
<li>
<p>Number of minors per block device
CONFIG_MMC_BLOCK_MINORS</p>
<p>为每个MMC块设备保留的次设备号数量.取值范围是[4,256].这里设置的值应该等于&quot;最大可能的分区数+1&quot;.因为总的次设备号只有256个,所以最大能支持的MMC块设备数量就等于256除以此处设置的值.默认值&quot;8&quot;可以保证最大的向后兼容性.不确定的请保持默认值.</p>
</li>
<li>
<p>Use bounce buffer for simple hosts
CONFIG_MMC_BLOCK_BOUNCE</p>
<p>为SD/MMC控制器提供更多的缓存(最大64KB),从而可以大幅提升其性能.建议选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SDIO UART/GPS class support
CONFIG_SDIO_UART</p>
<p>实现了<a href="http://zh.wikipedia.org/wiki/UART">UART</a>类的SDIO卡支持.包括那些表现的像UART一样的<a href="http://baike.baidu.com/view/7773.htm">GPS</a>类支持.主要用于嵌入式设备.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>MMC host test driver
CONFIG_MMC_TEST</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Secure Digital Host Controller Interface support
CONFIG_MMC_SDHCI</p>
<p>通用SD主控支持.笔记本电脑上用的SD主控(TI(德州仪器)/Ricoh(理光)/Toshiba(东芝)等厂商)基本上都是这个驱动.选中此项后,还需要选中相应的总线驱动(见下,通常是CONFIG_MMC_SDHCI_PCI).</p>
</li>
<li>
<p>SDHCI support on PCI bus
CONFIG_MMC_SDHCI_PCI</p>
<ul>
<li>PCI总线的SD主控支持,目前的笔记本的SD主控基本都接在PCI总线上.</li>
<li>
<ul>
<li>
<p>Ricoh MMC Controller Disabler
CONFIG_MMC_RICOH_MMC</p>
<p>用于修正Ricoh(理光)MMC主控的bug,如果你需要使用Ricoh主控,就选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SDHCI support for ACPI enumerated SDHCI controllers
CONFIG_MMC_SDHCI_ACPI</p>
<p>专用于&quot;ACPI Compatibility ID&quot;等于&quot;PNP0D40&quot;的SD主控,以及&quot;ACPI Hardware ID&quot;等于&quot;INT33C6,INT33BB,80860F14&quot;的SD主控.</p>
</li>
<li>
<p>SDHCI platform and OF driver helper
CONFIG_MMC_SDHCI_PLTFM</p>
<p>基于<a href="http://wenku.baidu.com/view/7673feacdd3383c4bb4cd211">platform</a>总线和<a href="http://www.openfirmware.org/">OpenFirmware</a>的SD主控.</p>
</li>
<li>
<ul>
<li>{此处省略的SD主控请按照实际使用的芯片进行选择}</li>
<li>MMC/SD/SDIO over SPI
CONFIG_MMC_SPI</li>
</ul>
<p>基于SPI总线的MMC/SD/SDIO主控.仅用于嵌入式环境.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sony MemoryStick card support
CONFIG_MEMSTICK</p>
<ul>
<li>Sony<a href="http://zh.wikipedia.org/wiki/Memory_Stick">记忆棒</a>是一种Sony专用的存储设备.</li>
<li>
<ul>
<li>
<p>MemoryStick debugging
CONFIG_MEMSTICK_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Allow unsafe resume (DANGEROUS)
CONFIG_MEMSTICK_UNSAFE_RESUME</p>
<p>假定在系统休眠的过程中,所有记忆棒依然插在各自的插槽上没有变动.也许只有嵌入式系统才可以做这样的假定.不确定的选&quot;N&quot;.参见CONFIG_USB_DEFAULT_PERSIST选项.</p>
</li>
<li>
<p>MemoryStick Pro block device driver
CONFIG_MSPRO_BLOCK</p>
<p>&ldquo;Memory Stick PRO&quot;是SONY从2003开始引入的升级版标准,早已成为主流,所以应该选&quot;Y&rdquo;(除非你仍在使用十年前的老VAIO笔记本).</p>
</li>
<li>
<p>{此处省略的MemoryStick主控请按照实际使用的芯片进行选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>LED Support
CONFIG_NEW_LEDS</p>
<p>发光二级管(LED)支持.[提示]标准键盘上的LED灯不在此列(由input子系统控制)</p>
</li>
<li>
<p>Accessibility support
CONFIG_ACCESSIBILITY</p>
<p>无障碍(Accessibility)支持.各种帮助残疾人使用计算机的软硬件技术.例如:盲文设备,语音合成,键盘映射,等等.</p>
</li>
<li>
<p>InfiniBand support
CONFIG_INFINIBAND</p>
<p><a href="http://server.it168.com/a2012/0924/1401/000001401869_all.shtml">InfiniBand</a>是一种低延迟/高带宽数据中心互联架构,采用远程直接内存存取(RDMA)实现高性能处理器间通信(IPC),同时对虚拟化技术也提供了良好的支持.主要用于服务器集群与高性能计算(HPC)领域.</p>
</li>
<li>
<p>EDAC (Error Detection And Correction) reporting
CONFIG_EDAC</p>
<ul>
<li>在电磁环境比较恶劣的情况下,一些大规模集成电路常常会受到干扰,特别是像<a href="http://baike.baidu.com/view/943101.htm">RAM</a>这种利用双稳态进行存储的器件,往往会在强干扰下发生翻转,使原来存储的&quot;0&quot;变为&quot;1&quot;,或者&quot;1&quot;变为&quot;0&quot;,造成严重的后果(例如控制程序跑飞,关键数据出错).随着芯片集成度的增加,发生错误的可能性也在增大,这已经成为一个不能忽视的问题.错误检测与纠正(<a href="http://blog.163.com/somen111@126/blog/static/115586684201356451437/">EDAC</a>)技术的目标就是发现并报告甚至纠正在计算机系统中发生的错误,这些错误是由CPU或芯片组报告的底层错误(内存错误/缓存错误/PCI错误/温度过高,等等),建议选&quot;Y&quot;.如果这些代码报告了一个错误,请到<a href="http://bluesmoke.sourceforge.net/">http://bluesmoke.sourceforge.net/</a>和<a href="http://buttersideup.com/edacwiki">http://buttersideup.com/edacwiki</a>查看更多信息.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/edac.txt">Documentation/edac.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>EDAC legacy sysfs
CONFIG_EDAC_LEGACY_SYSFS</p>
<p>仅在你需要使用老版本<a href="http://sourceforge.net/projects/edac-utils/">edac-utils</a>的情况下才需要选&quot;Y&rdquo;.</p>
</li>
<li>
<p>Debugging
CONFIG_EDAC_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Decode MCEs in human-readable form (only on AMD for now)
CONFIG_EDAC_DECODE_MCE</p>
<ul>
<li>将<a href="http://ilinuxkernel.com/?p=303">MCE</a>(<a href="http://h10025.www1.hp.com/ewfrf/wc/document?cc=cn&amp;lc=zh-hans&amp;docname=c02691010">Machine Check Exception</a>)解码为人类可读的形式(目前仅支持AMD).建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Simple MCE injection interface over /sysfs
CONFIG_EDAC_MCE_INJ</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Main Memory EDAC (Error Detection And Correction) reporting
CONFIG_EDAC_MM_EDAC</p>
<ul>
<li>一些系统能够检测和修正主内存中的错误,EDAC能够报告这些信息(EDAC自己检测到的或者根据<a href="http://baike.baidu.com/view/93728.htm">ECC</a>得到的).EDAC还会尽量检测这些错误发生在哪里以便于替换损坏的内存.建议选&quot;Y&quot;并按照你实际硬件状况选取子项</li>
<li>
<ul>
<li>
<p>Output ACPI APEI/GHES BIOS detected errors via EDAC
CONFIG_EDAC_GHES</p>
<p>并不是所有机器都提供基于硬件的EDAC技术,有部分机器提供的是基于ACPI BIOS的报告机制(使用CONFIG_ACPI_APEI_GHES驱动).开启此项后,如果检测到GHES BIOS,那么CONFIG_ACPI_APEI_GHES驱动提供的错误报告将会通过EDAC API发送到用户空间,同时,硬件EDAC也会被禁用,也就是进入&quot;固件优先&quot;模式.注意:GHES BIOS和硬件EDAC两者不能共存,因为BIOS和操作系统在读取error寄存器时会相互竞争.所以如果你不想使用&quot;固件优先&quot;模式,应该选&quot;N&quot;,或者使用&quot;ghes.disable=1&quot;内核引导参数.</p>
</li>
<li>
<p>{此处省略的芯片请按照实际情况选择}</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Real Time Clock
CONFIG_RTC_CLASS</p>
<ul>
<li>通用<a href="http://zh.wikipedia.org/wiki/%E5%AF%A6%E6%99%82%E6%99%82%E9%90%98">RTC</a>(实时时钟)类支持.所有的PC机主板都包含一个电池动力的<a href="http://www.ibm.com/developerworks/cn/linux/1307_liuming_linuxtime2/index.html">实时时钟芯片</a>,以便在断电后仍然能够继续保持时间,RTC通常与<a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94">CMOS</a>集成在一起,因此BIOS可以从中读取当前时间(精度一般是秒级).选中此项后你就可以在操作系统中使用一个或多个RTC设备(你还必须从下面启用一个或多个RTC接口).[注意]Clock与Timer没有任何关系,Timer是定时器(用于计量时长),Clock是时钟(用于记录当前的时刻&quot;年-月-日 时:分:秒&quot;)</li>
<li>
<ul>
<li>
<p>Set system time from RTC on startup and resume
CONFIG_RTC_HCTOSYS</p>
<p>系统启动时从指定的RTC设备(CONFIG_RTC_HCTOSYS_DEVICE)中读取时间,以设定系统时间,这将有助于避免时间不准导致的麻烦(例如不必要的文件系统检测(fsck)以及网络故障).建议选&quot;Y&quot;.</p>
</li>
<li>
<p>Set the RTC time based on NTP synchronization
CONFIG_RTC_SYSTOHC</p>
<ul>
<li>如果用户空间报告了&quot;<a href="http://baike.baidu.com/view/60648.htm">NTP</a>已同步&quot;,那么每隔大约11分钟,内核将会自动把系统时间写入指定的RTC设备(CONFIG_RTC_HCTOSYS_DEVICE)中.建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>RTC used to set the system time
CONFIG_RTC_HCTOSYS_DEVICE</p>
<p>默认的RTC设备(通常是&quot;rtc0&quot;).该设备的驱动必须静态编译进内核(而不能作为模块加载).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>RTC debug support
CONFIG_RTC_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>/sys/class/rtc/rtcN (sysfs)
CONFIG_RTC_INTF_SYSFS</p>
<p>允许通过sysfs接口使用RTC,允许多个RTC设备,也就是/sys/class/rtc/rtc0~N</p>
</li>
<li>
<p>/proc/driver/rtc (procfs for rtcN)
CONFIG_RTC_INTF_PROC</p>
<p>允许通过proc接口使用RTC,仅允许一个RTC设备,也就是/proc/driver/rtc(若有多个RTC设备,则其将对应&quot;rtc0&quot;)</p>
</li>
<li>
<p>/dev/rtcN (character devices)
CONFIG_RTC_INTF_DEV</p>
<ul>
<li>允许通过dev接口使用RTC,允许多个RTC设备,也就是/dev/rtc0~N,某些程序(比如<a href="http://baike.baidu.com/view/4808064.htm">hwclock</a>)需要使用/dev/rtc(这是个软连接,udev会自动将其指向默认的RTC设备)</li>
<li>
<ul>
<li>
<p>RTC UIE emulation on dev interface
CONFIG_RTC_INTF_DEV_UIE_EMUL</p>
<p>如果底层rtc芯片驱动没有提供RTC_UIE就仿真一个RTC_UIE.选&quot;N&quot;,除非你确实知道自己在做什么.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Test driver/device
CONFIG_RTC_DRV_TEST</p>
<p>仅供调试使用</p>
</li>
<li>
<ul>
<li>{此处省略的其他RTC设备一般仅用于非PC环境}</li>
<li>PC-style &lsquo;CMOS&rsquo;
CONFIG_RTC_DRV_CMOS</li>
</ul>
<p>这是所有PC和基于ACPI的系统通用的RTC驱动.必须选&quot;Y&quot;(不能选&quot;M&quot;),除非你是嵌入式系统.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DMA Engine support
CONFIG_DMADEVICES</p>
<ul>
<li>DMA引擎(<a href="http://en.wikipedia.org/wiki/Direct_memory_access">DMA</a> Engine)可以看做是传统DMA控制器(DMA controller)的新生.在DMA引擎的协助下,CPU只需初始化一个传输动作,其余的动作就可以由DMA引擎独立完成(完成后以中断的方式通知CPU),这对于高速传输大量数据以及&quot;分散-收集&quot;操作大有益处,可以节约大量的CPU资源(有时也可节约大量的内存操作).目前主要用于:(1)卸载高速网络栈中的内存COPY操作,(2)加速CONFIG_MD_RAID456驱动中的RAID操作.&ldquo;DMA引擎&quot;只是一个统称,在不同场合对应着不同的技术,例如<a href="http://www.intel.cn/content/www/cn/zh/wireless-network/accel-technology.html">Intel I/OAT</a>(PC平台)和<a href="http://baike.baidu.com/view/1362076.htm">AHB</a>(嵌入式).[提示]历史上,ISA架构的电脑都有一个专用的&quot;DMA控制器&rdquo;(最常见的是<a href="http://en.wikipedia.org/wiki/Intel_8237">Intel 8237</a>),但是到了PCI架构,由于每一个PCI设备都可以控制PCI总线(成为&quot;<a href="http://en.wikipedia.org/wiki/Bus_mastering">bus master</a>&quot;)并直接读写系统内存,所以虽然DMA的操作方式依然存在,但是&quot;DMA控制器&quot;却消失了.现在新生的&quot;DMA引擎&quot;目前仍然主要出现在<a href="http://cateee.net/lkddb/web-lkddb/DMADEVICES.html">Intel的高端芯片</a>上.</li>
<li>
<ul>
<li>
<p>DMA Engine debugging
CONFIG_DMADEVICES_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Intel MID DMA support for Peripheral DMA controllers
CONFIG_INTEL_MID_DMAC</p>
<p>Intel <a href="http://zh.wikipedia.org/wiki/%E8%A1%8C%E5%8B%95%E8%81%AF%E7%B6%B2%E8%A3%9D%E7%BD%AE">MID</a> DMA引擎,搭配Atom处理器使用.</p>
</li>
<li>
<p>Intel I/OAT DMA support
CONFIG_INTEL_IOATDMA</p>
<p>带有<a href="http://www.intel.cn/content/www/cn/zh/wireless-network/accel-technology.html">英特尔I/O加速技术</a>(I/O Acceleration Technology)的至强芯片组DMA引擎</p>
</li>
<li>
<p>Synopsys DesignWare AHB DMA support
CONFIG_DW_DMAC</p>
<p>基于<a href="http://www.synopsys.com.cn/products-and-solutions/ip">Synopsys DesignWare</a> IP核的<a href="http://baike.baidu.com/view/1362076.htm">AHB</a>总线DMA引擎.例如<a href="http://www.atmel.com/zh/cn/">Atmel</a> <a href="http://www.eet-china.com/ART_8800458944_617693_NP_375c2322.HTM">AT32ap7000</a>中就整合了这个引擎.</p>
</li>
<li>
<p>Timberdale FPGA DMA support
CONFIG_TIMB_DMA</p>
<p>Timberdale FPGA DMA引擎.&ldquo;Timberdale FPGA&quot;是一个多功能设备,出现在基于Intel Atom的车载信息娱乐系统<a href="http://wiki.meego.com/In-vehicle">IVI(In-Vehicle Infotainment)</a>上.</p>
</li>
<li>
<p>Intel EG20T PCH / LAPIS Semicon IOH(ML7213/ML7223/ML7831) DMA
CONFIG_PCH_DMA</p>
<p>所有与<a href="http://www.youcpu.com/chipset/Intel-Platform-Controller-Hub-EG20T-Intel-EG20T-PCH">Intel EG20T PCH</a>兼容的芯片的DMA引擎支持,具体型号可以查看内核帮助.都是嵌入式芯片.</p>
</li>
<li>
<p>Network: TCP receive copy offload
CONFIG_NET_DMA</p>
<p>通过在网络栈中利用DMA引擎来减少接收数据包时的copy-to-user操作以释放CPU资源,仅在CONFIG_INTEL_IOATDMA开启的前提下才有意义.</p>
</li>
<li>
<p>Async_tx: Offload support for the async_tx api
CONFIG_ASYNC_TX_DMA</p>
<p>如果你开启了CONFIG_MD_RAID456,同时你的硬件又支持DMA引擎,那么开启此项后可以加速RAID操作.</p>
</li>
<li>
<p>DMA Test client
CONFIG_DMATEST</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Auxiliary Display support
CONFIG_AUXDISPLAY</p>
<p>辅助显示设备.例如基于<a href="http://blog.sina.com.cn/s/blog_4a3946360100obaf.html">KS0108</a>控制器的<a href="http://www.crystalfontz.com/product/CFAG12864BTFHV">Crystalfontz CFAG12864B</a>单色液晶屏(分辨率:128x64).仅用于嵌入式系统.</p>
</li>
<li>
<p>Userspace I/O drivers
CONFIG_UIO</p>
<p><a href="http://baike.baidu.com/view/8975902.htm">UIO</a>(Userspace I/O)是运行在用户空间的I/O技术,它为开发用户空间的驱动提供了一个简单的架构(/dev/uioN).使用uio的设备一般都属于嵌入式系统.不确定的选&quot;N&rdquo;.[提示]<a href="http://www.osadl.org/projects/downloads/UIO/user/">lsuio</a>工具可以列出所有UIO的模块和其映射的内存地址.</p>
</li>
<li>
<p>VFIO Non-Privileged userspace driver framework
CONFIG_VFIO</p>
<ul>
<li>VFIO(Virtual Function I/O)无特权用户空间I/O驱动框架,主要用于为虚拟化环境中的I/O驱动提供更高的安全性,需要有<a href="http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware">IOMMU虚拟化硬件</a>支持(例如:AMD-Vi(AMD IOMMU),<a href="http://software.intel.com/zh-cn/articles/io-vt-d-io">Intel VT-d</a>).VFIO的目标是在IOMMU硬件的帮助下,取代UIO框架和&quot;KVM PCI device assignment&quot;(CONFIG_KVM_DEVICE_ASSIGNMENT).详见&quot;<a href="http://lxr.linux.no/linux/Documentation/vfio.txt">Documentation/vfio.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.[提示]<a href="http://wiki.qemu.org/ChangeLog/1.3">QEMU 1.3</a>以上版本才能利用VFIO特性.</li>
<li>
<ul>
<li>
<p>VFIO support for PCI devices
CONFIG_VFIO_PCI</p>
<ul>
<li>允许PCI设备使用VFIO框架.这是VFIO框架当前的主要用途.选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>VFIO PCI support for VGA devices
CONFIG_VFIO_PCI_VGA</p>
<p>让VFIO PCI支持VGA设备,建议选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Virtualization drivers
CONFIG_VIRT_DRIVERS</p>
<p>这个选项仅对<a href="http://baike.baidu.com/view/405903.htm">PowerPC</a>架构有意义</p>
</li>
<li>
<p>Virtio drivers</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/">Virtio</a>驱动.<a href="http://www.linux-kvm.org/page/Virtio">Virtio</a>的目标是为各种半虚拟化的<a href="http://www.ibm.com/developerworks/cn/linux/l-hypervisor/">虚拟机管理程序</a>(特别是<a href="http://smilejay.com/kvm_theory_practice/">KVM</a>)提供一组通用的模拟设备,目前已实现:network/block/balloon/console/hw_random,未来还会实现更多.</li>
<li>
<ul>
<li>
<p>PCI driver for virtio devices
CONFIG_VIRTIO_PCI</p>
<p>半虚拟化PCI设备驱动.VMM(虚拟机管理程序)必须要有相应的&quot;PCI virtio backend&quot;.基于QEMU的VMM(KVM,Xen)一般都支持该驱动.[提示]由于目前的ABI尚不稳定,建议使用时注意版本匹配.</p>
</li>
<li>
<p>Virtio balloon driver
CONFIG_VIRTIO_BALLOON</p>
<p><a href="http://smilejay.com/2012/11/kvm-ballooning-overview/">balloon</a>驱动支持增加和减少KVM客户机内的内存大小.</p>
</li>
<li>
<p>Platform bus driver for memory mapped virtio devices
CONFIG_VIRTIO_MMIO</p>
<ul>
<li>使用内存映射机制的platform设备驱动</li>
<li>
<ul>
<li>
<p>Memory mapped virtio devices parameter parsing
CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES</p>
<p>允许通过&quot;virtio_mmio.device&quot;内核模块参数实例化virtio-mmio设备.注意,错误的参数(特别是&quot;baseaddr&quot;错误)会导致系统崩溃.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/kernel-parameters.txt">Documentation/kernel-parameters.txt</a>&ldquo;文档中对&quot;virtio_mmio.device&quot;的说明.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Microsoft Hyper-V guest support</p>
<ul>
<li>仅在将此Linux内核作为<a href="http://technet.microsoft.com/zh-cn/library/hh831531.aspx">微软Hyper-V虚拟机</a>的来宾操作系统运行时,才需要开启这里的选项.</li>
<li>
<ul>
<li>
<p>Microsoft Hyper-V client drivers
CONFIG_HYPERV</p>
<ul>
<li>将Linux内核作为Hyper-V的来宾操作系统运行</li>
<li>
<ul>
<li>
<p>Microsoft Hyper-V Utilities driver
CONFIG_HYPERV_UTILS</p>
<p><a href="http://technet.microsoft.com/zh-cn/library/cc794756.aspx">Hyper-V管理工具</a>驱动.</p>
</li>
<li>
<p>Microsoft Hyper-V Balloon driver
CONFIG_HYPERV_BALLOON</p>
<p>Hyper-V <a href="http://technet.microsoft.com/zh-cn/library/hh831766.aspx">Balloon</a>驱动</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Xen driver support</p>
<p>仅在将此Linux内核作为半虚拟化模式的<a href="http://cn.opensuse.org/Xen%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%80%E4%BB%8B">XEN虚拟机</a>的来宾操作系统运行时,才需要开启这里的选项.由于KVM的高歌猛进,特别是Ubuntu和Redhat的力挺,与昔日的辉煌相比,<a href="http://virtual.51cto.com/art/201212/375071.htm">XEN现在已经没落许多了</a>.</p>
</li>
<li>
<p>Staging drivers
CONFIG_STAGING</p>
<p>尚在开发中或尚未完成的,目前尚不完善的驱动,切勿用于生产环境.仅供测试人员或者开发者试用.</p>
</li>
<li>
<p>X86 Platform Specific Device Drivers
CONFIG_X86_PLATFORM_DEVICES</p>
<ul>
<li>特定于X86平台的设备驱动.例如很多笔记本厂商的专有硬件和特色功能.大多数笔记本用户都应该进去看看(简单易懂,一看即知).</li>
<li>
<ul>
<li>
<ul>
<li>{此处省略所有特定于笔记本厂商的驱动}</li>
<li>Thermal Management driver for Intel menlow platform
CONFIG_INTEL_MENLOW</li>
</ul>
<p>此驱动专用于<a href="http://www.inpai.com.cn/doc/hard/105589.htm">Intel Menlow</a>平台(搭配Atom处理器),提供了增强的ACPI热量管理能力.</p>
</li>
<li>
<p>WMI
CONFIG_ACPI_WMI</p>
<p>ACPI-WMI(<a href="http://technet.microsoft.com/zh-cn/library/ee692772.aspx">Windows管理规范</a>)映射设备(PNP0C14)支持.<a href="http://en.wikipedia.org/wiki/Windows_Management_Instrumentation">WMI</a>是微软对ACPI规范的专有扩展,可将部分ACPI固件内容通过PNP0C14设备映射到用户空间,以方便用户空间调用ACPI固件的功能.本选项仅为那些依赖于WMI的驱动提供支持(并不真正导出到用户空间),例如CONFIG_DRM_NOUVEAU驱动以及专用于Acer/Asus/Dell/MSI/HP等品牌笔记本的WMI驱动.</p>
</li>
<li>
<p>Intel Intelligent Power Sharing
CONFIG_INTEL_IPS</p>
<p>Intel <a href="http://baike.baidu.com/view/1502112.htm">Calpella</a>平台支持Intel的智能电源共享(Intelligent Power Sharing)技术,可以在保持功耗不变的前提下,在CPU和GPU之间智能分配电力.开启此项和CONFIG_CPU_FREQ以及CONFIG_DRM_I915之后,即可实现此功能.</p>
</li>
<li>
<p>WMI support for MXM Laptop Graphics
CONFIG_MXM_WMI</p>
<p><a href="http://baike.baidu.com/view/776209.htm">MXM接口</a>笔记本显卡的WMI支持.目前主要用于nvidia显卡.</p>
</li>
<li>
<p>Intel Oaktrail Platform Extras
CONFIG_INTEL_OAKTRAIL</p>
<p>Intel <a href="http://baike.baidu.com/view/4045526.htm">Oak Trail</a>嵌入式平台需要此驱动来开关WiFi/相机/蓝牙等设备.</p>
</li>
<li>
<p>pvpanic device support
CONFIG_PVPANIC</p>
<p>pvpanic是<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-qemu-monitor/">QEMU</a>提供的一种准虚拟化(paravirtualized)设备,允许客户机向宿主机报告panic事件.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Common Clock Framework</p>
<ul>
<li>CCF(<a href="http://lwn.net/Articles/472998/">Common Clock Framework</a>)是从3.4内核开始引入的新时钟框架,用于取代原有的&quot;Clock Framework&rdquo;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/clk.txt">Documentation/clk.txt</a>&ldquo;文档.这里还有一个<a href="http://events.linuxfoundation.org/images/stories/slides/elc2013_clement.pdf">讲解CCF的PDF</a>.</li>
<li>
<ul>
<li>
<p>DebugFS representation of clock tree
CONFIG_COMMON_CLK_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>{此处省略的时钟设备请按实际情况选择(主要用于嵌入式设备)}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Hardware Spinlock drivers</p>
<p>硬件<a href="http://blog.chinaunix.net/uid-20543672-id-3252604.html">自旋锁</a>驱动.目前仅出现在嵌入式处理器上.自旋锁是保护共享资源的一种锁机制,与互斥锁比较类似,都是为了解决对某项资源的互斥使用.无论是互斥锁,还是自旋锁,在任何时刻,最多只能有一个持有者.也就是说,在任何时刻最多只能有一个执行单元获得锁.但是两者在调度机制上略有不同,对于互斥锁,如果资源已经被占用,资源申请者只能进入睡眠状态.但是自旋锁不会引起申请者睡眠,如果自旋锁已经被别的执行单元保持,调用者就一直在循环中&quot;忙等&rdquo;(占用CPU但无事可做),直到该自旋锁被释放.&ldquo;自旋&quot;一词就是因此而得名.自旋锁的使用非常方便,但仅适用于需要极短时间锁定的场合(例如1毫秒),以避免消耗太多的CPU空等时间.</p>
</li>
<li>
<p>Mailbox Hardware Support
CONFIG_MAILBOX</p>
<p>Mailbox硬件支持.这里的&quot;Mailbox&quot;是一个框架,通过消息队列和中断驱动信号,控制芯片上的多个处理器之间的通信.仅用于嵌入式环境.</p>
</li>
<li>
<p>IOMMU Hardware Support
CONFIG_IOMMU_SUPPORT</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/IOMMU">IOMMU</a>硬件主要出现在<a href="http://en.wikipedia.org/wiki/List_of_IOMMU-supporting_hardware">带有I/O虚拟化技术的硬件</a>上,例如带有<a href="http://www.amd.com/cn/products/server/processors/Pages/amd-platform-specifications.aspx">AMD-Vi</a>或<a href="http://software.intel.com/zh-cn/articles/io-vt-d-io">VT-d</a>技术的芯片.IOMMU主要作用:(1)内存地址转换(例如DMA地址转换,scatter-gather),(2)中断重映射,(3)对设备读取和写入的进行权限检查.这对于提高虚拟化性能和安全性,以及在64位系统上更好的使用32位设备,意义重大.[提示]此选项仅对宿主机有意义,如果此内核要作为来宾操作系统运行,请选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>AMD IOMMU support
CONFIG_AMD_IOMMU</p>
<ul>
<li>AMD IOMMU 硬件支持.一般还需要在BIOS中开启相应选项.</li>
<li>
<ul>
<li>
<p>Export AMD IOMMU statistics to debugfs
CONFIG_AMD_IOMMU_STATS</p>
<p>仅供调试使用</p>
</li>
<li>
<p>AMD IOMMU Version 2 driver
CONFIG_AMD_IOMMU_V2</p>
<p>新一代的AMD IOMMUv2硬件(支持PCI PRI和PASID接口)支持.首次出现在AMD Opteron 4000/6000系列平台上.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support for Intel IOMMU using DMA Remapping Devices
CONFIG_INTEL_IOMMU</p>
<ul>
<li>让Intel IOMMU支持DMA重映射,这是IOMMU的主要用途,只要你的芯片支持VT-d,就选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Enable Intel DMA Remapping Devices by default
CONFIG_INTEL_IOMMU_DEFAULT_ON</p>
<p>默认开启DMA重映射支持,相当于设置&quot;intel_iommu=on&quot;内核引导参数.选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support for Interrupt Remapping
CONFIG_IRQ_REMAP</p>
<p>支持对IO-APIC和MSI设备开启中断重映射,这也是IOMMU的主要用途,只要你的芯片支持VT-d,就选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Remoteproc drivers</p>
<p>现代的SoC芯片一般都会以<a href="http://baike.baidu.com/view/6350155.htm">AMP</a>(<a href="http://www.go-gddq.com/html/QiTa-ZongHe_tx/2012-04/946163.htm">非对称多处理器</a>)方式集成多个不同的处理器(例如<a href="http://www.ti.com.cn/general/cn/docs/wtbu/wtbuproductcontent.tsp?templateId=6123&amp;navigationId=12864&amp;contentId=103103">OMAP5432</a>就在单个芯片上集成了2个Cortex-A15处理器,2个Cortex-M4处理器,1个C64x DSP),这样就可在不同的处理器上分别运行多个不同的操作系统实例(例如,在2个Cortex-A9处理器上以SMP(对称多处理器)方式运行Linux,在2个Cortex-M3和1个C64x上分别运行不同的实时操作系统).而Remoteproc驱动对此种场合下的处理器间通信非常有用.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/remoteproc.txt">Documentation/remoteproc.txt</a>&ldquo;和&rdquo;<a href="http://lxr.linux.no/linux/Documentation/rpmsg.txt">Documentation/rpmsg.txt</a>&ldquo;文档.目前仅对嵌入式系统有意义.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Rpmsg drivers</p>
<p>此项和上面的Remoteproc紧密相关,目前其下尚无子项可选.</p>
</li>
<li>
<p>Generic Dynamic Voltage and Frequency Scaling (DVFS) support
CONFIG_PM_DEVFREQ</p>
<p>DVFS(<a href="http://www.360doc.com/content/09/0710/14/74585_4212349.shtml">动态电压与频率调整</a>)可以根据系统负载动态调节设备的运行频率和电压(对于同一芯片,频率越高,需要的电压也越高),从而达到节能目的.此选项提供了一个类似CPUfreq(CONFIG_CPU_FREQ)的通用DVFS框架(devfreq).目前DVFS技术进在嵌入式设备(例如Exynos4/Exynos5)上普遍存在.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>External Connector Class (extcon) support
CONFIG_EXTCON</p>
<p>extcon(外部连接器类)允许用户空间通过sysfs和uevent监控外部连接器,同时也支持多状态外部连接器(也就是拥有多个连接线缆的外部连接器).例如,一端连接到主机USB端口的多状态外部连接器,另一端可以同时连接一条<a href="http://baike.baidu.com/view/50611.htm">HDMI</a>线缆和一个<a href="http://baike.baidu.com/view/3591885.htm">AC适配器</a>.30针的<a href="http://zh.wikipedia.org/wiki/PDMI">PDMI</a>连接器也是多状态外部连接器的常见例子.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Memory Controller drivers
CONFIG_MEMORY</p>
<p>内存控制器驱动.这里所说的&quot;内存控制器&quot;仅指嵌入式SoC系统中的各种控制器.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Industrial I/O support
CONFIG_IIO</p>
<p><a href="http://blog.chinaunix.net/uid-20543672-id-2976189.html">IIO子系统</a>为各种不同总线(i2c,spi,等)的嵌入式传感器驱动提供了一个统一的框架.例如:(1)模数转换器,(2)加速度传感器,(3)陀螺仪,(4)惯性测量仪,(5)电容-数字转换器,(6)压力/温度/光线传感器,等等.主要用于工业领域和嵌入式领域.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Intel Non-Transparent Bridge support
CONFIG_NTB</p>
<p><a href="http://www.chinabaike.com/2011/0324/599696.html">PCI-E非透明桥</a>是一个点对点PCI-E总线,用于连接两条对等的PCI-E总线.通常用于嵌入式智能I/O板卡.例如英特尔C5500/C3500系列嵌入式至强处理器.具体支持的设备号(PCI_DEVICE_ID)可以查看&quot;drivers/ntb/ntb_hw.h&quot;文件.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>VME bridge support
CONFIG_VME_BUS</p>
<p><a href="http://baike.baidu.com/view/1548999.htm">VME</a>(VersaModule Eurocard)总线是一种通用的计算机总线,主要用于工业控制/军用系统/航空航天/交通运输/医疗等嵌入式领域.而<a href="http://zh.idt.com/products/interface-connectivity/vme/pci-vme-bridge">VME桥</a>则是其他总线(例如PCI/PCI-E)到VME总线之间的转换芯片.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Pulse-Width Modulation (PWM) Support
CONFIG_PWM</p>
<p><a href="http://zh.wikipedia.org/wiki/%E8%84%88%E8%A1%9D%E5%AF%AC%E5%BA%A6%E8%AA%BF%E8%AE%8A">PWM</a>(<a href="http://baike.baidu.com/view/631384.htm">脉宽调制</a>)是将模拟信号转换为脉波的一种技术.在计算机领域,这项技术常被用于控制风扇转速和背光显示器的亮度.很多微型处理器内部都包含有PWM控制器,此选项为所有PWM控制器驱动提供了一个统一的框架.主要用于嵌入式环境.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>IndustryPack bus support
CONFIG_IPACK_BUS</p>
<p><a href="http://www.acromag.com/catalog/818">IndustryPack</a>是工业控制领域常用的一种总线.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Reset Controller Support
CONFIG_RESET_CONTROLLER</p>
<p>为GPIO总线或者芯片内置的重启控制器提供通用支持.仅用于嵌入式设备.不确定的选&quot;N&quot;.</p>
</li>
</ul>
<h2 id="firmware-drivers-固件firmwarehttpbaikebaiducomview33738htm驱动"><a href=""></a>Firmware Drivers 固件(<a href="http://baike.baidu.com/view/33738.htm">Firmware</a>)驱动</h2>
<ul>
<li>
<p>BIOS Enhanced Disk Drive calls determine boot disk
CONFIG_EDD</p>
<ul>
<li>这是一个实验性选项,支持<a href="http://baike.baidu.com/view/404433.htm">实模式</a>BIOS中的增强磁盘服务(EDD),从而实现从某个特定的硬盘启动(可以从sysfs中查看具体是哪个硬盘),大多数BIOS提供商都没有实现这个特性.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Sets default behavior for EDD detection to off
CONFIG_EDD_OFF</p>
<p>选&quot;Y&quot;相当于使用&quot;edd=off&quot;内核引导参数(禁用EDD),选&quot;N&quot;相当于使用&quot;edd=on&quot;内核引导参数(启用EDD).语法:edd={on|skipmbr|off}.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Add firmware-provided memory map to sysfs
CONFIG_FIRMWARE_MEMMAP</p>
<p>将原始的固件内容映射到&quot;/sys/firmware/memmap&quot;文件.主要用于调试目的,以及kexec为下一个内核设置参数.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/ABI/testing/sysfs-firmware-memmap">Documentation/ABI/testing/sysfs-firmware-memmap</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>BIOS update support for DELL systems via sysfs
CONFIG_DELL_RBU</p>
<p>允许<a href="http://zh.community.dell.com/techcenter/systems-management/w/wiki/380.openmanage.aspx">Dell OpenManage</a>或<a href="http://wenku.baidu.com/view/1c00d6b2fd0a79563c1e72c9.html">DUP</a>(Dell Update Packages)工具通过sysfs更新DELL服务器主板的BIOS.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/dell_rbu.txt">Documentation/dell_rbu.txt</a>&ldquo;文档.即使你确实需要此功能,也建议选&quot;M&quot;而不是&quot;Y&rdquo;.毕竟刷BIOS不能当做家常便饭.留着刷BIOS的接口,总是件危险的事.</p>
</li>
<li>
<p>Dell Systems Management Base Driver
CONFIG_DCDBAS</p>
<p>该驱动为DELL服务器专用的系统管理软件(Dell OpenManage)提供了sysfs接口.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/dcdbas.txt">Documentation/dcdbas.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Export DMI identification via sysfs to userspace
CONFIG_DMIID</p>
<p>将<a href="http://baike.baidu.com/view/1790409.htm">SMBIOS</a>(<a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a>)/<a href="http://www.dmtf.org/standards/dmi">DMI</a>(<a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface">Desktop Management Interface</a>)中的系统识别信息(序列号,制造商,型号,等等)导出到用户空间(/sys/class/dmi/id/).开启此项后,<a href="http://www.joecen.com/2007/04/19/view-bios-operating-system-in-the-dmi-smbios-information/">dmidecode</a>工具就可以显示与制造商相关的信息.此外,基于DMI的模块的自动加载也依赖于此项.</p>
</li>
<li>
<p>DMI table support in sysfs
CONFIG_DMI_SYSFS</p>
<p>将SMBIOS/DMI中的原始数据(包含大量的系统硬件信息)导出到用户空间(/sys/firmware/dmi/).这些信息可以通过<a href="http://blog.sina.com.cn/s/blog_4152a9f50100wh48.html">dmidecode</a>工具显示出来.</p>
</li>
<li>
<p>iSCSI Boot Firmware Table Attributes
CONFIG_ISCSI_IBFT_FIND</p>
<ul>
<li>使内核能定位iBFT(<a href="http://zh.wikipedia.org/wiki/ISCSI">iSCSI</a> Boot Firmware Table)在内存中的位置.目的是为子项(CONFIG_ISCSI_IBFT)提供支持.</li>
<li>
<ul>
<li>
<p>iSCSI Boot Firmware Table Attributes module
CONFIG_ISCSI_IBFT</p>
<p>将iBFT(<a href="http://baike.baidu.com/view/120148.htm">iSCSI</a> Boot Firmware Table)的内容通过sysfs导出到用户空间.如果你想在系统引导过程中动态检测iSCSI引导参数,可以选&quot;Y&rdquo;,否则应选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Google Firmware Drivers
CONFIG_GOOGLE_FIRMWARE</p>
<p>仅用于Google自家的服务器</p>
</li>
<li>
<p>EFI (Extensible Firmware Interface) Support</p>
<ul>
<li><a href="http://www.intel.cn/content/www/cn/zh/architecture-and-technology/unified-extensible-firmware-interface/efi-homepage-general-technology.html">EFI/UEFI</a>(<a href="http://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">统一可扩展固件接口</a>)支持.2009年之后,UEFI已经基本全线取代了BIOS.</li>
<li>
<ul>
<li>
<p>EFI Variable Support via sysfs
CONFIG_EFI_VARS</p>
<ul>
<li>允许通过sysfs接口操作(读/写/新建/删除)EFI变量.开启后可支持各种<a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Userspace_Tools">操作EFI变量的工具</a>:<a href="https://github.com/vathpela/efivar">efivar‎</a>,<a href="http://linux.dell.com/efibootmgr/">efibootmgr</a>,<a href="https://github.com/vathpela/efibootmgr">vathpela/efibootmgr</a>,<a href="https://github.com/fpmurphy/Various">uefivars</a>,<a href="http://git.kernel.org/cgit/linux/kernel/git/jejb/efitools.git">efitools</a>,<a href="https://wiki.ubuntu.com/Kernel/Reference/fwts">fwts</a>(Firmware Test Suite).建议选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>Register efivars backend for pstore
CONFIG_EFI_VARS_PSTORE</p>
<ul>
<li>将efivars模块(CONFIG_EFI_VARS)用作pstore文件系统(CONFIG_PSTORE)的后端.这样就可以向EFI变量中写入各种pstore支持的信息,例如,控制台消息,崩溃转储,等等.</li>
<li>
<ul>
<li>
<p>Disable using efivars as a pstore backend by default
CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE</p>
<p>禁止默认将efivars模块(CONFIG_EFI_VARS)用作pstore文件系统(CONFIG_PSTORE)的后端.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="file-systems-文件系统"><a href=""></a>File systems 文件系统</h2>
<ul>
<li>
<p>Second extended fs support
CONFIG_EXT2_FS</p>
<ul>
<li>Ext2文件系统,无日志.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/ext2.txt">Documentation/filesystems/ext2.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Ext2 extended attributes
CONFIG_EXT2_FS_XATTR</p>
<ul>
<li>Ext2文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选&quot;N&rdquo;.</li>
<li>
<ul>
<li>
<p>Ext2 POSIX Access Control Lists
CONFIG_EXT2_FS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Ext2 Security Labels
CONFIG_EXT2_FS_SECURITY</p>
<p>&ldquo;安全标签&quot;允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ext2 execute in place support
CONFIG_EXT2_FS_XIP</p>
<p><a href="http://blog.chinaunix.net/uid-26404697-id-3152290.html">芯片内执行</a>(<a href="http://en.wikipedia.org/wiki/Execute_in_place">execute in place</a>)的意思是程序在写入存储介质时就已经分配好运行时的地址,因此不需要载入内存即可在芯片内执行,一般仅在嵌入式系统上才使用这种技术.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Ext3 journalling file system support
CONFIG_EXT3_FS</p>
<ul>
<li>Ext3日志型文件系统.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/ext3.txt">Documentation/filesystems/ext3.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Default to &lsquo;data=ordered&rsquo; in ext3
CONFIG_EXT3_DEFAULTS_TO_ORDERED</p>
<p>选&quot;Y&quot;表示将默认的日志模式设为&quot;data=ordered&rdquo;(更安全),选&quot;N&quot;表示将默认的日志模式设为&quot;data=writeback&quot;(更危险).选&quot;Y&quot;,仅在你确实明白&quot;data=writeback&quot;的风险,以及确实有充足的理由的时候,才能选&quot;N&quot;.</p>
</li>
<li>
<p>Ext3 extended attributes
CONFIG_EXT3_FS_XATTR</p>
<ul>
<li>Ext3文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Ext3 POSIX Access Control Lists
CONFIG_EXT3_FS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Ext3 Security Labels
CONFIG_EXT3_FS_SECURITY</p>
<p>&ldquo;安全标签&quot;允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The Extended 4 (ext4) filesystem
CONFIG_EXT4_FS</p>
<ul>
<li>Ext4日志型文件系统.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/ext4.txt">Documentation/filesystems/ext4.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Use ext4 for ext2/ext3 file systems
CONFIG_EXT4_USE_FOR_EXT23</p>
<p>在ext2/ext3文件系统上使用ext4驱动.这样可以对ext2/ext3/ext4三种文件系统只使用同一个驱动.主要目的是减少内核尺寸.</p>
</li>
<li>
<p>Ext4 POSIX Access Control Lists
CONFIG_EXT4_FS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Ext4 Security Labels
CONFIG_EXT4_FS_SECURITY</p>
<p>&ldquo;安全标签&quot;允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选&quot;N&rdquo;.</p>
</li>
<li>
<p>EXT4 debugging support
CONFIG_EXT4_DEBUG</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JBD (ext3) debugging support
CONFIG_JBD_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>JBD2 (ext4) debugging support
CONFIG_JBD2_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Reiserfs support
CONFIG_REISERFS_FS</p>
<ul>
<li>曾经的明星文件系统,特别擅长处理大量小文件的场合,由于其创始人入狱,前景不明.</li>
<li>
<ul>
<li>
<p>Enable reiserfs debug mode
CONFIG_REISERFS_CHECK</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Stats in /proc/fs/reiserfs
CONFIG_REISERFS_PROC_INFO</p>
<p>在/proc/fs/reiserfs文件中显示Reiserfs文件系统的状态,仅供调试使用</p>
</li>
<li>
<p>ReiserFS extended attributes
CONFIG_REISERFS_FS_XATTR</p>
<ul>
<li>ReiserFS文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>ReiserFS POSIX Access Control Lists
CONFIG_REISERFS_FS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>ReiserFS Security Labels
CONFIG_REISERFS_FS_SECURITY</p>
<p>&ldquo;安全标签&quot;允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JFS filesystem support
CONFIG_JFS_FS</p>
<ul>
<li>JFS日志型文件系统.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/jfs.txt">Documentation/filesystems/jfs.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>JFS POSIX Access Control Lists
CONFIG_JFS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>JFS Security Labels
CONFIG_JFS_SECURITY</p>
<p>&ldquo;安全标签&quot;允许选择使用不同安全模块(如SELinux)实现的访问控制模型,如果你没有使用需要扩展属性的安全模块,可以选&quot;N&rdquo;.</p>
</li>
<li>
<p>JFS debugging
CONFIG_JFS_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>JFS statistics
CONFIG_JFS_STATISTICS</p>
<p>在/proc/fs/jfs/目录中显示JFS文件系统的统计信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>XFS filesystem support
CONFIG_XFS_FS</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/XFS">XFS</a>日志型文件系统是一个高性能的文件系统(笔者的最爱),<a href="http://os.51cto.com/art/201202/315553.htm">擅长大文件和多线程</a>.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/">Documentation/filesystems/</a>&ldquo;目录中&quot;xfs*.txt&quot;系列文档.</li>
<li>
<ul>
<li>
<p>XFS Quota support
CONFIG_XFS_QUOTA</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-104-4/index.html">XFS磁盘配额</a>(使用专用的<a href="http://linux.die.net/man/8/xfs_quota">xfs_quota</a>工具)比通用磁盘配额模块(CONFIG_QUOTA)拥有更高级的特性,它不但能够控制用户或组的磁盘用量,还能控制项目(文件夹)的磁盘用量(无论哪个用户在项目的文件夹中创建文件),但是不能同时使用组配额和项目配额.此外,对XFS来说,配额数据记录在文件系统元数据中,而不是像CONFIG_QUOTA那样记录在aquota.user和aquota.group文件中.最后,XFS配额和通用磁盘配额是两个相互独立的系统,可以同时并存.</p>
</li>
<li>
<p>XFS POSIX ACL support
CONFIG_XFS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>XFS Realtime subvolume support
CONFIG_XFS_RT</p>
<p>&ldquo;实时子卷&quot;是专门存储文件数据的卷,可以允许将日志与数据分开在不同的磁盘上,例如将大块头的流媒体文件存储在高速磁盘组成的实时子卷上.详见<a href="http://linux.die.net/man/5/xfs">xfs</a>手册页.</p>
</li>
<li>
<p>XFS Verbose Warnings
CONFIG_XFS_WARN</p>
<p>仅供调试使用</p>
</li>
<li>
<p>XFS Debugging support
CONFIG_XFS_DEBUG</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>GFS2 file system support
CONFIG_GFS2_FS</p>
<ul>
<li><a href="https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Global_File_System_2/ch-overview-GFS2.html">GFS2</a>可用于<a href="http://dreamfire.blog.51cto.com/418026/1219221">搭建高可用集群文件系统</a>,由红帽公司开发,允许所有集群节点并行访问,同时又能够完美的保持文件系统的一致性:一个节点对文件系统的任何修改都立即对所有其他节点可见.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/filesystems/">Documentation/filesystems/</a>&ldquo;目录中&quot;gfs*.txt&quot;系列文档.</li>
<li>
<ul>
<li>
<p>GFS2 DLM locking
CONFIG_GFS2_FS_LOCKING_DLM</p>
<p>GFS2分布式锁管理器(<a href="https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Global_File_System_2/s1-ov-lockbounce.html">DLM</a>).务必选&quot;Y&rdquo;,除非你知道自己在做什么.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>OCFS2 file system support
CONFIG_OCFS2_FS</p>
<ul>
<li><a href="http://www.oracle.com/us/technologies/linux/025995.htm">OCFS2</a>(<a href="http://wenku.baidu.com/view/2ee98027192e45361066f5d1.html">Oracle集群文件系统</a>)的目标是成为一种通用文件系统.OCFS2能使集群中的所有节点并发的通过标准文件系统接口来访问存储备.要使用OCFS2还需要<a href="http://oss.oracle.com/projects/ocfs2-tools">ocfs2-tools</a>的帮助.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/ocfs2.txt">Documentation/filesystems/ocfs2.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>O2CB Kernelspace Clustering
CONFIG_OCFS2_FS_O2CB</p>
<p>O2CB(OCFS2 Cluster Base)是位于内核空间的集群服务结构.具体包括:NM(节点管理器,监控所有节点),HB(心跳服务),TCP(控制节点间的通讯),DLM(分布式锁管理器),CONFIGFS(用户配置文件系统驱动,挂载点是/config),DLMFS(用户空间和内核空间DLM的接口).开启此项后,将只需要很少量的用户空间组件(也就是<a href="http://oss.oracle.com/projects/ocfs2-tools">ocfs2-tools</a>),OCFS2就可以转起来了.但它只能玩转OCFS2自身,玩不了其他集群.</p>
</li>
<li>
<p>OCFS2 Userspace Clustering
CONFIG_OCFS2_FS_USERSPACE_CLUSTER</p>
<p>为用户空间的集群服务提供支持.目的是为了配合CONFIG_DLM模块一起使用.</p>
</li>
<li>
<p>OCFS2 statistics
CONFIG_OCFS2_FS_STATS</p>
<p>允许对OCFS2的使用状况进行一些统计.开启后会增加内存占用.</p>
</li>
<li>
<p>OCFS2 logging support
CONFIG_OCFS2_DEBUG_MASKLOG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>OCFS2 expensive checks
CONFIG_OCFS2_DEBUG_FS</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Btrfs filesystem support
CONFIG_BTRFS_FS</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/">Btrfs</a>是由Oracle于2007年宣布的支持写时复制(COW)的文件系统.拥有众多抢眼球的特性:软RAID管理,卷管理,克隆/快照,压缩功能,支持跨多块磁盘动态增大或收缩卷.其目标是成为<a href="http://os.51cto.com/art/201004/195096.htm">下一代Linux标准文件系统</a>.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/filesystems/btrfs.txt">Documentation/filesystems/btrfs.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Btrfs POSIX Access Control Lists
CONFIG_BTRFS_FS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Btrfs with integrity check tool compiled in (DANGEROUS)
CONFIG_BTRFS_FS_CHECK_INTEGRITY</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Btrfs will run sanity tests upon loading
CONFIG_BTRFS_FS_RUN_SANITY_TESTS</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Btrfs debugging support</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NILFS2 file system support
CONFIG_NILFS2_FS</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-nilfs2/index.html">NILFS2</a>是一种非常前卫的&quot;log-structured&quot;文件系统,是<a href="http://www.ibm.com/developerworks/cn/linux/l-nilfs-exofs/">Linux下一代文件系统</a>的有力竞争者.NILFS2将底层设备当作一种只能追加写(append)的设备,文件系统的任何修改都只以顺序追加的方式写入磁盘(而是不覆盖旧数据),从而避免耗时的寻道(seek)操作,从而大幅提升写入性能(因为文件系统的整体效率主要由写操作的效率决定).此种思路带来了一系列靓瞎眼的特性:自动不间断快照(可以迅速恢复被删除的文件或者回到先前某个特定的时间点),快速崩溃恢复(比大多数日志型文件系统还要快),高性能(在SSD上更有绝对优势).但也带来了一个新问题:需要垃圾收集机制以清理旧数据,造成垃圾收集时的性能降低(可以通过合理安排垃圾收集时间来避免).NILFS2目前不支持如下功能:atime(访问时间),POSIX ACL,扩展属性.不过考虑到SSD(固态硬盘)即将成为主流,假以时日,前途大大的啊!.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/nilfs2.txt">Documentation/filesystems/nilfs2.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Enable POSIX file locking API
CONFIG_FILE_LOCKING</p>
<p>POSIX标准文件锁定API支持.NFS之类的网络文件系统和给文件加锁与解锁的<a href="http://blog.sina.com.cn/s/blog_484102dd0101385h.html">flock()</a>系统调用需要它.不确定的选&quot;Y&rdquo;.</p>
</li>
<li>
<p>Dnotify support
CONFIG_DNOTIFY</p>
<p>旧式的基于目录的文件变化的通知机制(已被Inotify取代),目前仅有少量古董程序依赖它.建议选&quot;N&quot;.</p>
</li>
<li>
<p>Inotify support for userspace
CONFIG_INOTIFY_USER</p>
<p>用户空间的Inotify支持.<a href="http://zh.wikipedia.org/zh-cn/Inotify">Inotify</a>是替代Dnotify的文件系统变化通知机制.建议选&quot;Y&quot;.[提示]如果你使用了<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>作为init,那就必须选&quot;Y&quot;.</p>
</li>
<li>
<p>Filesystem wide access notification
CONFIG_FANOTIFY</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-fanotify/">fanotify</a>是一种打算取代Inotify的文件系统变化通知机制,不过,由于目前<a href="http://blog.yikuyiku.com/?p=2885">Fanotify比inotify</a>支持的文件系统事件类型少很多,完全取代Inotify还不现实.建议选&quot;Y&quot;.[提示]如果你使用了<a href="http://zh.wikipedia.org/wiki/Systemd">systemd</a>作为init,那就必须选&quot;Y&quot;.</li>
<li>
<ul>
<li>
<p>fanotify permissions checking
CONFIG_FANOTIFY_ACCESS_PERMISSIONS</p>
<p>允许fanotify的监听器(listener)对文件系统事件进行权限检查.这样,监听器就可以在系统访问某个文件之前,首先扫描此文件.某些防病毒程序以及<a href="http://www.searchstorage.com.cn/whatis/word_2112.htm">分级存储管理</a>系统可能需要此特性.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Quota support
CONFIG_QUOTA</p>
<p>通用的磁盘配额支持(限制某个用户或者某组用户的磁盘占用空间).需要配合<a href="http://sourceforge.net/projects/linuxquota/">quota-tools</a>工具使用.</p>
</li>
<li>
<p>Report quota messages through netlink interface
CONFIG_QUOTA_NETLINK_INTERFACE</p>
<p>通过<a href="http://zh.wikipedia.org/wiki/Netlink">netlink</a>接口报告QUOTA的警告信息(例如&quot;到达限额&quot;).不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>Print quota warnings to console (OBSOLETE)
CONFIG_PRINT_QUOTA_WARNING</p>
<p>将QUOTA的警告信息直接显示在控制台上.反对使用,未来会移除此项.选&quot;N&quot;.</p>
</li>
<li>
<p>Additional quota sanity checks
CONFIG_QUOTA_DEBUG</p>
<p>对quota内部结构进行额外的完整性检查.主要用于调试目的.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Old quota format support
CONFIG_QFMT_V1</p>
<p>老旧的v1版配额格式(linux-2.4.22之前使用的格式)支持.选&quot;N&quot;.</p>
</li>
<li>
<p>Quota format vfsv0 and vfsv1 support
CONFIG_QFMT_V2</p>
<p>vfsv0/vfsv1配额格式支持.两者都支持32位的UID/GID,而vfsv1还支持64位的inode/block配额.建议开启.</p>
</li>
<li>
<p>Kernel automounter version 4 support (also supports v3)
CONFIG_AUTOFS4_FS</p>
<p>新的内核按需自动加载远程文件系统的支持(也支持v3).此特性需要配合用户空间工具(<a href="https://www.kernel.org/pub/linux/daemons/autofs/v5/">autofs</a>)使用,并且需要开启NFS文件系统支持.如果你的计算机不是大型分布式网络的一部分,你应该不会需要此功能.</p>
</li>
<li>
<p>FUSE (Filesystem in Userspace) support
CONFIG_FUSE_FS</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/FUSE">FUSE</a>允许在用户空间实现一个全功能的文件系统,还有一个与之对应的<a href="http://fuse.sourceforge.net/">libfuse2</a>库和相关工具.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/fuse.txt">Documentation/filesystems/fuse.txt</a>&ldquo;文档.如果你打算开发一个自己的文件系统或者使用一个基于FUSE的文件系统(例如<a href="https://wiki.archlinux.org/index.php/NTFS-3G_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">NTFS-3G</a>或<a href="http://www.ibm.com/developerworks/cn/linux/l-zfs/index.html">ZFS-FUSE</a>),可以选&quot;Y&rdquo;.</li>
<li>
<ul>
<li>
<p>Character device in Userspace support
CONFIG_CUSE</p>
<p>这是一个FUSE扩展,用于在用户空间实现字符设备支持.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Caches</p>
<ul>
<li>文件系统缓存</li>
<li>
<ul>
<li>
<p>General filesystem local caching manager
CONFIG_FSCACHE</p>
<ul>
<li>通用文件系统本地缓存管理器.它为各种不同的文件系统(例如网络文件系统)提供了统一的本地缓存框架.这样各种缓存实现可以作为插件添加进来.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/caching/fscache.txt">Documentation/filesystems/caching/fscache.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Gather statistical information on local caching
CONFIG_FSCACHE_STATS</p>
<p>收集本地缓存的统计信息(这会增加系统运行负载),并通过/proc/fs/fscache/stats文件导出到用户空间.主要用于调试目的.</p>
</li>
<li>
<p>Gather latency information on local caching
CONFIG_FSCACHE_HISTOGRAM</p>
<p>收集本地缓存的延迟信息(这会增加系统运行负载),并通过/proc/fs/fscache/histogram文件导出到用户空间.主要用于调试目的.</p>
</li>
<li>
<p>Debug FS-Cache
CONFIG_FSCACHE_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Maintain global object list for debugging purposes
CONFIG_FSCACHE_OBJECT_LIST</p>
<p>在/proc/fs/fscache/objects文件中维护一个活动缓存对象的全局列表.仅用于调试目的.</p>
</li>
<li>
<p>Filesystem caching on files
CONFIG_CACHEFILES</p>
<ul>
<li>将一个已挂载的文件系统用作另一个文件系统的缓存.例如将一个本地磁盘分区挂载为一个远程网络文件系统的缓存,或者将一个高速设备(例如SSD)用作一个低速设备(例如普通硬盘)的缓存.</li>
<li>
<ul>
<li>
<p>Debug CacheFiles
CONFIG_CACHEFILES_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>Gather latency information on CacheFiles
CONFIG_CACHEFILES_HISTOGRAM</p>
<p>收集本地缓存的延迟信息(这会增加系统运行负载),并通过/proc/fs/cachefiles/histogram文件导出到用户空间.主要用于调试目的.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CD-ROM/DVD Filesystems</p>
<ul>
<li>CD-ROM/DVD<a href="http://blog.chinaunix.net/uid-11647316-id-2858441.html">光盘文件系统</a></li>
<li>
<ul>
<li>
<p>ISO 9660 CDROM file system support
CONFIG_ISO9660_FS</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/ISO_9660">ISO9660</a>是所有CD/DVD光盘通用的标准文件系统.建议选&quot;Y&rdquo;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/isofs.txt">Documentation/filesystems/isofs.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Microsoft Joliet CDROM extensions
CONFIG_JOLIET</p>
<p>Microsoft对ISO9660文件系统的<a href="http://baike.baidu.com/view/32493.htm">Joliet扩展</a>,允许在文件名中使用Unicode字符,也允许长文件名.建议选&quot;Y&rdquo;.</p>
</li>
<li>
<p>Transparent decompression extension
CONFIG_ZISOFS</p>
<p>Linux对ISO9660文件系统的扩展,允许将数据透明的压缩存储在CD上.使用并不广泛,不确定的可以选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UDF file system support
CONFIG_UDF_FS</p>
<p><a href="http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%85%89%E7%A2%9F%E6%A0%BC%E5%BC%8F">UDF</a>的目标是取代ISO9660,现已经广泛地用于大容量DVD光盘上(特别是刻录盘).建议选&quot;Y&quot;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/udf.txt">Documentation/filesystems/udf.txt</a>&ldquo;文档.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DOS/FAT/NT Filesystems</p>
<ul>
<li>DOS/FAT/NTFS文件系统</li>
<li>
<ul>
<li>
<p>MSDOS fs support
CONFIG_MSDOS_FS</p>
<p>古老的MSDOS文件系统(FAT16),基本绝种了</p>
</li>
<li>
<p>VFAT (Windows-95) fs support
CONFIG_VFAT_FS</p>
<ul>
<li>从Win95开始使用的VFAT文件系统(FAT32).如果你要使用基于UEFI平台的电脑,并且使用GPT磁盘分区,则必须选&quot;Y&rdquo;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/vfat.txt">Documentation/filesystems/vfat.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Default codepage for FAT
CONFIG_FAT_DEFAULT_CODEPAGE</p>
<p>在FAT系列文件系统上,&ldquo;8.3&quot;格式的短文件名以特定的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%A0%81%E9%A1%B5">代码页</a>进行存储(可以通过chcp命令查看),但长文件名却以Unicode进行存储.此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页.可以通过&quot;codepage&quot;挂载选项进行修改.简体中文通常使用&quot;936&rdquo;,繁体中文通常使用&quot;950&rdquo;.</p>
</li>
<li>
<p>Default iocharset for FAT
CONFIG_FAT_DEFAULT_IOCHARSET</p>
<p>指定默认以什么<a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">字符集</a>显示文件名,这个值可以通过&quot;iocharset&quot;挂载选项修改.但必须与系统的locale设置保持一致.例如在&quot;zh_CN.UTF-8&quot;或&quot;en_US.UTF-8&quot;的情况下应该使用&quot;utf8&quot;.[注意]应谨慎使用&quot;iocharset=utf8&quot;，因为它会导致FAT文件系统上的文件名变得大小写敏感。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NTFS file system support
CONFIG_NTFS_FS</p>
<ul>
<li>NTFS文件系统.仅选中此项表示仅支持只读(不支持NTFS压缩或加密文件),不支持写入.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/ntfs.txt">Documentation/filesystems/ntfs.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>NTFS debugging support
CONFIG_NTFS_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>NTFS write support
CONFIG_NTFS_RW</p>
<p>由于微软没有公开NTFS的技术标准,所以内核只能支持非常残缺的写入功能:仅能覆盖已存在的文件但不能改变其长度,不能创建文件或目录.建议选&quot;N&rdquo;.[提示]在Linux环境下写入NTFS始终是一件危险的事情,即使对于<a href="http://www.oschina.net/question/12_4941">NTFS-3G</a>也是如此,除了不支持压缩或加密文件之外,网上还有不少<a href="http://bbs.cfanclub.net/thread-497916-1-1.html">血的教训</a>,有兴趣可以搜搜.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Pseudo filesystems</p>
<ul>
<li>伪文件系统</li>
<li>
<ul>
<li>
<p>/proc file system support
CONFIG_PROC_FS</p>
<ul>
<li>显示系统状态的虚拟文件系统(进程信息,irq设置,内存使用,设备驱动,网络状态等),通常挂载到&quot;<a href="http://www.ibm.com/developerworks/cn/linux/l-proc.html">/proc</a>&ldquo;目录.许多程序依赖于它.选&quot;Y&rdquo;,除非你知道自己在做什么.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/proc.txt">Documentation/filesystems/proc.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>/proc/kcore support
CONFIG_PROC_KCORE</p>
<p>系统物理内存的映象.建议选&quot;N&rdquo;.</p>
</li>
<li>
<p>/proc/vmcore support
CONFIG_PROC_VMCORE</p>
<p>以ELF格式转储的已崩溃内核镜像,仅供调试使用</p>
</li>
<li>
<p>Sysctl support (/proc/sys)
CONFIG_PROC_SYSCTL</p>
<p>显示各种不同的内核调节参数,并让root用户能通过/proc/sys/目录交互地更改其中的某些内容.必选&quot;Y&quot;,除非你是嵌入式系统并且知道自己在做什么.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/sysctl/">Documentation/sysctl/</a>&ldquo;目录中的文档.</p>
</li>
<li>
<p>Enable /proc page monitoring
CONFIG_PROC_PAGE_MONITOR</p>
<p>用于监视进程内存占用的接口(/proc/&lt;pid&gt;/{smaps,clear_refs,pagemap}和/proc/{kpagecount,kpageflags}).建议选&quot;Y&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>sysfs file system support
CONFIG_SYSFS</p>
<p>导出内核内部对象及其属性和对象之间的相互关系的文件系统,通常挂载到&quot;<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sysfs/index.html">/sys</a>&ldquo;目录,sysfs把连接在系统上的设备和总线以及驱动程序等组织成为一个分级的文件,并允许通过该文件系统调整某些内核子系统以及设备的参数.内核启动时依靠它挂载类似&rdquo;/dev/sda1&quot;这样形式的根分区,禁用sysfs后必须在内核引导参数中使用设备号指定根分区(类似&quot;root=03:01&quot;这样).选&quot;Y&quot;,除非你知道自己在做什么.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/">Documentation/filesystems/</a>&ldquo;目录中&quot;sysfs*.txt&quot;系列文档.</p>
</li>
<li>
<p>Tmpfs virtual memory file system support (former shm fs)
CONFIG_TMPFS</p>
<ul>
<li><a href="http://baike.baidu.com/view/1511292.htm">tmpfs</a>文件系统(以前叫shm[共享内存]文件系统),大多数系统的正常运行都依赖于它(例如<a href="http://zh.wikipedia.org/wiki/Udev">Udev</a>使用的&rdquo;/dev/&ldquo;目录通常挂载为tmpfs).选&quot;Y&rdquo;,除非你知道自己在做什么.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/tmpfs.txt">Documentation/filesystems/tmpfs.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>Tmpfs POSIX Access Control Lists
CONFIG_TMPFS_POSIX_ACL</p>
<p>POSIX <a href="http://www.ibm.com/developerworks/cn/linux/l-acl/">ACL</a>(访问控制列表)支持,这是一种超越&quot;owner/group/world&quot;的权限管理方式,可以更精细的针对每个用户进行访问控制.详见<a href="http://www.bestbits.at/acl/man/man5/acl.txt">acl</a>手册.许多发行版都要求/dev/目录支持ACL(例如让ALSA相关的文件可以正常工作).不确定的选&quot;Y&rdquo;.</p>
</li>
<li>
<p>Tmpfs extended attributes
CONFIG_TMPFS_XATTR</p>
<p>TMPFS文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持(仅支持trusted.*和security.*命名空间).详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.由于它被CONFIG_TMPFS_POSIX_ACL依赖,所以选&quot;Y&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HugeTLB file system support
CONFIG_HUGETLBFS</p>
<p>这是使用大内存页的传统方式,需要专门进行配置以及应用程序的特别支持.推荐使用较新的<a href="http://blog.chinaunix.net/uid-26489617-id-3205109.html">透明大内存页</a>(CONFIG_TRANSPARENT_HUGEPAGE).选&quot;N&quot;.</p>
</li>
<li>
<p>Userspace-driven configuration filesystem
CONFIG_CONFIGFS_FS</p>
<p><a href="http://lwn.net/Articles/148973/">configfs</a>是一个基于内存的虚拟文件系统,与sysfs类似但又有不同:configfs用于从用户空间查看/修改/创建/删除内核对象,而sysfs仅能查看/修改由内核负责创建和删除的对象.通常挂载到&quot;/config&quot;目录.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/configfs/">Documentation/configfs/</a>&ldquo;目录中的文档.不确定的选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Miscellaneous filesystems
CONFIG_MISC_FILESYSTEMS</p>
<ul>
<li>各种非主流的杂项文件系统,有些是专用于嵌入式系统,有些是来自于其他操作系统,还有些专用于某些特定场合.</li>
<li>
<ul>
<li>
<ul>
<li>{此处省略哪些非常非主流的文件系统}</li>
<li>eCrypt filesystem layer support
CONFIG_ECRYPT_FS</li>
</ul>
<!---->
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-ecryptfs/">eCryptfs</a>是一个符合POSIX标准的企业级文件系统加密栈(加密/解密转换层),工作在<a href="http://www.ibm.com/developerworks/cn/linux/l-virtual-filesystem-switch/">VFS</a>(虚拟文件系统)层,可以在各种普通文件系统上使用(需要<a href="http://ecryptfs.org/">ecryptfs-utils</a>工具).eCryptfs将加密元数据保存在每个文件的首部,从而允许文件在不同主机之间任意移动,同时又能确保仅在内核密钥环中拥有正确密钥的时候才能解密文件的内容.此外,eCryptfs还支持高级密匙管理和配置策略.[提示]<a href="http://wiki.ubuntu.org.cn/Ecryptfs%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">使用eCryptfs</a>之后,读操作性能最大可下降1/3左右,写操作性能则普遍下降一个数量级.</li>
<li>
<ul>
<li>
<p>Enable notifications for userspace key wrap/unwrap
CONFIG_ECRYPT_FS_MESSAGING</p>
<p>允许ecryptfsd守护进程操作/dev/ecryptfs设备.这将允许用户空间使用其他后端(例如OpenSSL)加密/解密FEK(file encryption key).不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>SquashFS 4.0 - Squashed file system support
CONFIG_SQUASHFS</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/1306_qinzl_squashfs/">SquashFS</a>是一种高压缩率的只读文件系统,可以使用多种压缩算法(例如zlib,xz,lzo).<a href="http://squashfs.sourceforge.net/">SquashFS</a>常用于嵌入式设备和LiveCD系统.</li>
<li>
<ul>
<li>
<p>Squashfs XATTR support
CONFIG_SQUASHFS_XATTR</p>
<p>Squashfs文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.详见<a href="http://www.bestbits.at/acl/man/man5/attr.txt">attr</a>手册.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Include support for ZLIB compressed file systems
CONFIG_SQUASHFS_ZLIB</p>
<p>ZLIB是Squashfs默认的标准压缩算法.在压缩率和性能之间达到了最佳的平衡.</p>
</li>
<li>
<p>Include support for LZO compressed file systems
CONFIG_SQUASHFS_LZO</p>
<p>LZO是性能最佳的压缩算法(CPU和内存占用都很低),但是压缩率确是最差的.常用于资源有限的嵌入式系统.</p>
</li>
<li>
<p>Include support for XZ compressed file systems
CONFIG_SQUASHFS_XZ</p>
<p>XZ是压缩率最佳的压缩算法,但其CPU和内存占用都最高.可用于PC环境.</p>
</li>
<li>
<p>Use 4K device block size?
CONFIG_SQUASHFS_4K_DEVBLK_SIZE</p>
<p>出于降低潜伏时间的考虑,Squashfs默认使用1K大小的块.但是在<a href="http://www.cnblogs.com/hnrainll/archive/2011/05/17/2048288.html">MTD NAND</a>设备上,使用4K大小的块才可以获得最佳性能.此外,在大多数设备上,使用4K大小的块才能获得最佳连续读取性能.如果你的Squashfs位于闪存设备上,建议选&quot;Y&quot;.否则建议选&quot;N&quot;.</p>
</li>
<li>
<p>Additional option for memory-constrained systems
CONFIG_SQUASHFS_EMBEDDED</p>
<ul>
<li>允许强制指定缓存大小.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Number of fragments cached
CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE</p>
<p>SquashFS默认缓存最后3个从文件系统上读取的片段.降低此值(最小值是&quot;1&quot;,不能设为&quot;0&quot;)可以降低内存的占用,但是会增加底层物理设备的读取次数.增加此值则正好相反.[提示]按一般经验,大于&quot;3&quot;的值并不能带来显著的性能提升.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>EFI Variable filesystem
CONFIG_EFIVAR_FS</p>
<p>efivarfs可以取代通过sysfs(CONFIG_EFI_VARS)展示的&quot;EFI变量&quot;,其主要目的是可以突破sysfs中变量值不能超出1024字节的限制.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Network File Systems
CONFIG_NETWORK_FILESYSTEMS</p>
<ul>
<li>网络文件系统</li>
<li>
<ul>
<li>
<p>NFS client support
CONFIG_NFS_FS</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">NFS</a>(Network File System)客户端支持,这样就可以使用<a href="http://linux-nfs.org/">nfs-utils</a>包中的<a href="http://linux.die.net/man/8/mount.nfs">mount.nfs</a>工具挂载远程服务器提供的NFS文件系统.详见<a href="http://linux.die.net/man/5/nfs">nfs</a>手册页.</li>
<li>
<ul>
<li>
<p>NFS client support for NFS version 2
CONFIG_NFS_V2</p>
<p>NFSv2(RFC 1094)版本协议支持</p>
</li>
<li>
<p>NFS client support for NFS version 3
CONFIG_NFS_V3</p>
<ul>
<li>NFSv3(RFC 1813)版本协议支持</li>
<li>
<ul>
<li>
<p>NFS client support for the NFSv3 ACL protocol extension
CONFIG_NFS_V3_ACL</p>
<p>为NFSv3添加POSIX ACL支持(Solaris NFSv3 ACL).大多数NFS服务器都不支持这个扩展.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NFS client support for NFS version 4
CONFIG_NFS_V4</p>
<p>NFSv4(RFC 3530)版本协议支持</p>
</li>
<li>
<p>Provide swap over NFS support
CONFIG_NFS_SWAP</p>
<p>允许将NFS文件系统用做swap分区.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NFS client support for NFSv4.1
CONFIG_NFS_V4_1</p>
<ul>
<li><a href="http://stor-age.zdnet.com.cn/stor-age/2008/0331/786932.shtml">NFSv4.1</a>(RFC 5661)版本协议客户端支持,这样就可以使用<a href="http://linux-nfs.org/">nfs-utils</a>包中的<a href="http://linux.die.net/man/8/mount.nfs">mount.nfs</a>工具挂载远程服务器提供的NFS文件系统.详见<a href="http://linux.die.net/man/5/nfs">nfs</a>手册页以及<a href="http://blog.csdn.net/ycnian/article/details/8515517">NFS各个版本之间的比较</a>.</li>
<li>
<ul>
<li>
<p>NFSv4.1 Implementation ID Domain
CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN</p>
<p>NFSv4.1规范新引入了<a href="http://www.cnblogs.com/zhenjing/archive/2011/05/29/NFS4_1_session.html">会话机制</a>,该选项定义在建立会话过程中使用在EXCHANGE_ID指令中的&quot;domain&quot;部分的值.这个值必须是个标准的DNS域名格式.如果你没有修改内核的NFS客户端代码,那么请保持默认值&quot;kernel.org&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Root file system on NFS
CONFIG_ROOT_NFS</p>
<p>允许将NFS挂载为根文件系统(root=/dev/nfs),通常用于没有本地存储设备的无盘工作站(还必须开启CONFIG_IP_PNP以及至少一个子项).详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/nfs/nfsroot.txt">Documentation/filesystems/nfs/nfsroot.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Provide NFS client caching support
CONFIG_NFS_FSCACHE</p>
<p>为NFS提供本地缓存支持,也就是利用CONFIG_FSCACHE选项的功能.</p>
</li>
<li>
<p>Use the legacy NFS DNS resolver
CONFIG_NFS_USE_LEGACY_DNS</p>
<p>内核现在有自己的DNS解析实现,如果你依然想使用老式的DNS解析脚本,可以选&quot;Y&rdquo;.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>NFS server support
CONFIG_NFSD</p>
<ul>
<li>NFS服务器端支持.要实现此功能,还需要<a href="http://linux-nfs.org/">nfs-utils</a>软件包的支持.详见<a href="http://linux.die.net/man/5/nfs">nfs</a>手册页.这里也有一个<a href="http://blog.csdn.net/ycnian/article/category/1320297">NFS文章系列</a>可以看看.此选项内嵌了NFSv2协议支持.</li>
<li>
<ul>
<li>
<p>NFS server support for NFS version 3
CONFIG_NFSD_V3</p>
<ul>
<li>NFSv3(RFC 1813)版本协议支持</li>
<li>
<ul>
<li>
<p>NFS server support for the NFSv3 ACL protocol extension
CONFIG_NFSD_V3_ACL</p>
<p>为NFSv3添加POSIX ACL支持(Solaris NFSv3 ACL).此扩展并不属于NFSv3协议的官方内容.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NFS server support for NFS version 4
CONFIG_NFSD_V4</p>
<ul>
<li>NFSv4(RFC 3530)版本协议支持</li>
<li>
<ul>
<li>
<p>NFS server manual fault injection
CONFIG_NFSD_FAULT_INJECTION</p>
<p>仅供调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Secure RPC: Kerberos V mechanism
CONFIG_RPCSEC_GSS_KRB5</p>
<p>为使用<a href="http://zh.wikipedia.org/wiki/Kerberos">Kerberos</a> V5 GSS-API身份验证机制(RFC1964)的<a href="http://docs.oracle.com/cd/E19253-01/819-7061/auth-2/index.html">安全RPC</a>提供支持.要实现此功能,还需要<a href="http://linux-nfs.org/">nfs-utils</a>软件包以及用户空间的<a href="http://zhumeng8337797.blog.163.com/blog/static/10076891420104410573960/">Kerberos</a>支持.</p>
</li>
<li>
<p>RPC: Enable dprintk debugging
CONFIG_SUNRPC_DEBUG</p>
<p>允许使用rpcdebug工具调试RPC故障,如果选&quot;N&quot;会让故障调试特别困难.</p>
</li>
<li>
<p>Ceph distributed file system
CONFIG_CEPH_FS</p>
<p>允许挂载<a href="http://ceph.newdream.net/">Ceph</a>分布式文件系统.不确定的选&quot;N&quot;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/ceph.txt">Documentation/filesystems/ceph.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>CIFS support (advanced network filesystem, SMBFS successor)
CONFIG_CIFS</p>
<ul>
<li><a href="http://baike.baidu.com/view/1034390.htm">CIFS</a>(Common Internet File System)协议客户端支持.CIFS主要用于Linux与Windows之间共享文件系统.如果你打算挂载<a href="http://www.microsoft.com/china/windowsxp/pro/using/itpro/managing/filesharing.mspx">Windows的共享文件夹</a>,或者由<a href="http://linux.vbird.org/linux_server/0370samba.php">Samba</a>提供的文件系统,就选&quot;Y&rdquo;.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/cifs.txt">Documentation/filesystems/cifs.txt</a>&ldquo;文档.</li>
<li>
<ul>
<li>
<p>CIFS statistics
CONFIG_CIFS_STATS</p>
<ul>
<li>在/proc/fs/cifs/Stats文件中显示每个被挂载的CIFS文件系统的统计信息</li>
<li>
<ul>
<li>
<p>Extended statistics
CONFIG_CIFS_STATS2</p>
<p>在/proc/fs/cifs/目录下显示更详细的统计信息.对运行性能和内存占用都有些影响.不确定的选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Support legacy servers which use weaker LANMAN security
CONFIG_CIFS_WEAK_PW_HASH</p>
<p>选&quot;N&quot;,除非你确实知道自己在干什么.</p>
</li>
<li>
<p>Kerberos/SPNEGO advanced session setup
CONFIG_CIFS_UPCALL</p>
<p>Kerberos/<a href="http://baike.baidu.com/view/5160766.htm">SPNEGO</a>高级会话支持.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>CIFS extended attributes
CONFIG_CIFS_XATTR</p>
<ul>
<li>CIFS文件系统<a href="http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7">扩展属性</a>(与inode关联的name:value对)支持.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>CIFS POSIX Extensions
CONFIG_CIFS_POSIX</p>
<p>CIFS POSIX扩展.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Provide CIFS ACL support
CONFIG_CIFS_ACL</p>
<p>允许从服务器抓取CIFS/NTFS ACL.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Enable CIFS debugging routines
CONFIG_CIFS_DEBUG</p>
<p>仅供调试使用</p>
</li>
<li>
<p>DFS feature support
CONFIG_CIFS_DFS_UPCALL</p>
<p><a href="http://technet.microsoft.com/library/Cc960860">DFS</a>(Distributed File System)支持.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>SMB2 network file system support
CONFIG_CIFS_SMB2</p>
<p>仅供开发与调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Provide CIFS client caching support
CONFIG_CIFS_FSCACHE</p>
<p>为CIFS提供本地缓存支持,也就是利用CONFIG_FSCACHE选项的功能.</p>
</li>
<li>
<p>NCP file system support (to mount NetWare volumes)
CONFIG_NCP_FS</p>
<p>NCP(NetWare Core Protocol)协议支持.这东西早就销声匿迹了,选&quot;N&quot;.</p>
</li>
<li>
<p>Coda file system support (advanced network fs)
CONFIG_CODA_FS</p>
<p><a href="http://zh.wikipedia.org/wiki/Coda">Coda</a>是一种比NFS更先进的分布式集群文件系统.<a href="http://zh.linuxvirtualserver.org/">LVS</a>(Linux Virtual Server)就采用了<a href="http://www.bsdmap.com/diary/coda.php">Coda分布式文件系统</a>.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/filesystems/coda.txt">Documentation/filesystems/coda.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Andrew File System support
CONFIG_AFS_FS</p>
<p><a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%BE%B7%E9%AD%AF%E6%AA%94%E6%A1%88%E7%B3%BB%E7%B5%B1">AFS</a>(Andrew File System)文件系统的实验性支持,目前仅支持只读访问.详见&rdquo;<a href="http://lxr.linux.no/linux/Documentation/filesystems/afs.txt">Documentation/filesystems/afs.txt</a>&ldquo;文档.</p>
</li>
<li>
<p>Provide AFS client caching support
CONFIG_AFS_FSCACHE</p>
<p>为AFS提供本地缓存支持,也就是利用CONFIG_FSCACHE选项的功能.</p>
</li>
<li>
<p>Plan 9 Resource Sharing Support (9P2000)
CONFIG_9P_FS</p>
<p>9P2000协议是<a href="http://baike.baidu.com/view/1597745.htm">Plan 9</a>概念网络操作系统上使用的资源共享协议.不确定的选&quot;N&rdquo;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Native language support
CONFIG_NLS</p>
<ul>
<li>本地语言支持.仅在你使用FAT/NTFS/JOLIET文件系统的情况下才需要这个东西.</li>
<li>
<ul>
<li>
<p>Default NLS Option
CONFIG_NLS_DEFAULT</p>
<p>挂载文件系统时,控制台的默认本地语言(不是文件系统用于存储文件名的语言),建议设为&quot;utf8&quot;(因为控制台的默认编码是&quot;utf8&quot;:vt.default_utf8=1).</p>
</li>
<li>
<p>{此处省略的各种字符集请按需选择}</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Distributed Lock Manager (DLM)
CONFIG_DLM</p>
<ul>
<li>通用的分布式锁管理器(<a href="http://en.wikipedia.org/wiki/Distributed_lock_manager">DLM</a>).用于为各种分布式文件系统提供通用的锁定支持.</li>
<li>
<ul>
<li>
<p>DLM debugging
CONFIG_DLM_DEBUG</p>
<p>仅供开发与调试使用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="kernel-hacking-内核hack选项"><a href=""></a>Kernel hacking 内核hack选项</h2>
<ul>
<li>
<p>Show timing information on printks
CONFIG_PRINTK_TIME</p>
<p>在控制台和syslog()系统调用的输出中包含printk()消息的时间戳,以便于直接显示内核启动过程中各步骤所用的时间.注意:无论此项是否开启,时间戳总会被记录在/dev/kmsg中,开启此项仅相当于使用&quot;printk.time=1&quot;内核引导参数.</p>
</li>
<li>
<p>Default message log level (1-7)
CONFIG_DEFAULT_MESSAGE_LOGLEVEL</p>
<p>printk()内核消息日志的默认级别,取值范围是[1,7].数值越大显示的消息就越详细:1=ALERT,2=CRIT,3=ERR,4=WARNING,5=NOTICE,6=INFO,7=DEBUG.</p>
</li>
<li>
<p>Enable __deprecated logic
CONFIG_ENABLE_WARN_DEPRECATED</p>
<p>编译时开启&quot;反对使用&quot;逻辑检查,关闭此项将不会显示类似&quot;warning: &lsquo;foo&rsquo; is deprecated (declared at kernel/power/somefile.c:1234)&ldquo;的警告消息.</p>
</li>
<li>
<p>Enable __must_check logic
CONFIG_ENABLE_MUST_CHECK</p>
<p>编译时开启&quot;必须检查&quot;逻辑检查,关闭此项将不会显示类似&quot;warning: ignoring return value of &lsquo;foo&rsquo;, declared with attribute warn_unused_result&quot;的警告消息.</p>
</li>
<li>
<p>Warn for stack frames larger than (needs gcc 4.4)
CONFIG_FRAME_WARN</p>
<p>堆栈帧大小警告阈值,设置过小会导致编译时警告太多,设为&quot;0&quot;可以关闭警告,需要GCC-4.4或更高版本</p>
</li>
<li>
<p>Magic SysRq key
CONFIG_MAGIC_SYSRQ</p>
<p>开启&rdquo;<a href="http://www.docin.com/p-188851857.html">魔法键</a>&quot;(<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sysrq/">SysRq</a>)支持(可以通过&quot;echo 0 &gt; /proc/sys/kernel/sysrq&quot;关闭).由于SysRq会带来安全隐患(允许未经登录的操作),所以你应该仅在确实需要的场合开启.更多详情参见&quot;<a href="http://lxr.linux.no/linux/Documentation/sysrq.txt">Documentation/sysrq.txt</a>&ldquo;文档</p>
</li>
<li>
<p>Strip assembler-generated symbols during link
CONFIG_STRIP_ASM_SYMS</p>
<p>连接时剥离汇编器产生的内部符号(类似&rsquo;.Lxxx&rsquo;),这样可以净化get_wchan()之类的输出,同时还可以减小内核尺寸.建议开启.</p>
</li>
<li>
<p>Generate readable assembler code
CONFIG_READABLE_ASM</p>
<p>生成人类易读的汇编输出,以方便内核调试.这会禁用一些编译优化措施,也会降低内核的运行速度.</p>
</li>
<li>
<p>Enable unused/obsolete exported symbols
CONFIG_UNUSED_SYMBOLS</p>
<p>导出无用和废弃的符号,这将使内核不必要的增大.建议关闭.</p>
</li>
<li>
<p>Debug Filesystem
CONFIG_DEBUG_FS</p>
<p>debugfs是内核开发者用来存储调试信息的虚拟文件系统.不搞内核开发就别选</p>
</li>
<li>
<p>Run &lsquo;make headers_check&rsquo; when building vmlinux
CONFIG_HEADERS_CHECK</p>
<p>在编译内核时运行&rsquo;make headers_check&rsquo;命令检查内核头文件的正确性,当你修改了与用户空间相关的内核头文件后应该启用该选项</p>
</li>
<li>
<p>Enable full Section mismatch analysis
CONFIG_DEBUG_SECTION_MISMATCH</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Kernel debugging
CONFIG_DEBUG_KERNEL</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Panic on Oops
CONFIG_PANIC_ON_OOPS</p>
<p>当内核<a href="http://www.cnblogs.com/wwang/archive/2010/11/14/1876735.html">oops</a>时,直接<a href="http://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E9%94%99%E8%AF%AF">panic</a>掉(相当于Windows蓝屏死机),这样可以确保内核停止工作,避免导致无法预料的后果.等价于使用&quot;oops=panic&quot;内核引导参数.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Detect Hung Tasks
CONFIG_DETECT_HUNG_TASK</p>
<p>探测挂起的任务(处于不可中断的&quot;D&quot;状态).由于仅能检测,不能做进一步的处理,所以仅用于帮助内核调试.</p>
</li>
<li>
<p>Collect scheduler debugging info
CONFIG_SCHED_DEBUG</p>
<p>提供一个&quot;/proc/sched_debug&quot;文件以帮助调试调度程序.仅供内核开发使用.</p>
</li>
<li>
<p>Collect scheduler statistics
CONFIG_SCHEDSTATS</p>
<p>收集调度程序的统计信息,并展示在&quot;/proc/schedstat&quot;文件中.可以用于调试调度程序,或者调整特定的应用程序.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Collect kernel timers statistics
CONFIG_TIMER_STATS</p>
<p>收集内核计时器的统计信息,并展示在&quot;/proc/timer_stats&quot;文件中.使用&quot;echo 1 &gt; /proc/timer_stats&quot;开启统计,使用&quot;echo 0 &gt; /proc/timer_stats&quot;关闭统计.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Debug object operations
CONFIG_DEBUG_OBJECTS</p>
<p>跟踪各种对象的生命周期(life time),并校验对这些对象的各种操作.仅供内核调试.</p>
</li>
<li>
<p>Debug slab memory allocations
CONFIG_DEBUG_SLAB</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>SLUB debugging on by default
CONFIG_SLUB_DEBUG_ON</p>
<p>默认开启SLUB内存分配器调试功能.仅供调试,切勿用于生产环境.</p>
</li>
<li>
<p>Enable SLUB performance statistics
CONFIG_SLUB_STATS</p>
<p>收集SLUB内存分配器的性能统计信息.仅供调试,切勿用于生产环境.</p>
</li>
<li>
<p>Kernel memory leak detector
CONFIG_DEBUG_KMEMLEAK</p>
<p>内核内存泄漏检测.仅供内核调试.</p>
</li>
<li>
<p>Debug preemptible kernel
CONFIG_DEBUG_PREEMPT</p>
<p>对内核的主动抢占特性进行调试.仅供内核开发者使用</p>
</li>
<li>
<p>RT Mutex debugging, deadlock detection
CONFIG_DEBUG_RT_MUTEXES</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Built-in scriptable tester for rt-mutexes
CONFIG_RT_MUTEX_TESTER</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Spinlock and rw-lock debugging: basic checks
CONFIG_DEBUG_SPINLOCK</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Mutex debugging: basic checks
CONFIG_DEBUG_MUTEXES</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Lock debugging: detect incorrect freeing of live locks
CONFIG_DEBUG_LOCK_ALLOC</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Lock debugging: prove locking correctness
CONFIG_PROVE_LOCKING</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Lock usage statistics
CONFIG_LOCK_STAT</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Lock dependency engine debugging
CONFIG_DEBUG_LOCKDEP</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Sleep inside atomic section checking
CONFIG_DEBUG_ATOMIC_SLEEP</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Locking API boot-time self-tests
CONFIG_DEBUG_LOCKING_API_SELFTESTS</p>
<p>在内核启动时运行一个简短的加锁/解锁函数(spinlocks,rwlocks,mutexes,rwsems)自我测试.仅供内核开发者使用</p>
</li>
<li>
<p>Stack utilization instrumentation
CONFIG_DEBUG_STACK_USAGE</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>kobject debugging
CONFIG_DEBUG_KOBJECT</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Verbose BUG() reporting (adds 70K)
CONFIG_DEBUG_BUGVERBOSE</p>
<p>在内核panic时让BUG()函数报告更详细的信息.内核将会增大70-100K.</p>
</li>
<li>
<p>Compile the kernel with debug info
CONFIG_DEBUG_INFO</p>
<p>以调试方式编译内核(gcc -g).仅供内核开发者使用</p>
</li>
<li>
<p>Debug VM
CONFIG_DEBUG_VM</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug VM translations
CONFIG_DEBUG_VIRTUAL</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug filesystem writers count
CONFIG_DEBUG_WRITECOUNT</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug memory initialisation
CONFIG_DEBUG_MEMORY_INIT</p>
<p>在内存初始化时增加额外的合理性检查.不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>Debug linked list manipulation
CONFIG_DEBUG_LIST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Linked list sorting test
CONFIG_TEST_LIST_SORT</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug SG table operations
CONFIG_DEBUG_SG</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug notifier call chains
CONFIG_DEBUG_NOTIFIERS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug credential management
CONFIG_DEBUG_CREDENTIALS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Compile the kernel with frame pointers
CONFIG_FRAME_POINTER</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Delay each boot printk message by N milliseconds
CONFIG_BOOT_PRINTK_DELAY</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>RCU Debugging</p>
<p>仅供内核开发者使用.建议所有子项全选&quot;N&quot;.</p>
</li>
<li>
<p>Kprobes sanity tests
CONFIG_KPROBES_SANITY_TEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Self test for the backtrace code
CONFIG_BACKTRACE_SELF_TEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Force extended block device numbers and spread them
CONFIG_DEBUG_BLOCK_EXT_DEVT</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Force weak per-cpu definitions
CONFIG_DEBUG_FORCE_WEAK_PER_CPU</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug access to per_cpu maps
CONFIG_DEBUG_PER_CPU_MAPS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Linux Kernel Dump Test Tool Module
CONFIG_LKDTM</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Notifier error injection
CONFIG_NOTIFIER_ERROR_INJECTION</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Fault-injection framework
CONFIG_FAULT_INJECTION</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Latency measuring infrastructure
CONFIG_LATENCYTOP</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Strict user copy size checks
CONFIG_DEBUG_STRICT_USER_COPY_CHECKS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Debug page memory allocations
CONFIG_DEBUG_PAGEALLOC</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Tracers
CONFIG_FTRACE</p>
<p>仅供内核开发者使用.建议选&quot;N&quot;.</p>
</li>
<li>
<p>Red-Black tree test
CONFIG_RBTREE_TEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Interval tree test
CONFIG_INTERVAL_TREE_TEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Remote debugging over FireWire early on boot
CONFIG_PROVIDE_OHCI1394_DMA_INIT</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Remote debugging over FireWire with firewire-ohci
CONFIG_FIREWIRE_OHCI_REMOTE_DMA</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Build targets in Documentation/ tree
CONFIG_BUILD_DOCSRC</p>
<p>编译内核源码树下&quot;Documentation&quot;目录中的目标.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable dynamic printk() support
CONFIG_DYNAMIC_DEBUG</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Enable debugging of DMA-API usage
CONFIG_DMA_API_DEBUG</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Perform an atomic64_t self-test at boot
CONFIG_ATOMIC64_SELFTEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Self test for hardware accelerated raid6 recovery
CONFIG_ASYNC_RAID6_TEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Sample kernel code
CONFIG_SAMPLES</p>
<p>内核示例代码.仅供内核开发者使用</p>
</li>
<li>
<p>KGDB: kernel debugger
CONFIG_KGDB</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>kmemcheck: trap use of uninitialized memory
CONFIG_KMEMCHECK</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Test functions located in the string_helpers module at runtime
CONFIG_TEST_STRING_HELPERS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Test kstrto*() family of functions at runtime
CONFIG_TEST_KSTRTOX</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Filter access to /dev/mem
CONFIG_STRICT_DEVMEM</p>
<p>如果选&quot;N&quot;,那么用户空间的root用户将可以通过/dev/mem访问所有内存空间(包括用户空间与内核空间),以方便调试内核.如果选&quot;Y&quot;,那么内核空间除了PCI和BIOS部分以及数据区之外,都禁止访问,以保护系统安全.不确定的选&quot;Y&quot;.</p>
</li>
<li>
<p>Enable verbose x86 bootup info messages
CONFIG_X86_VERBOSE_BOOTUP</p>
<p>显示详细的内核引导信息.建议选&quot;N&quot;使引导过程更安静(依然会显示错误信息).</p>
</li>
<li>
<p>Early printk
CONFIG_EARLY_PRINTK</p>
<ul>
<li>将内核日志直接输出到VGA缓冲或串口.这有助于调试那些在控制台尚未完成初始化之前就造成系统崩溃的bug.</li>
<li>
<ul>
<li>
<p>Early printk via EHCI debug port
CONFIG_EARLY_PRINTK_DBGP</p>
<p>支持将内核日志直接通过EHCI调试端口输出.选&quot;N&quot;,除非你想调试内核.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Check for stack overflows
CONFIG_DEBUG_STACKOVERFLOW</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Export kernel pagetable layout to userspace via debugfs
CONFIG_X86_PTDUMP</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Write protect kernel read-only data structures
CONFIG_DEBUG_RODATA</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Set loadable kernel module data as NX and text as RO
CONFIG_DEBUG_SET_MODULE_RONX</p>
<p>将内核模块的数据区标记为NX(不可执行),文本段标记为RO(只读),以防止不良模块(例如被植入病毒的模块)对系统的破坏,也能预防某些类型的内核入侵.这需要CPU支持<a href="http://zh.wikipedia.org/wiki/NX%E4%BD%8D%E5%85%83">NX位</a>(CPU flags中要含有&quot;nx&quot;标志).但是这也有副作用:会与运行时代码补丁冲突,还会导致动态内核跟踪失效.建议选&quot;Y&quot;,除非你需要调试内核,或者需要为运行中的模块打补丁.</p>
</li>
<li>
<p>Testcase for the NX non-executable stack feature
CONFIG_DEBUG_NX_TEST</p>
<p>对处理器的NX的测试用例.仅供内核开发者使用</p>
</li>
<li>
<p>Set upper limit of TLB entries to flush one-by-one
CONFIG_DEBUG_TLBFLUSH</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Enable IOMMU debugging
CONFIG_IOMMU_DEBUG</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Enable IOMMU stress-test mode
CONFIG_IOMMU_STRESS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>IOMMU leak tracing
CONFIG_IOMMU_LEAK</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>x86 instruction decoder selftest
CONFIG_X86_DECODER_SELFTEST</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>IO delay type</p>
<ul>
<li>IO延迟方式</li>
<li>
<ul>
<li>
<p>port 0x80 based port-IO delay
CONFIG_IO_DELAY_0X80</p>
<p>传统的Linux IO延迟方式,久经考验,也是最安全的默认值.</p>
</li>
<li>
<p>port 0xed based port-IO delay
CONFIG_IO_DELAY_0XED</p>
<p>基于0xed端口的IO延迟方式,主要是为了避免和基于0x80端口的<a href="http://baike.baidu.com/view/288235.htm">主板诊断卡</a>冲突.绝大多数人都没有主板诊断卡,除非那些专门维修主板的硬件工程师.</p>
</li>
<li>
<p>udelay based port-IO delay
CONFIG_IO_DELAY_UDELAY</p>
<p>使用内核端udelay()函数作为延迟方法(简单的延迟2微秒).可以不占用任何IO端口空间.</p>
</li>
<li>
<p>no port-IO delay
CONFIG_IO_DELAY_NONE</p>
<p>不使用任何port-IO延迟机制.只要你的机器不是老古董,建议选择此项.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Debug boot parameters
CONFIG_DEBUG_BOOT_PARAMS</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>CPA self-test code
CONFIG_CPA_DEBUG</p>
<p>仅供内核开发者使用</p>
</li>
<li>
<p>Allow gcc to uninline functions marked &lsquo;inline&rsquo;
CONFIG_OPTIMIZE_INLINING</p>
<p>允许GCC将标记为内联(inline)的函数变成非内联(uninline).选&quot;Y&quot;后将完全无视代码中的&quot;inline&quot;标记,完全由GCC自行决定是否应该将函数内联.由于GCC4.x系列更新了判断函数是否应该内联的算法,选&quot;Y&quot;后,编译出的内核体积会减小,但运行速度未必提升.建议经过测试后决定&quot;Y&quot;还是&quot;N&quot;.</p>
</li>
<li>
<p>NMI Selftest
CONFIG_DEBUG_NMI_SELFTEST</p>
<p>对不可屏蔽中断(Non Maskable Interrupt)进行自检,仅供内核开发者使用</p>
</li>
</ul>
<h2 id="security-options-安全选项-这里的选项不明白的建议不要选否则有可能弄巧成拙"><a href=""></a>Security options 安全选项 这里的选项不明白的建议不要选,否则有可能弄巧成拙.</h2>
<ul>
<li>
<p>Enable access key retention support
CONFIG_KEYS</p>
<ul>
<li>在内核中保留认证令牌(<a href="http://en.wikipedia.org/wiki/Security_token">authentication token</a>)和访问密钥(access key).eCryptfs(CONFIG_ECRYPT_FS)依赖于它.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>TRUSTED KEYS
CONFIG_TRUSTED_KEYS</p>
<p>&ldquo;TRUSTED KEY&quot;的意思是由<a href="http://security.ctocio.com.cn/wpsummary/141/8692641.shtml">TPM</a>(<a href="http://baike.baidu.com/view/1130324.htm">可信赖平台模块</a>)用<a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA算法</a>封装的一对随机数.开启此项后,内核将可以为创建/封装/解封&quot;TRUSTED KEY&quot;提供支持.如果引导PCR(平台配置寄存器)和各种条件都匹配,那么TPM只解封密钥.用户空间永远只能看到加密过后的二进制内容.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>ENCRYPTED KEYS
CONFIG_ENCRYPTED_KEYS</p>
<p>&ldquo;ENCRYPTED KEY&quot;的意思是由内核封装的一对随机数,该对随机数可以用一个&quot;主密钥&quot;使用对称加密算法进行加密和解密.开启此项后,内核将可以为创建/加密/解密&quot;ENCRYPTED KEY&quot;提供支持.&ldquo;主密钥&quot;既可以是&quot;TRUSTED KEY&quot;也可以是&quot;user-key&rdquo;(用户选择的密钥).用户空间永远只能看到/存储加密过后的二进制内容.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Enable the /proc/keys file by which keys may be viewed
CONFIG_KEYS_DEBUG_PROC_KEYS</p>
<p>开启&quot;/proc/keys&quot;文件支持,该文件中保存了系统上所有可见的密钥.注意,<a href="http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/">LSM</a>(Linux安全模块)安全检查仍然是必须的.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Restrict unprivileged access to the kernel syslog
CONFIG_SECURITY_DMESG_RESTRICT</p>
<p>禁止非特权用户访问内核日志(<a href="http://baike.baidu.com/view/712946.htm">dmesg</a>),相当于&quot;echo 1 &gt; /proc/sys/kernel/dmesg_restrict&quot;.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable different security models
CONFIG_SECURITY</p>
<p>允许内核选择不同的<a href="http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/">LSM</a>(Linux安全模块),如果未选中则内核将使用默认的安全模块(&ldquo;Default security module&rdquo;).不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable the securityfs filesystem
CONFIG_SECURITYFS</p>
<p>securityfs安全文件系统支持.当前仅被TPM bios字符设备驱动以及IMA(完整性提供者)使用.它与SELinux或SMACK之类没有关系.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Socket and Networking Security Hooks
CONFIG_SECURITY_NETWORK</p>
<ul>
<li>允许安全模块通过Security Hook对Socket与Networking进行访问控制.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>XFRM (IPSec) Networking Security Hooks
CONFIG_SECURITY_NETWORK_XFRM</p>
<p>为XFRM(IPSec)启用安全Hook.这样安全模块可以通过这些hook,根据IPSec策略标签,实现针对每个网络包的访问控制.非IPSec通信则被当做&quot;无标签&quot;处理,仅允许那些被明确批准可以不使用策略标签的socket才能不通过IPSec进行通信.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Security hooks for pathname based access control
CONFIG_SECURITY_PATH</p>
<p>此安全钩子程序可以让各种安全模块实现基于路径的访问控制.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Enable Intel(R) Trusted Execution Technology (Intel(R) TXT)
CONFIG_INTEL_TXT</p>
<p>支持使用<a href="http://blog.csdn.net/trustbo/article/details/9292011">可信引导</a>(<a href="http://wenku.baidu.com/view/8bccb8335a8102d276a22faf.html">Trusted Boot</a>)技术引导内核(需要使用<a href="http://tboot.sourceforge.net/">tboot</a>模块).这将使用英特尔<a href="http://baike.baidu.com/view/4060870.htm">TXT</a>(<a href="http://baike.baidu.com/view/1553859.htm">可信任执行技术</a>)来引导内核.在不支持<a href="http://www.intel.com/content/www/us/en/architecture-and-technology/trusted-execution-technology/malware-reduction-general-technology.html">TXT</a>的平台上开启此项没有效果.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/intel_txt.txt">Documentation/intel_txt.txt</a>&ldquo;文档.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Low address space for LSM to protect from user allocation
CONFIG_LSM_MMAP_MIN_ADDR</p>
<p>禁止用户空间分配的低位内存范围.禁止用户写入低位内存有助于降低内核NULL指针漏洞造成的破坏(参见CONFIG_DEFAULT_MMAP_MIN_ADDR选项).建议保持默认值&quot;65536&quot;.</p>
</li>
<li>
<p>NSA SELinux Support
CONFIG_SECURITY_SELINUX</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-secure-linux-ru/index.html">SELinux</a>(安全增强Linux)是美国国家安全局(NSA)开发的<a href="http://www.ibm.com/developerworks/cn/linux/l-lsm/part1/index.html">Linux安全模块</a>,它拥有一个灵活而强制性的访问控制结构,可防御未知攻击,相当于B1级的军事安全性能(比微软所谓的C2等高得多).应用SELinux后,可以减轻恶意攻击或恶意软件带来的灾难,对机密性和完整性有很高要求的信息,亦可提供很高的安全保障.但另一方面,如果不深入<a href="http://www.ibm.com/developerworks/cn/views/linux/libraryview.jsp?site_id=10&amp;contentarea_by=Linux&amp;sort_by=Date&amp;sort_order=2&amp;topic_by=-1&amp;type_by=%E6%89%80%E6%9C%89%E7%B1%BB%E5%88%AB&amp;show_abstract=true&amp;search_by=SELinux">了解SELinux知识</a>而盲目使用,则会弄巧成拙.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>NSA SELinux boot parameter
CONFIG_SECURITY_SELINUX_BOOTPARAM</p>
<ul>
<li>添加&quot;selinux&quot;内核引导参数.以允许在引导时使用&rsquo;selinux=0&rsquo;禁用SELinux或&rsquo;selinux=1&rsquo;启用SELinux.</li>
<li>
<ul>
<li>
<p>NSA SELinux boot parameter default value
CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE</p>
<p>&ldquo;selinux&quot;内核引导参数的默认值.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>NSA SELinux runtime disable
CONFIG_SECURITY_SELINUX_DISABLE</p>
<p>允许在运行时禁用SELinux.建议选&quot;N&rdquo;.</p>
</li>
<li>
<p>NSA SELinux Development Support
CONFIG_SECURITY_SELINUX_DEVELOP</p>
<p>SELinux开发支持.开启此项后,除非明确使用&quot;enforcing=1&quot;引导参数让内核以&quot;强制模式&quot;运行,否则内核将以&quot;许可模式&quot;运行(记录所有事件,同时允许所有操作).主要用于测试SELinux以及策略开发.此外,开启此项后,还可以在运行时通过&quot;/selinux/enforce&quot;让内核在&quot;强制模式&quot;与&quot;许可模式&quot;之间切换.</p>
</li>
<li>
<p>NSA SELinux AVC Statistics
CONFIG_SECURITY_SELINUX_AVC_STATS</p>
<p>搜集访问向量缓存(access vector cache)的统计信息并在/selinux/avc/cache_stats中显示出来.这些信息可以用avcstat之类的工具查看.</p>
</li>
<li>
<p>NSA SELinux checkreqprot default value
CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE</p>
<p>内核引导参数&quot;checkreqprot&quot;的默认值.设为&quot;0&quot;表示默认检查内核要求执行的保护策略,设为&quot;1&quot;表示默认检查应用程序要求执行的保护策略.此值还可以在运行时通过/selinux/checkreqprot修改.不确定的选&quot;1&quot;.</p>
</li>
<li>
<p>NSA SELinux maximum supported policy format version
CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX</p>
<ul>
<li>将支持的策略格式的最高版本设置为一个特定的数值.该数值将通过/selinux/policyvers向用户空间报告,并在加载策略时被使用.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>NSA SELinux maximum supported policy format version value</p>
<p>支持策略格式的最高版本的数值.可以通过&quot;checkpolicy -V&quot;命令检查当前工具链支持的版本数值.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Simplified Mandatory Access Control Kernel Support
CONFIG_SECURITY_SMACK</p>
<p><a href="http://en.wikipedia.org/wiki/Smack">Smack</a>(简化的强制访问控制内核)<a href="http://zh.wikipedia.org/wiki/Linux%E5%AE%89%E5%85%A8%E6%A8%A1%E7%B5%84">内核安全模块</a>.<a href="http://blog.csdn.net/wangzhicheng1983/article/details/9221359">Smack</a>是一种简单而有效的强制访问控制机制,它的简单体现在安全策略的配置很简单,它的有效体现在完全使用LSM作为其控制手段.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>TOMOYO Linux Support
CONFIG_SECURITY_TOMOYO</p>
<p><a href="http://en.wikipedia.org/wiki/TOMOYO_Linux">TOMOYO Linux</a>是日本NTT数据公司开发的一种Linux安全模块.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>AppArmor support
CONFIG_SECURITY_APPARMOR</p>
<p><a href="http://blog.csdn.net/ustc_dylan/article/details/7944955">AppArmor</a>是来自Novell的一种Linux安全模块.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Yama support
CONFIG_SECURITY_YAMA</p>
<p>Yama(阎王)是3.4版内核新引入的一种Linux安全模块.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Digital signature verification using multiple keyrings
CONFIG_INTEGRITY_SIGNATURE</p>
<ul>
<li>允许使用多个<a href="http://book.51cto.com/art/200902/108112.htm">密钥环</a>(keyring)进行数字签名验证,也就允许为多个不同的使用场合(evm,ima,module)分别使用不同的keyring.看不懂的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Enable asymmetric keys support
CONFIG_INTEGRITY_ASYMMETRIC_KEYS</p>
<p>允许使用非对称密钥进行数字签名验证.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Integrity Measurement Architecture(IMA)
CONFIG_IMA</p>
<ul>
<li><a href="http://wiki.gentoo.org/wiki/Integrity_Measurement_Architecture">IMA</a>(完整性度量架构)是一个在<a href="http://www.trustedcomputinggroup.org/cn">TCG</a>(<a href="http://zh.wikipedia.org/wiki/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97">可信计算</a>工作组)技术规范之上提出的完整性检查技术.IMA维护着一个系统关键文件的哈希值列表,从而可以检测这些关键文件是否被篡改.如果系统上有<a href="http://baike.baidu.com/view/687208.htm">TPM安全芯片</a>,那么IMA还会在TPM芯片内存储哈希值的集合.这样的TPM芯片可以提供给第三方,用于检查系统上的关键文件是否被篡改.不确定的选&quot;N&quot;.</li>
<li>
<ul>
<li>
<p>Enables auditing support
CONFIG_IMA_AUDIT</p>
<p>添加&quot;ima_audit&quot;内核引导参数支持.当设为&quot;ima_audit=1&quot;时,将允许显示完整性审计信息.</p>
</li>
<li>
<p>Appraise integrity measurements
CONFIG_IMA_APPRAISE</p>
<p>本地完整性鉴定支持.这样就可以在加载文件时检验它的完整性.这要求系统配置<a href="http://wiki.gentoo.org/wiki/Using_Extended_Verification_Module_in_Gentoo">EVM</a>支持.不确定的选&quot;N&quot;.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>EVM support
CONFIG_EVM</p>
<ul>
<li><a href="https://wiki.gentoo.org/wiki/Extended_Verification_Module">EVM</a>通过保护文件的安全扩展属性来对抗完整性攻击.</li>
<li>
<ul>
<li>
<p>EVM HMAC version
CONFIG_EVM_HMAC_VERSION</p>
<p>支持的EVM HMAC版本:&ldquo;1&quot;表示原始版本,默认值&quot;2&quot;表示添加了文件系统<a href="http://zh.wikipedia.org/wiki/UUID">UUID</a>支持的改进版本.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Default security module</p>
<p>内核默认的安全模块.[提示]&ldquo;Unix Discretionary Access Controls&quot;是经典的UNIX基于目录的访问控制安全模型.如果没有开启任何安全模块,这将是默认值.</p>
</li>
</ul>
<h2 id="cryptographic-api-内核加密api支持-这里的加密算法被广泛的应用于驱动程序通信协议等机制中子选项可以全不选内核中若有其他部分依赖它会自动选上使用内核树外的模块时可能需要手动选择"><a href=""></a>Cryptographic API 内核加密API支持 这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选,内核中若有其他部分依赖它,会自动选上.使用内核树外的模块时可能需要手动选择.</h2>
<ul>
<li>
<p>FIPS 200 compliance
CONFIG_CRYPTO_FIPS</p>
<p>&ldquo;fips&quot;内核引导参数支持.这是在<a href="http://book.2cto.com/201209/4003.html">FIPS200</a>认证的系统中运行所必须的.选&quot;N&rdquo;,除非你确实知道自己在做什么.</p>
</li>
<li>
<p>Cryptographic algorithm manager
CONFIG_CRYPTO_MANAGER</p>
<p>创建默认的加密模版实例.必选</p>
</li>
<li>
<p>Userspace cryptographic algorithm configuration
CONFIG_CRYPTO_USER</p>
<p>用户空间加密实例配置.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>Disable run-time self tests
CONFIG_CRYPTO_MANAGER_DISABLE_TESTS</p>
<p>禁止在注册算法时进行简单的自我检测.不确定的选&quot;Y&rdquo;.</p>
</li>
<li>
<p>GF(2^128) multiplication functions
CONFIG_CRYPTO_GF128MUL</p>
<p>由高效表格驱动的<a href="http://wenku.baidu.com/view/503a96fa770bf78a65295425.html">伽罗瓦域 GF(2^128)乘法器</a>支持.某些加密模式需要它.不确定的选&quot;N&quot;.如果有其它模块需要此特性,会被自动选中.</p>
</li>
<li>
<p>Null algorithms
CONFIG_CRYPTO_NULL</p>
<p>NULL加密算法(什么也不做),用于IPsec协议的封装安全载荷模块(ESP)</p>
</li>
<li>
<p>Parallel crypto engine
CONFIG_CRYPTO_PCRYPT</p>
<p>将任意加密算法转化成并行算法,并在内核线程中执行.</p>
</li>
<li>
<p>Software async crypto daemon
CONFIG_CRYPTO_CRYPTD</p>
<p>这是一个通用的软件异步加密守护进程,可将任意的同步软件加密算法转换成在内核线程中执行的异步算法.</p>
</li>
<li>
<p>Authenc support
CONFIG_CRYPTO_AUTHENC</p>
<p>用于IPSec组合模式的包装器.</p>
</li>
<li>
<p>Testing module
CONFIG_CRYPTO_TEST</p>
<p>丑陋的加密测试模块.仅供调试使用.</p>
</li>
<li>
<p>CCM support
CONFIG_CRYPTO_CCM</p>
<p><a href="http://baike.baidu.com/view/3169861.htm">CBC-MAC</a>计数器.IPsec需要它.</p>
</li>
<li>
<p>GCM/GMAC support
CONFIG_CRYPTO_GCM</p>
<p>GCM(<a href="http://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois/Counter Mode</a>)与GMAC(Galois Message Authentication Code)支持.IPsec需要它.[注释]GCM是一种对称加密算法的块密码工作模式,使用128位块大小.<a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">块密码工作模式</a>可以分为加密模式,认证模式,认证加密模式.GCM模式为认证模式的一种,提供认证和加密两种功能.</p>
</li>
<li>
<p>Sequence Number IV Generator
CONFIG_CRYPTO_SEQIV</p>
<p>序号初始向量(IV)生成器.它基于一个序号与一个盐粒子(salt)的异或值生成一个向量.此算法主要用于块密码的CTR(计数模式).</p>
</li>
<li>
<p>CBC support
CONFIG_CRYPTO_CBC</p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:密码分组链接(Cipher Block Chaining)模式.IPSec需要它.</p>
</li>
<li>
<p>CTR support
CONFIG_CRYPTO_CTR</p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:计数器(Counter)模式.IPSec需要它.</p>
</li>
<li>
<p>CTS support
CONFIG_CRYPTO_CTS</p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:密文窃取(Cipher Text Stealing)模式.Kerberos gss机制支持的AES加密需要它.</p>
</li>
<li>
<p>ECB support
CONFIG_CRYPTO_ECB</p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>电子密码本(Electronic CodeBook)模式.这是最简单的分组密码算法,只是简单的分别加密每个块.</p>
</li>
<li>
<p>LRW support
CONFIG_CRYPTO_LRW</p>
<p><a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F#.E5.85.B6.E5.AE.83.E6.A8.A1.E5.BC.8F.E5.92.8C.E5.AF.86.E7.A0.81.E5.AD.A6.E6.A6.82.E5.BF.B5">块密码工作模式</a>:LRW(Liskov Rivest Wagner)模式.这个模式以三个人名命名.这是一种小数据块加密模式,加密后的数据保持与明文数据同样的长度,专门用于CONFIG_DM_CRYPT模块加密磁盘区块(使用&quot;aes-lrw-benbi&quot;指定).</p>
</li>
<li>
<p>PCBC support
CONFIG_CRYPTO_PCBC</p>
<p><a href="http://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">块密码工作模式</a>:填充密码块链接(Propagating Cipher Block Chaining)模式.CONFIG_AF_RXRPC需要它.</p>
</li>
<li>
<p>XTS support
CONFIG_CRYPTO_XTS</p>
<p><a href="http://msdn.microsoft.com/zh-cn/library/system.security.cryptography.ciphermode.aspx">块密码工作模式</a>:XTS模式.这是IEEE1619/D16规范制定的一种小数据块加密模式,加密后的数据保持与明文数据同样的长度,专门用于加密磁盘区块(使用&quot;aes-xts-plain&quot;指定).</p>
</li>
<li>
<p>CMAC support
CONFIG_CRYPTO_CMAC</p>
<p>NIST(美国国家标准与技术研究所)制定的基于密文的<a href="http://wenku.baidu.com/view/c0bb4078168884868762d6a1.html">消息认证码</a>(<a href="http://www.rfc-editor.org/rfc/rfc4493.txt">Cipher-based Message Authentication Code</a>)</p>
</li>
<li>
<p>HMAC support
CONFIG_CRYPTO_HMAC</p>
<p>基于哈希的消息验证代码(<a href="http://blog.chinaunix.net/uid-20356525-id-1700433.html">RFC2104</a>).在发送方和接收方共享机密密钥的前提下,<a href="http://baike.baidu.com/view/1136366.htm">HMAC</a>可用于确定通过不安全信道发送的消息是否被篡改.IPSec需要它.</p>
</li>
<li>
<p>XCBC support
CONFIG_CRYPTO_XCBC</p>
<p>基于哈希的加密算法(<a href="http://www.ietf.org/rfc/rfc3566.txt">RFC3566</a>)</p>
</li>
<li>
<p>VMAC support
CONFIG_CRYPTO_VMAC</p>
<p><a href="http://fastcrypto.org/vmac">VMAC</a>是一种专用于64位CPU的高速消息认证算法</p>
</li>
<li>
<p>CRC32c CRC algorithm
CONFIG_CRYPTO_CRC32C</p>
<p><a href="http://blog.csdn.net/codegame/article/details/6540965">CRC32c</a>摘要算法是常见的CRC32<a href="http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a>的一个变种,仅多项式常数不同,算法完全一样.常用于iSCSI和SCTP数据校验.</p>
</li>
<li>
<p>CRC32c INTEL hardware acceleration
CONFIG_CRYPTO_CRC32C_INTEL</p>
<p>利用<a href="http://en.wikipedia.org/wiki/SSE4">SSE4.2</a>指令集中专用的&quot;CRC32&quot;指令,可以提高最少10倍的运算速度.如果你的CPU支持SSE4.2,建议选&quot;Y&quot;.</p>
</li>
<li>
<p>CRC32 CRC algorithm
CONFIG_CRYPTO_CRC32</p>
<p>经典的CRC32<a href="http://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">循环冗余校验</a>算法.</p>
</li>
<li>
<p>CRC32 PCLMULQDQ hardware acceleration
CONFIG_CRYPTO_CRC32_PCLMUL</p>
<p>使用处理器的PCLMULQDQ指令(又称<a href="http://en.wikipedia.org/wiki/CLMUL_instruction_set">CLMUL</a>指令集,其实只有一条指令)加速CRC32的运算.PCLMULQDQ是从Intel <a href="http://zh.wikipedia.org/wiki/Intel_Nehalem#Nehalen.E8.A3.BD.E7.A8.8B.E6.94.B9.E9.80.B2.E7.89.88.EF.BC.9AWestmere.E6.9E.B6.E6.A7.8B">Westmere</a>和AMD <a href="http://zh.wikipedia.org/wiki/AMD_Bulldozer">Bulldozer</a>开始引入的指令(隶属于<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>).可以大幅提升CRC32的运算速度.如果你的CPU支持AES指令集,建议选&quot;Y&quot;.</p>
</li>
<li>
<p>GHASH digest algorithm
CONFIG_CRYPTO_GHASH</p>
<p><a href="http://wenku.baidu.com/view/c5d3a56c783e0912a3162a07.html">GHASH</a>是用于GCM(Galois/Counter Mode)的消息摘要算法.</p>
</li>
<li>
<p>MD4 digest algorithm
CONFIG_CRYPTO_MD4</p>
<p>老旧的<a href="http://baike.baidu.com/view/444142.htm">MD4</a>(RFC1320)摘要算法,已经被淘汰.</p>
</li>
<li>
<p>MD5 digest algorithm
CONFIG_CRYPTO_MD5</p>
<p>广泛使用的<a href="http://zh.wikipedia.org/wiki/MD5">MD5</a>(RFC1321)摘要算法,128位.已经被发现可以快速找到碰撞,正逐渐淘汰中.</p>
</li>
<li>
<p>Michael MIC keyed digest algorithm
CONFIG_CRYPTO_MICHAEL_MIC</p>
<p>Michael MIC是仅用于<a href="http://baike.baidu.com/view/755337.htm">TKIP</a>(IEEE 802.11i)的摘要算法.不能用于其它场合,因为它存在一些缺陷.</p>
</li>
<li>
<p>RIPEMD-128 digest algorithm
CONFIG_CRYPTO_RMD128</p>
<p>RIPEMD-128(ISO/IEC 10118-3:2004)128位摘要算法.安全性不高,不建议使用.</p>
</li>
<li>
<p>RIPEMD-160 digest algorithm
CONFIG_CRYPTO_RMD160</p>
<p><a href="http://baike.baidu.com/view/260854.htm">RIPEMD</a>-160(ISO/IEC 10118-3:2004)160位摘要算法.是替代各种128位摘要算法(RIPEMD-128,MD5,MD4)的首选.其运算速度和SHA1相当,但是目前尚无已知有效的攻击方法.</p>
</li>
<li>
<p>RIPEMD-256 digest algorithm
CONFIG_CRYPTO_RMD256</p>
<p>RIPEMD-256在本质上和RIPEMD-128是一样的.因为RIPEMD的设计者们根本就没有真正设计256和320位这两种标准,他们只是在128位和160位的基础上,修改了初始参数和s-box来达到输出为256和320位的目的.所以,256位的强度和128相当,而320位的强度和160位相当.</p>
</li>
<li>
<p>RIPEMD-320 digest algorithm
CONFIG_CRYPTO_RMD320</p>
<p>RIPEMD-320在本质上和RIPEMD-160是一样的.因为RIPEMD的设计者们根本就没有真正设计256和320位这两种标准,他们只是在128位和160位的基础上,修改了初始参数和s-box来达到输出为256和320位的目的.所以,256位的强度和128相当,而320位的强度和160位相当.</p>
</li>
<li>
<p>SHA1 digest algorithm
CONFIG_CRYPTO_SHA1</p>
<p>目前使用最广泛的SHA-1(FIPS 180-1/DFIPS 180-2)160位摘要算法是<a href="http://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F">SHA家族</a>中的一员,在许多安全协议中广为使用(TLS,SSL,PGP,SSH,S/MIME,IPsec等).SHA-1曾被视为是MD5的后继者,但由于出现了针对SHA-1的理论上破解的方法(不等于实践中被破解),有些人已经开始改用其它的替代算法(例如<a href="http://www.oschina.net/translate/keccak-the-new-sha-3-encryption-standard">SHA-3</a>).</p>
</li>
<li>
<p>SHA1 digest algorithm (SSSE3/AVX)
CONFIG_CRYPTO_SHA1_SSSE3</p>
<p>使用<a href="http://en.wikipedia.org/wiki/SSSE3">SSSE3</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>指令集加速SHA-1的计算.如果你的CPU支持SSSE3/AVX指令集,建议选&quot;Y&quot;.</p>
</li>
<li>
<p>SHA256 digest algorithm (SSSE3/AVX/AVX2)
CONFIG_CRYPTO_SHA256_SSSE3</p>
<p>使用<a href="http://en.wikipedia.org/wiki/SSSE3">SSSE3</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a>指令集加速SHA-256的计算.</p>
</li>
<li>
<p>SHA512 digest algorithm (SSSE3/AVX/AVX2)
CONFIG_CRYPTO_SHA512_SSSE3</p>
<p>使用<a href="http://en.wikipedia.org/wiki/SSSE3">SSSE3</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a>指令集加速SHA-512的计算.</p>
</li>
<li>
<p>SHA224 and SHA256 digest algorithm
CONFIG_CRYPTO_SHA256</p>
<p>SHA-224和SHA-256摘要算法,速度较SHA1稍慢,都属于&quot;SHA-2&quot;系列,目前尚无已知的有效攻击方法.但并未被广泛使用.</p>
</li>
<li>
<p>SHA384 and SHA512 digest algorithms
CONFIG_CRYPTO_SHA512</p>
<p>SHA-384和SHA-512摘要算法,速度大约只有SHA1的40-50%,都属于&quot;SHA-2&quot;系列,目前尚无已知的有效攻击方法.但并未被广泛使用.</p>
</li>
<li>
<p>Tiger digest algorithms
CONFIG_CRYPTO_TGR192</p>
<p>Tiger号称是最快的哈希算法,专门为64位机器做了优化.</p>
</li>
<li>
<p>Whirlpool digest algorithms
CONFIG_CRYPTO_WP512</p>
<p><a href="http://blog.csdn.net/simb/article/details/1266177">Whirlpool</a>是一种512位的摘要算法,利用了已有的AES分组密码算法构造Hash函数,拥有相当高的安全性,已经被列入了ISO标准,目前最新版本为3.0(2003年发布).</p>
</li>
<li>
<p>GHASH digest algorithm (CLMUL-NI accelerated)
CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL</p>
<p>使用CPU的<a href="http://en.wikipedia.org/wiki/CLMUL_instruction_set">CLMUL</a>指令集(包含在<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>中)加速GHASH摘要算法.</p>
</li>
<li>
<p>AES cipher algorithms
CONFIG_CRYPTO_AES</p>
<p><a href="http://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">AES</a>(FIPS-197)又称&quot;Rijndael&quot;,是目前最佳的<a href="http://zh.wikipedia.org/wiki/%E5%B0%8D%E7%AD%89%E5%8A%A0%E5%AF%86">对称加密</a>算法,快速且节省内存,可以使用128/192/256位密钥,是目前使用最广泛的对称加密算法.</p>
</li>
<li>
<p>AES cipher algorithms (x86_64)
CONFIG_CRYPTO_AES_X86_64</p>
<p>针对x86_64架构的AES实现.</p>
</li>
<li>
<p>AES cipher algorithms (AES-NI)
CONFIG_CRYPTO_AES_NI_INTEL</p>
<p>使用<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>加速AES的计算.如果你的CPU支持AES指令集,建议选&quot;Y&quot;.</p>
</li>
<li>
<p>Anubis cipher algorithm
CONFIG_CRYPTO_ANUBIS</p>
<p>Anubis是一种分组密码算法.分组长度为128位,密钥长度可变(最低128位),圈数可变(最低12圈).是欧洲于2000年1月1日启动的<a href="http://wenku.baidu.com/view/23e92c0e7cd184254b3535fb.html">NESSIE计划17个候选分组加密算法</a>之一.</p>
</li>
<li>
<p>ARC4 cipher algorithm
CONFIG_CRYPTO_ARC4</p>
<p>一种脆弱的流对称加密算法,仅用于已经被淘汰的<a href="http://baike.baidu.com/view/32853.htm">WEP</a>.</p>
</li>
<li>
<p>Blowfish cipher algorithm
CONFIG_CRYPTO_BLOWFISH</p>
<p><a href="http://zh.wikipedia.org/wiki/Blowfish_(%E5%AF%86%E7%A0%81%E5%AD%A6)">Blowfish</a>对称加密算法,一种又老又慢的对称加密算法.</p>
</li>
<li>
<p>Blowfish cipher algorithm (x86_64)
CONFIG_CRYPTO_BLOWFISH_X86_64</p>
<p>针对x86_64架构的Blowfish实现</p>
</li>
<li>
<p>Blowfish cipher algorithm (x86_64/AVX2)
CONFIG_CRYPTO_BLOWFISH_AVX2_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a>指令集加速Blowfish的计算.</p>
</li>
<li>
<p>Camellia cipher algorithms
CONFIG_CRYPTO_CAMELLIA</p>
<p><a href="http://zh.wikipedia.org/wiki/Camellia">Camellia</a>是欧盟NESSIE项目的选定算法,也是日本CRYPTREC项目的推荐算法.可以使用128/192/256位密钥,具有与AES同等级的安全强度及运算速度.</p>
</li>
<li>
<p>Camellia cipher algorithm (x86_64)
CONFIG_CRYPTO_CAMELLIA_X86_64</p>
<p>针对x86_64架构的Camellia实现</p>
</li>
<li>
<p>Camellia cipher algorithm (x86_64/AES-NI/AVX)
CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速Camellia的计算.</p>
</li>
<li>
<p>Camellia cipher algorithm (x86_64/AES-NI/AVX2)
CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/AES_instruction_set">AES指令集</a>/<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2指令集</a>加速Camellia的计算.</p>
</li>
<li>
<p>CAST5 (CAST-128) cipher algorithm
CONFIG_CRYPTO_CAST5</p>
<p>老旧的CAST5(CAST-128)对称加密算法</p>
</li>
<li>
<p>CAST5 (CAST-128) cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_CAST5_AVX_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速CAST5的计算.</p>
</li>
<li>
<p>CAST6 (CAST-256) cipher algorithm
CONFIG_CRYPTO_CAST6</p>
<p>老旧的CAST6(CAST-256)对称加密算法</p>
</li>
<li>
<p>CAST6 (CAST-256) cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_CAST6_AVX_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速CAST6的计算.</p>
</li>
<li>
<p>DES and Triple DES EDE cipher algorithms
CONFIG_CRYPTO_DES</p>
<p>老旧的DES和三重DES对称加密算法.</p>
</li>
<li>
<p>FCrypt cipher algorithm
CONFIG_CRYPTO_FCRYPT</p>
<p>FCrypt对称加密算法仅用于CONFIG_AF_RXRPC</p>
</li>
<li>
<p>Khazad cipher algorithm
CONFIG_CRYPTO_KHAZAD</p>
<p><a href="http://en.wikipedia.org/wiki/KHAZAD">Khazad</a>是一种最终进入NESSIE决赛的对称加密算法,专为64位CPU设计,支持128位密钥.</p>
</li>
<li>
<p>Salsa20 stream cipher algorithm
CONFIG_CRYPTO_SALSA20</p>
<p><a href="http://en.wikipedia.org/wiki/Salsa20">Salsa20</a>是一种<a href="http://wenku.baidu.com/view/a431d1125f0e7cd184253620.html">流密码算法</a>,也是<a href="http://www.ecrypt.eu.org/stream/">eSTREAM</a>工程最终胜选算法之一.</p>
</li>
<li>
<p>Salsa20 stream cipher algorithm (x86_64)
CONFIG_CRYPTO_SALSA20_X86_64</p>
<p>针对x86_64架构的Salsa20实现</p>
</li>
<li>
<p>SEED cipher algorithm
CONFIG_CRYPTO_SEED</p>
<p>SEED(RFC4269)对称分组加密算法,采用128位密钥,是韩国的国家标准.</p>
</li>
<li>
<p>Serpent cipher algorithm
CONFIG_CRYPTO_SERPENT</p>
<p><a href="http://en.wikipedia.org/wiki/Serpent_(cipher)">Serpent</a>对称加密算法曾经是AES的最终5个候选算法之一,因为速度较Rijndael慢而最终得票数次之.目前尚未发现针对Serpent的有效攻击,因此被认为是一种强安全算法(甚至被认为比Rijndael更安全).</p>
</li>
<li>
<p>Serpent cipher algorithm (x86_64/SSE2)
CONFIG_CRYPTO_SERPENT_SSE2_X86_64</p>
<p>使用<a href="http://zh.wikipedia.org/wiki/SSE2">SSE2</a>指令集加速Serpent的计算.</p>
</li>
<li>
<p>Serpent cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_SERPENT_AVX_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速Serpent的计算.</p>
</li>
<li>
<p>Serpent cipher algorithm (x86_64/AVX2)
CONFIG_CRYPTO_SERPENT_AVX2_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2指令集</a>加速Serpent的计算.</p>
</li>
<li>
<p>TEA, XTEA and XETA cipher algorithms
CONFIG_CRYPTO_TEA</p>
<p>较弱的几种对称加密算法</p>
</li>
<li>
<p>Twofish cipher algorithm
CONFIG_CRYPTO_TWOFISH</p>
<p><a href="http://zh.wikipedia.org/wiki/%E5%8F%8C%E9%B1%BC%E7%AE%97%E6%B3%95">Twofish</a>是派生自Blowfish的对称加密算法,曾经是AES的最终5个候选算法之一,最终得票数第三.</p>
</li>
<li>
<p>Twofish cipher algorithm (x86_64)
CONFIG_CRYPTO_TWOFISH_X86_64</p>
<p>针对x86_64架构的Twofish实现</p>
</li>
<li>
<p>Twofish cipher algorithm (x86_64, 3-way parallel)
CONFIG_CRYPTO_TWOFISH_X86_64_3WAY</p>
<p>针对x86_64架构的三路并行Twofish实现.能够充分利用<a href="http://zh.wikipedia.org/wiki/%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C">乱序执行</a>CPU的指令周期.</p>
</li>
<li>
<p>Twofish cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_TWOFISH_AVX_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>加速Twofish的计算.</p>
</li>
<li>
<p>Twofish cipher algorithm (x86_64/AVX2)
CONFIG_CRYPTO_TWOFISH_AVX2_X86_64</p>
<p>使用<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2指令集</a>加速Twofish的计算.</p>
</li>
<li>
<p>Deflate compression algorithm
CONFIG_CRYPTO_DEFLATE</p>
<p><a href="http://zh.wikipedia.org/wiki/DEFLATE">Deflate</a>(RFC1951)无损数据压缩算法.当在IPSec中使用<a href="http://wenku.baidu.com/view/082419c00c22590102029d2d.html">IPCOMP</a>协议时才需要.</p>
</li>
<li>
<p>Zlib compression algorithm
CONFIG_CRYPTO_ZLIB</p>
<p><a href="http://zh.wikipedia.org/wiki/Zlib">zlib</a>无损数据压缩算法是一种事实上的业界标准.被广泛应用.</p>
</li>
<li>
<p>LZO compression algorithm
CONFIG_CRYPTO_LZO</p>
<p><a href="http://zh.wikipedia.org/wiki/LZO">LZO</a>是致力于解压速度的一种无损数据压缩算法.</p>
</li>
<li>
<p>Pseudo Random Number Generation for Cryptographic modules
CONFIG_CRYPTO_ANSI_CPRNG</p>
<p>通用的伪随机数生成器.用于为密码模块提供相应的支持.</p>
</li>
<li>
<p>User-space interface for hash algorithms
CONFIG_CRYPTO_USER_API_HASH</p>
<p>哈希算法的用户空间接口.</p>
</li>
<li>
<p>User-space interface for symmetric key cipher algorithms
CONFIG_CRYPTO_USER_API_SKCIPHER</p>
<p>对称加密算法的用户空间接口.</p>
</li>
<li>
<p>Hardware crypto devices
CONFIG_CRYPTO_HW</p>
<ul>
<li>硬件加密设备支持</li>
<li>
<ul>
<li>
<p>Support for VIA PadLock ACE
CONFIG_CRYPTO_DEV_PADLOCK</p>
<ul>
<li>带有<a href="http://www.viatech.com.cn/cn/initiatives/padlock/index.jsp">PadLock</a>技术的VIA系列处理器支持</li>
<li>
<ul>
<li>
<p>PadLock driver for AES algorithm
CONFIG_CRYPTO_DEV_PADLOCK_AES</p>
<p>利用PadLock技术<a href="http://www.viatech.com.cn/cn/initiatives/padlock/features.jsp#aes">加速AES运算</a>.VIA C3及以上的CPU都支持.</p>
</li>
<li>
<p>PadLock driver for SHA1 and SHA256 algorithms
CONFIG_CRYPTO_DEV_PADLOCK_SHA</p>
<p>利用PadLock技术<a href="http://www.viatech.com.cn/cn/initiatives/padlock/features.jsp#sha">加速SHA1和SHA256运算</a>.VIA C7及以上的CPU都支持.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Asymmetric (public-key cryptographic) key type
CONFIG_ASYMMETRIC_KEY_TYPE</p>
<ul>
<li><a href="http://baike.baidu.com/view/1490349.htm">非对称加密算法</a>(<a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公钥加密算法</a>)</li>
<li>
<ul>
<li>
<p>Asymmetric public-key crypto algorithm subtype
CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE</p>
<ul>
<li>非对称公钥加密算法子类型.如果需要生成或者校验签名,那就还必须配合哈希算法一起使用.</li>
<li>
<ul>
<li>
<p>RSA public-key algorithm
CONFIG_PUBLIC_KEY_ALGO_RSA</p>
<p><a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA</a>算法(<a href="http://wenku.baidu.com/view/168e67175f0e7cd18425369a.html">PKCS#1</a>, RFC3447)支持</p>
</li>
<li>
<p>X.509 certificate parser
CONFIG_X509_CERTIFICATE_PARSER</p>
<p><a href="http://baike.baidu.com/view/156016.htm">X.509</a>证书解析支持</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="virtualization-虚拟化支持-仅在将此内核用作宿主机host的情况下才需要开启这里的子项"><a href=""></a>Virtualization 虚拟化支持 仅在将此内核用作宿主机(host)的情况下才需要开启这里的子项</h2>
<ul>
<li>
<p>Kernel-based Virtual Machine (KVM) support
CONFIG_KVM</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-linux-kvm/index.html">KVM</a>(<a href="http://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA">内核虚拟机</a>)是一种基于Linux内核的<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vt/">全虚拟化技术</a>,需要CPU支持<a href="http://zh.wikipedia.org/wiki/X86%E8%99%9A%E6%8B%9F%E5%8C%96">x86硬件虚拟化技术</a>(Intel VT或AMD-V).开启此项后,将可以通过字符文件&quot;/dev/kvm&quot;使用虚拟机.</li>
<li>
<ul>
<li>
<p>KVM for Intel processors support
CONFIG_KVM_INTEL</p>
<p><a href="http://baike.baidu.com/view/2236017.htm">Intel VT</a>技术支持.也就是cpu-flags中有&quot;vmx&quot;标记.</p>
</li>
<li>
<p>KVM for AMD processors support
CONFIG_KVM_AMD</p>
<p><a href="http://sites.amd.com/cn/business/it-solutions/virtualization/Pages/amd-v.aspx">AMD-V</a>技术支持.也就是cpu-flags中有&quot;svm&quot;标记.</p>
</li>
<li>
<p>Audit KVM MMU
CONFIG_KVM_MMU_AUDIT</p>
<p>添加一个&quot;kvm.mmu_audit&quot;内核参数,用于控制是否允许在运行时对KVM MMU进行审计.&ldquo;0&quot;表示禁止审计,&ldquo;1&quot;表示允许审计.主要用于调试目的.不确定的选&quot;N&rdquo;.</p>
</li>
<li>
<p>KVM legacy PCI device assignment support
CONFIG_KVM_DEVICE_ASSIGNMENT</p>
<p>通过KVM支持传统的PCI设备分配.内核目前还通过VFIO(CONFIG_VFIO)支持一个全功能的<a href="http://www.linux-kvm.com/content/pci-device-assignment-driver-coming-linux-36-vfio">用户空间设备驱动框架</a>,可以取代这里的功能.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Host kernel accelerator for virtio net
CONFIG_VHOST_NET</p>
<p>在宿主机内核中开启此项后,可以加速客户机的网络操作速度(客户机内核必须要加载virtio_net模块(CONFIG_VIRTIO_NET)).</p>
</li>
<li>
<p>VHOST_SCSI TCM fabric driver
CONFIG_VHOST_SCSI</p>
<p>允许将宿主机的TCM fabric模块(vhost_scsi)用于加载了virtio-scsi模块的客户机.看不懂的选&quot;N&rdquo;.</p>
</li>
</ul>
<h2 id="library-routines-库子程序-子选项可以全不选内核中若有其他部分依赖它会自动选上使用内核树外的模块时可能需要手动选择"><a href=""></a>Library routines 库子程序 子选项可以全不选,内核中若有其他部分依赖它,会自动选上.使用内核树外的模块时可能需要手动选择.</h2>
<ul>
<li>
<p>CRC-CCITT functions
CONFIG_CRC_CCITT</p>
<p>为内核树外的模块提供<a href="http://djb69.blog.163.com/blog/static/6776323420100158391490/">CRC-CCITT</a>循环验证算法支持.</p>
</li>
<li>
<p>CRC16 functions
CONFIG_CRC16</p>
<p>为内核树外的模块提供<a href="http://blog.csdn.net/kwbin/article/details/3323836">CRC16</a>循环验证算法支持.</p>
</li>
<li>
<p>CRC calculation for the T10 Data Integrity Field
CONFIG_CRC_T10DIF</p>
<p>为内核树外的模块提供<a href="http://zh.wikipedia.org/zh/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97">CRC</a>循环验证算法支持.从而允许内核树外的SCSI模块利用<a href="http://www.ibm.com/developerworks/cn/aix/library/au-T10E2E/">T10/SCSI Data Integrity Field</a>保障<a href="http://alanwu.blog.51cto.com/3652632/1093600">端到端的数据完整性</a>.</p>
</li>
<li>
<p>CRC ITU-T V.41 functions
CONFIG_CRC_ITU_T</p>
<p>为内核树外的模块提供CRC ITU-T V.41循环验证算法支持.</p>
</li>
<li>
<p>CRC32/CRC32c functions
CONFIG_CRC32</p>
<ul>
<li>为内核树外的模块提供CRC32/CRC32c循环验证算法支持.</li>
<li>
<ul>
<li>
<p>CRC32 perform self test on init
CONFIG_CRC32_SELFTEST</p>
<p>在CRC32算法初始化的时候进行一个简单的自我测试.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>CRC32 implementation</p>
<p>选择CRC32算法的实现方式.不确定的请保持默认值&quot;Slice by 8 bytes&quot;,除非你知道自己在做什么.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CRC7 functions
CONFIG_CRC7</p>
<p>为内核树外的模块提供CRC7循环验证算法支持.</p>
</li>
<li>
<p>CRC32c (Castagnoli, et al) Cyclic Redundancy-Check
CONFIG_LIBCRC32C</p>
<p>为内核树外的模块提供CRC32c循环验证算法支持.</p>
</li>
<li>
<p>CRC8 function
CONFIG_CRC8</p>
<p>为内核树外的模块提供CRC8循环验证算法支持.</p>
</li>
<li>
<p>XZ decompression support
CONFIG_XZ_DEC</p>
<p>为内核树外的模块提供XZ解压支持.详见&quot;<a href="http://lxr.linux.no/linux/Documentation/xz.txt">Documentation/xz.txt</a>&ldquo;文档.子项是针对不同平台的&quot;BCJ filter decoder&rdquo;.按需选择即可.</p>
</li>
<li>
<p>XZ decompressor tester
CONFIG_XZ_DEC_TEST</p>
<p>XZ解压测试程序.不确定的选&quot;N&quot;.</p>
</li>
<li>
<p>Averaging functions
CONFIG_AVERAGE</p>
<p>为内核树外的模块提供averaging函数支持</p>
</li>
<li>
<p>CORDIC algorithm
CONFIG_CORDIC</p>
<p>为内核树外的模块提供<a href="http://en.wikipedia.org/wiki/CORDIC">CORDIC</a>算法支持</p>
</li>
<li>
<p>JEDEC DDR data
CONFIG_DDR</p>
<p>为内核树外的DDR SDRAM内存控制器驱动提供获取<a href="http://zh.wikipedia.org/wiki/JEDEC">JEDEC</a>数据支持.</p>
</li>
</ul>
<h2 id="general-setup通用选项">General setup（通用选项）</h2>
<p>[*] Prompt for development and/or incomplete code/drivers，设置界面中显示还在开发或者还没有完成的代码与驱动，最好选上，许多设备都需要它才能配置。</p>
<p>[ ]Cross-compiler tool prefix，交叉编译工具前缀，如果你要使用交叉编译工具的话输入相关前缀。默认不使用。嵌入式 linux 更不需要。</p>
<p>[ ]Local version - append to kernel release，自定义版本，也就是 uname -r 可以看到的版本，可以自行修改，没多大意义。</p>
<p>[ ]Automatically append version information to the version string，自动生成版本信息。这个选项会自动探测你的内核并且生成相应的版本，使之不会和原先的重复。这需要 Perl 的支持。由于在编译的命令 make-kpkg 中我们会加入 - – append-to-version 选项来生成自定义版本，所以这里选 N。</p>
<p>[]Support for paging of anonymous memory (swap)，交换分区支持，也就是虚拟内存支持，嵌入式不需要。</p>
<p>[*]POSIX Message Queues，这是 POSIX 的消息队列，它同样是一种 IPC(进程间通讯)。建议你最好将它选上。</p>
<p>[ ]Auditing support，审计功能，某些内核模块需要它（SELINUX），如果不知道，不用选。</p>
<p>[ ]RCU Subsystem，一个高性能的锁机制 RCU 子系统，不懂不了解，按默认就行。</p>
<p>[ ]Kernel .config support，将. config 配置信息保存在内核中，选上它及它的子项使得其它用户能从 / proc/ config.gz 中得到内核的配置, 选上，重新配置内核时可以利用已有配置</p>
<p>Enable access to .config through /proc/config.gz，上一项的子项，可以通过 / proc/ config.gz 访问. config 配置，上一个选的话，建议选上。</p>
<p>(16)Kernel log buffer size (16 =&gt; 64KB, 17 =&gt; 128KB) ，内核日志缓存的大小，使用默认值即可。12 =&gt; 4 KB，13 =&gt; 8 KB，14 =&gt; 16 KB 单处理器，15 =&gt; 32 KB 多处理器，16 =&gt; 64 KB，17 =&gt; 128 KB。</p>
<p>[ ]Control Group support（有子项），使用默认即可，不清楚可以不选。</p>
<p>Example debug cgroup subsystem，cgroup 子系统调试例子</p>
<p>Namespace cgroup subsystem，cgroup 子系统命名空间</p>
<p>Device controller for cgroups，cgroups 设备控制器</p>
<p>Cpuset support，只有含有大量 CPU(大于 16 个) 的 SMP 系统或 NUMA(非一致内存访问) 系统才需要它。</p>
<p>[]enable deprecated sysfs features to support old userspace tools，在某些文件系统上 (比如 debugfs) 提供从内核空间向用户空间传递大量数据的接口，一般不选。</p>
<p>[]Kernel-&gt;user space relay support (formerly relayfs)，内核系统区和用户区进行传递通讯的支持，这个选项在特定文件系统（relayfs）中提供数据接口支持，它可以支持从内核空间到用户空间的大批量数据传递的支持。不清楚可以不选。</p>
<p>[ ]Namespaces support，（有子项）命名空间支持，允许服务器为不同的用户信息提供不同的用户名空间服务，不清楚可以不选。</p>
<p>[]Initial RAM filesystem and RAM disk (initramfs/initrd) support，初始 RAM 的文件和 RAM 磁盘（ initramfs /initrd）支持（如果要采用 initrd 启动则要选择，否则可以不选), 不需要，不用选。嵌入式 linux 一般不选。</p>
<p>[ ]Optimize for size，优化大小，-Os 代替 - O2 参数，可能会有二进制错误问题，一般不选。</p>
<p>（0）Default panic timeout，添 0 即可。</p>
<p>[*]Configure standard kernel features (for small systems)，特殊内核用到，可以不选，嵌入式 linux 则必选。</p>
<p>[ ]Enable the Anonymous Shared Memory Subsystem，启用匿名共享内存子系统，不清楚可以不选。</p>
<p>[ ]Enable AIO support，支持 AIO（Asynchronous I/O 异步事件非阻塞 I/O），（包含 aio.h, aio_read, 向内核发出读命令，aio_write 向内核写命令，详细见‘AIO 介绍‘文档），AIO 机制为服务器端高并发应用程序提供了一种性能优化的手段。加大了系统吞吐量，所以一般用于大型服务器，一般不用选。</p>
<p>[ ]Kernel Performance Events And Counters（有子项），不清楚，不选。</p>
<p>[*]Enable VM event counters for /proc/vmstat，允许在 / proc/vmstat 中包含虚拟内存事件记数器。</p>
<p>[*]Enable SLUB debugging support，支持 SLUB 内存分配管理器调试，</p>
<p>[ ]Disable heap randomization，禁用随即 head，选不选均可。</p>
<p>Choose SLAB allocator (SLUB (Unqueued Allocator))  &mdash;&gt;， 选择内存分配管理器，强烈推荐使用 SLUB。</p>
<p>[ ]Profiling support，剖面支持，用一个工具来扫描和计算计算机的剖面图，支持系统测评，一般开发人员使用，不选。</p>
<p>[ ]Kprobes，调试人员使用，不选。</p>
<p>GCOV-based kernel profiling  &mdash;&gt;（有子项），默认即可。</p>
<ol start="2">
<li>Enable loadable module support(可加载模块)</li>
</ol>
<p>[ ]Forced module loading， 强行加载模块，不建议选。</p>
<p>[*]Module unloading，支持模块卸载，必须选上。</p>
<p>[ ]Forced module unloading，强行卸载模块，即使内核认为这样并不安全，也就是说你可以把正在使用中的模快卸载掉。如果你不是内核开发人员或者骨灰级的玩家，不建议选。</p>
<p>[ ]Module versioning suppor，这个功能可以让你使用其它版本的内核模块，除非特殊需要，一般不选。</p>
<p>[ ]Source checksum for all modules，这个功能是为了防止更改了内核模块的代码但忘记更改版本号而造成版本冲突, 现在很少使用，不选。</p>
<ol start="3">
<li>Enable the block layer(块设备层)</li>
</ol>
<p>[*]Support for large (2TB+) block devices and files，仅在使用大于 2TB 的块设备时需要</p>
<p>[*]Block layer SG support v4，通用 SCSI 设备第四版支持。</p>
<p>[*]Block layer data integrity support，块设备数据完整性支持。</p>
<p>[*]IO Schedulers  &mdash;&gt;（有子项），IO 调度器</p>
<p>[]Anticipatory I/O scheduler，抢先式 I/O 调度器，大多数块设备只有一个物理查找磁头 (例如一个单独的 SATA 硬盘), 将多个随机的小写入流合并成一个大写入流, 用写入延时换取最大的写入吞吐量. 适用于大多数环境, 特别是写入较多的环境 (比如文件服务器)</p>
<p>[]Deadline I/O scheduler，期限式 I/O 调度器，轮询的调度器, 简洁小巧, 提供了最小的读取延迟和尚佳的吞吐量, 特别适合于读取较多的环境 (比如数据库)。</p>
<p>[ ]CFQ I/O scheduler，使用 QoS 策略为所有任务分配等量的带宽, 避免进程被饿死并实现了较低的延迟, 可以认为是上述两种调度器的折中. 适用于有大量进程的多用户系统 CFQ 调度器尝试为所有进程提供相同的带宽。它将提供平等的工作环境，对于桌面系统很合适。</p>
<p>Default I/O scheduler (CFQ)  &mdash;&gt; 默认 IO 调度器有上面三个 IO 调度器：抢先式是传统的，它的原理是一有响应，就优先考虑调度。如果你的硬盘此时在运行一项工作，它也会暂停下来先响应用户。期限式则是：所有的工作都有最终期限，在这之前必须完成。当用户有响应时，它会根据自己的工作能否完成，来决定是否响应用户。CFQ 则是平均分配资源，不管你的响应多急，也不管它的工作量是多少，它都是平均分配，一视同仁的。</p>
<ol start="4">
<li>
<p>System Type(arm 占用配置，一般是厂家提供，与第 7 项代替了原有的 Processor type and features)</p>
</li>
<li>
<p><input disabled="" type="checkbox"> FIQ Mode Serial Debugger，一般不选。</p>
</li>
<li>
<p>Bus support(总线支持)</p>
</li>
</ol>
<p>PCI support，PCI 总线支持，主板上最长用的插槽，最好选上，arm linux 可以不选，arm 一般没有 PCI 总线。</p>
<p>PCCard (PCMCIA/CardBus) support，一般笔记本有这种插槽，笔记本选上，arm linux 不选。</p>
<ol start="7">
<li>Kernel Features(内核特征)</li>
</ol>
<p>[] Tickless System (Dynamic Ticks)，非固定平率系统，能让内核运行的更有效率，并且省电，pc 下可选，特别是笔记本，arm linux 一般不用选。</p>
<p>[ ] High Resolution Timer Support，支持高频率时间发生器，需要硬件兼容，但大多数 PC 和 ARM 都不支持，不选</p>
<p>Memory split (2G/2G user/kernel split)  &mdash;&gt;，内核与用户空间各占 2G，内核空间 0-0x7FFFFFFF, 用户空间 80000000-FFFFFFFF</p>
<p>[ ]Compile the kernel in Thumb-2 mode，编译 Thumb-2 mode 内核，一般不选</p>
<p>[*] Use the ARM EABI to compile the kernel，与下面绑定配置。</p>
<p>[*] Allow old ABI binaries to run with this kernel (EXPERIMENTAL)，对于嵌入式系统 (jffs2 yaffs2)，这两个要选上，否则很可能启动的时候报错（kernel panic- not syncing: Attempted to kill init!）</p>
<p>[] High Memory Support (EXPERIMENTAL)（有子项）， 1G 物理内存以下不选，超过 1G 才选。（配置略有变化，以前的选项是 OFF（&lt;1G）,4G(&gt;1G &amp;&amp; &lt;4G),64G(&gt;4G)）。</p>
<p>Allocate 2nd-level pagetables from highmem，1G 物理内存以下不选，超过 1G（小于 4G）才选</p>
<p>Allocate 3nd-level pagetables from highmem，大于 4G，选择此项目。</p>
<p>Memory model (Flat Memory)  &mdash;&gt;，一般选 &ldquo;Flat Memory&rdquo;, 其他选项涉及内存热插拔。</p>
<p>[ ] Enable KSM for page merging，允许 linux 内核识别出包含相同内容的内存页，然后合并这些内存页，将数据整合在一个位置可以多次引用，特殊功能，不用选。</p>
<p>(4096) Low address space to protect from user allocation，默认 4096 即可</p>
<p>[] Use kernel mem{cpy,set}() for {copy_to,clear}_user() (EXPERIMENTAL)，不清楚可以不选。</p>
<hr>
<p>附：yaffs2 文件系统: Kernel panic - not syncing: Attempted to kill init!</p>
<p>在内核挂载根文件系统时，提示 Kernel panic - not syncing: Attempted to kill init! 的解决方法：</p>
<p>方法 1：</p>
<p>Kernel Features  &mdash;&gt;</p>
<p>[*] Use the ARM EABI to compile the kernel</p>
<p>[*]   Allow old ABI binaries to run with this kernel (EXPERIMENTA)</p>
<p>方法 2：</p>
<p>修改 busybox 的 Makefile</p>
<p>修改</p>
<p>CC=$(CROSS_COPILE)gcc</p>
<p>为</p>
<p>CC=$(CROSS_COPILE)gcc -march=armv4t</p>
<p>一般海思编译器选择此选项，linux-gcc-3.4.5 以下的编译器，不用选，如果用 4.3.3（支持 EABI 的编译器）以上的最好选上。</p>
<ol start="8">
<li>Boot options</li>
</ol>
<p>一般不需要配置，u-boot 会把启动参数传递给内核。如果 bootloader 没有传参数，可以配置启动参数，类似下面这样：</p>
<p>(0x0) Compressed ROM boot loader base address</p>
<p>(0x0) Compressed ROM boot loader BSS address</p>
<p>(mem=32M console=ttySAC0 root=/dev/ram initrd=0x30800000,4M ramdisk_size=4096 rw) Default kernel command string</p>
<ol start="9">
<li>CPU Power Management</li>
</ol>
<p>[ ] CPU idle PM support, 允许软件控制的空闲进程电源管理，arm linux 一般不用选。</p>
<ol start="10">
<li>Floating point emulation(浮点运算，(arm 专用) 看 arm 是否支持硬浮点协处理器，支持的话选择 VFP，不支持选择 NWFPE)</li>
</ol>
<p>[ ] NWFPE math emulation</p>
<p>[] FastFPE math emulation (EXPERIMENTAL)</p>
<p>[*] VFP-format floating point maths</p>
<p>[] Advanced SIMD (NEON) Extension support</p>
<ol start="10">
<li>Userspace binary formats(二进制支持)</li>
</ol>
<p>[*] Kernel support for ELF binaries，必须选，否则内核可能不能启动，其他可以全部不选，</p>
<p>[ ] Write ELF core dumps with partial segments</p>
<p>&lt; &gt; Kernel support for a.out and ECOFF binaries</p>
<p>&lt; &gt; Kernel support for MISC binaries</p>
<ol start="11">
<li>Power management options（电源管理）</li>
</ol>
<p>一般用于笔记本，PC 和 arm 可以不选。</p>
<p>[*] Power Management support，选择此项，下面的项才能可见</p>
<p>[ ] Power Management Debug Support，调试用，不用选</p>
<p>[*] Suspend to RAM and standby，待机到内存，即内存供电而暂时关闭硬盘等外设。</p>
<p>&lt; &gt; Advanced Power Management Emulation，高级电源管理，</p>
<p>[ ] Run-time PM core functionality，允许对运行中接入的 I/O 设备进行电源管理。</p>
<ol start="12">
<li>Networking support，（协议层的网络支持，socket 等，硬件层的支持在 Device Drivers 中配置）</li>
</ol>
<p>Networking options  &mdash;&gt;，网络选项</p>
<p>&lt;*&gt; Packet socket，这种 socket 能够让应用程序（tcpdump，iptables）直接与网络设备通讯，而不通过内核中的其他中介协议，最好选上。</p>
<p>&lt;*&gt; Unix domain sockets，一种仅运行于本机上的效率高于 TCP/IP 的 socket, 简称 Unix socket. 许多程序都使用它在操作系统内部进行进程间通信 (IPC), 比如 X Window 和 syslog，最好选上。</p>
<p>&lt;&gt; Transformation user configuration interface，为 IPsec(可在 ip 层加密) 之类的工具提供 XFRM 用户配置接口支持，不清楚可以不选。</p>
<p>[] Transformation sub policy support (EXPERIMENTAL)，XFRM 子策略支持, 仅供开发者使用，不清楚不要选。</p>
<p>[] Transformation migrate database (EXPERIMENTAL)，</p>
<p>[] Transformation statistics (EXPERIMENTAL)，</p>
<p>&lt; &gt; PF_KEY sockets，用于可信任的密钥管理程序和操作系统内核内部的密钥管理进行通信, IPsec 也依赖于它，可以不选。</p>
<p>[]   PF_KEY MIGRATE (EXPERIMENTAL)，子项，不用选。</p>
<p>[*] TCP/IP networking，TCP/IP 协议，必须要选</p>
<p>[*]   IP: multicasting，群组广播，选上</p>
<p>[]   IP: advanced router，高级路由功能，做路由器的话选上，可以不选。</p>
<p>Choose IP: FIB lookup algorithm (choose FIB_HASH if unsure) (FIB_HASH)，子项，不懂的话就选 FIB_HASH 吧</p>
<p>[ ]   IP: policy routing，策略路由，不清楚可以不选。</p>
<p>[ ]   IP: equal cost multipath，用于路由的基于目的地址的均衡。不清楚可以不选。</p>
<p>[ ]   IP: verbose route monitoring，显示冗余的路由监控信息，可以不选</p>
<p>[ ]   IP: kernel level autoconfiguration，内核启动时自动配置 IP 地址、路由表等，需要从网络启动的无盘工作站需要这个，普通用户不需要。</p>
<p>&lt; &gt;  IP: tunneling，IP 隧道，将一个 IP 报文装在另一个 IP 报文的技术。不清楚不用选。</p>
<p>&lt; &gt;  IP: GRE tunnels over IP，基于 IP 的 GRE（通用路由封装）隧道，不清楚可以不选。</p>
<p>[]   IP: multicast routing，多重传播路由，没有特殊需求可以不选。</p>
<p>[ ]     IP: multicast policy routing，子项，不清楚可以不选</p>
<p>[ ]     IP: PIM-SM version 1 support，子项，不清楚可以不选</p>
<p>[ ]     IP: PIM-SM version 2 support，子项，不清楚可以不选</p>
<p>[ ]   IP: ARP daemon support，废弃功能，不选。</p>
<p>[]   IP: TCP syncookie support，抵抗 SYN flood 攻击的好东西, 要启用它必须同时启用 / proc 文件系统和 &ldquo;Sysctlsupport&rdquo;, 然后在系统启动并挂载了 / proc 之后执行 &ldquo;echo 1&gt;/proc/sys/net/ipv4/tcp_syncookies&rdquo; 命令，不清楚可以不选。</p>
<p>&lt;&gt;  IP: AH transformation，IPsec 验证头 (AH), 实现了数据发送方的验证处理, 可确保数据既对于未经验证的站点不可用也不能在路由过程中更改，不清楚可以不选。</p>
<p>&lt;&gt;  IP: ESP transformation，IPsec 封闭安全负载 (ESP), 实现了发送方的验证处理和数据加密处理, 用以确保数据不会被拦截 / 查看或复制。不清楚可以不选。</p>
<p>&lt;&gt;  IP: IPComp transformation，IPComp(IP 静荷载压缩协议), 用于支持 IPsec，不清楚可以不选。</p>
<p>&lt; &gt;  IP: IPsec transport mode，IPsec 传输模式, 常用于对等通信, 用以提供内网安全. 数据包经过了加密但 IP 头没有加密, 因此任何标准设备或软件都可查看和使用 IP 头，不清楚可以不选。</p>
<p>&lt;&gt;  IP: IPsec tunnel mode，IPsec 隧道模式, 用于提供外网安全 (包括虚拟专用网络). 整个数据包(数据头和负载) 都已经过加密处理且分配有新的 ESP 头 / IP 头和验证尾, 从而能够隐藏受保护站点的拓扑结构，不清楚可以不选。</p>
<p>&lt; &gt;  IP: IPsec BEET mode，IPsec BEET 模式，不清楚可以不选。</p>
<p>[*]   Large Receive Offload (ipv4/tcp)，针对 TCP 流量的 LRO (Large Receive Offload) 支持，选上。</p>
<p>&lt;*&gt;  INET: socket monitoring interface，socket 监视接口, 一些 Linux 本地工具 (如: 包含 ss 的 iproute2) 需要使用它，选上</p>
<p>[]   TCP: advanced congestion control  &mdash;&gt;，高级拥塞控制, 如果没有特殊需求 (比如无线网络) 就别选了, 内核会自动将默认的拥塞控制设为 &ldquo;Cubic&rdquo; 并将 &ldquo;Reno&rdquo; 作为候补，可以不选。如果网络用处较多，还是选上为好（如网络视频服务器）。 关于拥塞控制，见 tcp 拥塞控制. doc 文档。</p>
<p>[]   TCP: MD5 Signature Option support (RFC2385) (EXPERIMENTAL)，不清楚可以不选。</p>
<p>&lt;*&gt;   The IPv6 protocol  &mdash;&gt;，IPV6 支持的话，就选上，</p>
<p>[*] Only allow certain groups to create sockets，只允许特定的群体创建 socket，选上，没什么坏处。</p>
<p>[*] Network activity statistics tracking，最好选上。</p>
<p>……. 网络选项中，后面的不清楚的话 可以不选，选上基本几项，网络就可以工作了，有时间进一步深入研究。</p>
<p>-*-   Wireless  &mdash;&gt;（无线，没有无线网卡的话可以不选）</p>
<p>&lt;*&gt;   cfg80211 - wireless configuration API，暂时未会，使用默认配置</p>
<ol start="13">
<li>Device Drivers（设备驱动）</li>
</ol>
<p>Generic Driver Options  &mdash;&gt;，通用选项</p>
<p>(/sbin/mdev) path to uevent helper，不理解，用的默认值</p>
<p>[ ] Maintain a devtmpfs filesystem to mount at /dev，让 devtmpfs 文件系统安装在 / dev，不清楚可以不选。</p>
<p>[*] Select only drivers that don&rsquo;t need compile-time external firmware，只显示那些不需要内核对外部设备的固件作 map 支持的驱动程序, 除非你有某些怪异硬件, 否则请选上。</p>
<p>[ ] Prevent firmware from being built，不编译固件（固化的软件，如 bios）. 固件一般是随硬件的驱动程序提供的, 仅在更新固件的时候才需要重新编译。可以不选，但想要更新固件的话就要重新编译内核了。</p>
<p>{*} Userspace firmware loading support，提供某些内核之外的模块需要的用户空间固件加载支持, 在内核树之外编译的模块可能需要它，选上。</p>
<p>[*]  Include in-kernel firmware blobs in kernel binary</p>
<p>()   External firmware blobs to build into the kernel binary</p>
<p>&lt;&gt; Connector - unified userspace &lt;-&gt; kernelspace linker  &mdash;&gt;，用户空间和内核空间连接器，工作在 netlink socket 协议的顶层，不清楚可以不选。</p>
<p>&lt;*&gt; Memory Technology Device (MTD) support  &mdash;&gt;，特殊的存储技术，如常用语数码相机或嵌入式系统的闪存卡，一般是 NOR flash 和 Nand 的支持，arm linux 必选，PC 不用选。</p>
<p>[ ]   Debugging，调试模式，不选。</p>
<p>&lt; &gt;  MTD tests support，MTD 测试支持，不清楚可以不选。</p>
<p>&lt; &gt;  MTD concatenating support，连接多个 MTD 设备，例如使用 JFFS2 文件系统管理多片 Flash 的情形。只有一片 Flash 时不选。</p>
<p>[*]  MTD partitioning support，分区支持，选上。</p>
<p>&lt; &gt;     RedBoot partition table parsing，使用 RedBoot 解析 Flash 分区表, 如果需要读取这个分区表的信息选择此项</p>
<p>[*]     Command line partition table parsing，允许通过内核命令行传递 MTD 分区表信息，</p>
<p>&lt; &gt;     ARM Firmware Suite partition parsing，使用 AFS 分区信息</p>
<p>&lt; &gt;     TI AR7 partitioning support，AR7 分区支持</p>
<p>&lt;*&gt;  Direct char device access to MTD devices，将系统中的 MTD 设备看做字符设备进行读写，需要与驱动同步的。</p>
<p>-*-  Common interface to block layer for MTD &rsquo;translation layers&rsquo;</p>
<p>&lt;*&gt;  Caching block device access to MTD devices，文件系统挂载后，模拟块设备进行访问。常用于只读文件系统。如果是 DiskOnChip 使用 NFTL 方式。</p>
<p>&lt;&gt;  FTL (Flash Translation Layer) support，提供对 Flash 翻译层支持，可以不选</p>
<p>&lt;&gt;  NFTL (NAND Flash Translation Layer) support，NAND Flash 翻译层支持，可以不选</p>
<p>&lt;&gt;  INFTL (Inverse NAND Flash Translation Layer) support，提供 INFTL 支持，DiskOnChip 使用</p>
<p>&lt;&gt;  Resident Flash Disk (Flash Translation Layer) support，提供 RFD 支持，为嵌入式系统提供类似 BIOS 功能，不清楚可以不选，使用 Uboot 驱动的话也不用选。</p>
<p>&lt;&gt;  NAND SSFDC (SmartMedia) read only translation layer，NAND SSFDC 只读翻译层，不清楚可以不选。</p>
<p>&lt; &gt;  SmartMedia/xD new translation layer，不清楚可以不选。</p>
<p>&lt; &gt;  Log panic/oops to an MTD buffer，MTD 缓冲日志，不清楚可以不选。</p>
<p>RAM/ROM/Flash chip drivers  &mdash;&gt;，RAM/ROM/Flash 芯片驱动，不清楚可以不选。</p>
<p>Mapping drivers for chip access  &mdash;&gt;，为芯片的访问方式选择 Mapping 驱动，不清楚可以不选。</p>
<p>Self-contained MTD device drivers  &mdash;&gt;，自身包含 MTD 设备驱动，一般不选。</p>
<p>&lt; &gt;  Include chip ids for known NAND devices.，NAND flash 信息，不用选。</p>
<p>&lt;&gt;  NAND Device Support  &mdash;&gt;，Nand 设备支持，有 nand 的话选上，子项默认配置即可，如果支持 Nand，加选这一项就够了。</p>
<p>&lt;&gt;  OneNAND Device Support  &mdash;&gt;，One nand 支持，不清楚可以不选。</p>
<p>LPDDR flash memory drivers  &mdash;&gt;，LPDDR Flash 内存驱动，未用，不用选。</p>
<p>UBI - Unsorted block images  &mdash;&gt; 未分类 block 影响，不清楚不选。</p>
<p>附：配置支持 jffs2 两步</p>
<ol>
<li>在 “memory technology devices(mtd)” 选项中选择:</li>
</ol>
<p>&lt;*&gt;memory technology device(mtd)support</p>
<p>&lt;*&gt;mtd partitioning support</p>
<p>&lt;*&gt;cashing block device access to mtd devices</p>
<p>ram/rom/flash chip drivers&mdash;&gt;</p>
<p>&lt;*&gt; detect flash chips by common flash interface(cfi) probe</p>
<p>&lt;*&gt; support for intel/sharp flash chips</p>
<p>mapping drivers for chip access&mdash;&gt;</p>
<p>&lt;*&gt; cfi flash device in physical memory map</p>
<p>(0)   physical start address of flash mapping</p>
<p>(1000000)physical length of flash mapping</p>
<p>(2)buswidthin octets</p>
<p>&lt;*&gt; intel strataflash device mapped on at91rm9200</p>
<p>这里设置了 flash 芯片的起始地址、大小以及宽度，比如: 起始地址为 “0”，大小为“1000000”，即 16mb，宽度为“2”，即 16 字节。然后选中自己加入的“intel strataflash device mapped on at91rm9200” 这一项</p>
<ol start="2">
<li>在 “file systems” 选项中选择:</li>
</ol>
<p>&lt;*&gt;joumalling flash file system v2(jffs2)support</p>
<p>对于其他功能，可根据自己的实际情况，进行裁减，然后保存退出，接下来编译出操作系统内核映像。(详细见 linux 支持 nor flash.txt 文档)</p>
<p>&lt;&gt; Parallel port support  &mdash;&gt;，配置并口，如打印机，arm linux 可以不用配置</p>
<p>&lt;&gt;   PC-style hardware (NEW)，</p>
<p>&lt;&gt;   AX88796 Parallel Port (NEW)，</p>
<p>[]    IEEE 1284 transfer modes (NEW)，</p>
<p>[*] Block devices  &mdash;&gt;，块设备，一般都不用选，除非有特殊需要</p>
<p>&lt; &gt;   Loopback device support，拿文件来模拟块设备，想要 mount ios 文件的话必须选上，一般不选。</p>
<p>&lt; &gt;   Network block device support，网络块设备支持，让 PC 成为网络块设备的客户端。一般不选</p>
<p>&lt; &gt;   Low Performance USB Block driver，低性能 USB 块设备驱动程序，一般不选。</p>
<p>&lt;*&gt;   RAM block device support，RAM 块设备支持，子选项保持默认就好了。</p>
<p>&lt; &gt;   Packet writing on CD/DVD media，不清楚可以不选。</p>
<p>&lt; &gt;   ATA over Ethernet support，不清楚可以不选。</p>
<p>[*] Misc devices  &mdash;&gt;，混杂设备驱动，一般不选。</p>
<p>&lt;&gt; ATA/ATAPI/MFM/RLL support (DEPRECATED)  &mdash;&gt;，不清楚可以不选。</p>
<p>SCSI device support  &mdash;&gt;，支持 u 盘的话，需要选上。</p>
<p>&lt; &gt; RAID Transport Class，不清楚可以不选。</p>
<p>&lt;*&gt; SCSI device support，支持 u 盘选上，子选项默认配置即可。</p>
<p>&lt;&gt; Serial ATA and Parallel ATA drivers  &mdash;&gt;，SATA 和 PATA 支持，没有硬盘的话可以不选。</p>
<p>[] Multiple devices driver support (RAID and LVM)  &mdash;&gt;，特殊服务器管理用到，如 LVM，一般用户不会用到，不用选，</p>
<p>[*] Network device support  &mdash;&gt;，网络设备支持，必选。包括前兆网卡，PPPOE 等的支持。</p>
<p>[*] HID Devices  &mdash;&gt;，HID 支持，选上</p>
<p>[*] USB support  &mdash;&gt;，USB 支持，选上</p>
<p>&lt;*&gt; MMC/SD/SDIO card support  &mdash;&gt;，SD 卡支持，选上。</p>
<p>……</p>
<p>其他选项根据需求来。在嵌入式 linux 中一般 IIC SPI 等 device 都自己写驱动，不用选。</p>
<ol start="14">
<li>File systems（文件系统）</li>
</ol>
<p>&lt;*&gt; Second extended fs support，EXT2 文件系统支持。</p>
<p>[*]   Ext2 extended attribute，EXT2 文件系统支持。</p>
<p>&lt;*&gt; Ext3 journalling file system support，EXT3 文件系统支持，子项默认就行。</p>
<p>&lt;*&gt; The Extended 4 (ext4) filesystem ，EXT4 文件系统支持，子项默认就行。</p>
<p>……</p>
<p>有 JFS（IBM 所用）文件系统等，省略，用的不多。</p>
<p>……</p>
<p>[*] Enable POSIX file locking API，使能 POSIX 文件锁的 API，最好选上。</p>
<p>[*] Dnotify support，基于目录的文件变化的通知机制，不选 nfsd 起不来，比选的。</p>
<p>[ ] Inotify file change notification support，新式的文件体统的变化通知机制，用以替代老旧的 Dnotify，选了 Dnotify 就不要选它了。</p>
<p>[*] Inotify support for userspace，用户空间的 Inotify 支持，最好选上。（notify 是一个 Linux 特性，它监控文件系统操作，比如读取、写入和创建）。</p>
<p>&lt;*&gt; FUSE (Filesystem in Userspace) support，允许在用户空间实现一个文件系统，如果打算开发一个自己的文件系统或使用一个机遇 FUSE 的文件系统，最好打开。</p>
<p>&lt;*&gt;   Character device in Userpace support，允许在用户空间实现一个字符设备，</p>
<p>-*- Miscellaneous filesystems  &mdash;&gt;，杂项文件系统，子项很复杂，主要配置 jffs2 和 yaffs2 文件系统，一般用于嵌入式设备。</p>
<p>[*] Network File Systems  &mdash;&gt;，网络文件系统，NFS 等。</p>
<p>……</p>
<p>其他没有特殊需求可以不选。</p>
<ol start="15">
<li>Kernel hacking（内核 hack 选项，基本上选 Enable __must_check logic 和 Stacktrace 就可以了，有需要再深入研究）</li>
</ol>
<p>[ ] Show timing information on printks，在 printk 的输出中包含时间信息, 可以用来分析内核启动过程各步骤所用时间，需要时选上。</p>
<p>[ ] Enable __deprecated logic，不清楚不要选。</p>
<p>[*] Enable __must_check logic，在编译内核的过程中使用 &ldquo;必须检查&rdquo; 的逻辑, 禁用它将不会显示某些警告信息，选上。</p>
<p>[ ] Magic SysRq key，不懂，千万别选。</p>
<p>[ ] Strip assembler-generated symbols during link，，不清楚不要选。</p>
<p>[ ] Enable unused/obsolete exported symbols，没用的信息符号，会使内核增大，不选.</p>
<p>[ ] Debug Filesystem，不是内核开发者的别选。</p>
<p>[ ]Run &lsquo;make headers_check&rsquo; when building vmlinux，在编译内核时运行&rsquo;make headers_check&rsquo;命令检查内核头文件, 当你修改了与用户空间相关的内核头文件后建议启用该选项。</p>
<p>[ ] Kernel debugging，不是内核开发者的别选。</p>
<p>[ ] SLUB debugging on by default，不清楚不要选。</p>
<p>[ ] Enable SLUB performance statistics，不清楚不要选。</p>
<p>[*] Stacktrace，支持调用栈，用于出错排查问题。</p>
<p>[ ] Debug memory initialization，调试内存初始化，不选，</p>
<p>[ ] Check for stalled CPUs delaying RCU grace periods ，检查停止 CPU 延缓 RCU 的宽限期，</p>
<p>[ ] Latency measuring infrastructure，不清楚不要选。</p>
<p>[ ] Sysctl checks，不清楚不要选。</p>
<p>[] Tracers  &mdash;&gt;，不清楚不要选。</p>
<p>[ ] Perform an atomic64_t self-test at boot，不清楚不要选。</p>
<p>[] Sample kernel code  &mdash;&gt;  ，不清楚不要选。</p>
<p>[*] Enable stack unwinding support，可以不选（31 没选）。</p>
<p>[*] Verbose user fault messages，可以不选（31 没选）。</p>
<p>[ ] On-chip ETM and ETB，片上 ETM、ETB，不清楚可以不选。</p>
<ol start="16">
<li>Security options（安全选项，一般不需要配置，）</li>
</ol>
<p>[ ]  Enable the /proc/keys file by which keys may be viewed，允许有权限的进程通过 / proc/keys 读取所有的 key，最好不要选。</p>
<p>[ ]  Restrict unprivileged access to the kernel syslog，限制未经授权访问内核日志。</p>
<p>[ ]  Enable different security models，允许内核选择不同的安全模式，如果未选择按默认处理。</p>
<p>[*] Enable the securityfs filesystem，不清楚可以不选（16 没选）。</p>
<p>Default security module (Unix Discretionary Access Controls)  &mdash;&gt;，默认安全模式。</p>
<ol start="17">
<li>
<p>Cryptographic API（支持的加密算法）</p>
</li>
<li>
<p>Library routines（库子程序）</p>
</li>
</ol>
<p>Linux 内核配置选项 （经典学习）-CSDN 博客
本文转自 <a href="https://blog.csdn.net/lh2016rocky/article/details/70882449">https://blog.csdn.net/lh2016rocky/article/details/70882449</a></p>
<p>2.5  Linux 内核配置选项</p>
<p>下面以最新的 Linux 2.6.20 内核为例，介绍比较常用的一些 Linux 内核配置选项，其他选项读者可以参考系统提供的帮助信息。</p>
<p>需要说明的是，在内核配置中，某项选择 Y 表示把该项选择进内核，选择 M 则表示把该项编译成模块，选择 N 则表示 不选择进内核。在 make menuconfig 下，* 表示 Y，M 表示 M，空白表示 N。在 make xconfig 下，√表示 Y，· 表示 M，空白表示 N。如果某选项在配置菜单中是可选择的，这并不意味着目标系统就支持该功能，当然大部分供选择的选项是目 标系统文持的；同样，配置菜单中没有的选项并不一定就表示目标系统不支持该功能，原因可能是该功能还未在目标系统上测试过，或者是维护人员未将该功能选项 加入到各级系统配置文件的 config.in 中，具体可以查看内核的英文说明。</p>
<p>2.5.1  General setup</p>
<p>General setup 选项为常规安装选项，包括版本信息、虚拟内存、进程间通信、系统调用、审计支持等基本内核配置选项。下面介绍常规安装选项下主要子选项的配置方法。</p>
<p>3）Support for paging of anonymous memory（swap）</p>
<p>使用交换分区或者交换文件来作为虚拟内存，也就是让计算机好像拥有比实际内存更多的内存空间用来执行很大的程序。Linux 中的虚拟内存即 SWAP 分区，除非不需要 SWAP 分区，否则这里选择 Y。</p>
<p>8）UTS Namespaces</p>
<p>UTS（通用终端系统）命名空间支持。它允许容器，比如 Vservers 利用 UTS 命名空间来为不同的服务器提供不同的 UTS。如果不清楚，则选择 N。</p>
<p>10）Kernel.config support</p>
<p>把内核的配置信息编译进内核中，以后可以通过 scripts/extract-ikconfig 脚本来提取这些信息。</p>
<p>这个选项允许. config 文件（即编译 Linux 时的配置文件）编译进内核中。可以通过内核镜像文件 kernel image file，用命令 script scripts/extract-ikconfig 来提取这些配置信息，作为当前内核重编译或者另一个内核编译的参考。如果内核在运行中，可以通过 / proc/config.gz 文件来读取。</p>
<p>其中 Enable access to .config through/proc/config.gz 子选项表示可以通过 / proc/config.gz 访问当前内核的. config。这两个选项，要选择 Y 就都选择，以便调用其他内核。</p>
<p>11）Cpuset support</p>
<p>多 CPU 支持。这个选项可以建立和管理 CPU 集群，它可以动态地将系统分割在各个 CPU 和内存节点中，在各个 节点是独立运行的，这对大型的系统尤其有效。一般只有在含有大量 CPU（大于 16 个）的 SMP 系统或 NUMA（非一致内存访问）系统才需要它。如果不清 楚，则选择 N。</p>
<p>12）Kernel-&gt;user space relay support（formerly relayfs）</p>
<p>内核系统区和用户区进行传递通信的支持。在某些文件系统上（比如 debugfs）提供从内核空间向用户空间传递大量数据的接口。</p>
<p>这个选项在特定的文件系统中提供数据传递接口支持，它可以提供从内核空间到用户空间的大批量的数据传递工具和设施。如果不清楚，则选择 N。</p>
<p>13）Initramfs source file(s)</p>
<p>initrd 已经被 initramfs 取代，选 N 即可。</p>
<p>14）Optimize for size（Look out for broken compilers!）</p>
<p>这个选项将在 GCC 命令后用 “-Os” 代替 “-O2” 参数，编译时优化内核尺寸，以在编译时优化内核尺寸。</p>
<p>警告：某些 GCC 版本会产生错误的二进制代码。如果有错，请升级 GCC。</p>
<p>这是优化内核大小的功能，一般没必要选。因为一个编译好的内核只有 7～10MB，如果空间足够就不要冒出问题的风险来优化内核大小。</p>
<p>15）Configure standard kernel features（for small systems）</p>
<p>配置标准的内核特性（为小型系统）。这个选项可以让内核的基本选项和设置无效或者扭曲。这是用于特定环境中的，它允许 “非标准” 内核。它是为了编译某些特殊用途的内核使用的，例如引导盘系统。通常选这一选项，也不必关心其子选项。</p>
<p>2.5.2  Loadable module support</p>
<p>Loadable module support 即引导模块支持，该选项包括加载模块、卸载模块、模块校验、自动加载模块等引导模块配置相关子选项。本节主要介绍引导模块支持子选项的配置方法。</p>
<p>1）Enable loadable module support</p>
<p>打开可加载模块支持，如果打开它则必须通过 make modules_install 把内核模块安装在 / lib/modules / 中。模块是一小段代码，编译后可在系统内核运行时动态地加入内核，从而为内核 增加一些特性或是对某种硬件进行支持。一般一些不常用到的驱动或特性可以编译为模块以减少内核的体积。在运行时可以使用 modprobe 命令来加载它到内 核中去（在不需要时还可以移除它）。一些特性是否编译为模块的原则有不常使用的，或是在系统启动时不需要的驱动可以将其编译为模块，如果是一些在系统启动 时就要用到的驱动，比如说文件系统，系统总线的支持就不要编为模块，否则无法启动系统。在启动时不用到的功能编成模块是最有效的方式。可以查看 MAN 手册 来了解 modprobe、lsmod、modinfo、insmod 和 rmmod。</p>
<p>如果选择了这项，则需要运行 make modules_install 命令来把模块添加到 / lib/modules / 目录下，以便 modprobe 可以找到它们。如果不清楚，则选择 Y。</p>
<p>2）Module unloading</p>
<p>允许卸载已经加载的模块。如果选择 N，将不能卸载任何模块（有些模块一旦加载就不能卸载，不管是否选择了这个选项）。如果不清楚，则选择 Y。</p>
<p>其中，Forced module unloading 子选项允许强制卸载正在使用中的模块，即使内核认为这不安全，内核也将会立即移除模块，而不管是否有人在使用它（用 rmmod -f 命令）。如果不清楚，则选择 N。</p>
<p>3）Module versioning support（MODVERSIONS）</p>
<p>允许使用其他内核版本的模块。选这项会添加一些版本信息，来给编译的模块提供独立的特性，以使不同的内核在使用同一模块时区别于它原有的模块。如果不清楚，则选择 N。</p>
<p>4）Source checksum for all modules</p>
<p>为所有的模块校验源码，如果不是自己编写内核模块就不需要它。这个功能是为了防止在编译模块时不小心更改了内核模块的源代码但忘记更改版本号而造成版本冲突。如果不清楚，则选择 N。</p>
<p>5）Automatic kernel module loading</p>
<p>允许内核通过运行 modprobe 自动加载模块，比如可以自动解决模块的依赖关系。在一般情况下，如果我们的 内核在某些任务中要使用一些被编译为模块的驱动或特性时，我们要先使用 modprobe 命令来加载它，内核才能使用。如果选择了这个选项，在内核需要一些 模块时它可以自动调用 modprobe 命令来加载需要的模块。如果不清楚，则选择 Y。</p>
<p>2.5.3  Processor type and features</p>
<p>Processor type and features 即处理器类型及特性，该模块包括处理器系列、内核抢占模式、抢占式大内核锁、内存模式、使用寄存器参数等处理器配置相关信息。本节介绍其中与嵌入式开发有关的主要子选项的配置方法。</p>
<p>1）Symmetric multi-processing support（SMP）</p>
<p>对称多处理器支持。将支持多个 CPU 的系统，此时 Enhanced Real Time Clock Support 选项必须开启，Advanced Power Management 选项必须选择 N。如果系统只有一个 CPU，则选择 N。反之，选择 Y。如果选择 N，内核将会在单个或者多个 CPU 的机器上运行，但是只 会使用一个 CPU。如果选择 Y，内核可以在很多（但不是所有）单 CPU 的机器上运行，在这样的机器上选择 N，会使内核运行得更快。如果不清楚，则选择 N。</p>
<p>2）Processor family</p>
<p>处理器系列。针对嵌入式系统所使用的处理器类型，选取相应的选项。</p>
<p>3）Preemptible kernel</p>
<p>内核抢占模式。一些优先级很高的程序可以先让一些低优先级的程序执行，即使这些程序是在内核态下执行。从而减 少内核潜伏期，提高系统的响应。当然在一些特殊的点的内核是不可抢占的，比如内核中的调度程序自身在执行时就是不可被抢占的。这个特性可以提高桌面系统、 实时系统的性能。有下面 3 个选项。</p>
<p>n        No Forced Preemption（Server）：非强迫式抢占。这是传统的 Linux 抢占式模型，针对于高吞吐量设计。它同样在很多时候会提供很好的响应，但是也 可能会有较长的延迟。如果是要建立服务器或者用于科学运算，或者要最大化内核的运算能力而不理会调度上的延迟，则选这项。</p>
<p>n        Voluntary Kernel Preemption（Desktop）：自动式内核抢占。这个选项通过向内核添加更多的 “清晰抢占点” 来减少内核延迟。这些新的抢占点以降低吞吐量为代 价，来降低内核的最大延迟，提供更快的应用程序响应。这通过允许低优先级的进程自动抢占来响应事件，即使进程在内核中进行系统调用。这使得应用程序运行得 更“流畅”，即使系统已经是高负荷运转。嵌入式系统里面通常选择 N。</p>
<p>n        Preemptible Kernel（Low-Latency Desktop）：可抢占式内核（低延迟桌面）。这个选项通过使所有内核代码（非致命部分）编译为 “可抢占” 来降低内核延迟。通过允许低优先级进程进行强 制抢占来响应事件，即使这些进程正在进行系统调用或者未达到正常的“抢占点”。这使得应用程序运行得更加“流畅”，即使系统已经是高负荷运转。代价是吞吐 量降低，内核运行开销增大。嵌入式系统编译内核通常选择 Y，这样只有很少的延迟。</p>
<p>其中，Preemptible Kernel 子选项提供了最快的响应，适合对实时性要求较高的嵌入式系统。</p>
<p>4）Preempt The Big Kernel Lock</p>
<p>抢占式大内核锁。应用于实时要求高的场合，适合嵌入式系统。这个选项通过让大内核锁变成 “可抢占” 来降低延迟。构建实时性要求较高的嵌入式系统，通常选择 N。</p>
<p>5）Machine Check Exception</p>
<p>机器例外检查。让 CPU 检测到系统故障时通知内核，以便内核采取相应的措施（如过热关机等）。内核根据问题的 严重程度来决定下一步的行为，比如在命令行上打印警告信息或者关机。处理器必须是 Pentium 或者更新版本才能支持这个功能。用 cat /proc/cpuinfo 来检测 CPU 是否有 mce 标志。</p>
<p>所以使用 ARM 处理器的嵌入式系统在这里选择 N。</p>
<p>6）Memory model</p>
<p>内存模式。一般选 Flat Memory（平坦内存模式），Sparse Memory（稀疏内存模式）选项涉及内存热插拔。</p>
<p>7）Use register arguments（REGPARM）</p>
<p>使用寄存器参数。使用 - mregparm=3 参数编译内核，将前 3 个参数以寄存器方式进行参数调用，这使 GCC 使用更高效的应用程序二进制接口（ABI）来跳过编译时的前 3 个调用寄存器参数，可以生成更紧凑和高效的代码。如果选择 N，这个选项默认的 ABI 将 会使用。如果不清楚，则选择 Y。</p>
<p>8）kexec system call（KEXEC）</p>
<p>kexec 系统调用。使用此选项可以不必重启而切换到另一个内核。</p>
<p>kexec 是一个用来选择 N 当前内核，然后开启另一个内核的系统调用。它和重启很像，但是它不访问系统固件。 由于和重启很像，可以启动任何内核，不仅仅是 Linux。kexec 这个名字是从 exec 系统调用来的，它只是一个进程，可以确定硬件是否正确，所以这段 代码可能不会正确地进行初始化工作。为慎重起见，在一般情况下，建议选择 N。</p>
<p>2.5.4  Networking support</p>
<p>Networking support 即网络支持，该选项配置的是网络协议，内容庞杂，这里就不一一介绍了。只要对网络协议有所了解，应该可以看懂相关帮助文件。如果要开发嵌入 式系统能像 PC 一样使用各类网络协议，则可以使用默认选项，其中，最常用的 TCP/IP networking 选项当然要选择。</p>
<p>2.5.5  Device Drivers</p>
<p>Device Drivers 即设备驱动，该选项包括内核所支持的各类硬件设备的配置信息。对于嵌入式系统来说，设备驱动配置选项是最重要的步骤之一，下面详细介绍它们。</p>
<p>1）Generic Driver Options</p>
<p>驱动程序通用选项。包括以下几个子选项。</p>
<p>n        Select only drivers that don&rsquo;t need compile-time external firmware：只显示不需要内核对外部设备的固件做 map 支持的驱动程序，除非有某些怪异硬件，否则要选择 Y。</p>
<p>n        Prevent firmware from being built：不编译固件。固件一般是随硬件的驱动程序提供的，仅在更新固件的时候才需要重新编译。建议选择 Y。</p>
<p>n        Userspace firmware loading support：提供某些内核之外的模块需要的用户空间固件加载支持，在内核树之外编译的模块可能需要它。如果不清楚，则选择 N。</p>
<p>n        Driver Core verbose debug messages：让驱动程序内核在系统日志中产生冗长的调试信息，仅供调试使用。如果不清楚，则选择 N。</p>
<p>2）Connector - unified userspace &lt;-&gt; kernelspace linker</p>
<p>统一的用户空间和内核空间连接器，工作在 netlink socket 协议的顶层。如果不确定，则选择 N。</p>
<p>其中，Report process events to userspace 子选项表示向用户空间报告进程事件。</p>
<p>3）Memory Technology Devices（MTD）</p>
<p>特殊的存储技术装置，如常用于数码相机或嵌入式系统的闪存卡。如果不清楚，则选择 N。</p>
<p>4）Parallel port support</p>
<p>并口支持（传统的打印机接口）。如果不清楚，则选择 N。</p>
<p>5）Plug and Play support</p>
<p>支持即插即用，若未选，则应当在 BIOS 中的 “PnP OS” 选择 N。这里的选项与 PCI 设备无关。包括以下几个子选项。</p>
<p>n        PnP Debug Messages：该选项仅供调试使用。</p>
<p>n        ISA Plug and Play support：ISA 设备支持即插即用。如果不清楚，则选择 N。</p>
<p>n        Plug and Play BIOS support：Linux 使用 Plug and Play BIOS 规范 v1.0A（1994 年）中定义的 PnPBIOS 自动检测主板上的资源和设备，但是其中的某些特性目前尚未实现，比如，事件通知 / 扩展坞 （Docking Station）信息 / ISAPnP 服务。如果希望由内核检测主板上的设备并为其分配资源（此时 BIOS 中的 “PnP OS” 必须开启）可以选择 Y。此外，PnPBIOS 还有助于防止主板上的设备与其他总线设备冲突。不过需要注意的是 ACPI 将会逐渐取代 PnPBIOS（虽然目前两者可以共存），所以如果系统不使用 ISA 设备并且支持 ACPI，建议不要选择 Y。将 BIOS 中的 “PnP OS” 选择 N。</p>
<p>n        Plug and Play BIOS/proc interface：该选项仅供调试使用。如果不清楚，则选择 N。</p>
<p>n        Plug and Play ACPI support：让 Linux 使用 PnPACPI 自动检测主板上内建的设备并为其分配资源（即使这些设备已被 BIOS 禁用），它有助于避免设备之间的资源（如中断）冲突。如果不清楚，则选择 N。</p>
<p>6）Block devices</p>
<p>块设备。包括以下几个子选项。</p>
<p>n        ormal floppy disk support：通用软驱支持。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        XT hard disk support：一种老式产品。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Parallel port IDE device support：通过并口与计算机连接的 IDE 设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Compaq SMART2 support：基于 Compaq SMART2 控制器的磁盘阵列卡。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Compaq Smart Array 5xxx support：基于 Compaq SMART 控制器的磁盘阵列卡。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Mylex DAC960/DAC1100 PCI RAID Controller support：一种老式产品。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Micro Memory MM5415 Battery Backed RAM support：一种使用电池做后备电源的内存。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Loopback device support：Loopback 是指拿文件来模拟块设备，比如可以将一个 iso9660 镜像文件挂成一个文件系统。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Cryptoloop Support：使用系统提供的加密 API 对 Loopback 设备加密，但不能用于日志型文件系统。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Network block device support：让系统成为网络块设备的客户端。如果不清楚，则选择 N。</p>
<p>n        Promise SATA SX8 support：基于 Promise 公司的 SATA SX8 控制器的 RAID 卡。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Low Performance USB Block driver：该选项并非表示支持优盘。一般情况下，建议选择 N。</p>
<p>n        RAM disk support：内存中的虚拟磁盘，大小固定（由下面的选项决定，也可给内核传递 ramdisk_size＝参数来决定），它的功能和代码都比 shmem 简单许多。如果嵌入式系统采用 RAM disk，则选择 Y。</p>
<p>n        Default number of RAM disks：默认 RAM disk 的数量。一般不必修改。</p>
<p>n        Default RAM disk size（kbytes）：默认 RAM disk 容量。一般不必修改。</p>
<p>n        Default RAM disk block size（bytes）：每一个 RAM disk 的默认块大小，设为 PAGE_SIZE 的值时效率最高。</p>
<p>n        Initial RAM filesystem and RAM disk（initramfs/initrd）support：如果启动系统所必须的模块都在内核里，则选择 Y。</p>
<p>n        Packet writing on CD/DVD media：CD/DVD 刻录支持。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Free buffers for data gathering：用于收集写入数据的缓冲区个数（每个占用 64KB 内存），在内存运行的情况下，缓冲区越多性能越好。</p>
<p>n        Enable write caching：为 CD－R/W 设备启用写入缓冲。由于安全性问题，在一般情况下，建议选择 Y。</p>
<p>n        ATA over Ethernet support：以太网 ATA 设备支持。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>7）Misc devices</p>
<p>杂项设备。如果不清楚，则选择 N。</p>
<p>8）ATA/ATAPI/MFM/RLL support</p>
<p>SCSI 设备通常是 IDE 硬盘和 ATAPI 光驱。纯 SCSI 系统且不使用这些接口可以选择 N。</p>
<p>9）SCSI device support</p>
<p>SCSI 设备。如果不清楚，则选择 N。</p>
<p>10）Serial ATA and Parallel ATA drivers</p>
<p>SATA 与 PATA 设备。如果不清楚，则选择 N。</p>
<p>11）Old CD-ROM drivers（not SCSI，not IDE）</p>
<p>老旧的 CD-ROM 驱动，这种 CD-ROM 既不使用 SCSI 接口，也不使用 IDE 接口。如果不清楚，则选择 N。</p>
<p>12）Multi-device support（RAID and LVM）</p>
<p>多设备支持（RAID 和 LVM）。RAID 和 LVM 的功能是使多个物理设备组建成一个单独的逻辑磁盘。如果不清楚，则选择 N。</p>
<p>13）Fusion MPT device support</p>
<p>Fusion MPT 设备支持。如果不清楚，则选择 N。</p>
<p>14）IEEE 1394（FireWire）support</p>
<p>IEEE 1394（火线）。如果不清楚，则选择 N。</p>
<p>15）I2O device support</p>
<p>I2O（智能 I/O）设备使用专门的 I/O 处理器负责中断处理、缓冲存取、数据传输等烦琐任务以减少 CPU 占用，一般 PC 的主板上没有。如果不清楚，则选择 N。</p>
<p>16）Network device support</p>
<p>网络设备。包含以下子选项。</p>
<p>n        Network device support：网络设备支持，如果要开发的嵌入式系统需要上网，则选择 Y。</p>
<p>n        Intermediate Functional Block support：这是一个中间层驱动，可以用来灵活的配置资源共享。如果不清楚，则选择 N。</p>
<p>n        Dummy net driver support：哑接口网络，使用 SLIP 或 PPP 传输协议（如 ADSL 用户）的需要它。如果不清楚，则选择 N。</p>
<p>n        Bonding driver support：将多个以太网通道绑定为一个，也就是两块网卡具有相同的 IP 地址并且聚合成一个逻辑链路工作，可以用来实现负载均衡或硬件冗余。如果不清楚，则选择 N。</p>
<p>n        EQL（serial line load balancing）support：串行线路的负载均衡。如果有两个 MODEM 和两条电话线而且用 SLIP 或 PPP 协议，该选项可以让你同时使用这两个 MODEM 以达到双倍速度（在网络的另一端也要有同样的设备）。如果不清楚，则选择 N。</p>
<p>n        Universal TUN/TAP device driver support：TUN/TAP 可以为用户空间提供包的接收和发送服务，比如可以用来虚拟一张网卡或点对点通道。如果不清楚，则选择 N。</p>
<p>n        General Instruments Surfboard 1000：Surfboard 1000 插卡式 Cable Medem（ISA 接口），一种老式产品。如果不清楚，则选择 N。</p>
<p>n        ARCnet devices：一般人没有 ARCnet 类型的网卡。如果不清楚，则选择 N。</p>
<p>n        PHY device support：数据链路层芯片简称为 MAC 控制器，物理层芯片简称为 PHY，通常的网卡把 MAC 和 PHY 的功能做到了一颗芯片中，但也有一些仅含 PHY 的 “软网卡”。如果不清楚，则选择 N。</p>
<p>n        Ethernet（10/100Mbit）：目前最广泛的 10/100MB 网卡。如果不清楚，则选择 N。</p>
<p>n        Ethernet（1000 Mbit）：目前已成装机主流的 1000MB 网卡。如果不清楚，则选择 N。</p>
<p>n        Ethernet（10000 Mbit）：高速（万兆）网卡。如果不清楚，则选择 N。</p>
<p>n        Token Ring devices：令牌环网设备。如果不清楚，则选择 N。</p>
<p>n        Wireless LAN（non-hamradio）：无线 LAN。如果不清楚，则选择 N。</p>
<p>n        PCMCIA network device support：PCMCIA 或 CardBus 网卡。如果不清楚，则选择 N。</p>
<p>n        WAN interfaces：WAN 接口。如果不清楚，则选择 N。</p>
<p>n        ATM drivers：异步传输模式。如果不清楚，则选择 N。</p>
<p>n        FDDI driver support：光纤分布式数据接口。如果不清楚，则选择 N。</p>
<p>n        HIPPI driver support：HIPPI（高性能并行接口）是一个在短距离内高速传送大量数据的点对点协议。如果不清楚，则选择 N。</p>
<p>n        PLIP（parallel port）support：将并口映射成网络设备，这样两台机器即使没有网卡也可以使用并口通过并行线传输 IP 数据包。如果不清楚，则选择 N。</p>
<p>n        PPP（point-to-point protocol）support：点对点协议，PPP 已经基本取代 SLIP 了，若使用 ADSL 则要选择 Y。如果不清楚，则选择 N。</p>
<p>n        PPP multilink support：多重链路协议（RFC1990）允许将多个线路（物理的或逻辑的）组合为一个 PPP 连接以充分利用带宽，这不但需要 pppd 的支持，还需要 ISP 的支持。如果不清楚，则选择 N。</p>
<p>n        PPP filtering：允许对通过 PPP 接口的包进行过滤。如果不清楚，则选择 N。</p>
<p>n        PPP support for async serial ports：通过标准异步串口（COM1，COM2）使用 PPP，比如使用老式的外置 MODEM（非同步 MODEM 或 ISDN MODEM）上网。如果不清楚，则选择 N。</p>
<p>n        PPP support for sync tty ports：通过同步 tty 设备（比如 SyncLink 适配器）使用 PPP，常用于高速租用线路（比如 T1/E1）。如果不清楚，则选择 N。</p>
<p>n        PPP Deflate compression：为 PPP 提供 Deflate（等价于 gzip 压缩算法）压缩算法支持，需要通信双方的支持才有效。如果不清楚，则选择 N。</p>
<p>n        PPP BSD-Compress compression：为 PPP 提供 BSD（等价于 LZW 压缩算法，没有 gzip 高效）压缩算法支持，需要通信双方的支持才有效。如果不清楚，则选择 N。</p>
<p>n        PPP MPPE compression（encryption）：为 PPP 提供 MPPE 加密协议支持，它被用于微软的 P2P 隧道协议中。如果不清楚，则选择 N。</p>
<p>n        PPP over Ethernet：这就是 ADSL 用户最常见的 PPPoE，也就是在以太网上运行的 PPP 协议。如果不清楚，则选择 N。</p>
<p>n        PPP over ATM：在 ATM 上运行的 PPP。如果不清楚，则选择 N。</p>
<p>n        SLIP（serial line）support：一个在串行线上（例如电话线）传输 IP 数据报的 TCP/IP 协议。小猫一族的通信协议，与宽带用户无关。如果不清楚，则选择 N。</p>
<p>n        CSLIP compressed headers：CSLIP 协议比 SLIP 快，它将 TCP/IP 头（而非数据）进行压缩传送，需要通信双方的支持才有效。如果不清楚，则选择 N。</p>
<p>n        Keepalive and linefill：让 SLIP 驱动支持 RELCOM linefill 和 keepalive 监视，这在信号质量比较差的模拟线路上是个好主意。如果不清楚，则选择 N。</p>
<p>n        Six bit SLIP encapsulation：这种线路非常罕见，在一般情况下，建议选择 N。</p>
<p>n        Fibre Channel driver support：光纤通道。如果不清楚，则选择 N。</p>
<p>n        Traffic Shaper：流量整形，已废弃。在一般情况下，建议选择 N。</p>
<p>n        Network console logging support：通过网络记录内核信息。如果不清楚，则选择 N。</p>
<p>n        Netpoll support for trapping incoming packets：在一般情况下，建议选择 N。</p>
<p>n        Netpoll traffic trapping：在一般情况下，建议选择 N。</p>
<p>17）ISDN subsystem</p>
<p>综合业务数字网（Integrated Service Digital Network）。如果不清楚，则选择 N。</p>
<p>18）Telephony Support</p>
<p>VoIP 支持。如果不清楚，则选择 N。</p>
<p>19）Input device support</p>
<p>输入设备。包括以下子选项。</p>
<p>n        Generic input layer（needed for keyboard，mouse）：通用输入层，如果是使用键盘鼠标的，则选择 Y。如果不清楚，则选择 N。</p>
<p>n        Support for memoryless force-feedback devices：游戏玩家使用的力反馈设备。如果不清楚，则选择 N。</p>
<p>n        Mouse interface：鼠标接口。如果不清楚，则选择 N。</p>
<p>n        Provide legacy/dev/psaux device：仍然支持作为传统的 / dev/psaux 设备。如果不清楚，则选择 N。</p>
<p>n        Horizontal screen resolution：数字化转换器或图形输入板的水平分辨率。如果不清楚，则选择 N。</p>
<p>n        Vertical screen resolution：数字化转换器或图形输入板的垂直分辨率。如果不清楚，则选择 N。</p>
<p>n        Joystick interface：游戏杆。如果不使用，则选择 N。</p>
<p>n        Touchscreen interface：触摸屏。如果不使用，则选择 N。</p>
<p>n        Event interface：能够利用 / dev/input/eventX 来存取输入设备的事件。如果不清楚，则选择 N。</p>
<p>n        Event debugging：该选项仅供调试使用。如果不清楚，则选择 N。</p>
<p>n        Keyboards：键盘驱动，一般选个 AT 键盘即可。如果不清楚，则选择 N。</p>
<p>n        Mouse：鼠标驱动，一般选个 PS/2 鼠标即可。如果不清楚，则选择 N。</p>
<p>n        Joysticks：游戏杆驱动。如果不使用，则选择 N。</p>
<p>n        Touchscreens：触摸屏驱动。如果不使用，则选择 N。</p>
<p>n        Miscellaneous devices：其他杂项驱动，一般选个 PC 喇叭即可。如果不清楚，则选择 N。</p>
<p>n        Hardware I/O ports：硬件 I/O 端口。如果不清楚，则选择 N。</p>
<p>n        Serial I/O support：使用 PS/2 键盘或鼠标，则选择 Y。如果不使用，则选择 N。</p>
<p>n        i8042 PC Keyboard controller：PS/2 接口的键盘和鼠标。如果不使用，则选择 N。</p>
<p>n        Serial port line discipline：串口键盘或鼠标。如果不使用，则选择 N。</p>
<p>n        ct82c710 Aux port controller：一种德州仪器 TravelMate 笔记本上使用 QuickPort 接口的鼠标。如果不使用，则选择 N。</p>
<p>n        Parallel port keyboard adapter：并口键盘或鼠标。如果不使用，则选择 N。</p>
<p>n        PCI PS/2 keyboard and PS/2 mouse controller：接在移动式扩展坞（Docking station）上的键盘或鼠标。如果不使用，则选择 N。</p>
<p>n        PS/2 driver library：为 PS/2 接口上的设备提供驱动（比如 PS/2 鼠标或标准 AT 键盘）。如果不使用，则选择 N。</p>
<p>n        Raw access to serio ports：在一般情况下，建议选择 N。</p>
<p>n        Gameport support：类似早年 “小霸王” 游戏机上的那种手柄。如果不使用，则选择 N。</p>
<p>20）Character devices</p>
<p>字符设备。包含以下子选项。</p>
<p>n        Virtual terminal：虚拟终端。嵌入式系统在一般情况下，建议选择 N。</p>
<p>n        Support for console on virtual terminal：内核将一个虚拟终端用做系统控制台（将诸如模块错误、内核错误、启动信息之类的警告信息发送到这里，通常是第一个虚拟终端）。嵌入式系统在一般情况下，建议选择 N。</p>
<p>n        Support for binding and unbinding console drivers：虚拟终端是通过控制台驱动程序与物理终端相结合的，但在某些系统上可以使用多个控制台驱动程序（如 framebuffer 控制台驱动程序），该选项使得可以选择其中之一。如果不清楚，则选择 N。</p>
<p>n        Non-standard serial port support：非标准串口支持。这样的设备已废弃不用。在一般情况下，建议选择 N。</p>
<p>n        Serial drivers：串口驱动。如果有老式的串口鼠标或小猫，则选择 Y。否则选择 N。</p>
<p>n        Unix98 PTY support：伪终端（PTY）可以模拟一个终端，它由 slave（等价于一个物理终端）和 master（被一个诸如 xterms 之类的进程用来读写 slave 设备）两部分组成的软设备。如果使用 telnet 或 ssh 远程登录者，则选择 Y。如果不清楚，则选择 N。</p>
<p>n        Legacy（BSD）PTY support：使用过时的 BSD 风格的 / dev/ptyxx 作为 master，/dev/ttyxx 作为 slave。这个方案有一些安全问题，建议选择 N。</p>
<p>n        Parallel printer support：并口打印机。如果不使用，则选择 N。</p>
<p>n        Support for console on line printer：允许将内核信息输出到并口，这样就可以打印出来。如果不清楚，则选择 N。</p>
<p>n        Support for user-space parallel port device drivers：/dev/parport 设备支持，比如 deviceid 之类的程序需要使用它。在一般情况下，建议选择 N。</p>
<p>n        Texas Instruments parallel link cable support：德州仪器生产的一种使用并行电缆的图形计算器。如果不清楚，则选择 N。</p>
<p>n        IPMI：可以利用 IPMI 远程监视服务器的物理特征（温度、电压、风扇、电源、机箱入侵），它是独立于 CPU、BIOS、OS 的，只要接通电源就可以实现对服务器的监控。如果不清楚，则选择 N。</p>
<p>n        IPMI top-level message handler：IPMI 消息处理器，要启用 IPMI 远程监视，则选择 Y。如果不清楚，则选择 N。</p>
<p>n        Generate a panic event to all BMCs on a panic：当发生紧急情况（panic）时，IPMI 消息处理器将会向每一个已注册的底板管理控制器（BMC）接口生成一个描述该 panic 的 IPMI 事件，这些事件可以引发日志记录、报警、重启、关机等动作。如果不清楚，则选择 N。</p>
<p>n        Generate OEM events containing the panic string：当发生紧急情况（panic）时，IPMI 消息处理器将会产生 OEM 类型的事件。如果不清楚，则选择 N。</p>
<p>n        Device interface for IPMI：为 IPMI 消息处理器提供一个 IOCTL 接口，以便用户空间的进程也可以使用 IPMI。如果不清楚，则选择 N。</p>
<p>n        IPMI System Interface handler：向系统提供接口（KCS、SMIC），一般用了 IPMI 就需要选择 Y。如果不清楚，则选择 N。</p>
<p>n        IPMI WatchDog Timer：启用 IPMI WatchDog 定时器。如果不清楚，则选择 N。</p>
<p>n        IPMI Poweroff：允许 IPMI 消息处理器选择 N。如果不清楚，则选择 N。</p>
<p>n        WatchDog Cards：能让系统在出现致命故障后自动重启，如果没有硬件 WatchDog，建议使用 Hangcheck timer 而不是软件 WatchDog。如果不清楚，则选择 N。</p>
<p>n        Watchdog Timer Support：选择 Y。下面的一个 Driver 之后，再创建一个 / dev/ watchDog 节点即可拥有一只 WatchDog 了。更多信息请参考内核帮助。如果不清楚，则选择 N。</p>
<p>n        Disable watchDog shutdown on close：一旦 WatchDog 启动后就禁止将其停止。如果不清楚，则选择 N。</p>
<p>n        Software watchDog：软件 WatchDog，使用它不需要有任何硬件的支持，但是可靠性没有硬件 WatchDog 高。如果不清楚，则选择 N。</p>
<p>n        Hardware Random Number Generator Core support：硬件随机数发生器内核支持。如果不清楚，则选择 N。</p>
<p>n        Intel HW Random Number Generator support：Intel 芯片组的硬件随机数发生器。如果不清楚，则选择 N。</p>
<p>n        AMD HW Random Number Generator support：AMD 芯片组的硬件随机数发生器。如果不清楚，则选择 N。</p>
<p>n        AMD Geode HW Random Number Generator support：AMD Geode LX 的硬件随机数发生器。如果不清楚，则选择 N。</p>
<p>n        VIA HW Random Number Generator support：VIA 芯片组的硬件随机数发生器。如果不清楚，则选择 N。</p>
<p>n        /dev/nvram support：直接存取主板上 CMOS 的接口。可能发生安全性问题，建议选择 N。</p>
<p>n        Enhanced Real Time Clock Support：启用该选项并创建 / dev/RTC 文件后就可以通过 / proc/driver/RTC 访问系统的硬件时钟（RTC），众多功能依赖于它（如 SMP、IRQ 共享、定时器）。在一般情况下，建议选择 Y。</p>
<p>n        Double Talk PC internal speech card support：由 RC Systems 公司制造的一种语音合成器。如果不清楚，则选择 N。</p>
<p>n        Siemens R3964 line discipline：与使用西门子 R3964 协议的设备同步通信。除非有一些诸如 PLC 之类的特殊设备，否则在一般情况下，建议选择 N。</p>
<p>n        Applicom intelligent fieldbus card support：Applicom international 公司生产的用于现场总线连接卡。如果不清楚，则选择 N。</p>
<p>n        Sony Vaio Programmable I/O Control Device support：Sony VAIO 笔记本上的设备。如果不清楚，则选择 N。</p>
<p>n        Ftape，the floppy tape device driver：针对使用磁带的系统。如果不清楚，则选择 N。</p>
<p>n        /dev/agpgart（AGP Support）：AGP 总线支持，有 AGP 显卡的还必须从子项中选取符合嵌入式系统所使用显卡型号的驱动。如果不清楚，则选择 N。</p>
<p>n        Direct Rendering Manager：DRI 允许应用程序以高效安全的方式直接访问图形处理，主要用于硬件 3D 加速。建议桌面用户选择此方式，同时还必须从子项中选取符合嵌入式系统所使用显卡型号的驱动。如果不清楚，则选择 N。</p>
<p>n        PCMCIA character devices：使用 PCMCIA 接口的字符设备。如果不清楚，则选择 N。</p>
<p>n        ACP Modem（Mwave）support：IBM Thinkpad 上的一种软猫，一种老式产品。如果不清楚，则选择 N。</p>
<p>n        NatSemi SCx200 GPIO Support：松下的一种通用输入、输出（GPIO）芯片。嵌入式系统一般选择 Y。</p>
<p>n        NatSemi PC8736x GPIO Support：松下的一种通用输入、输出（GPIO）芯片。嵌入式系统一般选择 Y。</p>
<p>n        NatSemi Base GPIO Support：松下的一种通用输入、输出（GPIO）芯片。嵌入式系统一般选择 Y。</p>
<p>n        AMD CS5535/CS5536 GPIO：常用于 AMD Geode 的一种通用输入、输出（GPIO）芯片。嵌入式系统一般选择 Y。</p>
<p>n        RAW driver（/dev/raw/rawN）：一种老式设备，已废弃。在一般情况下，建议选择 N。</p>
<p>n        HPET－High Precision Event Timer：高精度事件定时器。如果不清楚，则选择 N。</p>
<p>n        Allow mmap of HPET：允许对 HPET 寄存器进行映射。在一般情况下，建议选择 Y。</p>
<p>n        Hangcheck timer：宕机检测定时器周期性地检查系统任务调度程序，以确定系统的运行状况，如果超过阈值，计算机将重新启动。它通常可以比 WatchDog 更好地解决可用性和可靠性问题。如果不清楚，则选择 N。</p>
<p>n        TPM devices：基于硬件的 “可信赖平台模块”。在一般情况下，建议选择 N。</p>
<p>n        Telecom clock driver for MPBL0010 ATCA SBC：在一般情况下，建议选择 N。</p>
<p>21）I2C support</p>
<p>I2C 是 Philips 极力推动的微控制应用中使用的低速串行总线协议，可用于监控电压、风扇转速、温度等。SMBus（系统管理总线）是 I2C 的子集。除硬件传感器外，Video For Linux 也需要该模块的支持。包含以下子选项。</p>
<p>n        I2C device interface：I2C 设备接口，允许用户空间的程序通过 / dev/i2c-* 设备文件使用 I2C 总线。如果不清楚，则选择 N。</p>
<p>n        I2C Algorithms：I2C 算法支持，可以全选择 N。若有其他部分依赖其子项时，建议选择 Y。</p>
<p>n        I2C Hardware Bus support：按实际硬件情况选对应的子项即可。</p>
<p>n        Miscellaneous I2C Chip support：其他不常见的产品，按需求选择。如果不清楚，则选择 N。</p>
<p>n        I2C Core debugging messages：仅供调试使用。如果不清楚，则选择 N。</p>
<p>n        I2C Algorithm debugging messages：仅供调试使用。如果不清楚，则选择 N。</p>
<p>n        I2C Bus debugging messages：仅供调试使用。如果不清楚，则选择 N。</p>
<p>n        I2C Chip debugging messages：仅供调试使用。如果不清楚，则选择 N。</p>
<p>22）SPI support</p>
<p>串行外围接口（SPI）常用于微控制器（MCU）与外围设备（传感器、EEprom、Flash、编码器、模数转换器）之间的通信，比如 MMC 和 SD 卡就通常需要使用 SPI。</p>
<p>23）Dallas&rsquo;s 1-wire bus</p>
<p>一线总线。如果不清楚，则选择 N。</p>
<p>24）Hardware Monitoring support</p>
<p>当前主板大多都有一个监控硬件健康的设备用于监视温度、电压、风扇转速等，请按照嵌入式系统所使用主板实际使用的芯片选择相应的子项。另外，该功能还需要 I2C 的支持。如果不清楚，则选择 N。</p>
<p>25）Multimedia devices</p>
<p>多媒体设备。包括以下子选项。</p>
<p>n        Video For Linux：如果是使用音频 / 视频设备或 FM 收音卡的则选择 Y。此功能还需要 I2C 的支持。如果不清楚，则选择 N。</p>
<p>n        Enable Video For Linux API 1：使用老旧的 V4L 第一版 API。在一般情况下，建议选择 N。</p>
<p>n        Enable Video For Linux API 1 compatible Layer：提供对第一版 V4L 的兼容。在一般情况下，建议选择 N。</p>
<p>n        Video Capture Adapters：视频捕获卡。如果不清楚，则选择 N。</p>
<p>n        Enable advanced debug functionality：该选项仅供调试使用。如果不清楚，则选择 N。</p>
<p>n        Autoselect pertinent encoders/decoders and other helper chips：为视频卡自动选择所需的编码和解码模块。在一般情况下，建议选择 Y。</p>
<p>n        Virtual Video Driver：虚拟视频卡，仅供测试视频程序和调试。如果不清楚，则选择 N。</p>
<p>n        SAA5246A，SAA5281 Teletext processor：该选项仅面向欧洲用户，中国用户一般选择 N。</p>
<p>n        SAA5249 Teletext processor：该选项仅面向欧洲用户，中国用户一般选择 N。</p>
<p>n        V4L USB devices：使用 USB 接口的视频卡，子选项请根据嵌入式系统实际使用的视频卡选择。</p>
<p>n        Radio Adapters：音频卡，子选项请根据嵌入式系统实际使用的音频卡选择。</p>
<p>n        Digital Video Broadcasting Devices：数字视频广播设备（DVB 卡或机顶盒），子选项请根据嵌入式系统实际使用的硬件选择</p>
<p>n        DABUSB driver：USB 接口的数字音频广播设备接收器。如果不清楚，则选择 N。</p>
<p>26）Graphics support</p>
<p>图形设备 / 显卡支持。包括以下子选项。</p>
<p>n        Enable firmware EDID：允许访问 Video BIOS 中的扩展显示器识别数据（EDID）。如果不清楚，则选择 N。</p>
<p>n        Support for frame buffer devices：帧缓冲设备是为了让应用程序使用统一的接口操作显示设备而对硬件进行的抽象。如果不清楚，则选择 N。</p>
<p>n        Enable Video Mode Handling Helpers：使用 GTF 和 EDID 来帮助处理显示模式，可以选择 N。若有其他选项依赖于它时，则会自动选择 Y。</p>
<p>n        Enable Tile Blitting Support：可以选择 N。若有其他选项依赖于它时，会自动选择 Y。</p>
<p>n        VGA 16－color graphics support：16 色 VGA 显卡。如果有这样一种老式设备，则选择 Y。</p>
<p>n        VESA VGA graphics support：符合 VESA 2.0 标准的显卡的通用驱动，如果显卡芯片在下面能够找到就可以选择 N。</p>
<p>n        Virtual Frame Buffer support：仅供调试使用。</p>
<p>n        Console display driver support：控制台显示驱动。如果不清楚，则选择 N。</p>
<p>n        VGA text console：文本控制台。如果不清楚，则选择 N。</p>
<p>n        Enable Scrollback Buffer in System RAM：在内存中开辟额外的屏幕缓冲区，这将允许回滚屏幕。如果不清楚，则选择 N。</p>
<p>n        Scrollback Buffer Size（in KB）：在内存中开辟的额外屏幕缓冲区大小。如果不清楚，则选择 N。</p>
<p>n        Video mode selection support：允许在内核启动时使用 vga＝选择文本模式，如果希望一行能够显示更多字符的话可以打开它。如果不清楚，则选择 N。</p>
<p>n        MDA text console（dual-headed）：如果有老式的单色显卡并且作为第二块显卡使用以实现双头显示，则选择 Y。如果不清楚，则选择 N。</p>
<p>n        Framebuffer Console support：基于 Framebuffer 的控制台驱动，服务器可以选择 N。</p>
<p>n        Framebuffer Console Rotation：显示画面旋转，它可能大大降低显示速度，建议选择 N。</p>
<p>n        Select compiled-in fonts：选择内建字体。如果不清楚，则选择 N。</p>
<p>n        VGA 8x8 font：高分辨率下的小字体。如果不清楚，则选择 N。</p>
<p>n        VGA 8x16 font：低分辨率下的大字体。如果不清楚，则选择 N。</p>
<p>n        Logo configuration：启动时显示 Linux 的 logo（一幅企鹅图像），喜欢炫一下的则选择 Y。</p>
<p>n        Backlight＆LCD device support：LCD 显示器支持。如果不清楚，则选择 N。</p>
<p>27）Sound</p>
<p>声卡。包括以下子选项。</p>
<p>n        Advanced Linux Sound Architecture：使用声卡者选择 Y。</p>
<p>n        Sequencer support：音序器支持（MIDI 必需），除非确定不需要，否则请选择 Y。</p>
<p>n        Sequencer dummy client：除非要同时连接到多个 MIDI 设备或应用程序，否则一般选择 N。</p>
<p>n        OSS Mixer API：OSS 混音器 API 仿真，许多程序目前仍然需要使用它。在一般情况下，建议选择 Y。</p>
<p>n        OSS PCM（digital audio）API：OSS 数字录音（PCM）API 模拟，许多程序目前仍然需要使用它。在一般情况下，建议选择 Y。</p>
<p>n        OSS PCM（digital audio）API-Include plugin system：在一般情况下，建议选择 N。</p>
<p>n        OSS Sequencer API：OSS 音序器支持，许多程序目前仍然需要使用它。在一般情况下，建议选择 Y。</p>
<p>n        RTC Timer support：为 ALSA 启用 RTC 定时器支持。在一般情况下，建议选择 Y。</p>
<p>n        Use RTC as default sequencer timer：将 RTC 当做默认的时序脉冲发生器。如果不清楚，则选择 N。</p>
<p>n        Dynamic device file minor numbers：仅供拥有多个声卡的用户选择。如果不清楚，则选择 N。</p>
<p>n        Support old ALSA API：支持已被废弃的老版本 ALSA API。如果不清楚，则选择 N。</p>
<p>n        Verbose procfs contents：仅供调试使用。</p>
<p>n        Verbose printk：仅供调试使用。</p>
<p>n        Debug：仅供调试使用。</p>
<p>n        Generic devices：通用设备。如果不清楚，则选择 N。</p>
<p>n        Dummy（/dev/null）soundcard：仅供调试使用。</p>
<p>n        Virtual MIDI soundcard：虚拟 MIDI 驱动，允许将使用原始 MIDI 设备的应用程序连接到音序器客户端。如果不清楚，则选择 N。</p>
<p>n        PCI devices：PCI 接口的声卡，请按实际使用的声卡选择子项。</p>
<p>n        USB devices：USB 接口的声卡，请按实际使用的声卡选择子项。</p>
<p>n        PCMCIA devices：PCMCIA 接口的声卡，请按实际使用的声卡选择子项。</p>
<p>n        Open Sound System：在一般情况下，建议选择 N。</p>
<p>28）USB support</p>
<p>USB 支持。包括以下子选项。</p>
<p>n        Support for Host-side USB：主机端（Host-side）USB 支持。通用串行总线（USB）是一个串行总线子系统规范，它比传统的串口速度更快并且特性更丰富（供电、热插 拔，最多可接 127 个设备等），有望在将来统一 PC 外设接口。USB 的 “Host”（主机）被称为 “根”（也可以理解为是主板上的 USB 控制器），外部设 备被称为 “叶子”，而内部的节点则称为 HUB（集线器）。基本上只要想使用任何 USB 设备都必须选择此项。另外，还需要从下面选择 Y。至少一个 Host Controller Driver（HCD），比如适用于 USB 1.1 的 UHCI HCD support 或 OHCI HCD support，适用于 USB 2.0 的 EHCI HCD（USB 2.0）support。如果拿不准的话把他们全部选择 Y，一般也不会出问题。如果系统有设备端的 USB 接口（也就是系统可以作为叶子使用），请到 USB Gadget 中进行选择。</p>
<p>n        USB verbose debug messages：仅供调试使用。</p>
<p>n        USB device filesystem：在 / proc/bus/USB 里列出当前连接的 USB 设备（mount-t USBfs none/proc/bus/USB），这样用户空间的程序就可以直接访问这些 USB 设备。如果要使用 USB 设备的话就必须选择 Y。</p>
<p>n        Enforce USB bandwidth allocation：执行 USB 带宽分配限制，禁止打开占用 USB 总线带宽超过 90％的设备，选择 N 可能会导致某些设备无法正常工作。</p>
<p>n        Dynamic USB minor allocation：除非有超过 16 个同类型的 USB 设备，否则选择 N。</p>
<p>n        USB selective suspend/resume and wakeup：USB 设备的挂起和恢复。在一般情况下，建议选择 N。</p>
<p>n        EHCI HCD（USB 2.0）support：USB 2.0 支持（大多数 2002 年以后的主板都支持）。如果此项选择 Y，一般来说 OHCI 或 UHCI 驱动选项同时需要也选择 Y。</p>
<p>n        Full speed ISO transactions：由于 USB 2.0 支持低速（1.5Mbps）、全速（12Mbps）、高速（480Mbps）3 种规格的外部设备，为了将全 / 低速设备对高速设备可用带宽的影响减到 最小，在 USB 2.0 集线器中提供了一种事务转换（Transaction Translator）机制，该机制支持在 HUB 连接的是全 / 低速设备的情况下，允许主控制器与 HUB 之间以高速传输所有设备的数据，从而节省不必要的等 待。如果没有外置的 USB 集线器可以选择 N。</p>
<p>n        Root Hub Transaction Translators：带有 USB 2.0 接口的主板上都有一个根集线器（Root Hub），以允许在无须额外购买 HUB 的情况下就可以提供多个 USB 插口，其中的某些产品还在其中集成了事务转换（Transaction Translator）功能，这样就不需要再额外使用一个兼容 OHCI 或 UHCI 的控制器来兼容 USB 1.1，即使不太清楚嵌入式系统所使用主板上的根集线器是否集成了事务转换功能，也可以安全地选择此项。</p>
<p>n        Improved Transaction Translator scheduling：如果有一个高速 USB 2.0 HUB 并且某些接在这个 HUB 上的低速或全速设备不能正常工作（显示&rsquo;cannot submit datapipe: error-28&rsquo;或&rsquo;error-71&rsquo;错误），可以考虑选择 Y。</p>
<p>n        ISP116X HCD support：ISP1160/ISP1161 主机 USB 控制器，是符合 USB 2.0 全速规范的单片主机控制器和设备控制器，支持 OHCI 标准。</p>
<p>n        OHCI HCD support：开放主机控制接口（OHCI）是主要针对嵌入式系统的 USB 1.1 主机控制器规范。如果不清楚，则选择 N。</p>
<p>n        UHCI HCD（most Intel and VIA）support：通用主机控制器接口（UHCI）是主要针对 PC 的 USB 1.1 主机控制器规范。另外，EHCI 也可能需要它。如果不清楚，则选择 N。</p>
<p>n        Elan U132 Adapter Host Controller：如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        SL811HS HCD support：如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Bluetooth TTY support：USB 蓝牙 TTY 设备支持。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB MIDI support：USB MIDI 设备支持。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB MODEM（CDC ACM）support：USB 接口的猫或 ISDN 适配器。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Printer support：USB 打印机。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Mass Storage support：USB 存储设备（优盘、USB 硬盘、USB 软盘、USB CD-ROM、USB 磁带、memory sticks、数码相机、读卡器等）。该选项依赖于 SCSI device support，且大部分情况下还依赖于 SCSI disk support（比如优盘或 USB 硬盘）。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Mass Storage verbose debug：仅供调试使用。</p>
<p>n        The shared table of common（或 usual）storage devices：该模块包含一张记录了常用 USB 存储设备及其驱动的表格，这样无须重新编译模块即可在切换这些设备时自动邦定对应的驱动（还需要对 /etc/modprobe。conf 进行相应的设置）。如果不清楚，则选择 N。</p>
<p>n        USB Human Interface Device（full HID）support：USB 人机界面设备（鼠标、键盘、游戏杆、手写板等操作计算机的设备），该驱动不能和 USB HID Boot Protocol drivers 同时使用。如果不清楚，则选择 N。</p>
<p>n        HID input layer support：如果有 USB 接口的鼠标、键盘、游戏杆、手写板等输入设备，则选择 Y。</p>
<p>n        Enable support for iBook/PowerBook special keys：苹果 iBooks/PowerBooks 键盘上的 Fn/Numlock 等功能键支持。如果不清楚，则选择 N。</p>
<p>n        Force feedback support：力反馈设备。如果不清楚，则选择 N。</p>
<p>n        /dev/hiddev raw HID device support：如果有 USB 监控装置或不间断电源（UPS）之类的非输入设备就选择 Y。</p>
<p>n        USB HID Boot Protocol drivers：如果有绝对的把握确信不为嵌入式系统所使用的键盘和鼠标使用通常的 HID 驱动，而要使用 Boot Protocol 模式的 HID 驱动（常见于嵌入式环境），则选择 Y。</p>
<p>n        Aiptek 6000U/8000U tablet support：一种手写板。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Wacom Intuos/Graphire tablet support：一种手写 / 绘图板。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Acecad Flair tablet support：一种数控绘图板。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        KB Gear JamStudio tablet support：一种手写 / 绘图板。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Griffin PowerMate and Contour Jog support：一种具有调节音量、滚动文本、视频快进 / 快退等功能的产品。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Touchscreen Driver：USB 触摸屏驱动。如果嵌入式系统采用 USB 触摸屏硬件，则选择 Y。</p>
<p>n        Yealink USB-p1k voip phone：一种 VoIP 电话。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        X-Box gamepad support：X-Box 游戏板。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        ATI/X10 USB RF remote control：一种 USB 远程控制设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        ATI/Philips USB RF remote control：一种 USB 远程控制设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Keyspan DMR USB remote control：一种 USB 远程控制设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Apple USB Touchpad support：苹果机上的触摸板。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Mustek MDC800 Digital Camera support：一种数码相机。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Microtek X6USB scanner support：一种扫描仪。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Network Adapters：USB 网络适配器，如果有这种设备请根据嵌入式系统实际使用的硬件选择子项。</p>
<p>n        USB Monitor：USB 流量监控。在一般情况下，建议选择 N。</p>
<p>n        USS720 parport driver：一种 USB 接口转并口的转换设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Serial Converter support：USB 接口转串口的转换设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        EMI 6｜2m USB Audio interface support：一种 USB 音频设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        EMI 2｜6 USB Audio interface support：一种 USB 音频设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        ADU devices from Ontrak Control Systems：Ontrak Control Systems 公司的一种自动拨号设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Auerswald ISDN support：一种 ISDN 设备。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Diamond Rio500 support：一种 MP3 播放器。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Lego Infrared Tower support：一种无线发射机。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB LCD driver support：USB 液晶显示器。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB LED driver support：USB 发光二极管。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Cypress CY7C63xxx USB driver support：德国 AK Modul-Bus Computer GmbH 公司的一种产品。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Cypress USB thermometer driver support：一种温度计。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Phidgets drivers：来自 Phidgets 公司的各种 USB 产品。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Siemens ID USB Mouse Fingerprint sensor support：西门子公司的一种指纹传感器。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Elan PCMCIA CardBus Adapter USB Client：Elan 公司的一种 USB 转 PCMCIA 的适配器。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        Apple Cinema Display support：苹果公司的一种 Cinema Display。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB 2.0 SVGA dongle support（Net2280/SiS315）：一种软件狗。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB LD driver：USB LD 驱动。如果嵌入式系统采用 USB LD 硬件，则选择 Y。</p>
<p>n        PlayStation 2 Trance Vibrator driver support：SONY 的 PS2 上面的 “入迷振荡器”，类似于力反馈手柄。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB testing driver：这是一种测试中的驱动。在一般情况下，建议选择 N。</p>
<p>n        USB DSL modem support：对 USB DSL 猫的支持。如果嵌入式系统采用这种设备，则选择 Y。</p>
<p>n        USB Gadget Support：USB 杂项支持。如果不清楚，则选择 N。</p>
<p>29）MMC/SD Card support</p>
<p>MMC/SD 卡支持。如果嵌入式系统采用此类设备，则选择 Y。</p>
<p>30）LED devices</p>
<p>发光二级管（LED）设备。如果嵌入式系统采用此类设备，则选择 Y。</p>
<p>31）InfiniBand support</p>
<p>InfiniBand 是一个通用的高性能 I/O 规范，它使得存储区域网中以更低的延时传输 I/O 消息和集群通信消息并且提供很好的伸缩性。用于 Linux 服务器集群系统。如果不清楚，则选择 N。</p>
<p>32）EDAC-error detection and reporting（RAS）</p>
<p>错误检测与纠正（EDAC）的目标是发现并报告，甚至纠正在计算机系统中发生的错误，这些错误是由 CPU 或芯片组报告的底层错误（内存错误、缓存错误、PCI 错误、温度过高等）。在一般情况下，建议选择 Y。如果这些代码报告了一个错误，请到以下网站查看更多信息。</p>
<p>n        <a href="http://bluesmoke.Sourceforge.net/">http://bluesmoke.Sourceforge.net/</a>。</p>
<p>n        <a href="http://buttersideup.com/edacwiki/">http://buttersideup.com/edacwiki/</a>。</p>
<p>该选项包括以下子选项。</p>
<p>n        Debugging：仅供调试使用。</p>
<p>n        Main Memory EDAC（Error Detection And Correction）reporting：一些系统能够检测和修正主内存中的错误，EDAC 能够报告这些信息（EDAC 自己检测到的或者根据 ECC 得到 的）。EDAC 还会尽量检测这些错误发生在哪里，以便于替换损坏的内存。建议选择并按照实际使用的芯片组选取子项。</p>
<p>n        Error detecting method：错误检测方法，当前只有一个 Poll for errors（错误轮询）可用。如果不清楚，则选择 N。</p>
<p>33）Real Time Clock</p>
<p>所有的 PC 主板都包含一个电池动力的实时时钟芯片，以便在断电后仍然能够继续保持时间，RTC 通常与 CMOS 集成在一起，因此 BIOS 可以从中读取当前时间。该选项包括以下子选项。</p>
<p>n        RTC class：通用 RTC 类支持，选择此项后就可以在操作系统中使用一个或多个 RTC 设备，还必须从下面启用一个或多个 RTC 接口。如果不清楚，则选择 N。</p>
<p>n        Set system time from RTC on startup：系统启动时使用从指定的 RTC 设备中读取的时间来设定系统时间，通常这将有助于避免不必要的文件系统检测程序（fsck）的运行。在一般情况下，建议选择 Y。</p>
<p>n        The RTC to read the time from：指定具体从哪个 RTC 设备中读取时间。如果不清楚，则选择 N。</p>
<p>n        RTC debug support：仅供调试使用。</p>
<p>n        sysfs：允许通过 sysfs 接口使用 RTC，允许多个 RTC 设备，也就是 / sys/class/RTC/ RTC0_N。如果不清楚，则选择 N。</p>
<p>n        proc：允许通过 proc 接口使用 RTC，仅允许一个 RTC 设备，也就是 / proc/driver/RTC。如果不清楚，则选择 N。</p>
<p>n        dev：允许通过 dev 接口使用 RTC，允许多个 RTC 设备，也就是 udev 设置的 / dev/RTC0_N，建议建立一个指向其中之一的软连接 / dev/RTC，某些程序（比如 hwclock）需要使用 / dev/RTC。如果不清楚，则选择 N。</p>
<p>n        RTC UIE emulation on dev interface：该选项的作用是，如果底层 RTC 芯片接口没有提供 RTC_UIE 支持，就仿真一个 RTC_UIE。如果不清楚，则选择 N。</p>
<p>34）DMA Engine support</p>
<p>从 Intel Bensley 双核服务器平台开始引入的数据移动加速（Data Movement Acceleration）引擎，它将某些传输数据的操作从 CPU 转移到专用硬件，从而可以进行异步传输并减轻 CPU 负载。Intel 已将此项技术变为开 放的标准，将来应当会有更多的厂商支持。该选项包括以下子选项。</p>
<p>n        TCP receive copy offload：通过在网络栈中利用 DMA 引擎来减少接收数据包时的 copy-to-user 操作，以释放 CPU 资源，这是 DMA 引擎目前最主要的用途。如果不清楚，则选择 N。</p>
<p>n        Intel I/OAT DMA support：Intel I/O 加速技术（Intel I/O Acceleration Technology）中的 DMA 支持，基于 Intel Bensley 的新一代服务器平台都支持它。如果不清楚，则选择 N</p>
<p>Linux 2.6.19.x 内核编译配置选项简介</p>
<p>发 布 时 间 : 2008-11-19    来 源 : <a href="http://lamp.linux.gov.cn/Linux/kernel_options.html">http://lamp.linux.gov.cn/Linux/kernel_options.html</a>    作 者 : 金步国   浏 览 : 2185</p>
<p>版权声明</p>
<p>本文作者是一位自由软件爱好者，所以本文虽然不是软件，但是本着 GPL 的精神发布。任何人都可以自由使用、转载、复制和再分发，但必须保留作者署名，亦不得对声明中的任何条款作任何形式的修改，也不得附加任何其它条件。您可以自由链接、下载、传播此文档，但前提是必须保证全文完整转载，包括完整的版权信息和作译者声明。</p>
<p>其他作品</p>
<p>本文作者十分愿意与他人共享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有作品的列表：</p>
<p>电信用户请访问：　金步国作品列表
网通用户请访问：　金步国作品列表
铁通用户请访问：　金步国作品列表
教育网用户请访问：金步国作品列表
BUG 报告，切磋与探讨</p>
<p>由于作者水平有限，因此不能保证作品内容准确无误，请在阅读中自行鉴别。如果你发现了作品中的错误，请您来信指出，哪怕是错别字也好，任何提高作品质量的建议我都将虚心接纳。如果你愿意就作品中的相关内容与我进行进一步切磋与探讨，也欢迎你与我联系。联系方式：Email: <a href="mailto:csfrank@citiz.net">csfrank@citiz.net</a> ； QQ: 70171448 ； MSN: <a href="mailto:csfrank122@hotmail.com">csfrank122@hotmail.com</a></p>
<p>本文作者将不定期的根据最新的内核进行添加 (同时仍然保留老版本内核的选项), 欢迎常来光临并帮助指出其中的错误.</p>
<p>Code maturity level options
代码成熟度选项</p>
<p>Prompt for development and/or incomplete code/drivers</p>
<p>显示尚在开发中或尚未完成的代码与驱动. 除非你是测试人员或者开发者, 否则请勿选择</p>
<p>General setup
常规设置</p>
<p>Local version - append to kernel release</p>
<p>在内核版本后面加上自定义的版本字符串 (小于 64 字符), 可以用 &ldquo;uname -a&rdquo; 命令看到</p>
<p>Automatically append version information to the version string</p>
<p>自动在版本字符串后面添加版本信息, 编译时需要有 perl 以及 git 仓库支持</p>
<p>Support for paging of anonymous memory (swap)</p>
<p>使用交换分区或者交换文件来做为虚拟内存</p>
<p>IPC Namespaces</p>
<p>IPC 命名空间支持, 不确定可以不选</p>
<p>POSIX Message Queues</p>
<p>POSIX 消息队列, 这是 POSIX IPC 中的一部分</p>
<p>Export task/process statistics through netlink</p>
<p>Enable per-task delay accounting</p>
<p>在统计信息中包含进程等候系统资源 (cpu,IO 同步, 内存交换等) 所花费的时间</p>
<p>UTS Namespaces</p>
<p>UTS 名字空间支持, 不确定可以不选</p>
<p>Enable system-call auditing support</p>
<p>支持对系统调用的审计</p>
<p>Kernel .config support</p>
<p>把内核的配置信息编译进内核中, 以后可以通过 scripts/extract-ikconfig 脚本来提取这些信息</p>
<p>Enable access to .config through /proc/config.gz</p>
<p>允许通过 / proc/config.gz 访问内核的配置信息</p>
<p>Cpuset support</p>
<p>只有含有大量 CPU(大于 16 个) 的 SMP 系统或 NUMA(非一致内存访问) 系统才需要它</p>
<p>Kernel-&gt;user space relay support (formerly relayfs)</p>
<p>在某些文件系统上 (比如 debugfs) 提供从内核空间向用户空间传递大量数据的接口</p>
<p>Initramfs source file(s)</p>
<p>initrd 已经被 initramfs 取代, 如果你不明白这是什么意思, 请保持空白</p>
<p>Optimize for size (Look out for broken compilers!)</p>
<p>编译时优化内核尺寸 (使用 &ldquo;-Os&rdquo; 而不是 &ldquo;-O2&rdquo; 参数编译), 有时会产生错误的二进制代码</p>
<p>Enable extended accounting over taskstats</p>
<p>收集额外的进程统计信息并通过 taskstats 接口发送到用户空间</p>
<p>Configure standard kernel features (for small systems)</p>
<p>配置标准的内核特性 (为小型系统)</p>
<p>Enable 16-bit UID system calls</p>
<p>允许对 UID 系统调用进行过时的 16-bit 包装</p>
<p>Sysctl syscall support</p>
<p>不需要重启就能修改内核的某些参数和变量, 如果你也选择了支持 / proc, 将能从 / proc/sys 存取可以影响内核行为的参数或变量</p>
<p>Load all symbols for debugging/kksymoops</p>
<p>装载所有的调试符号表信息, 仅供调试时选择</p>
<p>Include all symbols in kallsyms</p>
<p>在 kallsyms 中包含内核知道的所有符号, 内核将会增大 300K</p>
<p>Do an extra kallsyms pass</p>
<p>除非你在 kallsyms 中发现了 bug 并需要报告这个 bug 才打开该选项</p>
<p>Support for hot-pluggable devices</p>
<p>支持热插拔设备, 如 usb 与 pc 卡等, Udev 也需要它</p>
<p>Enable support for printk</p>
<p>允许内核向终端打印字符信息, 在需要诊断内核为什么不能运行时选择</p>
<p>BUG() support</p>
<p>显示故障和失败条件 (BUG 和 WARN), 禁用它将可能导致隐含的错误被忽略</p>
<p>Enable ELF core dumps</p>
<p>内存转储支持, 可以帮助调试 ELF 格式的程序</p>
<p>Enable full-sized data structures for core</p>
<p>在内核中使用全尺寸的数据结构. 禁用它将使得某些内核的数据结构减小以节约内存, 但是将会降低性能</p>
<p>Enable futex support</p>
<p>快速用户空间互斥体可以使线程串行化以避免竞态条件, 也提高了响应速度. 禁用它将导致内核不能正确的运行基于 glibc 的程序</p>
<p>Enable eventpoll support</p>
<p>支持事件轮循的系统调用</p>
<p>Use full shmem filesystem</p>
<p>启用 shmem 支持. shmem 是基于共享内存的文件系统 (可能用到 swap), 在启用 TMPFS 后可以挂载为 tmpfs 供用户空间使用, 它比简单的 ramfs 先进许多</p>
<p>Use full SLAB allocator</p>
<p>使用 SLAB 完全取代 SLOB 进行内存分配, SLAB 是一种优秀的内存分配管理器, 推荐使用</p>
<p>Enable VM event counters for /proc/vmstat</p>
<p>允许在 / proc/vmstat 中包含虚拟内存事件记数器</p>
<p>Loadable module support
可加载模块支持</p>
<p>Enable loadable module support</p>
<p>打开可加载模块支持, 如果打开它则必须通过 &ldquo;make modules_install&rdquo; 把内核模块安装在 / lib/modules / 中</p>
<p>Module unloading</p>
<p>允许卸载已经加载的模块</p>
<p>Forced module unloading</p>
<p>允许强制卸载正在使用中的模块 (比较危险)</p>
<p>Module versioning support</p>
<p>允许使用其他内核版本的模块 (可能会出问题)</p>
<p>Source checksum for all modules</p>
<p>为所有的模块校验源码, 如果你不是自己编写内核模块就不需要它</p>
<p>Automatic kernel module loading</p>
<p>让内核通过运行 modprobe 来自动加载所需要的模块, 比如可以自动解决模块的依赖关系</p>
<p>Block layer
块设备层</p>
<p>Enable the block layer</p>
<p>块设备支持, 使用硬盘 / USB/SCSI 设备者必选</p>
<p>Support for Large Block Devices</p>
<p>仅在使用大于 2TB 的块设备时需要</p>
<p>Support for tracing block io actions</p>
<p>块队列 IO 跟踪支持, 它允许用户查看在一个块设备队列上发生的所有事件, 可以通过 blktrace 程序获得磁盘当前的详细统计数据</p>
<p>Support for Large Single Files</p>
<p>仅在可能使用大于 2TB 的文件时需要</p>
<p>IO Schedulers</p>
<p>IO 调度器</p>
<p>Anticipatory I/O scheduler</p>
<p>假设一个块设备只有一个物理查找磁头 (例如一个单独的 SATA 硬盘), 将多个随机的小写入流合并成一个大写入流, 用写入延时换取最大的写入吞吐量. 适用于大多数环境, 特别是写入较多的环境 (比如文件服务器)</p>
<p>Deadline I/O scheduler</p>
<p>使用轮询的调度器, 简洁小巧, 提供了最小的读取延迟和尚佳的吞吐量, 特别适合于读取较多的环境 (比如数据库)</p>
<p>CFQ I/O scheduler</p>
<p>使用 QoS 策略为所有任务分配等量的带宽, 避免进程被饿死并实现了较低的延迟, 可以认为是上述两种调度器的折中. 适用于有大量进程的多用户系统</p>
<p>Default I/O scheduler</p>
<p>默认 IO 调度器</p>
<p>Processor type and features
中央处理器 (CPU) 类型及特性</p>
<p>Symmetric multi-processing support</p>
<p>对称多处理器支持, 如果你有多个 CPU 或者使用的是多核 CPU 就选上. 此时 &ldquo;Enhanced Real Time Clock Support&rdquo; 选项必须开启,&ldquo;Advanced Power Management&rdquo; 选项必须关闭</p>
<p>Subarchitecture Type</p>
<p>处理器的子架构, 大多数人都应当选择 &ldquo;PC-compatible&rdquo;</p>
<p>Processor family</p>
<p>处理器系列, 请按照你实际使用的 CPU 选择</p>
<p>Generic x86 support</p>
<p>通用 x86 支持, 如果你的 CPU 能够在上述 &ldquo;Processor family&rdquo; 中找到就别选</p>
<p>HPET Timer Support</p>
<p>HPET 是替代 8254 芯片的新一代定时器, i686 及以上级别的主板都支持, 可以安全的选上</p>
<p>Maximum number of CPUs</p>
<p>支持的最大 CPU 数, 每增加一个内核将增加 8K 体积</p>
<p>SMT (Hyperthreading) scheduler support</p>
<p>支持 Intel 的超线程 (HT) 技术</p>
<p>Multi-core scheduler support</p>
<p>针对多核 CPU 进行调度策略优化</p>
<p>Machine Check Exception</p>
<p>让 CPU 检测到系统故障时通知内核, 以便内核采取相应的措施 (如过热关机等)</p>
<p>Check for non-fatal errors on AMD Athlon/Duron / Intel Pentium 4</p>
<p>每 5 秒检测一次这些 cpu 的非致命错误并纠正它们, 同时记入日志</p>
<p>check for P4 thermal throttling interrupt</p>
<p>当 P4 的 cpu 过热时显示一条警告消息</p>
<p>Enable VM86 support</p>
<p>虚拟 X86 支持, 在 DOSEMU 下运行 16-bit 程序或 XFree86 通过 BIOS 初始化某些显卡的时候才需要</p>
<p>Toshiba Laptop support</p>
<p>Toshiba 笔记本模块支持</p>
<p>Dell laptop support</p>
<p>Dell 笔记本模块支持</p>
<p>Enable X86 board specific fixups for reboot</p>
<p>修正某些旧 x86 主板的重起 bug, 这种主板基本绝种了</p>
<p>/dev/cpu/microcode - Intel IA32 CPU microcode support</p>
<p>使用不随 Linux 内核发行的 IA32 微代码, 你必需有 IA32 微代码二进制文件, 仅对 Intel 的 CPU 有效</p>
<p>/dev/cpu/*/msr - Model-specific register support</p>
<p>在多 cpu 系统中让特权 CPU 访问 x86 的 MSR 寄存器</p>
<p>/dev/cpu/*/cpuid - CPU information support</p>
<p>能从 / dev/cpu/x/cpuid 获得 CPU 的唯一标识符 (CPUID)</p>
<p>Firmware Drivers</p>
<p>固件驱动程序</p>
<p>BIOS Enhanced Disk Drive calls determine boot disk</p>
<p>有些 BIOS 支持从某块特定的硬盘启动 (如果 BIOS 不支持则可能无法启动), 目前大多数 BIOS 还不支持</p>
<p>BIOS update support for DELL systems via sysfs</p>
<p>仅适用于 DELL 机器</p>
<p>Dell Systems Management Base Driver</p>
<p>仅适用于 DELL 机器</p>
<p>High Memory Support</p>
<p>最高内存支持, 总内存小于等于 1G 的选 &ldquo;off&rdquo;, 大于 4G 的选 &ldquo;64G&rdquo;</p>
<p>Memory split</p>
<p>如果你不是绝对清楚自己在做什么, 不要改动这个选项</p>
<p>Memory model</p>
<p>一般选 &ldquo;Flat Memory&rdquo;, 其他选项涉及内存热插拔</p>
<p>64 bit Memory and IO resources</p>
<p>使用 64 位的内存和 IO 资源</p>
<p>Allocate 3rd-level pagetables from highmem</p>
<p>在内存很多 (大于 4G) 的机器上将用户空间的页表放到高位内存区, 以节约宝贵的低端内存</p>
<p>Math emulation</p>
<p>数学协处理器仿真, 486DX 以上的 cpu 就不要选它了</p>
<p>MTRR (Memory Type Range Register) support</p>
<p>打开它可以提升 PCI/AGP 总线上的显卡 2 倍以上的速度, 并且可以修正某些 BIOS 错误</p>
<p>Boot from EFI support</p>
<p>EFI 是一种可代替传统 BIOS 的技术 (目前的 Grub/LILO 尚不能识别它), 但是现在远未普及</p>
<p>Enable kernel irq balancing</p>
<p>让内核将 irq 中断平均分配给多个 CPU 以进行负载均衡, 但是要配合 irqbanlance 守护进程才行</p>
<p>Use register arguments</p>
<p>使用 &ldquo;-mregparm=3&rdquo; 参数编译内核, 将前 3 个参数以寄存器方式进行参数调用, 可以生成更紧凑和高效的代码</p>
<p>Enable seccomp to safely compute untrusted bytecode</p>
<p>只有嵌入式系统可以不选</p>
<p>Timer frequency</p>
<p>内核时钟频率, 桌面推荐 &ldquo;1000 HZ&rdquo;, 服务器推荐 &ldquo;100 HZ&rdquo; 或 &ldquo;250 HZ&rdquo;</p>
<p>kexec system call</p>
<p>提供 kexec 系统调用, 可以不必重启而切换到另一个内核</p>
<p>kernel crash dumps</p>
<p>被 kexec 启动后产生内核崩溃转储</p>
<p>Physical address where the kernel is loaded</p>
<p>内核加载的物理地址, 除非你知道自己在做什么, 否则不要修改. 在提供 kexec 系统调用的情况下可能要修改它</p>
<p>Support for hot-pluggable CPUs</p>
<p>对热插拔 CPU 提供支持</p>
<p>Compat VDSO support</p>
<p>如果 Glibc 版本大于等于 2.3.3 就不选, 否则就选上</p>
<p>Power management options
电源管理选项</p>
<p>Power Management support</p>
<p>电源管理有 APM 和 ACPI 两种标准且不能同时使用. 即使关闭该选项, X86 上运行的 Linux 也会在空闲时发出 HLT 指令将 CPU 进入睡眠状态</p>
<p>Legacy Power Management API</p>
<p>传统的电源管理 API, 比如软关机和系统休眠等接口</p>
<p>Power Management Debug Support</p>
<p>仅供调试使用</p>
<p>Driver model /sys/devices/&hellip;/power/state files</p>
<p>内核帮助文档反对使用该选项, 即将被废除</p>
<p>ACPI (Advanced Configuration and Power Interface) Support</p>
<p>必须运行 acpid 守护程序 ACPI 才能起作用. ACPI 是为了取代 APM 而设计的, 因此应该尽量使用 ACPI 而不是 APM</p>
<p>AC Adapter</p>
<p>如果你的系统可以在 AC 和电池之间转换就可以选</p>
<p>Battery</p>
<p>通过 / proc/acpi/battery 向用户提供电池状态信息, 用电池的笔记本可以选</p>
<p>Button</p>
<p>守护程序捕获 Power,Sleep,Lid 按钮事件, 并根据 / proc/acpi/event 做相应的动作, 软件控制的 poweroff 需要它</p>
<p>Video</p>
<p>仅对集成在主板上的显卡提供 ACPI2.0 支持, 且不是所有集成显卡都支持</p>
<p>Generic Hotkey</p>
<p>统一的热键驱动, 建议不选</p>
<p>Fan</p>
<p>允许通过用户层的程序来对系统风扇进行控制 (开, 关, 查询状态), 支持它的硬件并不多</p>
<p>Dock</p>
<p>支持由 ACPI 控制的集线器 (docking stations)</p>
<p>Processor</p>
<p>让 ACPI 处理空闲状态, 并使用 ACPI C2 和 C3 处理器状态在空闲时节省电能, 同时它还被 cpufreq 的 &ldquo;Performance-state drivers&rdquo; 选项所依赖</p>
<p>Thermal Zone</p>
<p>系统温度过高时可以利用 ACPI thermal zone 及时调整工作状态以避免你的 CPU 被烧毁</p>
<p>ASUS/Medion Laptop Extras</p>
<p>ASUS 笔记本专用, 以提供额外按钮的支持, 用户可以通过 / proc/acpi/asus 来打开或者关闭 LCD 的背光 / 调整亮度 / 定制 LED 的闪烁指示等功能</p>
<p>IBM ThinkPad Laptop Extras</p>
<p>IBM ThinkPad 专用</p>
<p>Toshiba Laptop Extras</p>
<p>Toshiba 笔记本专用</p>
<p>Disable ACPI for systems before Jan 1st this year</p>
<p>输入四位数的年份, 在该年的 1 月 1 日前不使用 ACPI 的功能 (&ldquo;0&rdquo; 表示一直使用)</p>
<p>Debug Statements</p>
<p>详细的 ACPI 调试信息, 不搞开发就别选</p>
<p>Power Management Timer Support</p>
<p>这个 Timer 在所有 ACPI 兼容的平台上都可用, 且不会受 PM 功能的影响, 建议总是启用它. 如果你在 kernel log 中看到了&rsquo;many lost ticks&rsquo;那就必须启用它</p>
<p>ACPI0004,PNP0A05 and PNP0A06 Container Driver</p>
<p>支持内存和 CPU 的热插拔</p>
<p>Smart Battery System</p>
<p>支持依赖于 I2C 的 &ldquo;智能电池&rdquo;. 这种电池非常老旧且罕见, 还与当前的 ACPI 标准兼容性差</p>
<p>APM (Advanced Power Management) BIOS Support</p>
<p>APM 在 SMP 机器上必须关闭, 一般来说当前的笔记本都支持 ACPI, 所以应尽量关闭该该选项</p>
<p>Ignore USER SUSPEND</p>
<p>只有 NEC Versa M 系列的笔记本才需要选择这一项</p>
<p>Enable PM at boot time</p>
<p>系统启动时即启用 APM, 选上这个选项能让系统自动的进行电源管理, 但常常导致启动时死机</p>
<p>Make CPU Idle calls when idle</p>
<p>系统空闲时调用空闲指令 (halt), 只有老式的 CPU 才需要选它, 且对于 SMP 系统必须关闭</p>
<p>Enable console blanking using APM</p>
<p>在屏幕空白时关闭 LCD 背光, 事实上对所有的笔记本都无效</p>
<p>RTC stores time in GMT</p>
<p>将硬件时钟应该设为格林威治时间, 否则视为本地时间. 建议你使用 GMT, 这样你无须为时区的改变而担心</p>
<p>Allow interrupts during APM BIOS calls</p>
<p>允许 APM 的 BIOS 调用时中断, IBM Thinkpad 的一些新机器需要这项. 如果休眠时挂机 (包括睡下去就醒不来), 可以试试它</p>
<p>Use real mode APM BIOS call to power off</p>
<p>此驱动为某些有 Bug 的 BIOS 准备, 如果你的系统不能正常关机或关机时崩溃, 可以试试它</p>
<p>CPU Frequency scaling</p>
<p>允许动态改变 CPU 主频, 达到省电和降温的目的, 必须同时启用下面的一种 governor 才行</p>
<p>Enable CPUfreq debugging</p>
<p>允许对 CPUfreq 进行调试</p>
<p>CPU frequency translation statistics</p>
<p>通过 sysfs 文件系统输出 CPU 频率变换的统计信息</p>
<p>CPU frequency translation statistics details</p>
<p>输出详细的 CPU 频率变换统计信息</p>
<p>Default CPUFreq governor</p>
<p>默认的 CPU 频率调节器</p>
<p>&lsquo;performance&rsquo; governor</p>
<p>&lsquo;性能&rsquo;优先, 静态的将频率设置为 cpu 支持的最高频率</p>
<p>&lsquo;powersave&rsquo; governor</p>
<p>&lsquo;节能&rsquo;优先, 静态的将频率设置为 cpu 支持的最低频率</p>
<p>&lsquo;userspace&rsquo; governor for userspace frequency scaling</p>
<p>既允许手动调整 cpu 频率, 也允许用户空间的程序动态的调整 cpu 频率 (需要额外的调频软件, 比如 cpufreqd)</p>
<p>&lsquo;ondemand&rsquo; cpufreq policy governor</p>
<p>&lsquo;立即响应&rsquo;, 周期性的考察 CPU 负载并自动的动态调整 cpu 频率 (不需要额外的调频软件), 适合台式机</p>
<p>&lsquo;conservative&rsquo; cpufreq governor</p>
<p>&lsquo;保守&rsquo;, 和&rsquo;ondemand&rsquo;相似, 但是频率的升降是渐变式的 (幅度不会很大), 更适合用于笔记本 / PDA/AMD64 环境</p>
<p>ACPI Processor P-States driver</p>
<p>将 ACPI2.0 的处理器性能状态报告给 CPUFreq processor drivers 以决定如何调整频率, 该选项依赖于 ACPI-&gt;Processor</p>
<p>{省略的部分请按照自己实际使用的 CPU 选择}</p>
<p>/proc/acpi/processor/../performance interface</p>
<p>内核帮助文档反对使用该选项, 即将被废除</p>
<p>Relaxed speedstep capability checks</p>
<p>放松对系统的 speedstep 兼容性检查, 仅在某些老旧的 Intel 系统上需要打开</p>
<p>Bus options (PCI, PCMCIA, EISA, MCA, ISA)
总线选项</p>
<p>PCI support</p>
<p>PCI 支持, 如果使用了 PCI 或 PCI Express 设备就必选</p>
<p>PCI access mode</p>
<p>PCI 访问模式, 强列建议选 &ldquo;Any&rdquo;(系统将优先使用 &ldquo;MMConfig&rdquo;, 然后使用 &ldquo;BIOS&rdquo;, 最后使用 &ldquo;Direct&rdquo; 检测 PCI 设备)</p>
<p>PCI Express support</p>
<p>PCI Express 支持 (目前主要用于显卡和千兆网卡)</p>
<p>PCI Express Hotplug driver</p>
<p>如果你的主板和设备都支持 PCI Express 热插拔就可以选上</p>
<p>Use polling mechanism for hot-plug events</p>
<p>对热插拔事件采用轮询机制, 仅用于测试目的</p>
<p>Root Port Advanced Error Reporting support</p>
<p>由 PCI Express AER 驱动程序处理发送到 Root Port 的错误信息</p>
<p>Message Signaled Interrupts (MSI and MSI-X)</p>
<p>充许设备通过 PCI 总线写入内存堆栈产生一个中断而不是使用默认的 IRQ 中断, 建议不选</p>
<p>PCI Debugging</p>
<p>将 PCI 调试信息输出到系统日志里</p>
<p>Interrupts on hypertransport devices</p>
<p>允许本地的 hypertransport 设备使用中断</p>
<p>ISA support</p>
<p>现在基本上没有 ISA 的设备了, 如果你有就选吧</p>
<p>MCA support</p>
<p>微通道总线, 老旧的 IBM 的台式机和笔记本上可能会有这种总线</p>
<p>NatSemi SCx200 support</p>
<p>在使用 AMD Geode 处理器的机器上才可能有</p>
<p>PCCARD (PCMCIA/CardBus) support</p>
<p>PCMCIA 卡 (主要用于笔记本) 支持</p>
<p>Enable PCCARD debugging</p>
<p>仅供调试</p>
<p>16-bit PCMCIA support</p>
<p>一些老的 PCMCIA 卡使用 16 位的 CardBus</p>
<p>32-bit CardBus support</p>
<p>当前的 PCMCIA 卡基本上都是 32 位的 CardBus</p>
<p>CardBus yenta-compatible bridge support</p>
<p>使用 PCMCIA 卡的基本上都需要选择这一项, 子项请按照自己实际使用的 PCMCIA 卡选择</p>
<p>{省略的部分请按照自己实际使用的 PCMCIA 卡选择}</p>
<p>PCI Hotplug Support</p>
<p>PCI 热插拔支持, 如果你有这样的设备就到子项中去选吧</p>
<p>Executable file formats
可执行文件格式</p>
<p>Kernel support for ELF binaries</p>
<p>ELF 是开放平台下最常用的二进制文件格式, 支持动态连接, 支持不同的硬件平台. 除非你知道自己在做什么, 否则必选</p>
<p>Kernel support for a.out and ECOFF binaries</p>
<p>早期 UNIX 系统的可执行文件格式, 目前已经被 ELF 格式取代</p>
<p>Kernel support for MISC binaries</p>
<p>允许插入二进制的封装层到内核中, 使用 Java,.NET,Python,Lisp 等语言编写的程序时需要它</p>
<p>Networking
网络</p>
<p>Networking options</p>
<p>网络选项</p>
<p>Network packet debugging</p>
<p>在调试不合格的包时加上额外的附加信息, 但在遇到 Dos 攻击时你可能会被日志淹没</p>
<p>Packet socket</p>
<p>这种 Socket 可以让应用程序 (比如 tcpdump,iptables) 直接与网络设备通讯, 而不通过内核中的其它中介协议</p>
<p>Packet socket: mmapped IO</p>
<p>让 Packet socket 驱动程序使用 IO 映射机制以使连接速度更快</p>
<p>Unix domain sockets</p>
<p>一种仅运行于本机上的效率高于 TCP/IP 的 Socket, 简称 Unix socket. 许多程序都使用它在操作系统内部进行进程间通信 (IPC), 比如 X Window 和 syslog</p>
<p>Transformation user configuration interface</p>
<p>为 IPsec(可在 ip 层加密) 之类的工具提供 XFRM 用户配置接口支持</p>
<p>Transformation sub policy support</p>
<p>XFRM 子策略支持, 仅供开发者使用</p>
<p>PF_KEY sockets</p>
<p>用于可信任的密钥管理程序和操作系统内核内部的密钥管理进行通信, IPsec 依赖于它</p>
<p>TCP/IP networking</p>
<p>TCP/IP 协议当然要选</p>
<p>IP: multicasting</p>
<p>群组广播, 似乎与网格计算有关, 仅在使用 MBONE 的时候才需要</p>
<p>IP: advanced router</p>
<p>高级路由, 如果想做一个路由器就选吧</p>
<p>IP: policy routing</p>
<p>策略路由</p>
<p>IP: equal cost multipath</p>
<p>用于路由的基于目的地址的负载均衡</p>
<p>IP: verbose route monitoring</p>
<p>显示冗余的路由监控信息</p>
<p>IP: kernel level autoconfiguration</p>
<p>在内核启动时自动配置 ip 地址 / 路由表等, 需要从网络启动的无盘工作站才需要这个东西</p>
<p>IP: tunneling</p>
<p>IP 隧道, 将一个 IP 报文封装在另一个 IP 报文内的技术</p>
<p>IP: GRE tunnels over IP</p>
<p>基于 IP 的 GRE(通用路由封装) 隧道</p>
<p>IP: multicast routing</p>
<p>多重传播路由</p>
<p>IP: ARP daemon support</p>
<p>这东西尚处于试验阶段就已经被废弃了</p>
<p>IP: TCP syncookie support</p>
<p>抵抗 SYN flood 攻击的好东西, 要启用它必须同时启用 / proc 文件系统和 &ldquo;Sysctl support&rdquo;, 然后在系统启动并挂载了 / proc 之后执行 &ldquo;echo 1 &gt;/proc/sys/net/ipv4/tcp_syncookies&rdquo; 命令</p>
<p>IP: AH transformation</p>
<p>IPsec 验证头 (AH) 实现了数据发送方的验证处理, 可确保数据既对于未经验证的站点不可用也不能在路由过程中更改</p>
<p>IP: ESP transformation</p>
<p>IPsec 封闭安全负载 (ESP) 实现了发送方的验证处理和数据加密处理, 用以确保数据不会被拦截 / 查看或复制</p>
<p>IP: IPComp transformation</p>
<p>IPComp(IP 静荷载压缩协议), 用于支持 IPsec</p>
<p>IP: IPsec transport mode</p>
<p>IPsec 传输模式, 常用于对等通信, 用以提供内网安全. 数据包经过了加密但 IP 头没有加密, 因此任何标准设备或软件都可查看和使用 IP 头</p>
<p>IP: IPsec tunnel mode</p>
<p>IPsec 隧道模式, 用于提供外网安全 (包括虚拟专用网络). 整个数据包(数据头和负载) 都已经过加密处理且分配有新的 ESP 头 / IP 头和验证尾, 从而能够隐藏受保护站点的拓扑结构</p>
<p>IP: IPsec BEET mode</p>
<p>IPsec BEET 模式</p>
<p>INET: socket monitoring interface</p>
<p>socket 监视接口, 一些 Linux 本地工具 (如: 包含 ss 的 iproute2) 需要使用它</p>
<p>TCP: advanced congestion control</p>
<p>高级拥塞控制, 如果没有特殊需求 (比如无线网络) 就别选了, 内核会自动将默认的拥塞控制设为 &ldquo;Cubic&rdquo; 并将 &ldquo;Reno&rdquo; 作为候补</p>
<p>IP: Virtual Server Configuration</p>
<p>IP 虚拟服务器允许你基于多台物理机器构建一台高性能的虚拟服务器, 不玩集群就别选了</p>
<p>The IPv6 protocol</p>
<p>你要是需要 IPv6 就选吧</p>
<p>NetLabel subsystem support</p>
<p>NetLabel 子系统为诸如 CIPSO 与 RIPSO 之类能够在分组信息上添加标签的协议提供支持, 如果你看不懂就别选了</p>
<p>Security Marking</p>
<p>对网络包进行安全标记, 类似于 nfmark, 但主要是为安全目的而设计, 如果你不明白的话就别选</p>
<p>Network packet filtering (replaces ipchains)</p>
<p>Netfilter 可以对数据包进行过滤和修改, 可以作为防火墙 (&ldquo;packet filter&rdquo; 或 &ldquo;proxy-based&rdquo;) 或网关 (NAT) 或代理 (proxy) 或网桥使用. 选中此选项后必须将 &ldquo;Fast switching&rdquo; 关闭, 否则将前功尽弃</p>
<p>Network packet filtering debugging</p>
<p>仅供开发者调试 Netfilter 使用</p>
<p>Bridged IP/ARP packets filtering</p>
<p>如果你希望使用一个针对桥接的防火墙就打开它</p>
<p>Core Netfilter Configuration</p>
<p>核心 Netfilter 配置 (当包流过 Chain 时如果 match 某个规则那么将由该规则的 target 来处理, 否则将由同一个 Chain 中的下一个规则进行匹配, 若不 match 所有规则那么最终将由该 Chain 的 policy 进行处理)</p>
<p>Netfilter netlink interface</p>
<p>允许 Netfilter 在与用户空间通信时使用新的 netlink 接口. netlink Socket 是 Linux 用户态与内核态交流的主要方法之一, 且越来越被重视</p>
<p>Netfilter NFQUEUE over NFNETLINK interface</p>
<p>通过 NFNETLINK 接口对包进行排队</p>
<p>Netfilter LOG over NFNETLINK interface</p>
<p>通过 NFNETLINK 接口对包记录. 该选项废弃了 ipt_ULOG 和 ebg_ulog 机制, 并打算在将来废弃基于 syslog 的 ipt_LOG 和 ip6t_LOG 模块</p>
<p>Layer 3 Independent Connection tracking</p>
<p>独立于第三层的链接跟踪, 通过广义化的 ip_conntrack 支持其它非 IP 协议的第三层协议</p>
<p>Netfilter Xtables support</p>
<p>如果你打算使用 ip_tables,ip6_tables,arp_tables 之一就必须选上</p>
<p>&ldquo;CLASSIFY&rdquo; target support</p>
<p>允许为包设置优先级, 一些排队规则 (atm,cbq,dsmark,pfifo_fast,htb,prio) 需要使用它</p>
<p>&ldquo;CONNMARK&rdquo; target support</p>
<p>类似于 &ldquo;MARK&rdquo;, 但影响的是连接标记的值</p>
<p>&ldquo;DSCP&rdquo; target support</p>
<p>允许对 ip 包头部的 DSCP(Differentiated Services Codepoint) 字段进行修改, 该字段常用于 Qos</p>
<p>&ldquo;MARK&rdquo; target support</p>
<p>允许对包进行标记 (通常配合 ip 命令使用), 这样就可以改变路由策略或者被其它子系统用来改变其行为</p>
<p>&ldquo;NFQUEUE&rdquo; target Support</p>
<p>用于替代老旧的 QUEUE(iptables 内建的 target 之一), 因为 NFQUEUE 能支持最多 65535 个队列, 而 QUEUE 只能支持一个</p>
<p>&ldquo;NOTRACK&rdquo; target support</p>
<p>允许规则指定哪些包不进入链接跟踪 / NAT 子系统</p>
<p>&ldquo;SECMARK&rdquo; target support</p>
<p>允许对包进行安全标记, 用于安全子系统</p>
<p>&ldquo;CONNSECMARK&rdquo; target support</p>
<p>针对链接进行安全标记, 同时还会将连接上的标记还原到包上 (如果链接中的包尚未进行安全标记), 通常与 SECMARK target 联合使用</p>
<p>&ldquo;comment&rdquo; match support</p>
<p>允许你在 iptables 规则集中加入注释</p>
<p>&ldquo;connbytes&rdquo; per-connection counter match support</p>
<p>允许针对单个连接内部每个方向 (进 / 出) 匹配已经传送的字节数 / 包数</p>
<p>&ldquo;connmark&rdquo; connection mark match support</p>
<p>允许针对每个会话匹配先前由 &ldquo;CONNMARK&rdquo; 设置的标记值</p>
<p>&ldquo;conntrack&rdquo; connection tracking match support</p>
<p>连接跟踪匹配, 是 &ldquo;state&rdquo; 的超集, 它允许额外的链接跟踪信息, 在需要设置一些复杂的规则 (比如网关) 时很有用</p>
<p>&ldquo;DCCP&rdquo; protocol match support</p>
<p>DCCP 是打算取代 UDP 的新传输协议, 它在 UDP 的基础上增加了流控和拥塞控制机制, 面向实时业务</p>
<p>&ldquo;DSCP&rdquo; match support</p>
<p>允许对 IP 包头的 DSCP 字段进行匹配</p>
<p>&ldquo;ESP&rdquo; match support</p>
<p>允许对 IPSec 包中的 ESP 头进行匹配, 使用 IPsec 的话就选上吧</p>
<p>&ldquo;helper&rdquo; match support</p>
<p>加载特定协议的连接跟踪辅助模块, 由该模块过滤所跟踪的连接类型的包, 比如 ip_conntrack_ftp 模块</p>
<p>&ldquo;length&rdquo; match support</p>
<p>允许对包的长度进行匹配</p>
<p>&ldquo;limit&rdquo; match support</p>
<p>允许根据包的进出速率进行规则匹配, 常和 &ldquo;LOG target&rdquo; 配合使用以抵抗某些 Dos 攻击</p>
<p>&ldquo;mac&rdquo; address match support</p>
<p>允许根据以太网的 MAC 进行匹配, 常用于无线网络环境</p>
<p>&ldquo;mark&rdquo; match support</p>
<p>允许对先前由 &ldquo;MARK&rdquo; 标记的特定标记值进行匹配</p>
<p>IPsec &ldquo;policy&rdquo; match support</p>
<p>使用 IPsec 就选上吧</p>
<p>Multiple port match support</p>
<p>允许对 TCP 或 UDP 包同时匹配多个端口 (通常情况下只能匹配一个端口)</p>
<p>&ldquo;physdev&rdquo; match support</p>
<p>允许对到达的或将要离开的物理桥端口进行匹配</p>
<p>&ldquo;pkttype&rdquo; packet type match support</p>
<p>允许对封包目的地址类别 (广播 / 群播 / 直播) 进行匹配</p>
<p>&ldquo;quota&rdquo; match support</p>
<p>允许对总字节数的限额值进行匹配</p>
<p>&ldquo;realm&rdquo; match support</p>
<p>允许对 iptables 中的路由子系统中的 realm 值进行匹配</p>
<p>&ldquo;sctp&rdquo; protocol match support</p>
<p>流控制传输协议 (SCTP), 十年以后也许能够普及的东西</p>
<p>&ldquo;state&rdquo; match support</p>
<p>这是对包进行分类的有力工具, 它允许利用连接跟踪信息对连接中处于特定状态的包进行匹配</p>
<p>&ldquo;statistic&rdquo; match support</p>
<p>允许根据一个给定的百分率对包进行周期性的或随机性的匹配</p>
<p>&ldquo;string&rdquo; match support</p>
<p>允许根据包所承载的数据中包含的特定字符串进行匹配</p>
<p>&ldquo;tcpmss&rdquo; match support</p>
<p>允许根据 TCP SYN 包头中的 MSS(最大分段长度) 选项的值进行匹配</p>
<p>IP: Netfilter Configuration</p>
<p>针对 IPv4 的 Netfilter 配置</p>
<p>Connection tracking (required for masq/NAT)</p>
<p>链接跟踪. 可用于报文伪装或地址转换, 也可用于增强包过滤能力</p>
<p>Connection tracking flow accounting</p>
<p>允许针对每个连接记录已经传送的字节 / 包数, 常用于 connbytes match</p>
<p>Connection mark tracking support</p>
<p>允许对连接进行标记, 与针对单独的包进行标记的不同之处在于它是针对连接流的. CONNMARK target 和 connmark match 需要它的支持</p>
<p>Connection tracking security mark support</p>
<p>允许对连接进行安全标记, 通常这些标记包 (SECMARK) 复制到其所属连接(CONNSECMARK), 再从连接复制到其关联的包(SECMARK)</p>
<p>Connection tracking events</p>
<p>连接跟踪事件支持. 如果启用这个选项, 连接跟踪代码将提供一个 notifier 链, 它可以被其它内核代码用来获知连接跟踪状态的改变</p>
<p>Connection tracking netlink interface</p>
<p>支持基于 netlink 的用户空间接口</p>
<p>SCTP protocol connection tracking support</p>
<p>SCTP 是 IP 网面向多媒体通信的新一代的流控制传输协议</p>
<p>FTP protocol support</p>
<p>FTP 协议</p>
<p>IRC protocol support</p>
<p>IRC 协议是一种用来实时聊天协议, 用过 mIRC 的人应当不陌生</p>
<p>NetBIOS name service protocol support</p>
<p>NetBIOS 名字服务协议</p>
<p>TFTP protocol support</p>
<p>TFTP 是基于 UDP 的比 FTP 简单的文件传输协议</p>
<p>Amanda backup protocol support</p>
<p>Amanda 备份协议</p>
<p>PPTP protocol support</p>
<p>点对点隧道协议 (PPTP) 是一种支持多协议虚拟专用网络的网络技术, ADSL 用户对它应该很熟悉</p>
<p>H.323 protocol support</p>
<p>ITU-T 提出的用于 IP 电话的协议</p>
<p>SIP protocol support</p>
<p>IETE 提出的用于 IP 电话的协议</p>
<p>IP Userspace queueing via NETLINK</p>
<p>已废弃</p>
<p>IP tables support (required for filtering/masq/NAT)</p>
<p>要用 iptables 就肯定要选上</p>
<p>IP range match support</p>
<p>允许对 ip 地址的范围进行匹配</p>
<p>TOS match support</p>
<p>允许对 ip 包头的 TOS(Type Of Service) 字段进行匹配</p>
<p>recent match support</p>
<p>可以创建一个或多个刚刚使用过的 ip 地址列表, 然后根据这些列表进行匹配</p>
<p>ECN match support</p>
<p>允许对 TCP/IP 包头的 ECN(Explicit Congestion Notification) 字段进行匹配. ECN 是一种显式拥塞通知技术, 它不但要求路由器支持而且要求端到端主机的支持, 其基本思想是当路由器发生早期拥塞时不是丢弃包而是尽量对包进行标记, 接收方接到带有 ECN 提示的包时, 通知发送方网络即将发生拥塞, 也就是它通过对包的标记提示 TCP 源即将发生拥塞, 从而引发拥塞避免算法</p>
<p>AH match support</p>
<p>允许对 IPSec 包头的 AH 字段进行匹配</p>
<p>TTL match support</p>
<p>允许对 ip 包头的 TTL(生存期) 字段进行匹配</p>
<p>Owner match support</p>
<p>允许对本地生成的包按照其宿主 (user,group,process,session) 进行匹配</p>
<p>address type match support</p>
<p>允许对地址类型 (单播, 本地, 广播) 进行匹配</p>
<p>hashlimit match support</p>
<p>是 limit 的升级, 它基于你选择的 ip 地址与 / 或端口动态的创建以 limit 为桶 (bucket) 的哈希表. 它可以创建诸如 &ldquo;为每个特定的目标 IP 分配 10kpps&rdquo; 或 &ldquo;允许每个特定的源 IP 分配 500pps&rdquo; 之类的规则</p>
<p>Packet filtering</p>
<p>定义 filter 表以允许对包进行过滤</p>
<p>REJECT target support</p>
<p>允许返回一个 ICMP 错误而不是简单的丢弃包</p>
<p>LOG target support</p>
<p>允许将符合条件的包头信息通过 syslog 进行记录</p>
<p>ULOG target support</p>
<p>透过 netlink socket 将符合条件的封包交给用户空间的 ulogd 守护进程. 反对使用该选项, 因为它已经被 NETFILTER_NETLINK_LOG 代替</p>
<p>TCPMSS target support</p>
<p>允许修改 TCP 包头中的 MSS(最大分段长度) 选项值</p>
<p>Full NAT</p>
<p>允许进行伪装 / 端口转发以及其它的 NAT 功能, 仅在你需要使用 iptables 中的 nat 表时才需要选择</p>
<p>Packet mangling</p>
<p>在 iptables 中启用 mangle 表以便对包进行各种修改, 常用于改变包的路由</p>
<p>raw table support (required for NOTRACK/TRACE)</p>
<p>在 iptables 中添加一个&rsquo;raw&rsquo;表, 该表在 netfilter 框架中非常靠前, 并在 PREROUTING 和 OUTPUT 链上有钩子, 从而可以对收到的数据包在连接跟踪前进行处理</p>
<p>ARP tables support</p>
<p>ARP 表支持. 只有在局域网中才有 ARP 欺骗问题, 另外路由器也会遭到 ARP 欺骗</p>
<p>ARP packet filtering</p>
<p>ARP 包过滤. 对于进入和离开本地的 ARP 包定义一个 filter 表, 在桥接的情况下还可以应用于被转发 ARP 包</p>
<p>ARP payload mangling</p>
<p>允许对 ARP 包的荷载部分进行修改, 比如修改源和目标物理地址</p>
<p>IPv6: Netfilter Configuration</p>
<p>针对 IPv6 的 Netfilter 配置, 需要的话可以参考前面 IPv4 的 Netfilter 配置进行选择</p>
<p>DECnet: Netfilter Configuration</p>
<p>针对 DECnet 的 Netfilter 配置</p>
<p>Bridge: Netfilter Configuration</p>
<p>针对桥接的 Netfilter 配置</p>
<p>DCCP Configuration</p>
<p>数据报拥塞控制协议在 UDP 的基础上增加了流控和拥塞控制机制, 使数据报协议能够更好地用于流媒体业务的传输</p>
<p>SCTP Configuration</p>
<p>流控制传输协议是一种新兴的传输层协议. TCP 协议一次只能连接一个 IP 地址而在 SCTP 协议一次可以连接多个 IP 地址且可以自动平衡网络负载, 一旦某一个 IP 地址失效会自动将网络负载转移到其他 IP 地址上</p>
<p>TIPC Configuration</p>
<p>透明内部进程间通信协议, 以共享内存为基础实现任务和资源的调度, 专门用于内部集群通信</p>
<p>Asynchronous Transfer Mode (ATM)</p>
<p>异步传输模式 (ATM) 支持</p>
<p>802.1d Ethernet Bridging</p>
<p>802.1d 以太网桥</p>
<p>802.1Q VLAN Support</p>
<p>802.1Q 虚拟局域网</p>
<p>DECnet Support</p>
<p>DECnet 是一种很生僻的协议</p>
<p>ANSI/IEEE 802.2 LLC type 2 Support</p>
<p>看不懂可以不选</p>
<p>The IPX protocol</p>
<p>IPX 协议</p>
<p>Appletalk protocol support</p>
<p>与 Mac 机器通信的协议</p>
<p>CCITT X.25 Packet Layer</p>
<p>大约没人需要这东西</p>
<p>LAPB Data Link Driver</p>
<p>大约没人需要这东西</p>
<p>Acorn Econet/AUN protocols</p>
<p>一种被 Acorn 计算机使用的又老又慢的协议</p>
<p>WAN router</p>
<p>广域网路由</p>
<p>QoS and/or fair queueing</p>
<p>如果你需要 Qos 或公平队列就选吧</p>
<p>Network testing</p>
<p>网络测试, 仅供调试使用</p>
<p>Amateur Radio support</p>
<p>业余无线电支持</p>
<p>IrDA (infrared) subsystem support</p>
<p>红外线支持, 比如无线鼠标或无线键盘</p>
<p>Bluetooth subsystem support</p>
<p>蓝牙支持</p>
<p>Generic IEEE 802.11 Networking Stack</p>
<p>通用无线局域网 (IEEE 802.11 系列协议) 支持</p>
<p>Device Drivers
设备驱动程序</p>
<p>Generic Driver Options</p>
<p>驱动程序通用选项</p>
<p>Select only drivers that don&rsquo;t need compile-time external firmware</p>
<p>只显示那些不需要内核对外部设备的固件作 map 支持的驱动程序, 除非你有某些怪异硬件, 否则请选上</p>
<p>Prevent firmware from being built</p>
<p>不编译固件. 固件一般是随硬件的驱动程序提供的, 仅在更新固件的时候才需要重新编译. 建议选上</p>
<p>Userspace firmware loading support</p>
<p>提供某些内核之外的模块需要的用户空间固件加载支持, 在内核树之外编译的模块可能需要它</p>
<p>Driver Core verbose debug messages</p>
<p>让驱动程序核心在系统日志中产生冗长的调试信息, 仅供调试</p>
<p>Connector - unified userspace &lt;-&gt; kernelspace linker</p>
<p>统一的用户空间和内核空间连接器, 工作在 netlink socket 协议的顶层. 不确定可以不选</p>
<p>Report process events to userspace</p>
<p>向用户空间报告进程事件 (fork,exec,id 变化 (uid,gid,suid)</p>
<p>Memory Technology Devices (MTD)</p>
<p>特殊的存储技术装置, 如常用于数码相机或嵌入式系统的闪存卡</p>
<p>Parallel port support</p>
<p>并口支持 (传统的打印机接口)</p>
<p>Plug and Play support</p>
<p>即插即用支持, 若未选则应当在 BIOS 中关闭 &ldquo;PnP OS&rdquo;. 这里的选项与 PCI 设备无关</p>
<p>PnP Debug Messages</p>
<p>该选项仅供调试使用</p>
<p>ISA Plug and Play support</p>
<p>ISA 设备即插即用支持</p>
<p>Plug and Play BIOS support</p>
<p>Linux 使用 &ldquo;Plug and Play BIOS&rdquo; 规范 v1.0A(1994 年)中定义的 PNPBIOS 自动检测主板上的资源和设备, 但是其中的某些特性目前尚未实现, 比如: 事件通知 / 扩展坞 (Docking Station) 信息 / ISAPNP 服务. 如果你希望由内核检测主板上的设备并为其分配资源 (此时 BIOS 中的 &ldquo;PnP OS&rdquo; 必须开启) 可以选上, 此外, PNPBIOS 还有助于防止主板上的设备与其他总线设备冲突. 不过需要注意的是 ACPI 将会逐渐取代 PNPBIOS(虽然目前两者可以共存), 所以如果你的系统不使用 ISA 设备并且支持 ACPI, 建议你不要选中该选项并将 BIOS 中的 &ldquo;PnP OS&rdquo; 关闭</p>
<p>Plug and Play BIOS /proc interface</p>
<p>该选项仅供调试使用</p>
<p>Plug and Play ACPI support</p>
<p>让 Linux 使用 PNPACPI 自动检测主板上内建的设备并为其分配资源 (即使这些设备已被 BIOS 禁用), 它有助于避免设备之间的资源(如中断) 冲突</p>
<p>Block devices</p>
<p>块设备</p>
<p>Normal floppy disk support</p>
<p>通用软驱支持</p>
<p>XT hard disk support</p>
<p>古董级产品</p>
<p>Parallel port IDE device support</p>
<p>通过并口与计算机连接的 IDE 设备, 比如某些老旧的外接光驱或硬盘之类</p>
<p>Compaq SMART2 support</p>
<p>基于 Compaq SMART2 控制器的磁盘阵列卡</p>
<p>Compaq Smart Array 5xxx support</p>
<p>基于 Compaq SMART 控制器的磁盘阵列卡</p>
<p>Mylex DAC960/DAC1100 PCI RAID Controller support</p>
<p>古董级产品</p>
<p>Micro Memory MM5415 Battery Backed RAM support</p>
<p>一种使用电池做后备电源的内存</p>
<p>Loopback device support</p>
<p>Loopback 是指拿文件来模拟块设备, 比如可以将一个 iso9660 镜像文件挂成一个文件系统</p>
<p>Cryptoloop Support</p>
<p>使用系统提供的加密 API 对 Loopback 设备加密, 但不能用于日志型文件系统</p>
<p>Network block device support</p>
<p>让你的电脑成为网络块设备的客户端</p>
<p>Promise SATA SX8 support</p>
<p>基于 Promise 公司的 SATA SX8 控制器的 RAID 卡</p>
<p>Low Performance USB Block driver</p>
<p>它不是用来支持 U 盘的, 不懂的就别选</p>
<p>RAM disk support</p>
<p>内存中的虚拟磁盘, 大小固定 (由下面的选项决定, 也可给内核传递 &ldquo;ramdisk_size = 参数&rdquo; 来决定), 它的功能和代码都比 shmem 简单许多</p>
<p>Default number of RAM disks</p>
<p>默认 RAM disk 的数量</p>
<p>Default RAM disk size (kbytes)</p>
<p>仅在你真正知道它的含义时才允许修改</p>
<p>Default RAM disk block size (bytes)</p>
<p>每一个 RAM disk 的默认块大小, 设为 PAGE_SIZE 的值时效率最高</p>
<p>Initial RAM filesystem and RAM disk (initramfs/initrd) support</p>
<p>如果启动计算机所必须的模块都在内核里的话可以不选此项</p>
<p>Packet writing on CD/DVD media</p>
<p>CD/DVD 刻录支持</p>
<p>Free buffers for data gathering</p>
<p>用于收集写入数据的缓冲区个数 (每个占用 64Kb 内存), 缓冲区越多性能越好</p>
<p>Enable write caching</p>
<p>为 CD-R/W 设备启用写入缓冲, 目前这是一个比较危险的选项</p>
<p>ATA over Ethernet support</p>
<p>以太网 ATA 设备支持</p>
<p>Misc devices</p>
<p>杂项设备</p>
<p>ATA/ATAPI/MFM/RLL support</p>
<p>通常是 IDE 硬盘和 ATAPI 光驱. 纯 SCSI 系统且不使用这些接口可以不选</p>
<p>Max IDE interfaces</p>
<p>最大 IDE 接口数, 两个 IDE 插槽一般相当于 4 个接口</p>
<p>Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support</p>
<p>EIDE 支持是当然要选的, 否则 540MB 以上的硬盘都不认识而且不支持主从设备</p>
<p>Support for SATA (deprecated; conflicts with libata SATA driver)</p>
<p>反对使用, 该选项与 libata SATA 驱动有冲突</p>
<p>Use old disk-only driver on primary interface</p>
<p>没人用这些古董了</p>
<p>Include IDE/ATA-2 DISK support</p>
<p>ATA-2 支持, 除非你的硬盘是古董, 否则必选</p>
<p>Use multi-mode by default</p>
<p>如果不确定就别选, 除非出现帮助中指出的错误</p>
<p>PCMCIA IDE support</p>
<p>通过 PCMCIA 卡与计算机连接的 IDE 设备, 比如某些外置硬盘或光驱</p>
<p>Include IDE/ATAPI CDROM support</p>
<p>有 IDE 光驱的就选</p>
<p>Include IDE/ATAPI TAPE support</p>
<p>有 IDE 磁带的就选</p>
<p>Include IDE/ATAPI FLOPPY support</p>
<p>有 IDE 软驱的就选</p>
<p>SCSI emulation support</p>
<p>SCSI 仿真, 以前刻录光碟时需要, 现在不需要了</p>
<p>IDE Taskfile Access</p>
<p>对介质进行直接的原始访问, 它是一个复杂且有效的测试和校验硬件的方案, 可以在驱动层之下执行数据恢复工作</p>
<p>generic/default IDE chipset support</p>
<p>通用 IDE 芯片组支持</p>
<p>CMD640 chipset bugfix/support</p>
<p>586 以前的主板上常用, 毛病多多</p>
<p>PNP EIDE support</p>
<p>外接的即插即用 EIDE 卡支持</p>
<p>PCI IDE chipset support</p>
<p>基于 PCI 总线的 IDE 芯片组支持, 帮助 IDE 驱动自动检测和配置所有基于 PCI 的 IDE 接口</p>
<p>Sharing PCI IDE interrupts support</p>
<p>与其他 PCI 设备共享中断, 一来可能冲突, 二来降低性能, 不选为妙</p>
<p>Boot off-board chipsets first support</p>
<p>不使用外接 IDE 控制器的就别选, 使用外接 IDE 控制器的注意看帮助</p>
<p>Generic PCI IDE Chipset Support</p>
<p>通用的 PCI IDE 芯片组支持, 如果你的芯片组在下面能找到就别选</p>
<p>OPTi 82C621 chipset enhanced support</p>
<p>OPTi 82C621 EIDE 控制器</p>
<p>RZ1000 chipset bugfix/support</p>
<p>486/586 年代的玩艺</p>
<p>Generic PCI bus-master DMA support</p>
<p>通用的 PCI 总线控制器 DMA 支持, 586 以上的系统都支持</p>
<p>Force enable legacy 2.0.X HOSTS to use DMA</p>
<p>历史遗留问题, 别管它, 不选</p>
<p>Use PCI DMA by default when available</p>
<p>默认启用 DMA,586 以上的系统都支持, 建议选择</p>
<p>Enable DMA only for disks</p>
<p>只对硬盘启用 DMA, 若你的光驱不支持 DMA 就选上</p>
<p>{此处省略的部分按照自己主板上实际使用的芯片组进行选择}</p>
<p>Other IDE chipset support</p>
<p>其它 IDE 芯片组支持 (多数需要在引导时指定特定的内核参数), 如果你使用这样的芯片组就按实际情况选择子项吧</p>
<p>IGNORE word93 Validation BITS</p>
<p>ATA-4 和 ATA-5 规范中对于如何在 80 针的数据线上探测解释的不明确, 导致了两种不同标准的产品同时出现, 这可能导致 ATA-66/100 降低为 ATA-33, 若出现这个问题, 可以打开这个选项忽略这种不同, 但是又有可能导致另外的问题</p>
<p>Old hard disk (MFM/RLL/IDE) driver</p>
<p>旧版本的 MFM/RLL/IDE 驱动, 不建议使用</p>
<p>SCSI device support</p>
<p>SCSI 设备</p>
<p>RAID Transport Class</p>
<p>用于 SCSI 设备的软件 RAID 支持, 需要配合外部工具</p>
<p>SCSI device support</p>
<p>有任何 SCSI/SATA/USB / 光纤 / FireWire/IDE-SCSI 仿真设备之一就必须选上</p>
<p>legacy /proc/scsi/ support</p>
<p>一些老的刻录程序可能需要它</p>
<p>SCSI disk support</p>
<p>SCSI 硬盘或 U 盘</p>
<p>SCSI tape support</p>
<p>SCSI 磁带</p>
<p>SCSI OnStream SC-x0 tape support</p>
<p>另一种 SCSI 磁带</p>
<p>SCSI CDROM support</p>
<p>SCSI CDROM</p>
<p>Enable vendor-specific extensions</p>
<p>仅在古董级的 SCSI CDROM 设备上才需要</p>
<p>SCSI generic support</p>
<p>若有 SCSI 硬盘 / CD-ROM/tape 之外的 SCSI 设备才需要选择</p>
<p>SCSI media changer support</p>
<p>一种 SCSI 备份设备</p>
<p>Probe all LUNs on each SCSI device</p>
<p>在每个 SCSI 设备上探测逻辑设备数. 只在一个 SCSI 设备上有多个逻辑设备 (模拟多个 SCSI 设备, 比如多口读卡器) 时才需要选它, 一般的 SCSI 设备不需要</p>
<p>Verbose SCSI error reporting</p>
<p>以易读的方式报告 SCSI 错误, 内核将会增大 12K</p>
<p>SCSI logging facility</p>
<p>启用 SCSI 日志 (默认并不开启, 需要在挂载 / proc 后执行 echo &ldquo;scsi log token [level]&rdquo; &gt; /proc/scsi/scsi 命令才能打开日志), 可用于跟踪和捕获 SCSI 设备的错误</p>
<p>SCSI Transports</p>
<p>SCSI 接口类型, 下面的子项可以全不选, 内核中若有其他部分依赖它, 会自动选上</p>
<p>Parallel SCSI (SPI) Transport Attributes</p>
<p>传统且常见的并行 SCSI(Ultra320/160 之类)</p>
<p>FiberChannel Transport Attributes</p>
<p>光纤通道</p>
<p>iSCSI Transport Attributes</p>
<p>iSCSI 是利用 TCP/IP 网络传送 SCSI 命令和数据的 I/O 技术</p>
<p>SAS Transport Attributes</p>
<p>串行 SCSI 传输属性支持 (SAS 对于的关系 SPI 犹如 SATA 对于 ATA)</p>
<p>SAS Domain Transport Attributes</p>
<p>为使用了 SAS Domain 的驱动程序提供帮助</p>
<p>Compile the SAS Domain Transport Attributes in debug mode</p>
<p>仅供调试使用</p>
<p>SCSI low-level drivers</p>
<p>底层 SCSI 驱动程序, 按你实际使用的产品选择</p>
<p>iSCSI Initiator over TCP/IP</p>
<p>用于 iSCSI 在 TCP/IP 网络上传播的起动程序</p>
<p>{此处省略的部分按照自己实际使用的控制器进行选择, 仅用一个例子解说子项}</p>
<p>Adaptec AIC79xx U320 support</p>
<p>以基于 PCI-X 的 Adaptec Ultra 320 SCSI 控制器为例解说子项</p>
<p>Maximum number of TCQ commands per device</p>
<p>每个 SCSI 设备的标记指令队列的最大长度 (上限 253). 上限越高性能越好, 但是对于 SCSI 设备较多的系统来说可能造成内存分配失败. 此值还可以通过 tag_info 内核引导参数指定</p>
<p>Initial bus reset delay in milli-seconds</p>
<p>初始总线 reset 之后的延时微秒数 (默认 5000)</p>
<p>Enable Read Streaming for All Targets</p>
<p>对所有的标记队列启用 Read Streaming(可以增强效能, 但是在一些 Adaptec 早期的 U320 产品上有缺陷), 此特性还可以通过 rd_strm 内核引导参数指定</p>
<p>Compile in Debugging Code</p>
<p>仅用于调试</p>
<p>Debug code enable mask (16383 for all debugging)</p>
<p>出错代码的掩码, 0 表示禁止所有, 16383 表示打开所有</p>
<p>Decode registers during diagnostics</p>
<p>将出错代码的解释内容编译进去, 这样就不需要查看 aic7xxx.reg 中的出错代码表以确定出错代码的含意了</p>
<p>PCMCIA SCSI adapter support</p>
<p>通过 PCMCIA 卡与计算机连接的 SCSI 设备</p>
<p>Serial ATA and Parallel ATA drivers</p>
<p>SATA 与 PATA 设备</p>
<p>ATA device support</p>
<p>SATA 或 PATA 接口的硬盘或光驱等设备</p>
<p>AHCI SATA support</p>
<p>SATA 高级主机控制器接口. 要使用 NCQ 功能就必须选中它, 另外 BIOS 中的 SATA 工作模式亦要选 AHCI 模式</p>
<p>Generic ATA support</p>
<p>基于新的 ATA 层的通用 ATA 控制器驱动, 仅在你的芯片组在列表中找不到时才需要</p>
<p>{此处省略的部分按照自己主板上实际使用的芯片组进行选择}</p>
<p>Old CD-ROM drivers (not SCSI, not IDE)</p>
<p>老旧的 CD-ROM 驱动, 这种 CD-ROM 既不使用 SCSI 接口, 也不使用 IDE 接口</p>
<p>Multi-device support (RAID and LVM)</p>
<p>多设备支持 (RAID 和 LVM).RAID 和 LVM 的功能是使多个物理设备组建成一个单独的逻辑磁盘</p>
<p>RAID support</p>
<p>软件 RAID(需要使用外部工具), 若你有硬件 RAID 控制器, 可以不选</p>
<p>Linear (append) mode</p>
<p>追加模式 (简单的将一个分区追加在另一个分区之后)</p>
<p>RAID-0 (striping) mode</p>
<p>RAID-0(等量分割) 模式</p>
<p>RAID-1 (mirroring) mode</p>
<p>RAID-1(镜像) 模式</p>
<p>RAID-10 (mirrored striping) mode</p>
<p>RAID 0 1 模式</p>
<p>RAID-4/RAID-5/RAID-6 mode</p>
<p>这些模式比较复杂, 一般不用</p>
<p>Support adding drives to a raid-5 array</p>
<p>RAID-5 阵列可以通过添加额外的驱动器进行扩展 (restriping), 这个选项允许在线进行这样的操作, 同时要求 mdadm 的版本大于 2.4.1</p>
<p>Multipath I/O support</p>
<p>多路 IO 支持是指在服务器和存储设备之间使用冗余的物理路径组件创建 &ldquo;逻辑路径&rdquo;, 如果这些组件发生故障并造成路径失败, 多路径逻辑将为 I/O 使用备用路径以使应用程序仍然可以访问其数据</p>
<p>Faulty test module for MD</p>
<p>用于 MD(Multi-device) 的缺陷测试模块</p>
<p>Device mapper support</p>
<p>Device-mapper 是一个底层的卷管理器, 不用 LVM 就别选了</p>
<p>Fusion MPT device support</p>
<p>Fusion MPT 设备支持</p>
<p>IEEE 1394 (FireWire) support</p>
<p>IEEE 1394(火线)</p>
<p>I2O device support</p>
<p>I2O(智能 IO) 设备使用专门的 I/O 处理器负责中断处理 / 缓冲存取 / 数据传输等烦琐任务以减少 CPU 占用, 一般的主板上没这种东西</p>
<p>Network device support</p>
<p>网络设备</p>
<p>Network device support</p>
<p>网络设备支持, 当然要选啦</p>
<p>Intermediate Functional Block support</p>
<p>这是一个中间层驱动, 可以用来灵活的配置资源共享, 看不懂的可以不选</p>
<p>Dummy net driver support</p>
<p>哑接口网络, 使用 SLIP 或 PPP 传输协议 (如 ADSL 用户) 的需要它</p>
<p>Bonding driver support</p>
<p>将多个以太网通道绑定为一个, 也就是两块网卡具有相同的 IP 地址并且聚合成一个逻辑链路工作, 可以用来实现负载均衡或硬件冗余</p>
<p>EQL (serial line load balancing) support</p>
<p>串行线路的负载均衡. 如果有两个 MODEM 和两条电话线而且用 SLIP 或 PPP 协议, 该选项可以让您同时使用这两个 MODEM 以达到双倍速度 (在网络的另一端也要有同样的设备)</p>
<p>Universal TUN/TAP device driver support</p>
<p>TUN/TAP 可以为用户空间提供包的接收和发送服务, 比如可以用来虚拟一张网卡或点对点通道</p>
<p>General Instruments Surfboard 1000</p>
<p>SURFboard 1000 插卡式 Cable Medem(ISA 接口), 这玩意大概早就绝种了</p>
<p>ARCnet devices</p>
<p>一般人没有 ARCnet 类型的网卡</p>
<p>PHY device support</p>
<p>数据链路层芯片简称为 MAC 控制器, 物理层芯片简称之为 PHY, 通常的网卡把 MAC 和 PHY 的功能做到了一颗芯片中, 但也有一些仅含 PHY 的 &ldquo;软网卡&rdquo;</p>
<p>Ethernet (10 or 100Mbit)</p>
<p>目前最广泛的 10/100M 网卡</p>
<p>Ethernet (1000 Mbit)</p>
<p>目前已成装机主流的 1000M 网卡</p>
<p>Ethernet (10000 Mbit)</p>
<p>万兆网卡无福消受啦</p>
<p>Token Ring devices</p>
<p>令牌环网设备</p>
<p>Wireless LAN (non-hamradio)</p>
<p>无线 LAN</p>
<p>PCMCIA network device support</p>
<p>PCMCIA 或 CardBus 网卡</p>
<p>Wan interfaces</p>
<p>WAN 接口</p>
<p>ATM drivers</p>
<p>异步传输模式</p>
<p>FDDI driver support</p>
<p>光纤分布式数据接口</p>
<p>HIPPI driver support</p>
<p>HIPPI(高性能并行接口) 是一个在短距离内高速传送大量数据的点对点协议</p>
<p>PLIP (parallel port) support</p>
<p>将并口映射成网络设备, 这样两台机器即使没有网卡也可以使用并口通过并行线传输 IP 数据包</p>
<p>PPP (point-to-point protocol) support</p>
<p>点对点协议, PPP 已经基本取代 SLIP 了, 用 ADSL 的可要仔细选择了</p>
<p>PPP multilink support</p>
<p>多重链路协议 (RFC1990) 允许你将多个线路 (物理的或逻辑的) 组合为一个 PPP 连接一充分利用带宽, 这不但需要 pppd 的支持, 还需要 ISP 的支持</p>
<p>PPP filtering</p>
<p>允许对通过 PPP 接口的包进行过滤</p>
<p>PPP support for async serial ports</p>
<p>通过标准异步串口 (COM1,COM2) 使用 PPP, 比如使用老式的外置 modem(非同步 modem 或 ISDN modem)上网</p>
<p>PPP support for sync tty ports</p>
<p>通过同步 tty 设备 (比如 SyncLink 适配器) 使用 PPP, 常用于高速租用线路(比如 T1/E1)</p>
<p>PPP Deflate compression</p>
<p>为 PPP 提供 Deflate(等价于 gzip 压缩算法) 压缩算法支持, 需要通信双方的支持才有效</p>
<p>PPP BSD-Compress compression</p>
<p>为 PPP 提供 BSD(等价于 LZW 压缩算法, 没有 gzip 高效) 压缩算法支持, 需要通信双方的支持才有效</p>
<p>PPP MPPE compression (encryption)</p>
<p>为 PPP 提供 MPPE 加密协议支持, 它被用于微软的 P2P 隧道协议中</p>
<p>PPP over Ethernet</p>
<p>这就是 ADSL 用户最常见的 PPPoE 啦, 也就是在以太网上跑的 PPP 协议</p>
<p>PPP over ATM</p>
<p>在 ATM 上跑的 PPP</p>
<p>SLIP (serial line) support</p>
<p>一个在串行线上 (例如电话线) 传输 IP 数据报的 TCP/IP 协议. 小猫一族的通讯协议, 与宽带用户无关</p>
<p>CSLIP compressed headers</p>
<p>CSLIP 协议比 SLIP 快, 它将 TCP/IP 头 (而非数据) 进行压缩传送, 需要通信双方的支持才有效</p>
<p>Keepalive and linefill</p>
<p>让 SLIP 驱动支持 RELCOM linefill 和 keepalive 监视, 这在信号质量比较差的模拟线路上是个好主意</p>
<p>Six bit SLIP encapsulation</p>
<p>这种线路非常罕见, 不要选它</p>
<p>Fibre Channel driver support</p>
<p>光纤通道</p>
<p>Traffic Shaper</p>
<p>流量整形, 已废弃</p>
<p>Network console logging support</p>
<p>通过网络记录内核信息</p>
<p>Netpoll support for trapping incoming packets</p>
<p>不知道 Netpoll 是什么的可以不选</p>
<p>Netpoll traffic trapping</p>
<p>不知道 Netpoll 是什么的可以不选</p>
<p>ISDN subsystem</p>
<p>综合业务数字网 (Integrated Service Digital Network)</p>
<p>Telephony Support</p>
<p>VoIP 支持</p>
<p>Input device support</p>
<p>输入设备</p>
<p>Generic input layer (needed for keyboard,mouse&hellip;)</p>
<p>通用输入层, 要使用键盘鼠标的就必选</p>
<p>Support for memoryless force-feedback devices</p>
<p>游戏玩家使用的力反馈设备</p>
<p>Mouse interface</p>
<p>鼠标接口</p>
<p>Provide legacy /dev/psaux device</p>
<p>仍然支持作为传统的 / dev/psaux 设备</p>
<p>Horizontal screen resolution</p>
<p>数字化转换器或图形输入板的水平分辩率</p>
<p>Vertical screen resolution</p>
<p>数字化转换器或图形输入板的垂直分辨率</p>
<p>Joystick interface</p>
<p>游戏杆</p>
<p>Touchscreen interface</p>
<p>触摸屏</p>
<p>Event interface</p>
<p>能够利用 / dev/input/eventX 来存取输入设备的事件</p>
<p>Event debugging</p>
<p>该选项仅供调试</p>
<p>Keyboards</p>
<p>键盘驱动, 一般选个 AT 键盘即可</p>
<p>Mouse</p>
<p>鼠标驱动, 一般选个 PS/2 鼠标即可</p>
<p>Joysticks</p>
<p>游戏杆驱动</p>
<p>Touchscreens</p>
<p>触摸屏驱动</p>
<p>Miscellaneous devices</p>
<p>其他杂项驱动, 一般选个 PC 喇叭即可</p>
<p>Hardware I/O ports</p>
<p>硬件 I/O 端口</p>
<p>Serial I/O support</p>
<p>使用 PS/2 键盘或鼠标的就必选</p>
<p>i8042 PC Keyboard controller</p>
<p>PS/2 接口的键盘和鼠标</p>
<p>Serial port line discipline</p>
<p>串口键盘或鼠标</p>
<p>ct82c710 Aux port controller</p>
<p>一种德州仪器 TravelMate 笔记本上使用 QuickPort 接口的鼠标</p>
<p>Parallel port keyboard adapter</p>
<p>并口键盘或鼠标</p>
<p>PCI PS/2 keyboard and PS/2 mouse controller</p>
<p>接在移动式扩展坞 (Docking station) 上的键盘或鼠标</p>
<p>PS/2 driver library</p>
<p>为 PS/2 接口上的设备提供驱动 (比如 PS/2 鼠标或标准 AT 键盘)</p>
<p>Raw access to serio ports</p>
<p>不是 hacker 就别选了</p>
<p>Gameport support</p>
<p>就是早年 &ldquo;小霸王&rdquo; 游戏机上的那种手柄</p>
<p>Character devices</p>
<p>字符设备</p>
<p>Virtual terminal</p>
<p>虚拟终端. 除非是嵌入式系统, 否则必选</p>
<p>Support for console on virtual terminal</p>
<p>内核将一个虚拟终端用作系统控制台 (将诸如模块错误 / 内核错误 / 启动信息之类的警告信息发送到这里, 通常是第一个虚拟终端). 除非是嵌入式系统, 否则必选</p>
<p>Support for binding and unbinding console drivers</p>
<p>虚拟终端是通过控制台驱动程序与物理终端相结合的, 但在某些系统上可以使用多个控制台驱动程序 (如 framebuffer 控制台驱动程序), 该选项使得你可以选择其中之一</p>
<p>Non-standard serial port support</p>
<p>非标准串口支持. 这样的设备早就绝种了</p>
<p>Serial drivers</p>
<p>串口驱动. 如果你有老式的串口鼠标或小猫之类的就选吧</p>
<p>Unix98 PTY support</p>
<p>伪终端 (PTY) 可以模拟一个终端, 它由 slave(等价于一个物理终端)和 master(被一个诸如 xterms 之类的进程用来读写 slave 设备)两部分组成的软设备. 使用 telnet 或 ssh 远程登录者必选</p>
<p>Legacy (BSD) PTY support</p>
<p>使用过时的 BSD 风格的 / dev/ptyxx 作为 master,/dev/ttyxx 作为 slave, 这个方案有一些安全问题, 建议不选</p>
<p>Parallel printer support</p>
<p>并口打印机</p>
<p>Support for console on line printer</p>
<p>允许将内核信息输出到并口, 这样就可以打印出来</p>
<p>Support for user-space parallel port device drivers</p>
<p>/dev/parport 设备支持, 比如 deviceid 之类的程序需要使用它, 大部分人可以关闭该选项</p>
<p>Texas Instruments parallel link cable support</p>
<p>德州仪器生产的一种使用并行电缆的图形计算器, 如果你不知道这是什么设备就别选了</p>
<p>IPMI</p>
<p>可以利用 IPMI 远程监视服务器的物理特征 (温度, 电压, 风扇, 电源, 机箱入侵), 它是独立于 CPU,BIOS,OS 的, 只要接通电源就可以实现对服务器的监控</p>
<p>IPMI top-level message handler</p>
<p>IPMI 消息处理器, 要启用 IPMI 远程监视这个就必选</p>
<p>Generate a panic event to all BMCs on a panic</p>
<p>当发生紧急情况 (panic) 时, IPMI 消息处理器将会向每一个已注册的底板管理控制器 (BMC) 接口生成一个描述该 panic 的 IPMI 事件, 这些事件可以引发日志记录 / 报警 / 重启 / 关机等动作</p>
<p>Generate OEM events containing the panic string</p>
<p>当发生紧急情况 (panic) 时, IPMI 消息处理器将会产生 OEM 类型的事件</p>
<p>Device interface for IPMI</p>
<p>为 IPMI 消息处理器提供一个 IOCTL 接口已便用户空间的进程也可以使用 IPMI</p>
<p>IPMI System Interface handler</p>
<p>向系统提供接口 (KCS,SMIC), 一般你用了 IPMI 就需要选上</p>
<p>IPMI Watchdog Timer</p>
<p>启用 IPMI Watchdog 定时器</p>
<p>IPMI Poweroff</p>
<p>允许 IPMI 消息处理器关闭机器</p>
<p>Watchdog Cards</p>
<p>能让系统在出现致命故障后自动重启, 如果没有硬件 Watchdog, 建议使用 Hangcheck timer 而不是软件 Watchdog</p>
<p>Watchdog Timer Support</p>
<p>选中它并选中下面的一个 Driver 之后, 再创建一个 / dev/watchdog 节点即可拥有一只 Watchdog 了. 更多信息请参考内核帮助</p>
<p>Disable watchdog shutdown on close</p>
<p>一旦 Watchdog 启动后就禁止将其停止</p>
<p>Software watchdog</p>
<p>软件 Watchdog, 使用它不需要有任何硬件的支持, 但是可靠性没有硬件 Watchdog 高</p>
<p>{此处省略的硬件 Watchdog 部分请按照自己主板实际使用的芯片 (可能在南桥中) 进行选择}</p>
<p>Hardware Random Number Generator Core support</p>
<p>硬件随机数发生器核心支持</p>
<p>Intel HW Random Number Generator support</p>
<p>Intel 芯片组的硬件随机数发生器</p>
<p>AMD HW Random Number Generator support</p>
<p>AMD 芯片组的硬件随机数发生器</p>
<p>AMD Geode HW Random Number Generator support</p>
<p>AMD Geode LX 的硬件随机数发生器</p>
<p>VIA HW Random Number Generator support</p>
<p>VIA 芯片组的硬件随机数发生器</p>
<p>/dev/nvram support</p>
<p>直接存取主板上 CMOS 的接口, 太危险了! 建议别选</p>
<p>Enhanced Real Time Clock Support</p>
<p>启用该选项并创建 / dev/rtc 文件后就可以通过 / proc/driver/rtc 访问系统的硬件时钟 (RTC), 众多功能依赖于它 (如 SMP,IRQ 共享, 定时器), 建议选择</p>
<p>Double Talk PC internal speech card support</p>
<p>由 RC Systems 公司制造的一种语音合成器</p>
<p>Siemens R3964 line discipline</p>
<p>与使用西门子 R3964 协议的设备同步通信, 除非你有一些诸如 PLC 之类的特殊设备, 否则别选</p>
<p>Applicom intelligent fieldbus card support</p>
<p>Applicom international 公司生产的用于现场总线连接卡</p>
<p>Sony Vaio Programmable I/O Control Device support</p>
<p>Sony VAIO 笔记本上的东西</p>
<p>Ftape, the floppy tape device driver</p>
<p>还使用磁带的就选吧</p>
<p>/dev/agpgart (AGP Support)</p>
<p>AGP 总线支持, 有 AGP 显卡的还必须从子项中选取符合自己显卡型号的驱动</p>
<p>Direct Rendering Manager</p>
<p>DRI 允许应用程序以高效安全的方式直接访问图形处理, 主要用于硬件 3D 加速. 桌面用户建议选择, 同时还必须从子项中选取符合自己显卡型号的驱动</p>
<p>PCMCIA character devices</p>
<p>使用 PCMCIA 接口的字符设备, 如果你有这种设备就到子项中去选吧</p>
<p>ACP Modem (Mwave) support</p>
<p>IBM Thinkpad 上的一种软猫, 古董产品</p>
<p>NatSemi SCx200 GPIO Support</p>
<p>松下的一种通用输入输出 (GPIO) 芯片, 常用于嵌入式系统</p>
<p>NatSemi PC8736x GPIO Support</p>
<p>松下的一种通用输入输出 (GPIO) 芯片, 常用于嵌入式系统</p>
<p>NatSemi Base GPIO Support</p>
<p>松下的一种通用输入输出 (GPIO) 芯片, 常用于嵌入式系统</p>
<p>AMD CS5535/CS5536 GPIO</p>
<p>常用于 AMD Geode 的一种通用输入输出 (GPIO) 芯片, 常用于嵌入式系统</p>
<p>RAW driver (/dev/raw/rawN)</p>
<p>已废弃</p>
<p>HPET - High Precision Event Timer</p>
<p>高精度事件定时器</p>
<p>Allow mmap of HPET</p>
<p>允许对 HPET 寄存器进行映射, 建议选中</p>
<p>Hangcheck timer</p>
<p>宕机检测定时器周期性地检查系统任务调度程序以确定系统的运行状况, 如果超过阈值, 计算机将重新启动. 它通常可以比 Watchdog 更好地解决可用性和可靠性问题</p>
<p>TPM devices</p>
<p>基于硬件的 &ldquo;可信赖平台模块&rdquo;, 与数字霸权管理是一路货, 全不选</p>
<p>Telecom clock driver for MPBL0010 ATCA SBC</p>
<p>没见过这种硬件, 不选</p>
<p>I2C support</p>
<p>I2C 是 Philips 极力推动的微控制应用中使用的低速串行总线协议, 可用于监控电压 / 风扇转速 / 温度等. SMBus(系统管理总线) 是 I2C 的子集. 除硬件传感器外 &ldquo;Video For Linux&rdquo; 也需要该模块的支持</p>
<p>I2C device interface</p>
<p>I2C 设备接口, 允许用户空间的程序通过 / dev/i2c-* 设备文件使用 I2C 总线</p>
<p>I2C Algorithms</p>
<p>I2C 算法, 可以全不选, 若有其他部分依赖其子项时, 会自动选上</p>
<p>I2C Hardware Bus support</p>
<p>按实际硬件情况选对应的子项即可</p>
<p>Miscellaneous I2C Chip support</p>
<p>其他不常见的产品, 按需选择</p>
<p>I2C Core debugging messages</p>
<p>仅供调试</p>
<p>I2C Algorithm debugging messages</p>
<p>仅供调试</p>
<p>I2C Bus debugging messages</p>
<p>仅供调试</p>
<p>I2C Chip debugging messages</p>
<p>仅供调试</p>
<p>SPI support</p>
<p>串行外围接口 (SPI) 常用于微控制器 (MCU) 与外围设备 (传感器, eeprom,flash, 编码器, 模数转换器) 之间的通信, 比如 MMC 和 SD 卡就通常需要使用 SPI</p>
<p>Dallas&rsquo;s 1-wire bus</p>
<p>一线总线</p>
<p>Hardware Monitoring support</p>
<p>当前主板大多都有一个监控硬件健康的设备用于监视温度 / 电压 / 风扇转速等, 请按照自己主板实际使用的芯片选择相应的子项. 另外, 该功能还需要 I2C 的支持</p>
<p>Multimedia devices</p>
<p>多媒体设备</p>
<p>Video For Linux</p>
<p>要使用音频 / 视频设备或 FM 收音卡的就必选, 此功能还需要 I2C 的支持</p>
<p>Enable Video For Linux API 1</p>
<p>使用老旧的 V4L 第一版 API, 反对使用</p>
<p>Enable Video For Linux API 1 compatible Layer</p>
<p>提供对第一版 V4L 的兼容, 建议不选</p>
<p>Video Capture Adapters</p>
<p>视频捕获卡</p>
<p>Enable advanced debug functionality</p>
<p>该选项仅供调试</p>
<p>Autoselect pertinent encoders/decoders and other helper chips</p>
<p>为视频卡自动选择所需的编码和解码模块, 建议选择</p>
<p>Virtual Video Driver</p>
<p>虚拟视频卡, 仅供测试视频程序和调试</p>
<p>SAA5246A, SAA5281 Teletext processor</p>
<p>该选项仅对欧洲用户有意义, 中国用户不需要</p>
<p>SAA5249 Teletext processor</p>
<p>该选项仅对欧洲用户有意义, 中国用户不需要</p>
<p>{此处省略的硬件请按照自己实际使用的芯片进行选择}</p>
<p>V4L USB devices</p>
<p>使用 USB 接口的视频卡, 子项请按照自己实际使用的视频卡选择</p>
<p>Radio Adapters</p>
<p>音频卡, 子项请按照自己实际使用的音频卡选择</p>
<p>Digital Video Broadcasting Devices</p>
<p>数字视频广播设备 (DVB 卡或机顶盒), 子项请按自己实际使用的硬件选择</p>
<p>DABUSB driver</p>
<p>USB 接口的数字音频广播设备接收器</p>
<p>Graphics support</p>
<p>图形设备 / 显卡支持</p>
<p>Enable firmware EDID</p>
<p>允许访问 Video BIOS 中的扩展显示器识别数据 (EDID), 使用 Matrox 显卡的建议关闭, 建议桌面用户选择</p>
<p>Support for frame buffer devices</p>
<p>帧缓冲设备是为了让应用程序使用统一的接口操作显示设备而对硬件进行的抽象, 建议桌面用户选择</p>
<p>Enable Video Mode Handling Helpers</p>
<p>使用 GTF 和 EDID 来帮助处理显示模式, 可以不选, 若有其他选项依赖于它时, 会自动选上</p>
<p>Enable Tile Blitting Support</p>
<p>可以不选, 若有其他选项依赖于它时, 会自动选上</p>
<p>VGA 16-color graphics support</p>
<p>16 色 VGA 显卡. 如果你有这种古董就选吧</p>
<p>VESA VGA graphics support</p>
<p>符合 VESA 2.0 标准的显卡的通用驱动, 如果显卡芯片在下面能够找到就可以不选</p>
<p>{此处省略的硬件请按照自己实际使用的显卡芯片进行选择}</p>
<p>Virtual Frame Buffer support</p>
<p>仅供调试使用</p>
<p>Console display driver support</p>
<p>控制台显示驱动</p>
<p>VGA text console</p>
<p>文本控制台, 必选</p>
<p>Enable Scrollback Buffer in System RAM</p>
<p>在内存中开辟额外的屏幕缓冲区, 这将允许你回滚屏幕</p>
<p>Scrollback Buffer Size (in KB)</p>
<p>在内存中开辟的额外屏幕缓冲区大小</p>
<p>Video mode selection support</p>
<p>允许在内核启动时使用 &ldquo;vga=&rdquo; 选择文本模式, 如果你希望一行能够显示更多字符的话可以打开它</p>
<p>MDA text console (dual-headed)</p>
<p>如果你有古董级别的单色显卡并且作为第二块显卡使用以实现双头显示就选上吧</p>
<p>Framebuffer Console support</p>
<p>基于 framebuffer 的控制台驱动, 服务器可以不选</p>
<p>Framebuffer Console Rotation</p>
<p>显示画面旋转, 它可能大大降低显示速度, 建议不选</p>
<p>Select compiled-in fonts</p>
<p>选择内建字体</p>
<p>VGA 8x8 font</p>
<p>高分辨率下的小字体</p>
<p>VGA 8x16 font</p>
<p>底分辨率下的大字体</p>
<p>{其它字体省略}</p>
<p>Logo configuration</p>
<p>启动时显示 linux 的 logo(一幅企鹅图像), 喜欢炫一下的就选吧</p>
<p>Backlight &amp; LCD device support</p>
<p>LCD 显示器支持, 一般无需选择</p>
<p>Sound</p>
<p>声卡</p>
<p>Advanced Linux Sound Architecture</p>
<p>使用声卡者必选</p>
<p>Sequencer support</p>
<p>音序器支持 (MIDI 必需), 除非你确定不需要, 否则请选上</p>
<p>Sequencer dummy client</p>
<p>除非你要同时连接到多个 MIDI 设备或应用程序, 否则请不要选择</p>
<p>OSS Mixer API</p>
<p>OSS 混音器 API 仿真, 许多程序目前仍然需要使用它, 建议选择</p>
<p>OSS PCM (digital audio) API</p>
<p>OSS 数字录音 (PCM)API 模拟, 许多程序目前仍然需要使用它, 建议选择</p>
<p>OSS PCM (digital audio) API - Include plugin system</p>
<p>建议不选</p>
<p>OSS Sequencer API</p>
<p>OSS 音序器支持, 许多程序目前仍然需要使用它, 建议选择</p>
<p>RTC Timer support</p>
<p>为 ALSA 启用 RTC 定时器支持, 建议选择</p>
<p>Use RTC as default sequencer timer</p>
<p>将 RTC 当作默认的时序脉冲发生器</p>
<p>Dynamic device file minor numbers</p>
<p>仅供拥有多个声卡的用户选择</p>
<p>Support old ALSA API</p>
<p>支持已被废弃的老版本 ALSA API</p>
<p>Verbose procfs contents</p>
<p>仅供调试使用</p>
<p>Verbose printk</p>
<p>仅供调试使用</p>
<p>Debug</p>
<p>仅供调试使用</p>
<p>Generic devices</p>
<p>通用设备</p>
<p>Dummy (/dev/null) soundcard</p>
<p>仅供调试</p>
<p>Virtual MIDI soundcard</p>
<p>虚拟 MIDI 驱动, 允许将使用原始 MIDI 设备的应用程序连接到音序器客户端, 如果你不知道 MIDI 是什么就别选</p>
<p>{此处省略的硬件请按照自己实际使用的声卡芯片进行选择}</p>
<p>PCI devices</p>
<p>PCI 接口的声卡, 请按实际使用的声卡选择子项</p>
<p>USB devices</p>
<p>USB 接口的声卡, 请按实际使用的声卡选择子项</p>
<p>PCMCIA devices</p>
<p>PCMCIA 接口的声卡, 请按实际使用的声卡选择子项</p>
<p>Open Sound System</p>
<p>反对使用</p>
<p>USB support</p>
<p>USB 支持</p>
<p>Support for Host-side USB</p>
<p>主机端 (Host-side)USB 支持. 通用串行总线(USB) 是一个串行总线子系统规范, 它比传统的串口速度更快并且特性更丰富 (供电, 热插拔, 最多可接 127 个设备等), 有望在将来一统 PC 外设接口. USB 的 &ldquo;Host&rdquo;(主机) 被称为 &ldquo;根&rdquo;(也可以理解为是主板上的 USB 控制器), 外部设备被称为 &ldquo;叶子&rdquo;, 而内部的节点则称为 &ldquo;hub&rdquo;(集线器). 基本上只要你想使用任何 USB 设备都必须选中此项. 另外, 你还需要从下面选中至少一个 &ldquo;Host Controller Driver&rdquo;(HCD), 比如适用于 USB1.1 的 &ldquo;UHCI HCD support&rdquo; 或 &ldquo;OHCI HCD support&rdquo;, 适用于 USB2.0 的 &ldquo;EHCI HCD (USB 2.0) support&rdquo;. 如果你拿不准的话把他们全部选中一般也不会出问题. 如果你的系统有设备端的 USB 接口(也就是你的系统可以作为 &ldquo;叶子&rdquo; 使用), 请到 &ldquo;USB Gadget&rdquo; 中进行选择.</p>
<p>USB verbose debug messages</p>
<p>仅供调试使用</p>
<p>USB device filesystem</p>
<p>在 / proc/bus/usb 里列出当前连接的 usb 设备 (mount -t usbfs none /proc/bus/usb), 这样用户空间的程序就可以直接访问这些 USB 设备, 基本上你要使用 USB 设备的话就必须选中此项</p>
<p>Enforce USB bandwidth allocation</p>
<p>执行 usb 带宽分配限制, 禁止打开占用 usb 总线带宽超过 90% 的设备, 关闭该选项可能会导致某些设备无法正常工作</p>
<p>Dynamic USB minor allocation</p>
<p>除非你有超过 16 个同类型的 USB 设备, 否则不要选择</p>
<p>USB selective suspend/resume and wakeup</p>
<p>usb 设备的挂起和恢复, 毛病多多且许多设备尚未支持它, 建议不选</p>
<p>EHCI HCD (USB 2.0) support</p>
<p>USB 2.0 支持 (大多数 2002 年以后的主板都支持). 如果你选中了此项, 一般来说你还需要选中 OHCI 或 UHCI 驱动</p>
<p>Full speed ISO transactions</p>
<p>由于 USB 2.0 支持低速 (1.5Mbps)/ 全速(12Mbps)/ 高速(480Mbps) 三种规格的外部设备, 为了将全 / 低速设备对高速设备可用带宽的影响减到最小, 在 USB2.0 集线器中提供了一种事务转换 (Transaction Translator) 机制, 该机制支持在 Hub 连接的是全 / 低速设备的情况下, 允许主控制器与 Hub 之间以高速传输所有设备的数据, 从而节省不必要的等待. 如果你没有外置的 USB 集线器就无需选择</p>
<p>Root Hub Transaction Translators</p>
<p>带有 USB 2.0 接口的主板上都有一个 &ldquo;根集线器&rdquo;(Root Hub)以允许在无需额外购买 hub 的情况下就可以提供多个 USB 插口, 其中的某些产品还在其中集成了事务转换 (Transaction Translator) 功能, 这样就不需要再额外使用一个兼容 OHCI 或 UHCI 的控制器来兼容 USB 1.1, 即使你不太清楚自己主板上的根集线器是否集成了事务转换功能也可以安全的选中此项</p>
<p>Improved Transaction Translator scheduling</p>
<p>如果你有一个高速 USB 2.0 hub 并且某些接在这个 hub 上的低速或全速设备不能正常工作 (显示&rsquo;cannot submit datapipe: error -28&rsquo;或&rsquo;error -71&rsquo;错误), 可以考虑选上</p>
<p>ISP116X HCD support</p>
<p>ISP1160/ISP1161 主机 USB 控制器, 是符合 USB2.0 全速规范的单片主机控制器和设备控制器, 支持 OHCI 标准</p>
<p>OHCI HCD support</p>
<p>开放主机控制接口 (OHCI) 是主要针对嵌入式系统的 USB 1.1 主机控制器规范</p>
<p>UHCI HCD (most Intel and VIA) support</p>
<p>通用主机控制器接口 (UHCI) 是主要针对 PC 机的 USB 1.1 主机控制器规范. 另外, EHCI 也可能需要它</p>
<p>Elan U132 Adapter Host Controller</p>
<p>如果你有这种硬件就选吧</p>
<p>SL811HS HCD support</p>
<p>如果你有这种硬件就选吧</p>
<p>USB Bluetooth TTY support</p>
<p>USB 蓝牙 TTY 设备支持</p>
<p>USB MIDI support</p>
<p>USB MIDI 设备支持</p>
<p>USB Modem (CDC ACM) support</p>
<p>USB 接口的猫或 ISDN 适配器</p>
<p>USB Printer support</p>
<p>USB 打印机</p>
<p>USB Mass Storage support</p>
<p>USB 存储设备 (U 盘, USB 硬盘, USB 软盘, USB CD-ROM,USB 磁带, memory sticks, 数码相机, 读卡器等等). 该选项依赖于&rsquo;SCSI device support&rsquo;, 且大部分情况下还依赖于&rsquo;SCSI disk support&rsquo;(比如 U 盘或 USB 硬盘)</p>
<p>USB Mass Storage verbose debug</p>
<p>仅供调试使用</p>
<p>{省略的部分请按照自己实际使用的硬件选, 择 (事实上大部分人都没有这些设备, 可以全不选)}</p>
<p>The shared table of common (or usual) storage devices</p>
<p>该模块包含一张记录了常用 USB 存储设备及其驱动的表格, 这样你无需重新编译模块即可在切换这些设备时自动邦定对应的驱动 (还需要对 / etc/modprobe.conf 进行相应的设置). 不确定的建议不选</p>
<p>USB Human Interface Device (full HID) support</p>
<p>USB 人机界面设备 (鼠标 / 键盘 / 游戏杆 / 手写版等人操作计算机的设备), 该驱动不能和 &ldquo;USB HID Boot Protocol drivers&rdquo; 同时使用</p>
<p>HID input layer support</p>
<p>如果你有 USB 接口的鼠标 / 键盘 / 游戏杆 / 手写板等输入设备就必选</p>
<p>Enable support for iBook/PowerBook special keys</p>
<p>苹果 iBooks/PowerBooks 键盘上的 Fn/Numlock 等功能键支持</p>
<p>Force feedback support</p>
<p>力反馈设备</p>
<p>/dev/hiddev raw HID device support</p>
<p>如果你有 USB 监控装置或不间断电源 (UPS) 之类的非输入设备就选上</p>
<p>USB HID Boot Protocol drivers</p>
<p>如果你有绝对的把握确信不为自己的键盘和鼠标使用通常的 HID 驱动, 而要使用 Boot Protocol 模式的 HID 驱动 (常见于嵌入式环境) 就选吧</p>
<p>Aiptek 6000U/8000U tablet support</p>
<p>一种手写板</p>
<p>Wacom Intuos/Graphire tablet support</p>
<p>一种手写 / 绘图板</p>
<p>Acecad Flair tablet support</p>
<p>一种数控绘图板</p>
<p>KB Gear JamStudio tablet support</p>
<p>一种手写 / 绘图板</p>
<p>Griffin PowerMate and Contour Jog support</p>
<p>一种具有调节音量 / 滚动文本 / 视频快进快退等功能的产品</p>
<p>USB Touchscreen Driver</p>
<p>USB 触摸屏驱动</p>
<p>Yealink usb-p1k voip phone</p>
<p>一种 VoIP 电话</p>
<p>X-Box gamepad support</p>
<p>X-Box 游戏板</p>
<p>ATI / X10 USB RF remote control</p>
<p>一种 usb 远程控制设备</p>
<p>ATI / Philips USB RF remote control</p>
<p>一种 usb 远程控制设备</p>
<p>Keyspan DMR USB remote control</p>
<p>一种 usb 远程控制设备</p>
<p>Apple USB Touchpad support</p>
<p>苹果机上的触摸板</p>
<p>USB Mustek MDC800 Digital Camera support</p>
<p>一种数码相机</p>
<p>Microtek X6USB scanner support</p>
<p>一种扫描仪</p>
<p>USB Network Adapters</p>
<p>USB 网络适配器, 如果你有这种设备请按自己实际使用的硬件选择子项</p>
<p>USB Monitor</p>
<p>usb 流量监控, 一般没必要选它</p>
<p>USS720 parport driver</p>
<p>一种 USB 接口转并口的转换设备</p>
<p>USB Serial Converter support</p>
<p>USB 接口转串口的转换设备</p>
<p>EMI 6|2m USB Audio interface support</p>
<p>一种 USB 音频设备</p>
<p>EMI 2|6 USB Audio interface support</p>
<p>一种 USB 音频设备</p>
<p>ADU devices from Ontrak Control Systems</p>
<p>Ontrak Control Systems 公司的一种自动拨号设备</p>
<p>USB Auerswald ISDN support</p>
<p>一种 ISDN 设备</p>
<p>USB Diamond Rio500 support</p>
<p>一种 mp3 播放机</p>
<p>USB Lego Infrared Tower support</p>
<p>一种无线发射机</p>
<p>USB LCD driver support</p>
<p>USB 液晶显示器</p>
<p>USB LED driver support</p>
<p>USB 发光二极管</p>
<p>Cypress CY7C63xxx USB driver support</p>
<p>德国 AK Modul-Bus Computer GmbH 公司的一种产品, 不知道是用来干什么的</p>
<p>Cypress USB thermometer driver support</p>
<p>一种温度计??</p>
<p>USB Phidgets drivers</p>
<p>来自 Phidgets 公司的各种 USB 产品</p>
<p>Siemens ID USB Mouse Fingerprint sensor support</p>
<p>西门子公司的一种指纹传感器</p>
<p>Elan PCMCIA CardBus Adapter USB Client</p>
<p>Elan 公司的一种 USB 转 PCMCIA 的适配器</p>
<p>Apple Cinema Display support</p>
<p>苹果公司的一种 Cinema Display</p>
<p>USB 2.0 SVGA dongle support (Net2280/SiS315)</p>
<p>一种软件狗</p>
<p>USB LD driver</p>
<p>USB LD 驱动</p>
<p>PlayStation 2 Trance Vibrator driver support</p>
<p>SONY 的 PS2 上面的 &ldquo;入迷振荡器&rdquo;(类似于力反馈手柄)</p>
<p>USB testing driver</p>
<p>测试中的驱动, 别选</p>
<p>USB DSL modem support</p>
<p>USB DSL 猫</p>
<p>USB Gadget Support</p>
<p>其他各种杂七杂八的 usb 小玩艺</p>
<p>MMC/SD Card support</p>
<p>MMC/SD 卡支持</p>
<p>LED devices</p>
<p>发光二级管 (LED) 设备</p>
<p>InfiniBand support</p>
<p>InfiniBand 是一个通用的高性能 I/O 规范, 它使得存储区域网中以更低的延时传输 I/O 消息和集群通讯消息并且提供很好的伸缩性. 用于 Linux 服务器集群系统</p>
<p>EDAC - error detection and reporting (RAS)</p>
<p>错误检测与纠正 (EDAC) 的目标是发现并报告甚至纠正在计算机系统中发生的错误, 这些错误是由 CPU 或芯片组报告的底层错误(内存错误 / 缓存错误 / PCI 错误 / 温度过高, 等等), 建议选择. 如果这些代码报告了一个错误, 请到 <a href="http://bluesmoke.sourceforge.net/">http://bluesmoke.sourceforge.net/</a> 和 <a href="http://buttersideup.com/edacwiki">http://buttersideup.com/edacwiki</a> 查看更多信息</p>
<p>Debugging</p>
<p>仅供调试使用</p>
<p>Main Memory EDAC (Error Detection And Correction) reporting</p>
<p>一些系统能够检测和修正主内存中的错误, EDAC 能够报告这些信息 (EDAC 自己检测到的或者根据 ECC 得到的).EDAC 还会尽量检测这些错误发生在哪里以便于替换损坏的内存. 建议选择并按照你实际使用的芯片组选取子项</p>
<p>Error detecting method</p>
<p>错误检测方法, 当前只有一个 &ldquo;Poll for errors&rdquo;(错误轮询) 可用</p>
<p>Real Time Clock</p>
<p>所有的 PC 机主板都包含一个电池动力的实时时钟芯片, 以便在断电后仍然能够继续保持时间, RTC 通常与 CMOS 集成在一起, 因此 BIOS 可以从中读取当前时间</p>
<p>RTC class</p>
<p>通用 RTC 类支持, 选中此项后你就可以在操作系统中使用一个或多个 RTC 设备 (你还必须从下面启用一个或多个 RTC 接口)</p>
<p>Set system time from RTC on startup</p>
<p>系统启动时使用从指定的 RTC 设备中读取的时间来设定系统时间, 通常这将有助于避免不必要的文件系统检测程序 (fsck) 的运行, 建议选择</p>
<p>The RTC to read the time from</p>
<p>指定具体从哪个 RTC 设备中读取时间</p>
<p>RTC debug support</p>
<p>仅供调试使用</p>
<p>sysfs</p>
<p>允许通过 sysfs 接口使用 RTC, 允许多个 RTC 设备, 也就是 / sys/class/rtc/rtc0~N</p>
<p>proc</p>
<p>允许通过 proc 接口使用 RTC, 仅允许一个 RTC 设备, 也就是 / proc/driver/rtc</p>
<p>dev</p>
<p>允许通过 dev 接口使用 RTC, 允许多个 RTC 设备, 也就是 &ldquo;udev&rdquo; 设置的 / dev/rtc0~N, 建议你建立一个指向其中之一的软连接 / dev/rtc, 某些程序 (比如 hwclock) 需要使用 / dev/rtc</p>
<p>RTC UIE emulation on dev interface</p>
<p>如果底层 rtc 芯片驱动没有提供 RTC_UIE 就仿真一个 RTC_UIE. 那些请求将产生每秒一次的更新请求以用来同步 [这个选项的意思我也搞不清楚究竟时啥意思, 翻译的也可能有误]</p>
<p>{此处省略的 RTC 驱动请按照自己实际使用的 RTC 芯片进行选择}</p>
<p>DMA Engine support</p>
<p>从 Intel Bensley 双核服务器平台开始引入的数据移动加速 (Data Movement Acceleration) 引擎, 它将某些传输数据的操作从 CPU 转移到专用硬件, 从而可以进行异步传输并减轻 CPU 负载. Intel 已将此项技术变为开放的标准, 将来应当会有更多的厂商支持</p>
<p>Network: TCP receive copy offload</p>
<p>通过在网络栈中利用 DMA 引擎来减少接收数据包时的 copy-to-user 操作以释放 CPU 资源, 这是 DMA 引擎目前最主要的用途</p>
<p>Intel I/OAT DMA support</p>
<p>Intel I/O 加速技术 (Intel I/O Acceleration Technology) 中的 DMA 支持, 基于 Intel Bensley 的新一代服务器平台都支持它</p>
<p>File systems
文件系统
强烈建议在选择之前先看看各种文件系统的比较</p>
<p>Second extended fs support</p>
<p>Ext2 文件系统是 Linux 的标准文件系统, 擅长处理稀疏文件</p>
<p>Ext2 extended attributes</p>
<p>Ext2 文件系统扩展属性 (与 inode 关联的 name:value 对) 支持</p>
<p>Ext2 POSIX Access Control Lists</p>
<p>POSIX ACL(访问控制列表) 支持, 可以更精细的针对每个用户进行访问控制, 需要外部库和程序的支持</p>
<p>Ext2 Security Labels</p>
<p>安全标签允许选择使用不同的安全模型实现 (如 SELinux) 的访问控制模型, 如果你没有使用需要扩展属性的安全模型就别选</p>
<p>Ext2 execute in place support</p>
<p>程序在写入存储介质时就已经分配好运行时的地址, 因此不需要载入内存即可在芯片内执行, 一般仅在嵌入式系统上才有这种设备</p>
<p>Ext3 journalling file system support</p>
<p>Ext3 性能平庸, 使用 journal 日志模式时数据完整性非常好 (但怪异的是此时多线程并发读写速度却最快)</p>
<p>Ext3 extended attributes</p>
<p>Ext3 文件系统扩展属性 (与 inode 关联的 name:value 对) 支持</p>
<p>Ext3 POSIX Access Control Lists</p>
<p>POSIX ACL(访问控制列表) 支持, 可以更精细的针对每个用户进行访问控制, 需要外部库和程序的支持</p>
<p>Ext3 Security Labels</p>
<p>安全标签允许选择使用不同的安全模型实现 (如 SELinux) 的访问控制模型, 如果你没有使用需要扩展属性的安全模型就别选</p>
<p>Ext4dev/ext4 extended fs support</p>
<p>尚处于开发状态的 Ext4</p>
<p>JBD (ext3) debugging support</p>
<p>仅供开发者使用</p>
<p>JBD2 (ext4dev/ext4) debugging support</p>
<p>仅供开发者使用</p>
<p>Reiserfs support</p>
<p>性能几乎全面超越 Ext2(处理稀疏文件比 Ext2 慢), 小文件 (小于 4k) 性能非常突出, 创建和删除文件速度最快, 处理大量目录和文件 (5k-20k) 时仍然非常迅速. 日志模式建议使用 Ordered, 追求极速可使用 Writeback 模式, 追求安全可使用 Journal 模式. 建议使用 noatime,notail 选项挂载分区以提高速度和避免 bug. 用于 NFS 和磁盘限额时需要额外的补丁</p>
<p>Enable reiserfs debug mode</p>
<p>启用 ReiserFS 调试模式, 仅供开发者使用</p>
<p>Stats in /proc/fs/reiserfs</p>
<p>在 / proc/fs/reiserfs 文件中显示 Reiserfs 文件系统的状态, 仅供开发者使用</p>
<p>ReiserFS extended attributes</p>
<p>ReiserFS 文件系统扩展属性 (与 inode 关联的 name:value 对) 支持</p>
<p>ReiserFS POSIX Access Control Lists</p>
<p>POSIX ACL(访问控制列表) 支持, 可以更精细的针对每个用户进行访问控制, 需要外部库和程序的支持</p>
<p>ReiserFS Security Labels</p>
<p>安全标签允许选择使用不同的安全模型实现 (如 SELinux) 的访问控制模型, 如果你没有使用需要扩展属性的安全模型就别选了</p>
<p>JFS filesystem support</p>
<p>IBM 的 JFS 文件系统</p>
<p>XFS filesystem support</p>
<p>碎片最少, 多线程并发读写最佳, 大文件 (&gt;64k) 性能最佳, 创建和删除文件速度较慢. 由于 XFS 在内存中缓存尽可能多的数据且仅当内存不足时才会将数据刷到磁盘, 所以应当仅在确保电力供应不会中断的情况下才使用 XFS</p>
<p>Quota support</p>
<p>XFS 的磁盘配额支持</p>
<p>Security Label support</p>
<p>扩展的安全标签支持. SElinux 之类的安全系统会使用到这样的扩展安全属性</p>
<p>POSIX ACL support</p>
<p>POSIX ACL(访问控制列表) 支持, 可以更精细的针对每个用户进行访问控制, 需要外部库和程序的支持</p>
<p>Realtime support</p>
<p>实时子卷是专门存储文件数据的卷, 可以允许将日志与数据分开在不同的磁盘上</p>
<p>GFS2 file system support</p>
<p>一种用于集群的文件系统</p>
<p>OCFS2 file system support</p>
<p>一种用于集群的文件系统</p>
<p>Minix fs support</p>
<p>老古董文件系统</p>
<p>ROM file system support</p>
<p>用于嵌入式系统的内存文件系统的支持</p>
<p>Inotify file change notification support</p>
<p>新式的文件系统的变化通知机制, 简洁而强大, 用于代替老旧的 Dnotify</p>
<p>Inotify support for userspace</p>
<p>用户空间的 Inotify 支持</p>
<p>Quota support</p>
<p>磁盘配额支持, 限制某个用户或者某组用户的磁盘占用空间, Ext2/Ext3/Reiserfs 都支持它</p>
<p>Old quota format support</p>
<p>老式的配额格式支持</p>
<p>Quota format v2 support</p>
<p>新的 v2 格式允许使用 32 位的 UID/GID</p>
<p>Dnotify support</p>
<p>旧式的基于目录的文件变化的通知机制 (新机制是 Inotify), 目前仍然有一些程序依赖它</p>
<p>Kernel automounter support</p>
<p>内核自动加载远程文件系统 (v3, 就算选也不选这个旧的)</p>
<p>Kernel automounter version 4 support (also supports v3)</p>
<p>新的 (v4) 的内核自动加载远程文件系统的支持, 也支持 v3</p>
<p>Filesystem in Userspace support</p>
<p>FUSE 允许在用户空间实现一个文件系统, 如果你打算开发一个自己的文件系统或者使用一个基于 FUSE 的文件系统就选吧</p>
<p>CD-ROM/DVD Filesystems</p>
<p>CD-ROM/DVD 文件系统</p>
<p>ISO 9660 CDROM file system support</p>
<p>CD-ROM 的标准文件系统</p>
<p>Microsoft Joliet CDROM extensions</p>
<p>Microsoft 对 ISO 9660 文件系统的 Joliet 扩展, 允许在文件名中使用 Unicode 字符, 也允许长文件名</p>
<p>Transparent decompression extension</p>
<p>Linux 对 ISO 9660 文件系统的扩展, 允许将数据透明的压缩存储在 CD 上</p>
<p>UDF file system support</p>
<p>某些新式 CD/DVD 上的文件系统, 很少见</p>
<p>DOS/FAT/NT Filesystems</p>
<p>DOS/Windows 的文件系统</p>
<p>MSDOS fs support</p>
<p>古老的 MSDOS 文件系统</p>
<p>VFAT (Windows-95) fs support</p>
<p>从 Win95 开始使用的 VFAT 文件系统</p>
<p>Default codepage for FAT</p>
<p>默认代码页</p>
<p>Default iocharset for FAT</p>
<p>默认字符集</p>
<p>NTFS file system support</p>
<p>从 WinNT 开始使用的 NTFS 文件系统</p>
<p>NTFS debugging support</p>
<p>仅供调试使用</p>
<p>NTFS write support</p>
<p>NTFS 写入支持</p>
<p>Pseudo filesystems</p>
<p>伪文件系统</p>
<p>/proc file system support</p>
<p>显示系统状态的虚拟文件系统 (irq 设置, 内存使用, 加载的设备驱动器, 网络状态等), 许多程序依赖于它</p>
<p>/proc/kcore support</p>
<p>系统物理内存的映象</p>
<p>/proc/vmcore support</p>
<p>以 ELF 格式转储的已崩溃内核镜像, 仅供调试使用</p>
<p>Sysctl support (/proc/sys)</p>
<p>显示各种不同的内核参数, 并让 root 用户能交互地更改其中的某些内容</p>
<p>sysfs file system support</p>
<p>导出内核内部对象及其属性和对象之间的相互关系的文件系统, 它把连接在系统上的设备和总线以及驱动程序等组织成为一个分级的文件, 内核启动时依靠它挂载根分区, 禁用 sysfs 后必须在内核引导参数中使用设备号指定根分区</p>
<p>Virtual memory file system support (former shm fs)</p>
<p>tmpfs 文件系统 (以前叫 shm[共享内存] 文件系统)支持</p>
<p>Tmpfs POSIX Access Control Lists</p>
<p>POSIX ACL(访问控制列表) 支持, 可以更精细的针对每个用户进行访问控制, 需要外部库和程序的支持</p>
<p>HugeTLB file system support</p>
<p>仅仅能够在某些罕见的体系结构上使用的文件系统</p>
<p>Userspace-driven configuration filesystem</p>
<p>configfs 是用户空间驱动的文件系统, 提供与 sysfs 相反的功能</p>
<p>Miscellaneous filesystems</p>
<p>非主流的杂项文件系统</p>
<p>Network File Systems</p>
<p>网络文件系统</p>
<p>Partition Types</p>
<p>高级磁盘分区类型, 不确定可以全不选</p>
<p>Native Language Support</p>
<p>本地语言支持</p>
<p>Base native language support</p>
<p>基础本地语言, 必选</p>
<p>Default NLS Option</p>
<p>默认本地语言, 建议使用 UTF-8</p>
<p>{此处省略的部分请按需选择, 一般至少需要 CP437,ASCII,ISO-8859-1}</p>
<p>Distributed Lock Manager</p>
<p>通用的分布式锁管理器, 不明白就不选</p>
<p>Instrumentation Support
分析支持</p>
<p>Profiling support</p>
<p>对系统的活动进行分析, 仅供内核开发者使用</p>
<p>Kprobes</p>
<p>仅供内核开发者使用</p>
<p>Kernel hacking
内核 hack 选项</p>
<p>Show timing information on printks</p>
<p>在 printk 的输出中包含时间信息, 可以用来分析内核启动过程各步骤所用时间</p>
<p>Enable __must_check logic</p>
<p>在编译内核的过程中使用 &ldquo;必须检查&rdquo; 的逻辑, 禁用它将不会显示某些警告信息</p>
<p>Magic SysRq key</p>
<p>不懂的千万别选</p>
<p>Enable unused/obsolete exported symbols</p>
<p>导出无用和废弃的符号, 这将使内核不必要的增大</p>
<p>Kernel debugging</p>
<p>不是内核开发者的别选</p>
<p>Debug Filesystem</p>
<p>不是内核开发者的别选</p>
<p>Compile the kernel with frame unwind information</p>
<p>不是内核开发者的别选</p>
<p>Run &lsquo;make headers_check&rsquo; when building vmlinux</p>
<p>在编译内核时运行&rsquo;make headers_check&rsquo;命令检查内核头文件, 当你修改了与用户空间相关的内核头文件后建议启用该选项</p>
<p>Linux Kernel Dump Test Tool Module</p>
<p>不是内核开发者的别选</p>
<p>Enable doublefault exception handler</p>
<p>允许捕获非常罕见的导致系统无警告重启的 doublefault 异常, 对于调试非常重要</p>
<p>Security options
安全选项
这里的选项不明白的建议不要选, 否则有可能弄巧成拙.</p>
<p>Enable access key retention support</p>
<p>在内核中保留 authentication token 和 access key</p>
<p>Enable the /proc/keys file by which keys may be viewed</p>
<p>允许有权限的进程通过 / proc/keys 读取所有的 key</p>
<p>Enable different security models</p>
<p>允许内核选择不同的安全模型, 如果未选中则内核将使用默认的安全模型</p>
<p>Socket and Networking Security Hooks</p>
<p>允许安全模型通过 Security Hook 对 Socket 与 Networking 进行访问控制</p>
<p>XFRM (IPSec) Networking Security Hooks</p>
<p>启用 XFRM 安全 Hook</p>
<p>Default Linux Capabilities</p>
<p>启用与 &ldquo;默认&quot;Linux 的兼容性</p>
<p>Root Plug Support</p>
<p>一个简单的 Linux 安全模块, 在特定的 USB 设备不存在时它简单的禁止一切 egid==0 的进程运行</p>
<p>NSA SELinux Support</p>
<p>美国国家安全局 (NSA) 开发的安全增强 Linux(SELinux), 你还需要进行策略配置 (checkpolicy) 并且对文件系统进行标记(setfiles)</p>
<p>NSA SELinux boot parameter</p>
<p>添加一个内核引导参数以允许在引导时使用&rsquo;selinux=0&rsquo;禁用 SELinux 或&rsquo;selinux=1&rsquo;启用 SELinux</p>
<p>NSA SELinux boot parameter default value</p>
<p>上述参数的默认值</p>
<p>NSA SELinux runtime disable</p>
<p>允许在运行时禁用 SELinux</p>
<p>NSA SELinux Development Support</p>
<p>SELinux 开发支持</p>
<p>NSA SELinux AVC Statistics</p>
<p>搜集存取向量 (access vector) 缓冲区的统计信息并在 / selinux/avc/cache_stats 中显示出来. 这些信息可以用 avcstat 之类的工具查看</p>
<p>NSA SELinux checkreqprot default value</p>
<p>checkreqprot 标志的默认值</p>
<p>NSA SELinux enable new secmark network controls by default</p>
<p>默认启用新的基于安全标记 (secmark) 的网络</p>
<p>NSA SELinux maximum supported policy format version</p>
<p>允许将支持的最高策略格式版本设置为一个特定的数值</p>
<p>NSA SELinux maximum supported policy format version value</p>
<p>支持的最高策略格式版本的数值</p>
<p>Cryptographic options
加密选项</p>
<p>Cryptographic API</p>
<p>提供核心的加密 API 支持. 这里的加密算法被广泛的应用于驱动程序通信协议等机制中. 子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上</p>
<p>Cryptographic algorithm manager</p>
<p>创建加密模版实例, 必须要选</p>
<p>HMAC support</p>
<p>为 IPSec 所必须, 可为 PPPoE 提供压缩支持</p>
<p>Null algorithms</p>
<p>NULL 加密算法 (什么也不做), 用于 IPsec 协议的封装安全载荷模块 (ESP)</p>
<p>MD4 digest algorithm</p>
<p>老旧的摘要算法, 已经过时</p>
<p>MD5 digest algorithm</p>
<p>主流摘要算法, 128 位 (已被中国山东大学王小云攻破, 可以快速找到碰撞)</p>
<p>SHA1 digest algorithm</p>
<p>主流摘要算法, 160 位 (已被中国山东大学王小云攻破, 可以快速找到碰撞), 速度与 MD5 相当</p>
<p>SHA256 digest algorithm</p>
<p>更好的摘要算法, 256 位, 速度较 SHA1 稍慢</p>
<p>SHA384 and SHA512 digest algorithms</p>
<p>更好的摘要算法, 384/512 位, 速度大约只有 SHA1 的 40-50%</p>
<p>Whirlpool digest algorithms</p>
<p>最安全的摘要算法, 512 位, 已被列入 ISO 标准, 目前最新版本为 3.0(2003 年发布)</p>
<p>Tiger digest algorithms</p>
<p>号称最快的摘要算法, 192 位, 专门为 64 位 CPU 进行了优化</p>
<p>ECB support</p>
<p>电子密码本, 最简单的加密方法</p>
<p>CBC support</p>
<p>密码块链, IPSec 需要使用它</p>
<p>DES and Triple DES EDE cipher algorithms</p>
<p>老迈的 (DES) 和尚佳的 (Triple DES) 对称加密算法</p>
<p>Blowfish cipher algorithm</p>
<p>又老又慢的对称加密算法</p>
<p>Twofish cipher algorithm</p>
<p>很强的对称加密算法, 使用较广</p>
<p>Twofish cipher algorithms (i586)</p>
<p>很强的对称加密算法, 使用较广 (针对 i586 的版本)</p>
<p>Serpent cipher algorithm</p>
<p>很强的对称加密算法</p>
<p>AES cipher algorithms</p>
<p>最佳的对称加密算法 (Rijndael),128/192/256 位, 强度最高, 快速且节省内存</p>
<p>AES cipher algorithms (i586)</p>
<p>最佳的对称加密算法 (Rijndael),128/192/256 位, 强度最高, 快速且节省内存 (针对 i586 的版本)</p>
<p>CAST5 (CAST-128) cipher algorithm</p>
<p>对称加密算法</p>
<p>CAST6 (CAST-256) cipher algorithm</p>
<p>对称加密算法</p>
<p>TEA, XTEA and XETA cipher algorithms</p>
<p>较弱的对称加密算法</p>
<p>ARC4 cipher algorithm</p>
<p>脆弱的流对称加密算法</p>
<p>Khazad cipher algorithm</p>
<p>对称加密算法</p>
<p>Anubis cipher algorithm</p>
<p>对称加密算法</p>
<p>Deflate compression algorithm</p>
<p>压缩算法, 当在 IPSec 中使用 IPCOMP 协议时才需要</p>
<p>Michael MIC keyed digest algorithm</p>
<p>摘要算法, 仅仅用于校验 iSCSI 设备传输的数据, 因为算法本身比较脆弱</p>
<p>CRC32c CRC algorithm</p>
<p>摘要算法, 可用于校验 iSCSI 设备传输的数据</p>
<p>Testing module</p>
<p>快速且丑陋的测试模块</p>
<p>Hardware crypto devices</p>
<p>仅有 VIA C7 系列处理器支持硬件加密 (VIA PadLock 高级加密引擎)</p>
<p>Library routines
库子程序
仅有那些不包含在内核原码中的第三方内核模块才可能需要, 可以全不选, 内核中若有其他部分依赖它, 会自动选上</p>
<p>CRC-CCITT functions</p>
<p>传送 8-bit 字符, 欧洲标准</p>
<p>CRC16 functions</p>
<p>传送 8-bit 字符, 美国标准</p>
<p>CRC32 functions</p>
<p>用于点对点的同步数据传输中, 传输网络数据包所必须的</p>
<p>CRC32c (Castagnoli, et al) Cyclic Redundancy-Check</p>
<p>用于点对点的同步数据传输中, 比如 iSCSI 设备</p>
<p>Load an Alternate Configuration File</p>
<p>读入一个外部配置文件</p>
<p>Save Configuration to an Alternate File</p>
<p>将配置保存到一个外部文件</p>
<p>第一部分
Code maturity level options &mdash;&gt; 代码成熟等级选项
[ ]Prompt for development and/or incomplete code/drivers
默认情况下是选择的，这将会在设置界面中显示还在开发或者还没有完成的代码与驱动. 你应该选择它，因为有许多设备可能必需选择这个选项才能进行配置，实际上它是安全的。
[ ] Select only drivers expected to compile cleanly
选择这个选项你将不会看到一些已知的存在问题的驱动程序选项，默认的情况下也是选择的。如果你有设备没有找到驱动选项，你可以将这一项去掉，或许就可以找到相关驱动了， 不过它可能是有 BUG 的。
第二部分
General setup &mdash;&gt; 常规安装选项</p>
<p>[*] Support for paging of anonymous memory (swap)
这个选项将使你的内核支持虚拟内存，也就是让你的计算机好象拥有比实际内存更多 多的内存空间用来执行很大的程序。默认是选择的。</p>
<p>[ ] BSD Process Accounting
[*] Sysctl support此项功能可在不重新编译内核或是重新开机的前提下，动态变更某些特定的内核参数和变量，赋予内核较大的弹性。除非内存太少或是编译出来的内核是给安装、救援磁盘所使用，否则这个选项一定要选上。这将提供一个接口让你可以动态的更改一些核心参数与变量，而不需要重新启动系统。打开这个选项将会增加内核的体积至少8KB。如果你的内核仅用制作安装与恢复系统系统盘那么可以不选，以减少对内存的占用。</p>
<p>&mdash; Support for hot-pluggable devices
是否支持热插拔的选项，肯定要选上。不然 USB、PCMCIA 等这些设备都用不了。
[<em>] Kernel Userspace Events
内核中分为系统区和用户区，这里系统区和用户区进行通讯的一种方式，选上。
[ ] Kernel .config support
这将会把内核的配置信息与相关的文档说明编译进内核中，以后可以使用一些工具来提取它用来重新构建内核，一般不用选它。
[ ] Configure standard kernel features (for small systems) &mdash;&gt;
这是为了编译某些特殊用途的内核使用的，例如引导盘系统。通常你可以不选择这一选项，你也不用对它下面的子项操心了。
第三部分
Loadable module support &mdash;&gt;
可引导模块支持 建议作为模块加入内核
[</em>] Enable loadable module support
这个选项可以让你的内核支持模块，模块是什么呢？模块是一小段代码，编译后可在系统内核运行时动态的加入内核，从而为内核增加一些特性或是对某种硬件进行支持。一般一些不常用到的驱动或特性可以编译为模块以减少内核的体积。在运行时可以使用 modprobe 命令来加载它到内核中去(在不需要时还可以移除它)。一些特性是否编译为模块的原则是，不常使用的，特别是在系统启动时不需要的驱动可以将其编译为模块，如果是一些在系统启动时就要用到的驱动比如说文件系统，系统总线的支持就不要编为模块了，否在无法启动系统。
[<em>] Module unloading
这个选项可以让你卸载不再使用的模块，如果不选的话你将不能卸载任何模块(有些模块一旦加载就不能卸载，不管是否选择了这个选项)。不选择这个选项会让你的内核体积减小一点。
[</em>]Forced module unloading
允许强制卸载正在使用中的模块(比较危险)
[ ] Module versioning support (EXPERIMENTAL)
允许使用其他内核版本的模块(可能会出问题)
[ ] Source checksum for all modules
这个功能是为了防止更改了内核模块的代码但忘记更改版本号而造成版本冲突。我估计现在没有哪家公司在开发中还没使用版本控制工具，所以不需要这项了。如果你不是自己写内核模块，那就更不需要这一选项了。
[<em>] Automatic kernel module loading
一般情况下，如果用户的内核在某些任务中要使用一些被编译为模块的驱动或特性时，我们要先使用modprobe 命令来加载它，内核才能使用。不过，如果你选择了这个选项，在内核需要一些模块时它可以自动调用modprobe 命令来加载需要的模块，这是个很棒的特性，当然要选 Y 喽。
第四部分
System Type &mdash;&gt; 系统类型
ARM system type (Samsung S3C2410) &mdash;&gt; ARM 系统，基于 S3C2410
S3C24XX Implementations &mdash;&gt;  基于 S3C24xx 架构的实现
&mdash; S3C2410 Boot
&mdash; S3C2410 Setup
[</em>] S3C2410 DMA support 支持 DM 功能
[ ] S3C2410 DMA support debug 支持 DMA 调试功能
(0) S3C2410 UART to use for low-level messages
&mdash; Processor Type 处理器类型
&mdash; Processor Features 处理器特性
[<em>] Support Thumb user binaries 支持 Thumb 指令集
[ ] Disable I-Cache 禁止指令缓存（Instruction Cache，I-Cache）。
[ ] Disable D-Cache 禁止数据缓存（Data Cache，D-Cache）
[ ] Force write through D-cache强制回写数据缓存
第五部分
Bus support &mdash;&gt;总线支持
PCCARD (PCMCIA/CardBus) support &mdash;&gt;
&lt; &gt; PCCard (PCMCIA/CardBus) support
PCMCIA 卡支持
第六部分
Kernel Features
[ ] Symmetric Multi-Processing (EXPERIMENTAL)
[ ] Preemptible Kernel (EXPERIMENTAL)
第七部分
Boot options &mdash;&gt;
(0x0) Compressed ROM boot loader base address (0x0)
Compressed ROM boot loader BSS address
(console=ttyS0，115200) Default kernel command string
[ ] Kernel Execute-In-Place from ROM
第八部分
Floating point emulation &mdash;&gt;
&mdash; At least one emulation must be selected
[</em>] NWFPE math emulation
[ ] Support extended precision
[ ] FastFPE math emulation (EXPERIMENTAL)
第九部分
Userspace binary formats&mdash;&gt; 支持的可执行文件格式
[<em>] Kernel support for ELF binaries
ELF 是开放平台下最常用的二进制文件格式，支持动态连接，支持不同的硬件平台.除非你知道自己在做什么，否则必选
&lt; &gt; Kernel support for a.out and ECOFF binaries
这是早期 UNIX 系统的可执行文件格式，目前已经被 ELF 格式取代。
&lt; &gt; Kernel support for MISC binaries
允许插入二进制的封装层到内核中，使用 Java，.NET，Python，Lisp 等语言编写的程序时需要它
&lt; &gt; RISC OS personality
第十部分
Power management options &mdash;&gt; 电源管理选项
[ ] Power Management support
电源管理有 APM 和 ACPI 两种标准且不能同时使用.即使关闭该选项，X86 上运行的 Linux 也会在空闲时发出 HLT 指令将 CPU 进入睡眠状态
第十一部分
Device Drivers &mdash;&gt;设备驱动程序
Generic Driver Options &mdash;&gt;
驱动程序通用选项
[</em>] Select only drivers that don&rsquo;t need compile-time external firmware
只显示那些不需要内核对外部设备的固件作 map 支持的驱动程序，除非你有某些怪异硬件，否则请选上
[<em>] Prevent firmware from being built
不编译固件.固件一般是随硬件的驱动程序提供的，仅在更新固件的时候才需要重新编译. 建议选上
&lt;</em>&gt; Hotplug firmware loading support
加载热插拔固件支持 ，在内核树之外编译的模块可能需要它
[ ] Driver Core verbose debug messages
让驱动程序核心在系统日志中产生冗长的调试信息，仅供调试
Memory Technology Devices (MTD) &mdash;&gt;
特殊的存储技术装置，如常用于数码相机或嵌入式系统的闪存卡
Parallel port support&mdash;&gt;
并口支持(传统的打印机接口) Plug and Play support &mdash;&gt;
即插即用支持，若未选则应当在 BIOS 中关闭&quot;PnP OS&rdquo;.这里的选项与 PCI 设备无关
Block devices&mdash;&gt;
ATA/ATAPI/MFM/RLL support &mdash;&gt;
这个是有关各种接口的硬盘/光驱/磁带/软盘支持的，内容太多了，使用缺省的选项吧， 如果你使用了比较特殊的设备，比如 PCMCIA 等，就到里面自己找相应的选项吧
SCSI device support &mdash;&gt; SCSI 设备
Multi-device support (RAID and LVM)&mdash;&gt;
多设备支持(RAID 和 LVM).RAID 和 LVM 的功能是使多个物理设备组建成一个单独的逻辑磁盘
Fusion MPT device support &mdash;&gt; Fusion MPT 设备支持
IEEE 1394 (FireWire) support &mdash;&gt; IEEE 1394(火线)
I2O device support &mdash;&gt;
I2O(智能 IO)设备使用专门的 I/O 处理器负责中断处理/缓冲存取/数据传输等烦琐任务以减少 CPU 占用，一般的主板上没这种东西
Networking support &mdash;&gt; 网络支持
ISDN subsystem&mdash;&gt; 综合业务数字网(Integrated Service Digital Network)
Input device support&mdash;&gt; 输入设备
Character devices&mdash;&gt; 字符设备
I2C support&mdash;&gt;
I2C 是 Philips 极力推动的微控制应用中使用的低速串行总线协议，可用于监控电压/风扇转速/温度等.SMBus(系统管理总线)是 I2C 的子集.除硬件传感器外&quot;Video For Linux&quot;也需要该模块的支持
Misc devices &mdash;&gt;
Multimedia devices &mdash;&gt; 多媒体设备
Graphics support &mdash;&gt; 图形设备/显卡支持
Sound &mdash;&gt; 声卡
USB support &mdash;&gt; USB 支持
MMC/SD Card support &mdash;&gt; MMC/SD 卡支持
第十二部分
File systems &mdash;&gt; 文件系统
&lt;<em>&gt; Second extended fs support
Ext2 文件系统是 Linux 的标准文件系统，擅长处理稀疏文件
[</em>]Ext2 extended attributes
Ext2 文件系统扩展属性(与 inode 关联的 name:value 对)支持
[<em>]Ext2 POSIX Access Control Lists
POSIX ACL(访问控制列表)支持，可以更精细的针对每个用户进行访问控制，需要外部库和程序的支持
[ ]Ext2 Security Labels
安全标签允许选择使用不同的安全模型实现(如 SELinux)的访问控制模型，如果你没有使用需要扩展属性的安全模型就别选
&lt;</em>&gt; Ext3 journalling file system support
Ext3 性能平庸，使用 journal 日志模式时数据完整性非常好(但怪异的是此时多线程并发读写速度却最快)
[*]Ext3 extended attributes
Ext3 文件系统扩展属性(与 inode 关联的 name:value 对)支持
[ ]Ext3 POSIX Access Control Lists
POSIX ACL(访问控制列表)支持，可以更精细的针对每个用户进行访问控制，需要外部库和程序的支持
[ ]Ext3 Security Labels
安全标签允许选择使用不同的安全模型实现(如 SELinux)的访问控制模型，如果你没有使用需要扩展属性的安全模型就别选
[ ] JBD (ext3) debugging support 仅供开发者使用
&lt; &gt; Reiserfs support</p>
<p>性能几乎全面超越 Ext2(处理稀疏文件比 Ext2 慢)，小文件(小于 4k)性能非常突出，创建和删除文件速度最快，处理大量目录和文件(5k-20k)时仍然非常迅速.日志模式建议使用 Ordered，追求极速可使用 Writeback 模式，追求安全可使用 Journal 模式.建议使用 noatime，notail 选项挂载分区以提高速度和避免 bug.用于 NFS 和磁盘限额时需要额外的补丁
&lt; &gt; JFS filesystem support IBM 的 JFS 文件系统
XFS support &mdash;&gt;
碎片最少，多线程并发读写最佳，大文件(&gt;64k)性能最佳，创建和删除文件速度较慢.由于 XFS 在内存中缓存尽可能多的数据且仅当内存不足时才会将数据刷到磁盘，所以应当仅在确保电力供应不会中断的情况下才使用XFS
&lt; &gt; Minix fs support 老古董文件系统
&lt; &gt; ROM file system support
用于嵌入式系统的内存文件系统的支持
[ ] Quota support
磁盘配额支持，限制某个用户或者某组用户的磁盘占用空间，Ext2/Ext3/Reiserfs 都支持它</p>
<p>&lt;<em>&gt; Kernel automounter support
内核自动加载远程文件系统(v3，就算选也不选这个旧的)
&lt; &gt; Kernel automounter version 4 support (also supports v3)
新的(v4)的内核自动加载远程文件系统的支持，也支持 v3
CD-ROM/DVD Filesystems&mdash;&gt;
CD-ROM/DVD 文件系统
DOS/FAT/NT Filesystems &mdash;&gt;
DOS/Windows 的文件系统 Pseudo filesystems &mdash;&gt; 伪文件系统
Miscellaneous filesystems&mdash;&gt; 非主流的杂项文件系统
Network File Systems &mdash;&gt; 网络文件系统
Partition Types &mdash;&gt;
高级磁盘分区类型，不确定可以全不选 Native Language Support &mdash;&gt;
本地语言支持.如果你仅仅使用几种主流的 Linux 文件系统(ext2/3/4，Reiserfs，JFS， XFS)，就不需要这个东西.但是如果你需要使用 FAT/NTFS 分区的话，就需要这个东西了.
第十三部分
Profiling support &mdash;&gt;
[ ] Profiling support (EXPERIMENTAL)
对系统的活动进行分析，仅供内核开发者使用
第十四部分
Kernel hacking &mdash;&gt; 内核 hack 选项，普通用户是用不着这个功能的
[ ] Show timing information on printks
在 printk 的输出中包含时间信息，可以用来分析内核启动过程各步骤所用时间
[</em>] Kernel debugging
不是内核开发者的别选</p>
<p>[ ]Magic SysRq key 不懂的千万别选
(15) Kernel log buffer size (16 =&gt; 64KB， 17 =&gt; 128KB)
(16) [ ]Collect scheduler statistics
[ ]Debug memory allocations
[ ]Spinlock debugging
[ ]Sleep-inside-spinlock checking
[ ]kobject debugging
[ ]Compile the kernel with debug info
[ ]Debug Filesystem
[<em>] Verbose user fault messages
[ ] Wait queue debugging
[ ] Verbose kernel error messages
[</em>] Kernel low-level debugging functions
[ ]Kernel low-level debugging via EmbeddedICE DCC channel
[<em>]Kernel low-level debugging messages via S3C2410 UART
(0) S3C2410 UART to use for low-level debug
第十五部分
Security options &mdash;&gt;安全选项，这里的选项不明白的建议不要选，否则有可能弄巧成拙.
[ ] Enable access key retention support
在内核中保留 authentication token 和 access key
[ ] Enable different security models
允许内核选择不同的安全模型，如果未选中则内核将使用默认的安全模型
第十六部分
Cryptographic options &mdash;&gt; 加密选项
[</em>[<em>] Cryptographic API
提供核心的加密 API 支持.这里的加密算法被广泛的应用于驱动程序通信协议等机制中.子选项可以全不选，内核中若有其他部分依赖它，会自动选上
[ ]HMAC support
为 IPSec 所必须，可为 PPPoE 提供压缩支持
&lt; &gt;Null algorithms
NULL 加密算法(什么也不做)，用于 IPsec 协议的封装安全载荷模块(ESP)
&lt; &gt;MD4 digest algorithm 老旧的摘要算法，已经过时
&lt;</em>&gt; MD5 digest algorithm
主流摘要算法，128 位(已被中国山东大学王小云攻破，可以快速找到碰撞)
&lt; &gt;SHA1 digest algorithm
主流摘要算法，160 位(已被中国山东大学王小云攻破，可以快速找到碰撞)，速度与 MD5 相当
&lt; &gt;SHA256 digest algorithm
更好的摘要算法，256 位，速度较 SHA1 稍慢
&lt; &gt;SHA384 and SHA512 digest algorithms
更好的摘要算法，384/512 位，速度大约只有 SHA1 的 40-50%
&lt; &gt;Whirlpool digest algorithms
最安全的摘要算法，512 位，已被列入 ISO 标准，目前最新版本为 3.0(2003 年发布)
&lt; &gt;Tiger digest algorithms
号称最快的摘要算法，192 位，专门为 64 位 CPU 进行了优化
&lt;*&gt; DES and Triple DES EDE cipher algorithms 老迈的(DES)和尚佳的(Triple DES)对称加密算法
&lt; &gt;Blowfish cipher algorithm
又老又慢的对称加密算法
&lt; &gt;Twofish cipher algorithm 很强的对称加密算法，使用较广
&lt; &gt;Serpent cipher algorithm 很强的对称加密算法
&lt; &gt;AES cipher algorithms
最佳的对称加密算法(Rijndael)，128/192/256 位，强度最高，快速且节省内存
&lt; &gt;CAST5 (CAST-128) cipher algorithm 对称加密算法
&lt; &gt;CAST6 (CAST-256) cipher algorithm 对称加密算法
&lt; &gt;TEA and XTEA cipher algorithms 较弱的对称加密算法
&lt; &gt;ARC4 cipher algorithm 脆弱的流对称加密算法
&lt; &gt;Khazad cipher algorithm 对称加密算法
&lt; &gt;Anubis cipher algorithm 对称加密算法
&lt; &gt;Deflate compression algorithm
压缩算法，当在 IPSec 中使用 IPCOMP 协议时才需要
&lt; &gt;Michael MIC keyed digest algorithm
摘要算法，仅仅用于校验 iSCSI 设备传输的数据，因为算法本身比较脆弱
&lt; &gt;CRC32c CRC algorithm
摘要算法，可用于校验 iSCSI 设备传输的数据
&lt; &gt;Testing module 快速且丑陋的测试模块</p>
<p>Hardware crypto devices &mdash;&gt;
仅有 VIA C7 系列处理器支持硬件加密(VIA PadLock 高级加密引擎)
第十七部分
Library routines &mdash;&gt; 库子程序
&mdash; CRC-CCITT functions 传送 8-bit 字符，欧洲标准
&mdash; CRC32 functions
用于点对点的同步数据传输中，传输网络数据包所必须的
&lt;*&gt; CRC32c (Castagnoli， et al) Cyclic Redundancy-Check 用于点对点的同步数据传输中，比如 iSCSI 设备
第十八部分
Load an Alternate Configuration File 读入一个外部配置文件
Save Configuration to an Alternate File 将配置保存到一个外部文件</p>
<p>Linux 内核的主要配置选项_linux kernel4.1 配置详解_jack_201316888 的博客 - CSDN 博客
在内核中包含了一些不成熟的代码和功能，如果我们想使用这些功能，想打开相关的配置选项，就必需打开这一选项。</p>
<p>配置内核的命令是：</p>
<h1 id="make-config-文本配置方式">make config 文本配置方式</h1>
<h1 id="make-menuconfig-菜单配置方式">make menuconfig 菜单配置方式</h1>
<h1 id="make-xconfig-图形界面配置方式">make xconfig 图形界面配置方式</h1>
<p>我们可以采用任何一个命令配置内核，一般推荐使用 make menuconfig 来配置内核。</p>
<p>一．代码成熟度选项</p>
<p>Code maturity level options  &mdash;&gt;</p>
<p>[*] Prompt for development and/or incomplete code/drivers</p>
<p>[*]   Select only drivers expected to compile cleanly
在内核中包含了一些不成熟的代码和功能，如果我们想使用这些功能，想打开相关的配置选项，就必需打开这一选项。</p>
<p>三．可加载模块</p>
<p>Loadable module support  &mdash;&gt;
[<em>] Enable loadable module support
[</em>] Module unloading
[ ]     Forced module unloading
[<em>] Module versioning support (EXPERIMENTAL)
[ ] Source checksum for all modules
[</em>] Automatic kernel module loading
Enable loadable module support，很多人喜欢将全部功能、硬件支持一股脑的编进内核，而不是使用模块的方式。这样做非常不好（个人觉得）。其实我也做过嵌入式的开发，在针对特定硬件的平台下尽可能将内核编小，将始终是支持模块加载的。例如我们开发的防火墙就是做为内核的模块被加载的。使用模块支持，你的系统能具有更好的可扩充性。还有一个原因就是自己编写的功能模块、设备驱动模块（假设编写的质量不高）以模块方式工作引起 Kernel Panic 的机率要远远低于不支持模块全部编进内核的方式。讲了这么多，终于可以理直气壮的选上这一功能了。</p>
<p>Module unloading，不选这个功能，加载的模块就不能卸载。没什么需要多解释的，建议最好选上。</p>
<p>Forced module unloading，这个选项能强行卸载模块，即使内核认为这样并不安全，也就是说你可以把正在使用中的模快卸载掉。如果你不是内核开发人员或者骨灰级的玩家，不要选择这个选项。
Module versioning support (EXPERIMENTAL)，这个功能可以让你使用其它版本的内核模块，由于我自己写一些模块，所以我会用到这个选项，因为内核更新太快了，我的头文件更新根本赶不上内核的更新。</p>
<p>Module versioning support (EXPERIMENTAL)，这个功能可以让你使用其它版本的内核模块，由于我自己写一些模块，所以我会用到这个选项，因为内核更新太快了，我的头文件更新根本赶不上内核的更新。还有，虽然我在 Gentoo 下开发，但实际真实环境用的却是从 kernel.org 下载的内核。虽然我选择了这个选项，不过建议你不要选择这个选项。</p>
<p>Source checksum for all modules，这个功能是为了防止更改了内核模块的代码但忘记更改版本号而造成版本冲突。我估计现在没有哪家公司在开发中还没使用版本控制工具，所以不需要这项了。如果你不是自己写内核模块，那就更不需要这一选项了。</p>
<p>Automatic kernel module loading，这个选项能让内核自动的加载部份模块，建议你最好选上。举个例子说明一下，如模块 eth1394 依赖于模块 ieee1394。如果选择了这个选项，可以直接加载模块 eth1394；如果没有选择这个选项，必需先加载模块 ieee1394，再加载模块 eth1394，否则将出错。</p>
<p>四．总线支持配置</p>
<p>Bus support &mdash;&gt;</p>
<pre><code>   PCCARD (PCMCIA/CardBus) support  ---&gt;

       [ ]  Enable PCCARD debugging

       [ ]  16-bit PCMCIA support (NEW)

       [ ]    Load CIS updates from userspace (EXPERIMENTAL)(NEW)

       [ ]    PCMCIA control ioctl (obsolete) (NEW)

       --- PC-card bridges
</code></pre>
<p>PCCard (PCMCIA/CardBus) support，你的计算机是否支持 PCMCIA 卡</p>
<p>Enable PCCARD debugging，通常不需要选择调试 PCMCIA 设备，除非你是设备驱动的开发人员。</p>
<p>16-bit PCMCIA support，16 位的 PCMCIA 总线支持。</p>
<p>五．支持的可执行文件格式</p>
<p>Userspace binary formats -à
[<em>] Kernel support for ELF binaries
[</em>] Kernel support for a.out and ECOFF binaries
[<em>] Kernel support for MISC binaries
[</em>] RISC OS personality
Kernel support for ELF binaries，ELF 是开放平台下最常用的二进制文件，它支持不同的硬件平台。</p>
<p>Kernel support for a.out and ECOFF binaries，这是早期 UNIX 系统的可执行文件格式，目前已经被 ELF 格式取代。</p>
<p>Kernel support for MISC binaries，此选项允许插入二进制的封装层到内核中，当使用 Java、.NET、Python、Lisp 等语言编写的程序时非常有用。</p>
<p>六，文件系统</p>
<p>File systems</p>
<pre><code>   &lt;*&gt; Second extended fs support

   [*]   Ext2 extended attributes

   [*]     Ext2 POSIX Access Control Lists

   [*]     Ext2 Security Labels

   &lt;*&gt; Ext3 journalling file system support

   [*]   Ext3 extended attributes

   [*]     Ext3 POSIX Access Control Lists

   [*]     Ext3 Security Labels

   [ ] JBD (ext3) debugging support

   &lt;*&gt; Reiserfs support

   [ ]   Enable reiserfs debug mode

   [ ]   Stats in /proc/fs/reiserfs

   [*]   ReiserFS extended attributes

   [*]     ReiserFS POSIX Access Control Lists

   [*]     ReiserFS Security Labels

   JFS filesystem support

   [*]   JFS POSIX Access Control Lists

   [ ]   JFS debugging

   [ ]   JFS statistics

   XFS filesystem support

   [*]   Realtime support (EXPERIMENTAL)

   [*]   Quota support

   [*]   Security Label support

   [*]   POSIX ACL support

   &lt; &gt; Minix fs support

   &lt; &gt; ROM file system support

   [*] Quota support

   &lt; &gt;   Old quota format support

   Quota format v2 support

   [*] Dnotify support

   &lt; &gt; Kernel automounter support

   &lt; &gt; Kernel automounter version 4 support (also supports v3)

CD-ROM/DVD Filesystems  ---&gt;

DOS/FAT/NT Filesystems  ---&gt;

Pseudo filesystems  ---&gt;

Miscellaneous filesystems  ---&gt;

Network File Systems  ---&gt;

Partition Types  ---&gt;

Native Language Support  ---&gt;
</code></pre>
<p>Second extended fs support，标准的 Linux 文件系统，建议将这种文件系统编译进内核。</p>
<p>Ext2 extended attributes，Ext2 文件系统的结点名称、属性的扩展支持。</p>
<p>Ext2 POSIX Access Control Lists，POSIX 系统的访问权限列表支持。也就是 Owner/Group/Others 的 Read/Write/Execute 权限。请参考 Unix 标准文件系统权限。</p>
<p>Ext2 Security Labels，扩展的安全标签，例如 SELinux 之类的安全系统会使用到这样的扩展安全属性。</p>
<p>Ext3 journalling file system support，如果你熟悉 Redhat Linux，你一定会习惯 Ext3 文件系统。</p>
<p>Ext3 extended attributes，Ext3 文件系统的结点名称、属性的扩展支持。</p>
<p>Ext3 POSIX Access Control Lists，POSIX 系统的访问权限列表支持。</p>
<p>Ext3 Security Labels，扩展的安全标签支持。</p>
<p>JBD (ext3) debugging support，Ext3 的调试。除非你是文件系统的开发者，否则不要选上这一项。</p>
<p>Reiserfs support，如果你熟悉 Suse Linux，你一定会习惯 Reiserfs 文件系统。</p>
<p>Enable reiserfs debug mode，Reiserfs 的调试。除非你是文件系统的开发者，否则不要选上这一项。</p>
<p>Stats in /proc/fs/reiserfs，在 / proc/fs/reiserfs 文件中显示 Reiserfs 文件系统的状态。一般来说不需要选择这一项。</p>
<p>ReiserFS extended attributes，Reiserfs，文件系统的结点名称、属性的扩展支持。</p>
<p>ReiserFS POSIX Access Control Lists，POSIX 系统的访问权限列表支持。</p>
<p>ReiserFS Security Labels，扩展的安全标签支持。</p>
<p>JFS filesystem support，JFS 是 IBM 公司设计用于 AIX 系统上的文件系统。后来这一文件系统也能应用于 Linux 系统。</p>
<p>JFS POSIX Access Control Lists，POSIX 系统的访问权限列表支持。</p>
<p>JFS debugging，JFS 的调试。除非你是文件系统的开发者，否则不要选上这一项。</p>
<p>JFS statistics，在 / proc/fs/jfs 文件中显示 Reiserfs 文件系统的状态。一般来说不需要选择这一项。</p>
<p>XFS filesystem support，XFS 是 SGI 公司为其图形工作站设计的一种文件系统，后来这一文件系统也能应用于 Linux 系统。</p>
<p>Realtime support (EXPERIMENTAL)，实时卷的支持，能大幅提高大文件的读写速度。不过并不太安全，建议暂时不要选择这一选项。</p>
<p>Quota support，XFS 文件系统的配额支持。</p>
<p>Security Label support，扩展的安全标签支持。</p>
<p>POSIX ACL support，POSIX 系统的访问权限列表支持。</p>
<p>Minix fs support，Minix 可能是最早的 Linux 系统所使用的文件系统。后来被 Ext2 文件系统所取代。</p>
<p>ROM file system support，内存文件系统的支持。除非你是嵌入式系统的开发者，明确知道你要干什么，否则不要选这一项。</p>
<p>Quota support，配额支持。也就是说限制某个用户或者某组用户的磁盘占用空间。</p>
<p>Old quota format support，旧版本的配额支持。</p>
<p>Quota format v2 support，新版本（第二版）的配额支持。</p>
<p>Dnotify support，基于目录的文件变化的通知机制。</p>
<p>Kernel automounter support，内核自动加载远程文件系统的支持。</p>
<p>Kernel automounter version 4 support (also supports v3)，新的（第四版）的内核自动加载远程文件系统的支持，也支持第三版。</p>
<p>Linux-4.4-x86_64 内核配置选项简介_linux4.4_wdsfup 的博客 - CSDN 博客
Linux-4.4-x86_64 内核配置选项简介
作者：金步国
64-bit kernel
CONFIG_64BIT
编译 64 位内核. 本文仅讲述 x86_64(AMD64) 平台的内核编译, 所以这个是必选项.
General setup
常规设置
Cross-compiler tool prefix
CONFIG_CROSS_COMPILE
交叉编译工具前缀 (比如 &ldquo;arm-linux-&rdquo; 相当于使用 &ldquo;make CROSS_COMPILE=arm-linux-&rdquo; 进行编译). 除非你想配置后默认自动进行交叉编译, 否则不要使用此选项.</p>
<p>Support for paging of anonymous memory (swap)
CONFIG_SWAP
使用交换分区或者交换文件来做为虚拟内存
open by fhandle syscalls
CONFIG_FHANDLE
用户程序可以使用句柄 (而非文件名) 来追踪文件 (使用 open_by_handle_at(2)/name_to_handle_at(2) 系统调用), 即使某文件被重命名, 用户程序依然可定位那个文件. 此特性有助于实现用户空间文件服务器(userspace file server). 建议选 &ldquo;Y&rdquo;, 因为 systemd 和 udev 依赖于它.</p>
<p>Make audit loginuid immutable
CONFIG_AUDIT_LOGINUID_IMMUTABLE
审计时使用固定的 loginuid. 在使用 systemd 之类的系统上应该开启 (login 服务由 init 进程负责重启), 在使用 SysVinit 或 Upstart 之类的系统上应该关闭 (login 服务由系统管理员手动重启). OpenRC 就是一个基于 SysVinit 的系统.</p>
<p>Enable per-task delay accounting
CONFIG_TASK_DELAY_ACCT
在统计信息中包含进程等候系统资源 (cpu,IO 同步, 内存交换等) 所花费的时间
Enable extended accounting over taskstats
CONFIG_TASK_XACCT
在统计信息中包含进程的更多扩展信息. 不确定的选 &ldquo;N&rdquo;.
Enable per-task storage I/O accounting
CONFIG_TASK_IO_ACCOUNTING
在统计信息中包含进程在存储设备上的 I/O 字节数.</p>
<p>RCU Subsystem</p>
<p>RCU Implementation
RCU 的实现方式
Tree-based hierarchical RCU
CONFIG_TREE_RCU
基于树型分层结构的实现. 最适用于多 CPU 的非实时系统.
Preemptible tree-based hierarchical RCU
CONFIG_TREE_PREEMPT_RCU
抢占式基于树型分层结构的实现. 最适用于那些要求快速响应的多 CPU 实时系统.
UP-only small-memory-footprint RCU
CONFIG_TINY_RCU
最简单的实现, 能够大幅降低 RCU 系统的内存占用. 最适用于单 CPU 的非实时系统.
Preemptible UP-only small-memory-footprint RCU
CONFIG_TINY_PREEMPT_RCU
抢占式简单实现, 能够大幅降低 RCU 系统的内存占用. 最适用于那些要求快速响应的单 CPU 实时系统.
Consider userspace as in RCU extended quiescent state
CONFIG_RCU_USER_QS
在内核和用户边界设置钩子函数, 将运行在用户态的 CPU 从全局 RCU 状态机制中移除, 这样就不会在 RCU 系统中维护此 CPU 的时钟滴答. 除非你想要帮助开发 CONFIG_NO_HZ_FULL 模块, 否则不要打开此选项, 而且它还会对性能有不利影响.
Force context tracking
CONFIG_CONTEXT_TRACKING_FORCE
默认在内核和用户边界进行探测 (上下文跟踪), 以便测试依赖于此特性的各种功能 (比如用户空间的 RCU extended quiescent state), 这个特性目前仅用于调试目的, 未来也许会用于为 CONFIG_NO_HZ_FULL 模块提供支持
Tree-based hierarchical RCU fanout value
CONFIG_RCU_FANOUT
这个选项控制着树形 RCU 层次结构的端点数 (fanout), 以允许 RCU 子系统在拥有海量 CPU 的系统上高效工作. 这个值必须至少等于 CONFIG_NR_CPUS 的 1/4 次方 (4 次根号). 生产系统上应该使用默认值 (64). 仅在你想调试 RCU 子系统时才需要减小此值.
Tree-based hierarchical RCU leaf-level fanout value
CONFIG_RCU_FANOUT_LEAF
这个选项控制着树形 RCU 层次结构的叶子层的端点数 (leaf-level fanout). 对于期望拥有更高能耗比(更节能) 的系统, 请保持其默认值(16). 对于拥有成千上万个 CPU 的系统来说, 应该考虑将其设为最大值(CONFIG_RCU_FANOUT).
Disable tree-based hierarchical RCU auto-balancing
CONFIG_RCU_FANOUT_EXACT
强制按照 CONFIG_RCU_FANOUT_LEAF 的值, 而不是使用自动平衡树结构来实现 RCU 子系统. 目前仅用于调试目的. 未来也许会用于增强 NUMA 系统的性能.
Accelerate last non-dyntick-idle CPU&rsquo;s grace periods
CONFIG_RCU_FAST_NO_HZ
即使 CPU 还在忙碌, 也允许进入 dynticks-idle 状态, 并且阻止 RCU 每 4 个滴答就唤醒一次该 CPU, 这样能够更有效的使用电力, 同时也拉长了 RCU grace period 的时间, 造成性能降低. 如果能耗比对你而言非常重要 (你想节省每一分电力), 并且你不在乎系统性能的降低 (CPU 唤醒时间增加), 可以开启此选项. 台式机和服务器建议关闭此选项.
Enable RCU priority boosting
CONFIG_RCU_BOOST
允许提升 RCU 子系统的实时优先级 (包括读操作与写操作), 以避免 RCU 操作被阻塞太长时间. 如果系统的 CPU 负载经常很重, 或者你需要快速的实时响应系统, 那么就选 &ldquo;Y&rdquo;, 否则应该选 &ldquo;N&rdquo;.
Real-time priority to boost RCU readers to
CONFIG_RCU_BOOST_PRIO
允许提升被长时间抢占 (阻塞) 的 RCU 读操作的实时优先级到什么程度. 取值范围是 [1,99]. 默认值 &ldquo;1&rdquo; 适用于实时应用程序中不包含 CPU 密集型(CPU-bound) 线程的常规场合(例如大多数桌面系统). 但是如果你的实时应用程序拥有一个或多个 CPU 密集型线程, 那么可能需要增加这个值, 具体可以参考内核帮助的说明. 仅在你确实理解了的情况下再改变默认值.
Milliseconds to delay boosting after RCU grace-period start
CONFIG_RCU_BOOST_DELAY
在提升 RCU 读操作的优先级之前, 允许有多长时间潜伏期 (阻塞), 取值范围是 [0,3000], 单位是毫秒, 默认值是 &ldquo;500&rdquo;. 不确定的请使用默认值.
Offload RCU callback processing from boot-selected CPUs
CONFIG_RCU_NOCB_CPU
如果你想帮助调试内核可以开启, 否则请关闭.
Build-forced no-CBs CPUs
在开启 CONFIG_RCU_NOCB_CPU 选项的情况下, 指定哪些 CPU 是 No-CB CPU, 相当于预先设置 &ldquo;rcu_nocbs=&rdquo; 内核引导参数.
Kernel .config support
CONFIG_IKCONFIG
把内核的配置信息编译进内核中, 以后可以通过 scripts/extract-ikconfig 脚本从内核镜像中提取这些信息
Enable access to .config through /proc/config.gz
CONFIG_IKCONFIG_PROC
允许通过 /proc/config.gz 文件访问内核的配置信息
Kernel log buffer size
CONFIG_LOG_BUF_SHIFT
设置内核日志缓冲区的最小尺寸 (合理的设置应该等于 CONFIG_LOG_CPU_MAX_BUF_SHIFT * 最大 CPU 数量): 12(最小值)=4KB,&hellip;,16=64KB,17=128KB,18=256KB,&hellip;,25(最大值)
CPU kernel log buffer size contribution
CONFIG_LOG_CPU_MAX_BUF_SHIFT
每个 CPU 的内核日志缓存大小 (通常只有几行文字, 但在报告故障时可能会产生大量文字). 例如在最大 CPU 数量(包含热插拔 CPU) 为 64 的系统上, 如果 CONFIG_LOG_BUF_SHIFT=18, 那么该值应该设为 12</p>
<p>CONFIG_CGROUPS</p>
<p>Example debug cgroup subsystem
CONFIG_CGROUP_DEBUG
导出 cgroups 框架的调试信息, 仅用于调试目的.</p>
<p>Device controller for cgroups
CONFIG_CGROUP_DEVICE
允许为 cgroup 建立设备白名单, 这样 cgroup 内的进程将仅允许对白名单中的设备进行 mknod/open 操作. Docker 依赖于它.</p>
<p>Simple CPU accounting cgroup subsystem
CONFIG_CGROUP_CPUACCT
提供一个简单的资源控制器 (Resource Controller, 用于实现一组任务间的资源共享), 以监控 cgroup 内所有进程的总 CPU 使用量. Docker 依赖于它.
Resource counters
CONFIG_RESOURCE_COUNTERS
为 cgroup 提供独立于 controller 资源计数器</p>
<p>Memory Resource Controller Swap Extension
CONFIG_MEMCG_SWAP
给  Memory Resource Controller 添加对 swap 的管理功能. 这样就可以针对每个 cgroup 限定其使用的 mem+swap 总量. 如果关闭此选项, memory resource controller 将仅能限制 mem 的使用量, 而无法对 swap 进行控制 (进程有可能耗尽 swap). 开启此功能会对性能有不利影响, 并且为了追踪 swap 的使用也会消耗更多的内存 (如果 swap 的页面大小是 4KB, 那么每 1GB 的 swap 需要额外消耗 512KB 内存), 所以在内存较小的系统上不建议开启.</p>
<p>Memory Resource Controller Swap Extension enabled by default
CONFIG_MEMCG_SWAP_ENABLED
如果开启此选项, 那么将默认开启 CONFIG_MEMCG_SWAP 特性, 否则将默认关闭. 即使默认开启也可以通过内核引导参数 &ldquo;swapaccount=0&rdquo; 禁止此特性.</p>
<p>Memory Resource Controller Kernel Memory accounting
CONFIG_MEMCG_KMEM
为 Memory Resource Controller 添加对内核对象所占用内存的管理功能. 和标准的 Memory Resource Controller 对内存的控制不一样之处在于: 这些内核对象所占用的内存是基于每个内存页的, 并且可以被 swap 到硬盘. 使用这个功能可以确保 cgroup 中的进程不会单独耗尽所有内核资源.</p>
<p>Enable perf_event per-cpu per-container group (cgroup) monitoring
CONFIG_CGROUP_PERF
将 per-cpu 模式进行扩展, 使其可以监控属于特定 cgroup 并运行于特定 CPU 上的线程.
Group CPU scheduler
CONFIG_CGROUP_SCHED
让 CPU 调度程序可以在不同的 cgroup 之间分配 CPU 的带宽. Docker 依赖于它. systemd 资源控制单元 (resource control unit) 的 CPUShares 功能依赖于它.</p>
<p>Block IO controller
CONFIG_BLK_CGROUP</p>
<p>Enable Block IO controller debugging
CONFIG_DEBUG_BLK_CGROUP
仅用于调试 Block IO controller 目的.
Checkpoint/restore support
CONFIG_CHECKPOINT_RESTORE
在内核中添加 &ldquo;检查点 / 恢复&rdquo; 支持. 也就是添加一些辅助的代码用于设置进程的 text, data, heap 段, 并且在 /proc 文件系统中添加一些额外的条目. 用于检测两个进程是否共享同一个内核资源的 kcmp() 系统调用依赖于它. 使用 systemd 的建议开启此项.
Namespaces support
CONFIG_NAMESPACES
命名空间支持. 主要用于支持基于容器的轻量级虚拟化技术 (比如 LXC 和 Linux-VServer 以及 Docker).
UTS namespace
CONFIG_UTS_NS
uname() 系统调用的命名空间支持
IPC namespace
CONFIG_IPC_NS
进程间通信对象 ID 的命名空间支持
User namespace
CONFIG_USER_NS
允许容器使用 user 命名空间. 如果开启此项, 建议同时开启 CONFIG_MEMCG 和 CONFIG_MEMCG_KMEM 选项, 以允许用户空间使用 &ldquo;memory cgroup&rdquo; 限制非特权用户的内存使用量. 不确定的选 &ldquo;N&rdquo;, 如果你打算构建一个 VPS 服务器就必须选 &ldquo;Y&rdquo;.
PID Namespaces
CONFIG_PID_NS
进程 PID 命名空间支持
Network namespace
CONFIG_NET_NS
网络协议栈的命名空间支持. systemd 服务单元 (service unit) 中的 &ldquo;PrivateNetwork/PrivateDevices&rdquo; 依赖于它.
Require conversions between uid/gids and their internal representation
CONFIG_UIDGID_STRICT_TYPE_CHECKS
强制将 uid/gid 转换为内部表示形式, 以让那些未对 uid/gid 进行转换的内核子系统代码也能正常编译. 不确定的选 &ldquo;N&rdquo;.
Automatic process group scheduling
CONFIG_SCHED_AUTOGROUP
每个 TTY 动态地创建任务分组 (cgroup), 这样就可以降低高负载情况下的桌面延迟. 也就是传说中的桌面 &quot; 鸡血补丁 &ldquo;, 桌面用户建议开启. 但服务器建议关闭.
Enable deprecated sysfs features to support old userspace tools
CONFIG_SYSFS_DEPRECATED
为了兼容旧版本的应用程序而保留过时的 sysfs 特性. 仅当在使用 2008 年以前的发行版时才需要开启, 2009 年之后的发行版中必须关闭. 此外, 使用 udev 或 systemd 的系统也必须关闭.
Enable deprecated sysfs features by default
CONFIG_SYSFS_DEPRECATED_V2
默认开启上述特性
Kernel-&gt;user space relay support (formerly relayfs)
CONFIG_RELAY
在某些文件系统 (比如 debugfs) 中提供 中继 (relay) 支持 (从内核空间向用户空间传递大批量数据). 主要用于调试内核.
Initial RAM filesystem and RAM disk (initramfs/initrd) support
CONFIG_BLK_DEV_INITRD
初始内存文件系统 ( initramfs,2.6 以上内核的新机制, 使用 cpio 格式, 占据的内存随数据的增减自动增减) 与初始内存盘 ( initrd,2.4 以前内核遗留的老机制, 使用 loop 设备, 占据一块固定的内存, 需要额外开启 CONFIG_BLK_DEV_RAM 选项才生效) 支持, 一般通过 lilo/grub 的 initrd 指令加载. 更多细节可以参考 &quot; Documentation/initrd.txt&rdquo; 文件, 关于 initrd 到 initramfs 的进化 ( 墙内镜像), 可以参考 IBM 上的两篇文章: Linux2.6 内核的 Initrd 机制解析和 Linux 初始 RAM 磁盘（initrd）概述.
Initramfs source file(s)
CONFIG_INITRAMFS_SOURCE
如果你想 将 initramfs 镜像直接嵌入内核 (比如嵌入式环境或者想使用 EFI stub kernel), 而不是通过 lilo/grub 这样的引导管理器加载, 可以使用此选项, 否则请保持空白. 这个选项指明用来制作 initramfs 镜像的原料, 可以是一个. cpio 文件, 或一个 Initramfs 虚根目录 (其下包含 &ldquo;bin,dev,etc,lib,proc,sys&rdquo; 等子目录), 或一个描述文件. 细节可以参考 &quot; Documentation/early-userspace/README&quot; 文档.[注意] 内核帮助文档说可以指定多个目录或文件是错误的, 实际只能接受单一的目录或文件
User ID to map to 0 (user root)
INITRAMFS_ROOT_UID
此选项仅在 CONFIG_INITRAMFS_SOURCE 中包含目录时才有效, 将此值设为非零 (例如 &ldquo;37&rdquo;), 那么所有 UID=37 的文件在打包到 initramfs 镜像内时, 其 UID 都将被设为 &ldquo;0&rdquo;.
Group ID to map to 0 (group root)
INITRAMFS_ROOT_GID
此选项仅在 CONFIG_INITRAMFS_SOURCE 中包含目录时才有效, 将此值设为非零 (例如 &ldquo;37&rdquo;), 那么所有 GID=37 的文件在打包到 initramfs 镜像内时, 其 GID 都将被设为 &ldquo;0&rdquo;.
Support initial ramdisks compressed using gzip
CONFIG_RD_GZIP
支持经过 gzip 压缩的 ramdisk 或 cpio 镜像
Support initial ramdisks compressed using bzip2
CONFIG_RD_BZIP2
支持经过 bzip2 压缩的 ramdisk 或 cpio 镜像
Support initial ramdisks compressed using LZMA
CONFIG_RD_LZMA
支持经过 LZMA 压缩的 ramdisk 或 cpio 镜像
Support initial ramdisks compressed using XZ
CONFIG_RD_XZ
支持经过 XZ 压缩的 ramdisk 或 cpio 镜像
Support initial ramdisks compressed using LZO
CONFIG_RD_LZO
支持经过 LZO 压缩的 ramdisk 或 cpio 镜像
Built-in initramfs compression mode
选择 initramfs 镜像的压缩格式.&ldquo;gzip&rdquo; 是兼容性最好的格式, 但是压缩率却最低.&ldquo;XZ&rdquo; 是目前渐渐流行的格式, 压缩率高, 解压速度也不慢.
Optimize for size
CONFIG_CC_OPTIMIZE_FOR_SIZE
编译时优化内核尺寸 (使用 GCC 的 &ldquo;-Os&rdquo; 而不是 &ldquo;-O2&rdquo; 参数编译), 这会得到更小的内核, 但是运行速度可能会更慢. 主要用于嵌入式环境.
Configure standard kernel features (expert users)
CONFIG_EXPERT
配置标准的内核特性 (仅供专家使用). 这个选项允许你改变内核的 &ldquo;标准&rdquo; 特性 (比如用于需要 &ldquo;非标准&rdquo; 内核的特定环境中), 仅在你确实明白自己在干什么的时候才开启.
Enable 16-bit UID system calls
CONFIG_UID16
允许对 UID 系统调用进行过时的 16-bit 包装, 建议关闭
Multiple users, groups and capabilities support
CONFIG_MULTIUSER
多用户 (组) 支持. 若选 &ldquo;N&rdquo;, 则所有进程都将以 &ldquo;UID=0,GID=0&rdquo; 运行(也就是禁止存在非 root 用户). 选 &ldquo;Y&rdquo;, 除非你确实知道自己在干什么.
sgetmask/ssetmask syscalls support
CONFIG_SGETMASK_SYSCALL
是否开启已被反对使用的 sys_sgetmask/sys_ssetmask 系统调用 (已不再被 libc 支持). 建议选 &ldquo;N&rdquo;.
Sysfs syscall support
CONFIG_SYSFS_SYSCALL
是否开启已被反对使用的 sys_sysfs 系统调用 (已不再被 libc 支持). 建议选 &ldquo;N&rdquo;.
Sysctl syscall support
CONFIG_SYSCTL_SYSCALL
二进制 sysctl 接口支持. 由于现在流行直接通过 / proc/sys 以 ASCII 明码方式修改内核参数 (需要开启 CONFIG_PROC_SYSCTL 选项), 所以已经不需要再通过二进制接口去控制内核参数, 建议关闭它以减小内核尺寸.
Load all symbols for debugging/ksymoops
CONFIG_KALLSYMS
装载所有的调试符号表信息, 会增大内核体积, 仅供调试时选择
Include all symbols in kallsyms
CONFIG_KALLSYMS_ALL
在 /proc/kallsyms 中包含内核知道的所有符号, 内核将会增大 300K, 仅在你确实需要的时候再开启
Enable support for printk
CONFIG_PRINTK
允许内核向终端打印字符信息. 任何由 printk 显示的字符串通常记录在 / var/log/messages 文件里. 如果关闭, 内核在初始化过程中将不会输出字符信息, 这会导致很难诊断系统故障, 并且 &ldquo;dmesg&rdquo; 命令也会失效. 仅在你确实不想看到任何内核信息时选 &ldquo;N&rdquo;. 否则请选 &ldquo;Y&rdquo;.
BUG() support
CONFIG_BUG
显示故障和失败条件 (BUG 和 WARN), 禁用它将可能导致隐含的错误被忽略. 建议仅在嵌入式设备或者无法显示故障信息的系统上关闭
Enable ELF core dumps
CONFIG_ELF_CORE
内存转储支持, 可以帮助调试 ELF 格式的程序, 用于调试和开发用户态程序
Enable PC-Speaker support
CONFIG_PCSPKR_PLATFORM
主板上的 蜂鸣器支持. 主板上的蜂鸣器只能发出或长或短的 &ldquo;滴&rdquo; 或 &ldquo;嘟嘟&rdquo; 声, 一般用于系统报警. 不要和能够播放音乐的扬声器混淆. 如果你的主板上没有就关闭, 有的话 (开机自检完成后一般能听到 &ldquo;滴&rdquo; 的一声) 还是建议开启.
Enable full-sized data structures for core
CONFIG_BASE_FULL
在内核中使用全尺寸的数据结构. 禁用它将使得某些内核的数据结构减小以节约内存, 但是将会降低性能
Enable futex support
CONFIG_FUTEX
快速用户空间互斥 (fast userspace mutexes) 可以使线程串行化以避免竞态条件, 也提高了响应速度. 禁用它将导致内核不能正确的运行基于 glibc 的程序
Enable eventpoll support
CONFIG_EPOLL
Epoll 系列系统调用 (epoll_*) 支持, 这是当前在 Linux 下开发大规模并发网络程序 (比如 Nginx) 的热门人选, 设计目的是取代既有 POSIX select(2)与 poll(2)系统接口, systemd 依赖于它. 建议开启.
Enable signalfd() system call
CONFIG_SIGNALFD
signalfd() 系统调用支持, 建议开启. 传统的处理信号的方式是注册信号处理函数, 由于信号是异步发生的, 要解决数据的并发访问和可重入问题. signalfd 可以将信号抽象为一个文件描述符, 当有信号发生时可以对其 read, 这样可以将信号的监听放到 select/poll/epoll 监听队列中. systemd 依赖于它.
Enable timerfd() system call
CONFIG_TIMERFD
timerfd() 系统调用支持, 建议开启. timerfd 可以实现定时器功能, 将定时器抽象为文件描述符, 当定时器到期时可以对其 read, 这样也可以放到 select/poll/epoll 监听队列中. 更多信息可以参考 linux 新的 API signalfd、timerfd、eventfd 使用说明.systemd 依赖于它.
Enable eventfd() system call
CONFIG_EVENTFD
eventfd() 系统调用支持, 建议开启. eventfd 实现了线程之间事件通知的方式, eventfd 的缓冲区大小是 sizeof(uint64_t), 向其 write 可以递增这个计数器, read 操作可以读取, 并进行清零. eventfd 也可以放到 select/poll/epoll 监听队列中. 当计数器不是 0 时, 有可读事件发生, 可以进行读取.</p>
<p>Use full shmem filesystem
CONFIG_SHMEM
完全使用 shmem 来代替 ramfs.shmem 是基于共享内存的文件系统 (可以使用 swap), 在启用 CONFIG_TMPFS 后可以挂载为 tmpfs 供用户空间使用, 它比简单的 ramfs 先进许多. 仅在微型嵌入式环境中且没有 swap 的情况下才可能会需要使用原始的 ramfs.
Enable AIO support
CONFIG_AIO
开启 POSIX 异步 IO 支持. 它常常被高性能的多线程程序使用, 建议开启
Enable madvise/fadvise syscalls
CONFIG_ADVISE_SYSCALLS
开启内核的 madvise()/ fadvise() 系统调用支持 (2.6.16 版本开始引入). 以允许应用程序预先提示内核, 它将如何使用特定的内存与文件. 这种措施有助于提升应用程序的性能. 建议选 &ldquo;Y&rdquo;.
Enable userfaultfd() system call
CONFIG_USERFAULTFD
开启内核的 userfaultfd() 系统调用支持 (从 4.3 版本开始引入). 该特性可以被诸如 QEMU/KVM 之类的虚拟化技术用来提高 GuestOS 热迁移性能.
Enable PCI quirk workarounds
CONFIG_PCI_QUIRKS
开启针对多种 PCI 芯片组的错误规避功能, 仅在确定你的 PCI 芯片组确实没有没有任何 bug 时才关闭此功能. 至于究竟哪些芯片组有 bug, 你可以直接打开 &quot; drivers/pci/quirks.c&quot;文件查看. 不确定的选&quot;Y&quot;.
Enable membarrier() system call
CONFIG_MEMBARRIER
开启内核的 membarrier() 系统调用支持 (与 Memory Barrier 相关). 有助于提升多 CPU 场景下的并行计算性能. 建议选 &ldquo;Y&rdquo;.
Embedded system
CONFIG_EMBEDDED
如果你是为嵌入式系统编译内核, 可以开启此选项, 这样一些高级选项就会显示出来. 单独选中此项本身对内核并无任何改变.
Kernel Performance Events And Counters
CONFIG_PERF_EVENTS
性能相关的事件和计数器支持 (既有硬件的支持也有软件的支持). 大多数现代 CPU 都会通过性能计数寄存器对特定类型的硬件事件(指令执行, 缓存未命中, 分支预测失败) 进行计数, 同时又丝毫不会减慢内核和应用程序的运行速度. 这些寄存器还会在某些事件计数到达特定的阈值时触发中断, 从而可以对代码进行性能分析. Linux Performance Event 子系统对上述特性进行了抽象, 提供了针对每个进程和每个 CPU 的计数器, 并可以被 tools/perf/ 目录中的 &ldquo;perf&rdquo; 工具使用.
Debug: use vmalloc to back perf mmap() buffers
CONFIG_DEBUG_PERF_USE_VMALLOC
主要用于调试 vmalloc 代码.
Enable VM event counters for /proc/vmstat
CONFIG_VM_EVENT_COUNTERS
&quot; /proc/vmstat&quot; 中包含了从内核导出的虚拟内存的各种统计信息. 开启此项后可以显示较详细的信息 (包含各种事件计数器), 关闭此项则仅仅显示内存页计数. 主要用于调试和统计.
Enable SLUB debugging support
CONFIG_SLUB_DEBUG
SLUB 调试支持, 禁用后可显著降低内核大小, 同时 / sys/kernel/slab 也将不复存在.
Disable heap randomization
CONFIG_COMPAT_BRK
禁用堆随机化 (heap randomization) 功能. 堆随机化可以让针对堆溢出的攻击变得困难, 但是不兼容那些古董级的二进制程序(2000 年以前). 如果你不需要使用这些古董程序, 那么选 &ldquo;N&rdquo;.
Choose SLAB allocator
选择内存分配管理器
SLAB
CONFIG_SLAB
久经考验的 slab 内存分配器, 在大多数情况下都具有良好的适应性.
SLUB (Unqueued Allocator)
CONFIG_SLUB
SLUB 与 SLAB 兼容, 但通过取消大量的队列和相关开销, 简化了 slab 的结构. 特别是在多核时拥有比 slab 更好的性能和更好的系统可伸缩性.
SLOB (Simple Allocator)
CONFIG_SLOB
SLOB 针对小型系统设计, 做了非常激进的简化, 以适用于内存非常有限 (小于 64M) 的嵌入式环境.
SLUB per cpu partial cache
CONFIG_SLUB_CPU_PARTIAL
让 SLUB 内存分配器使用基于每个 CPU 的局部缓存, 这样可以加速分配和释放属于此 CPU 范围内的对象, 但这样做的代价是增加对象释放延迟的不确定性. 因为当这些局部缓存因为溢出而要被清除时, 需要使用锁, 从而导致延迟尖峰. 对于需要快速响应的实时系统, 应该选 &ldquo;N&rdquo;, 服务器则可以选 &ldquo;Y&rdquo;.
Provide system-wide ring of trusted keys
CONFIG_SYSTEM_TRUSTED_KEYRING
在内核中创建一个密钥环, 从而允许向密钥环上添加受信任的密钥, 主要用于内核模块的签名. 如果你开启了 CONFIG_MODULE_SIG, 此项将被自动选中. 不需要使用内核模块签名检查功能的应该选 &ldquo;N&rdquo;
Profiling support
CONFIG_PROFILING
添加扩展的性能分析支持, 可以被 OProfile 之类的工具使用. 仅用于调试目的.
OProfile system profiling
CONFIG_OPROFILE
OProfile 性能分析工具支持, 仅用于调试目的.
OProfile multiplexing support
CONFIG_OPROFILE_EVENT_MULTIPLEX
OProfile multiplexing 技术支持
Kprobes
CONFIG_KPROBES
Kprobes 是一个轻量级的内核调试工具, 能在内核运行的几乎任意时间点进行暂停 / 读取 / 修改等操作的调试工具. 仅供调试使用.
Optimize very unlikely/likely branches
CONFIG_JUMP_LABEL
针对内核中某些 &ldquo;几乎总是为真&rdquo; 或者 &ldquo;几乎总是为假&rdquo; 的条件分支判断使用 &ldquo;asm goto&rdquo; 进行优化 (在分支预测失败时会浪费很多时间在回退上, 但是这种情况极少发生). 很多内核子系统都支持进行这种优化. 建议开启.
Static key selftest
CONFIG_STATIC_KEYS_SELFTEST
在内核启动时对上述分支优化补丁进行一次自我检查.
Transparent user-space probes
CONFIG_UPROBES
Uprobes 与 Kprobes 类似, 但主要用于用户空间的调试.
Stack Protector buffer overflow detection
GCC 的 &ldquo;stack-protector&rdquo; 功能可以在函数开始执行时, 在函数的返回地址末端设置一个敏感值, 当函数执行完成要返回时, 检查这个敏感值, 看看是否存在溢出. 如果有溢出则表明可能受到了堆栈溢出攻击, 内核将通过 panic 来阻止可能的攻击. 选项中的 &ldquo;None&rdquo; 表示关闭此功能,&ldquo;Regular&rdquo; 表示启用此功能但是仅提供较弱的保护 (需要 GCC-4.2 及以上版本),&ldquo;Strong&rdquo; 则表示提供较强的保护 (需要 GCC-4.9 及以上版本)
Enable GCOV-based kernel profiling
CONFIG_GCOV_KERNEL
基于 GCC 的 gcov( 代码覆盖率测试工具) 的 代码分析支持, 仅用于调试
Profile entire Kernel
CONFIG_GCOV_PROFILE_ALL
支持对整个内核进行分析. 内核体积将会显著增大, 并且运行速度显著减慢.
Enable loadable module support
可加载模块支持
Enable loadable module support
CONFIG_MODULES
打开可加载模块支持, 可以通过 &ldquo;make modules_install&rdquo; 把内核模块安装在 / lib/modules / 中. 然后可以使用 modprobe, lsmod, modinfo, insmod, rmmod 等工具进行各种模块操作.
Forced module loading
CONFIG_MODULE_FORCE_LOAD
允许使用 &ldquo;modprobe &ndash;force&rdquo; 在不校验版本信息的情况下强制加载模块, 这绝对是个坏主意! 建议关闭.
Module unloading
CONFIG_MODULE_UNLOAD
允许卸载已经加载的模块. 如果将模块静态编译进内核中, 那么内核的执行效率会更好. 如果代码作为动态模块加载, 那么不使用时可以减少内核的内存使用并减少启动的时间, 然而内核和模块在内存上相互独立又会影响内核的执行性能.
Forced module unloading
CONFIG_MODULE_FORCE_UNLOAD
允许强制卸载正在使用中的模块 (rmmod -f), 即使可能会造成系统崩溃. 这又是一个坏主意! 建议关闭.
Module versioning support
CONFIG_MODVERSIONS
允许使用为其他内核版本编译的模块, 可会造成系统崩溃. 这同样是个坏主意! 建议关闭.
Source checksum for all modules
CONFIG_MODULE_SRCVERSION_ALL
为模块添加 &ldquo;srcversion&rdquo; 字段, 以帮助模块维护者准确的知道编译此模块所需要的源文件, 从而可以校验源文件的变动. 仅内核模块开发者需要它.
Module signature verification
CONFIG_MODULE_SIG
在 加载模块时检查 模块签名, 详情参见 &quot; Documentation/module-signing.txt&quot; 文件.[!! 警告!!] 开启此选项后, 必须确保模块签名后没有被 strip(包括 rpmbuild 之类的打包工具).
Require modules to be validly signed
CONFIG_MODULE_SIG_FORCE
仅加载已签名并且密钥正确的模块, 拒绝加载未签名或者签名密钥不正确的模块
Automatically sign all modules
CONFIG_MODULE_SIG_ALL
在执行 &ldquo;make modules_install&rdquo; 安装模块的时候, 自动进行签名. 否则你必须手动使用 scripts/sign-file 工具进行签名.
Which hash algorithm should modules be signed with?
选择对模块签名时使用的散列函数. 建议使用强度最高的 &ldquo;SHA-512&rdquo; 算法. 注意: 所依赖的散列算法必须被静态编译进内核. 对于 &ldquo;SHA-512&rdquo; 来说, 就是 CONFIG_CRYPTO_SHA512 和 CONFIG_CRYPTO_SHA512_SSSE3(如果你的 CPU 支持 SSSE3 指令集的话).
Compress modules on installation
CONFIG_MODULE_COMPRESS
在&rsquo;make modules_install&rsquo;时对内核模块进行压缩. 传统的 module-init-tools 工具可能支持 gzip 压缩, 而新式的 kmod 可能支持 gzip 与 xz 压缩. 使用 Kbuild 在内核树之外编译的模块也会同样在安装时被压缩. 不确定的选 &ldquo;N&rdquo;.
Enable the block layer
块设备支持
Enable the block layer
CONFIG_BLOCK
块设备支持, 使用 SSD / 硬盘 / U 盘 / SCSI/SAS 设备者必选. 除非你是某些特殊的嵌入式系统, 否则没有理由不使用块设备.
Block layer SG support v4
CONFIG_BLK_DEV_BSG
为块设备启用第四版 SG(SCSI generic)支持. v4 相比 v3 能够支持更复杂的 SCSI 指令 (可变长度的命令描述块, 双向数据传输, 通用请求 / 应答协议), 而且 UDEV 也要用它来获取设备的序列号. 对于使用 systemd 的系统来说, 必须选 &ldquo;Y&rdquo;. 对于不使用 systemd 的系统, 如果你需要通过 / dev/bsg/* 访问块设备, 建议开启此选项, 否则(通过 / dev/{sd*,st*,sr*}) 可以关闭.
Block layer SG support v4 helper lib
CONFIG_BLK_DEV_BSGLIB
你不需要手动开启此选项, 如果有其他模块需要使用, 会被自动开启.
Block layer data integrity support
CONFIG_BLK_DEV_INTEGRITY
某些块设备可以通过存储 / 读取额外的信息来保障 端到端的数据完整性, 这个选项为文件系统提供了相应的钩子函数来使用这个特性. 如果你的设备支持  T10/SCSI Data Integrity Field 或者 T13/ATA External Path Protection 特性, 那么可以开启此选项, 否则建议关闭.
Block layer bio throttling support
CONFIG_BLK_DEV_THROTTLING
Bio Throttling 支持, 也就是允许限制每个 cgroup 对特定设备的 IO 速率. 细节可以参考 &quot; Documentation/cgroups/blkio-controller.txt&quot;.
Block device command line partition parser
CONFIG_BLK_CMDLINE_PARSER
允许通过内核引导参数设定块设备的分区信息 ( Documentation/block/cmdline-partition.txt). 仅对某些嵌入式设备有意义.
Advanced partition selection
CONFIG_PARTITION_ADVANCED
如果你想支持各种不同的磁盘分区格式 (特别是与 UEFI 配合使用的 GPT 格式), 务必选中此项.
Acorn partition support
CONFIG_ACORN_PARTITION
Acorn 操作系统使用的分区格式, 请根据实际情况选择子项, 这里省略
Alpha OSF partition support
CONFIG_OSF_PARTITION
Alpha 平台上使用的分区格式
Amiga partition table support
CONFIG_AMIGA_PARTITION
AmigaOS 使用的分区格式
Atari partition table support
CONFIG_ATARI_PARTITION
Atari OS 使用的分区格式
Macintosh partition map support
CONFIG_MAC_PARTITION
苹果的 Macintosh 平台使用的分区格式
PC BIOS (MSDOS partition tables) support
CONFIG_MSDOS_PARTITION
渐成历史垃圾, 但目前依然最常见的 DOS 分区格式. 除非你确信不使用此格式, 否则必选. 其下的子项根据实际情况选择.
Windows Logical Disk Manager (Dynamic Disk) support
CONFIG_LDM_PARTITION
使用 Windows Logical Disk Manager 创建的分区格式. 参见 &quot; Documentation/ldm.txt&quot;
SGI partition support
CONFIG_SGI_PARTITION
SGI 平台上使用的分区格式
Ultrix partition table support
CONFIG_ULTRIX_PARTITION
DEC/Compaq Ultrix 平台上使用的分区格式
Sun partition tables support
CONFIG_SUN_PARTITION
SunOS 平台上使用的分区格式
Karma Partition support
CONFIG_KARMA_PARTITION
Rio Karma MP3 player 使用的分区格式
EFI GUID Partition support
CONFIG_EFI_PARTITION
代表未来趋势, 眼下正大红大紫的 EFI  GPT( GUID Partition Table) 分区格式. 建议开启. 如果你在 UEFI 平台上安装则必须开启.
SYSV68 partition table support
CONFIG_SYSV68_PARTITION
Motorola Delta 机器上使用的分区格式
IO Schedulers
IO 调度器 ( 另一篇文章)
Deadline I/O scheduler
CONFIG_IOSCHED_DEADLINE
deadline 调度器. 简洁小巧 (只有 400 + 行代码), 提供了最小的读取延迟, 非常适合同一时间只有少数个别进程进行 IO 请求的情况. 如果你希望尽快读取磁盘, 而不介意写入延迟, 那它是最佳选择. 通常对于数据库工作负载有最佳的表现.
CFQ I/O scheduler
CONFIG_IOSCHED_CFQ
cfq( Complete Fair Queuing) 调度器. 努力在各内核线程间公平分配 IO 资源, 适用于系统中存在着大量内核线程同时进行 IO 请求的情况. 但对于只有少数内核线程进行密集 IO 请求的情况, 则会出现明显的性能下降.
CFQ Group Scheduling support
CONFIG_CFQ_GROUP_IOSCHED
允许将 CFQ 和 cgroup 组合使用, 也就是将每个 cgroup 看成一个整体, 在各 cgroup 之间进行 IO 资源的分配. 参见 &quot; Documentation/cgroups/blkio-controller.txt&quot;文件. 还可以参考一下《Linux 内核精髓》中的&quot; 使用 Block I/O 控制器 &quot; 一章.
BFQ I/O scheduler
CONFIG_IOSCHED_BFQ
bfq(Budget Fair Queueing) 调度器. 这是一个基于 CFQ 调度器的改进版本, 更适合于对交互性要求比较高的场合, 比如桌面系统和实时系统. 如果静态编译进内核, 还支持和 cgroup 配合, 实现分层调度 (hierarchical scheduling).
BFQ hierarchical scheduling support
CONFIG_CGROUP_BFQIO
通过 cgroup 文件系统接口, 允许将 BFQ 分层使用 (类似 CONFIG_CFQ_GROUP_IOSCHED), 这个子系统的名字是 &ldquo;bfqio&rdquo;.
Default I/O scheduler
默认 IO 调度器. 如果上述调度器都是模块, 那么将使用最简单的内置 NOOP 调度器. NOOP(No Operation) 调度器只是一个简单的 FIFO 队列, 不对 IO 请求做任何重新排序处理 (但还是会做一定程度的归并), 适合于 SSD/U 盘 / 内存 / 虚拟机硬盘 / SAN(Storage Area Networks) 等 无需寻道的存储设备, 重点是可以节约 CPU 资源, 但不适用于普通硬盘这样的需要依靠磁头来定位的设备. 另外, 有人说拥有 TCQ/ NCQ 技术 (能够自动重新排序) 的硬盘也适合用 NOOP 调度器, 这个说法其实并不那么合理, 但笔者在此不敢断言, 希望读者在严谨的测试之后再做定夺.
Processor type and features
中央处理器 (CPU) 类型及特性
DMA memory allocation support
CONFIG_ZONE_DMA
允许为寻址宽度不足 32 位的设备 (也就是 ISA 和 LPC 总线设备) 在 物理内存的前 16MB 范围内 (也就是传统上 x86_32 架构的 ZONE_DMA 区域)分配内存. 不确定的选 &ldquo;N&rdquo;, 内核中若有其它驱动 (主要是某些老旧的声卡) 需要它会自动选中此项.[提示]LPC 总线通常和主板上的南桥物理相连, 通常连接了一系列的传统设备: BIOS,PS/2 键盘, PS/2 鼠标, 软盘, 并口设备, 串口设备, 某些集成声卡, TPM(可信平台模块), 等等.[题外话] x86_64 已经没有 ZONE_HIGHMEM 了
Symmetric multi-processing support
CONFIG_SMP
SMP(对称多处理器) 支持, 如果你有多个 CPU 或者使用的是多核 CPU 就选上.
Processor feature human-readable names
CONFIG_X86_FEATURE_NAMES
让 /proc/cpuinfo 中的 CPU 特性标记更具可读性. 选 &ldquo;Y&rdquo;.
Support x2apic
CONFIG_X86_X2APIC
x2apic 支持. 具有这个特性的 CPU 可以使用 32 位的 APIC ID(可以支持海量的 CPU), 并且可以使用 MSR 而不是 mmio 去访问 local APIC (更加高效). 可以通过 &ldquo;grep x2apic /proc/cpuinfo&rdquo; 命令检查你的 CPU 是否支持这个特性. 注意: 有时候还需要在 BIOS 中也开启此特性才真正生效.[提示] 在虚拟机中, 还需要 VMM 的支持 (例如 qemu-kvm).
Enable MPS table
CONFIG_X86_MPPARSE
如果是不支持 acpi 特性的古董级 SMP 系统就选上. 但现今的 64 位系统早都已经支持 acpi 了, 所以可以安全的关闭.
Support for extended (non-PC) x86 platforms
CONFIG_X86_EXTENDED_PLATFORM
支持非标准的 PC 平台: Numascale NumaChip, ScaleMP vSMP, SGI Ultraviolet. 绝大多数人都遇不见这些平台.
Numascale NumaChip
CONFIG_X86_NUMACHIP
Numascale NumaChip 平台支持
ScaleMP vSMP
CONFIG_X86_VSMP
ScaleMP vSMP 平台支持
SGI Ultraviolet
CONFIG_X86_UV
SGI Ultraviolet 平台支持
Intel Low Power Subsystem Support
CONFIG_X86_INTEL_LPSS
为 Intel  Lynx Point  PCH 或更高级别芯片组中的 Intel Low Power Subsystem 技术提供支持. Lynx Point PCH 芯片组主要是为采用 LGA1150 的 Haswell 处理器提供支持.
AMD ACPI2Platform devices support
CONFIG_X86_AMD_PLATFORM_DEVICE
为 AMD Carrizo 以及后继架构的 I2C,UART,GPIO 提供支持.
Intel SoC IOSF Sideband support for SoC platforms
CONFIG_IOSF_MBI
为主打低功耗的 Intel SoC 平台 CPU 开启 &ldquo;sideband&rdquo; 寄存器访问支持. 这些 CPU 包括: BayTrail, Braswell, Quark
Single-depth WCHAN output
CONFIG_SCHED_OMIT_FRAME_POINTER
使用简化的 /proc/<PID>/wchan 值, 禁用此选项会使用更加精确的 wchan 值 (可以在 &ldquo;ps -l&rdquo; 结果的 WCHAN 域看到), 但会轻微增加调度器消耗.
Linux guest support
CONFIG_HYPERVISOR_GUEST
如果这个内核将在 虚拟机里面运行就开启, 否则就关闭.
Enable paravirtualization code
CONFIG_PARAVIRT
半虚拟化 (paravirtualization) 支持.
paravirt-ops debugging
CONFIG_PARAVIRT_DEBUG
仅供调试. paravirt-ops 是内核通用的半虚拟化接口.
Paravirtualization layer for spinlocks
CONFIG_PARAVIRT_SPINLOCKS
半虚拟化的自旋锁支持. 开启之后运行在虚拟机里的内核速度会加快, 但是运行在物理 CPU 上的宿主内核运行效率会降低 (最多可能会降低 5%). 请根据实际情况选择.
Xen guest support
CONFIG_XEN
Xen 半虚拟化技术支持
Enable Xen debug and tuning parameters in debugfs
CONFIG_XEN_DEBUG_FS
为 Xen 在 debugfs 中输出各种统计信息和调整选项. 对性能有严重影响. 仅供调试.
KVM Guest support (including kvmclock)
CONFIG_KVM_GUEST
KVM 客户机支持 (包括 kvmclock).
Paravirtual steal time accounting
CONFIG_PARAVIRT_TIME_ACCOUNTING
允许进行更细粒度的 task steal time 统计. 会造成性能的略微降低. 仅在你确实需要的时候才开启.
Memtest
CONFIG_MEMTEST
为内核添加 内存测试功能, 也就是添加 &ldquo;memtest&rdquo; 内核引导参数以支持对内存进行 &ldquo;体检&rdquo;. 仅在你确实知道这是什么东西并且确实需要的时候再开启. 否则请关闭.
Processor family
处理器系列, 请按照你实际使用的 CPU 选择.&ldquo;Generic-x86-64&rdquo; 表示通用于所有 x86-64 平台, 而不是针对特定类型的 CPU 进行优化.
Supported processor vendors
CONFIG_PROCESSOR_SELECT
支持的 CPU 厂商, 按实际情况选择.
Enable DMI scanning
CONFIG_DMI
允许扫描 DMI( Desktop Management Interface)/ SMBIOS( System Management BIOS) 以 获得机器的硬件配置, 从而对已知的 bug bios 进行规避. 具体涉及到哪些机器可参见 &ldquo;drivers/acpi/blacklist.c&rdquo; 文件. 除非确定你的机器没有 bug, 否则请开启此项.
GART IOMMU support
CONFIG_GART_IOMMU
为较旧的 AMD Athlon64/Opteron/Turion/Sempron CPU 提供 GART  IOMMU 支持. 图形地址重映射表 ( Graphics Address Remapping Table)可以将物理地址不连续的系统内存映射成看上去连续的图形内存交给 GPU 使用, 是一种挖 CPU 内存补 GPU 内存机制, 这种机制也可以被认为是一种 &ldquo;伪 IOMMU&rdquo;(缺乏地址空间隔离和访问控制). 开启此选项以后, 在内存大于 3G 的系统上, 传统的 32 位总线 (PCI/AGP) 的设备将可以使用完全 DMA 的方式直接访问原本超出 32 位寻址范围之外的系统内存区域. 具体方法是: 通过编程让设备在受 GART 控制的显存区域工作, 然后使用 GART 将这个地址映射为真实的物理地址 (4GB 以上) 来实现的. USB / 声卡 / IDE/SATA 之类的设备常常需要它. 开启此选项之后, 除非同时开启了 CONFIG_IOMMU_DEBUG 选项或者使用了 &ldquo;iommu=force&rdquo; 内核引导参数, 否则此特性仅在条件满足的情况下 (内存足够大且确有支持 GART 的设备) 激活. 由于较新的 AMD CPU 都已配备了 AMD IOMMU(应该使用 CONFIG_AMD_IOMMU), 故而仅建议在内存大于 3G 的老式 AMD 系统上选 &ldquo;Y&rdquo;.
IBM Calgary IOMMU support
CONFIG_CALGARY_IOMMU
IBM xSeries/pSeries 系列服务器的  Calgary IOMMU 支持.
Should Calgary be enabled by default?
CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT
开启此选项表示默认启用 Calgary 特性, 关闭此选项表示默认禁用 Calgary 特性 (可以使用 &ldquo;iommu=calgary&rdquo; 内核引导参数开启).
Enable Maximum number of SMP Processors and NUMA Nodes
CONFIG_MAXSMP
让内核支持 x86_64 平台所能支持的最大 SMP 处理器数量和最大 NUMA 节点数量. 主要用于调试目的.
Maximum number of CPUs
CONFIG_NR_CPUS
支持的最大 CPU 数量, 每个 CPU 要占 8KB 的内核镜像, 最小有效值是 &ldquo;2&rdquo;, 最大有效值是 &ldquo;512&rdquo;. 注意: 这里的 &ldquo;CPU 数量&rdquo; 是指 &ldquo;逻辑 CPU 数量&rdquo;. 例如, 对于一颗带有超线程技术的 4 核 8 线程 CPU 来说, 相当于拥有 8 个 CPU.
SMT (Hyperthreading) scheduler support
CONFIG_SCHED_SMT
Intel 超线程技术 ( HyperThreading) 支持.
Multi-core scheduler support
CONFIG_SCHED_MC
针对多核 CPU 进行调度策略优化</p>
<p>Reroute for broken boot IRQs
CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS
这是一个对某些 芯片组 bug(在某些情况下会发送多余的 &quot; boot IRQ&quot;) 的修复功能. 开启此选项之后, 仅对有此 bug 的芯片组生效. 要检查哪些芯片组有此 bug 可以查看&quot; drivers/pci/quirks.c&quot;文件中的&quot;quirk_reroute_to_boot_interrupts_intel&quot; 函数.
Machine Check / overheating reporting
CONFIG_X86_MCE
MCE( Machine Check Exception)支持. 让 CPU 检测到硬件故障 (过热 / 数据错误) 时通知内核, 以便内核采取相应的措施(如显示一条提示信息或关机等). 更多信息可以 &ldquo;man mcelog&quot;看看. 可以通过&quot;grep mce /proc/cpuinfo&rdquo; 检查 CPU 是否支持此特性, 若支持建议选中, 否则请关闭. 当然, 如果你对自己的硬件质量很放心, 又是桌面系统的话, 不选也无所谓.
Intel MCE features
CONFIG_X86_MCE_INTEL
Intel CPU 支持
AMD MCE features
CONFIG_X86_MCE_AMD
AMD CPU 支持
Machine check injector support
CONFIG_X86_MCE_INJECT
MCE 注入支持, 仅用于调试
Enable vsyscall emulation
CONFIG_X86_VSYSCALL_EMULATION
对过时的 vsyscall 页提供仿真支持. 禁用此项大致相当于使用 &ldquo;vsyscall=none&rdquo; 内核引导参数 (差别在于当应用程序使用 vsyscall 时将直接崩溃(segfault) 而不会产生警告消息). 许多 2013 年之前编译的程序 (也可能包括某些新近编译的程序) 需要使用此特性.
Enable support for 16-bit segments
CONFIG_X86_16BIT
如果你需要使用 Wine 运行那些古董级的 16 位保护模式程序, 就选 &ldquo;Y&rdquo;, 否则选 &ldquo;N&rdquo;
Dell laptop support
CONFIG_I8K
Dell Inspiron 8000 笔记本的  System Management Mode 驱动 ( i8k). 该驱动可以读取 CPU 温度和风扇转速, 进而帮助 上层工具控制风扇转速. 该驱动仅针对 Dell Inspiron 8000 笔记本进行过测试, 所以不保证一定能适用于其他型号的 Dell 笔记本.
CPU microcode loading support
CONFIG_MICROCODE
CPU 的 微代码更新支持, 建议选中. CPU 的微代码更新就像是给 CPU 打补丁, 用于纠正 CPU 的行为. 更新微代码的常规方法是升级 BIOS, 但是也可以在 Linux 启动后更新. 比如在 Gentoo 下, 可以使用 &ldquo;emerge microcode-ctl&rdquo; 安装 microcode-ctl 服务, 再把这个服务加入 boot 运行级即可在每次开机时自动更新 CPU 微代码. 其他 Linux 系统可以参考 这个帖子.
Intel microcode loading support
CONFIG_MICROCODE_INTEL
Intel CPU 微代码支持
AMD microcode loading support
CONFIG_MICROCODE_AMD
AMD CPU 微代码支持
Early load microcode
CONFIG_MICROCODE_INTEL_EARLY
支持从 initrd 镜像首部加载微代码, 以便尽可能早的更新 CPU 微代码. 即使在 initrd 首部并未嵌入微代码也不会造成问题, 所以 &ldquo;Y&rdquo; 是安全的. 不过你真的需要吗? 笔者认为你一般并不需要:)
/dev/cpu/<em>/msr - Model-specific register support
CONFIG_X86_MSR
允许用户空间的特权进程 (使用 rdmsr 与 wrmsr 指令) 访问 x86 的 MSR 寄存器 ( Model-Specific Register) 以访问 CPU 的很多重要的参数. MSR 是非标准寄存器, 主要用于读取 CPU 的工作状态 (频率 / 电压 / 功耗 / 温度 / 性能等), 以及设置 CPU 的工作参数 (触发特定的 CPU 特性, 依 CPU 的不同而不同). msrtool 工具可以转储出 MSR 的内容. 不确定的可以选 &ldquo;M&rdquo;.
/dev/cpu/</em>/cpuid - CPU information support
CONFIG_X86_CPUID
允许用户空间的特权进程使用 CPUID 指令获得详细的 CPU 信息 ( CPUID):CPU 类型, 型号, 制造商信息, 商标信息, 序列号, 缓存等. 不确定的可以选 &ldquo;M&rdquo;.
Enable 1GB pages for kernel pagetables
CONFIG_DIRECT_GBPAGES
允许 内核页表使用大小为 1GB 的 Hugepages 并进行直线映射 (linear mapping), 需要高端 CPU 的支持 (可以用 &ldquo;grep pdpe1gb /proc/cpuinfo&rdquo; 命令检查). 这可以减小 页表缓存 ( Translation Lookaside Buffer)的压力, 从而提升系统的性能, 这对于拥有海量内存并且运行某些特定应用 (PosgreSQL,MySQL,Java,Memcached,KVM,Xen&hellip;) 的系统来说比较有意义. 如果你的 CPU 支持, 可以选 &ldquo;Y&rdquo;.
Numa Memory Allocation and Scheduler Support
CONFIG_NUMA
开启  NUMA(Non Uniform Memory Access) 支持. 虽然说集成了内存控制器的 CPU 都属于 NUMA 架构. 但事实上, 对于大多数只有一颗物理 CPU 的个人电脑而言, 即使支持 NUMA 架构, 也没必要开启此特性. 可以参考 SMP/NUMA/MPP 体系结构对比. 此外, 对于不支持 &ldquo;虚拟 NUMA&rdquo;, 或 &ldquo;虚拟 NUMA&rdquo; 被禁用的虚拟机 (即使所在的物理机是 NUMA 系统), 也应该关闭此项.
Old style AMD Opteron NUMA detection
CONFIG_AMD_NUMA
因为 AMD 使用一种旧式的方法读取 NUMA 配置信息 (新式方法是 CONFIG_X86_64_ACPI_NUMA), 所以如果你使用的是 AMD 多核 CPU, 建议开启. 不过, 即使开启此选项, 内核也会优先尝试 CONFIG_X86_64_ACPI_NUMA 方法, 仅在失败后才会使用此方法, 所以即使你不能确定 CPU 的类型也可以安全的选中此项.
ACPI NUMA detection
CONFIG_X86_64_ACPI_NUMA
使用基于 ACPI SRAT(System Resource Affinity Table) 技术的 NUMA 节点探测方法. 这也是检测 NUMA 节点信息的首选方法, 建议选中.
NUMA emulation
CONFIG_NUMA_EMU
仅供开发调试使用
Maximum NUMA Nodes (as a power of 2)
CONFIG_NODES_SHIFT
允许的最大 NUMA 节点数. 需要注意其计算方法: 最大允许节点数 = 2 CONFIG_NODES_SHIFT. 也就是说这里设置的值会被当做 2 的指数使用. 取值范围是 [1,10], 也就最多允许 1024 个节点.
Memory model
内存模式.&ldquo;Sparse Memory&rdquo; 主要用来支持内存热插拔, 相比其他两个旧有的内存模式, 代码复杂性也比较低, 而且还拥有一些性能上的优势, 对某些架构而言是唯一的可选项. 其他两个旧有的内存模式是:&quot; Discontiguous Memory&quot;和&quot; Flat Memory&quot;.
Sparse Memory virtual memmap
CONFIG_SPARSEMEM_VMEMMAP
对于 64 位 CPU 而言, 开启此选项可以简化 pfn_to_page/page_to_pfn 的操作, 从而提高内核的运行效率. 但是在 32 位平台则建议关闭. 更多细节可以参考 这个帖子.
Enable to assign a node which has only movable memory
CONFIG_MOVABLE_NODE
允许对一个完整的 NUMA 节点 (CPU 和对应的内存) 进行热插拔. 一般的服务器和个人电脑不需要这么高级的特性.
Allow for memory hot-add
CONFIG_MEMORY_HOTPLUG
支持向运行中的系统添加内存. 也就是内存热插支持.
Allow for memory hot remove
CONFIG_MEMORY_HOTREMOVE
支持从运行中的系统移除内存. 也就是内存热拔支持.
Allow for balloon memory compaction/migration
CONFIG_BALLOON_COMPACTION
允许规整 / 合并泡状内存 ( balloon memory). 内存的 Ballooning 技术是指虚拟机在运行时动态地调整它所占用的宿主机内存资源, 该技术在节约内存和灵活分配内存方面有明显的优势, 目前所有主流虚拟化方案都支持这项技术 (前提是客户机操作系统中必须安装有相应的 balloon 驱动). 由于内存的动态增加和减少会导致内存过度碎片化, 特别是对于 2M 尺寸的连续大内存页来说更加严重, 从而严重降低内存性能. 允许 balloon 内存压缩和迁移可以很好的解决在客户机中使用大内存页时内存过度碎片化问题. 如果你打算在虚拟机中使用大内存页 (huge page), 那么建议开启, 否则建议关闭.
Allow for memory compaction
CONFIG_COMPACTION
允许对 大内存页 (huge pages) 进行 规整. 主要是为了解决大内存页的碎片问题. 建议在使用大内存页的情况下开启此项, 否则建议关闭.
Page migration
CONFIG_MIGRATION
允许在保持虚拟内存页地址不变的情况下移动其所对应的物理内存页的位置. 这主要是为了解决两个问题:(1) 在 NUMA 系统上, 将物理内存转移到相应的节点上, 以加快 CPU 与内存之间的访问速度.(2) 在分配大内存页的时候, 可以避免碎片问题.
Enable bounce buffers
CONFIG_BOUNCE
为那些不能直接访问所有内存范围的驱动程序开启 bounce buffer 支持. 当 CONFIG_ZONE_DMA 被开启后, 这个选项会被默认开启 (当然, 你也可以在这里手动关闭). 这主要是为了那些不具备 IOMMU 功能的 PCI/ISA 设备而设, 但它对性能有些不利影响. 在支持 IOMMU 的设备上, 应该关闭它而是用 IOMMU 来代替.
Enable KSM for page merging
CONFIG_KSM
KSM( Kernel Samepage Merging) 支持: 周期性的扫描那些被应用程序标记为 &ldquo;可合并&rdquo; 的地址空间, 一旦发现有内容完全相同的页面, 就将它们合并为同一个页面, 这样就可以节约内存的使用, 但对性能有不利影响. 推荐和内核虚拟机 KVM( Documentation/vm/ksm.txt) 或者其他支持 &ldquo;MADV_MERGEABLE&rdquo; 特性的应用程序一起使用. KSM 并不默认开启, 仅在应用程序设置了 &ldquo;MADV_MERGEABLE&rdquo; 标记, 并且 /sys/kernel/mm/ksm/run 被设为 &ldquo;1&rdquo; 的情况下才会生效.
Low address space to protect from user allocation
CONFIG_DEFAULT_MMAP_MIN_ADDR
2009 年, 内核曾经爆过一个严重的 NULL 指针漏洞, 由于其根源是将 NULL 指针映射到地址 &ldquo;0&rdquo; 所致, 所以从 2.6.32 版本以后, 为了防止此类漏洞再次造成严重后果, 特别设置了此选项, 用于指定受保护的内存低端地址范围 (可以在系统运行时通过  /proc/sys/vm/mmap_min_addr 进行调整), 这个范围内的地址禁止任何用户态程序的写入, 以从根本上堵死此类漏洞可能对系统造成的损害. 但内核这种强加的限制, 对于需要使用 vm86 系统调用 (用于在保护模式的进程中模拟 8086 的实模式) 或者需要映射此低端地址空间的程序 (bitbake,dosemu,qemu,wine,&hellip;) 来说, 则会造成不兼容, 不过目前这些程序的新版本都进行了改进, 以适应内核的这种保护. 一般情况下,&ldquo;4096&rdquo; 是个明智的选择, 或者你也可以保持默认值.
Enable recovery from hardware memory errors
CONFIG_MEMORY_FAILURE
在具备 MCA(Machine Check Architecture) 恢复机制的系统上, 允许内核在物理内存中的发生数据错误的情况下, 依然坚强的纠正错误并恢复正常运行. 这需要有相应的硬件 (通常是 ECC 内存) 支持. 有 ECC 内存的选, 没有的就别选了.
HWPoison pages injector
CONFIG_HWPOISON_INJECT
仅用于调试.
Transparent Hugepage Support
CONFIG_TRANSPARENT_HUGEPAGE
大多数现代计算机体系结构都支持多种不同的 内存页面大小 (比如 x86_64 支持 4K 和 2M 以及 1G[需要 cpu-flags 中含有 &ldquo;pdpe1gb&rdquo;]). 大于 4K 的内存页被称为 &quot; 大页 &ldquo;( Hugepage). TLB( 页表缓存) 是位于 CPU 内部的 分页表 (虚拟地址到物理地址的映射表)缓冲区, 既高速又很宝贵 (尺寸很小). 如果系统内存很大(大于 4G) 又使用 4K 的内存页, 那么分页表将会变得很大而难以在 CPU 内缓存, 从而导致较高的 TLB 不命中概率, 进而降低系统的运行效率. 开启大内存页支持之后, 就可以使用大页(2M 或 1G), 从而大大缩小分页表的尺寸以大幅提高 TLB 的命中率, 进而 优化系统性能. 传统上使用大内存页的方法是通过 Hugetlbfs 虚拟文件系统 (CONFIG_HUGETLBFS), 但是 hugetlbfs 需要专门进行配置以及应用程序的特别支持. 所以从 2.6.38 版本开始引入了 THP( Transparent Hugepages), 目标是替代先前的 Hugetlbfs 虚拟文件系统 (CONFIG_HUGETLBFS).THP 允许内核在可能的条件下, 透明的 (对应用程序来说) 使用大页 ( huge pages) 与 HugeTLB,THP 不像 hugetlbfs 那样需要专门进行配置以及应用程序的特别支持. THP 将这一切都交给操作系统来完成, 也不再需要额外的配置, 对于应用程序完全透明, 因而可用于更广泛的应用程序. 这对于数据库 / KVM 等需要使用大量内存的应用来说, 可以提升其效能, 但对于内存较小 (4G 或更少) 的个人 PC 来说就没啥必要了. 详见 &quot; Documentation/vm/transhuge.txt&rdquo; 文档.
Transparent Hugepage Support sysfs defaults
设置 /sys/kernel/mm/transparent_hugepage/enabled 文件的默认值.&ldquo;always&rdquo; 表示总是对所有应用程序启用透明大内存页支持,&ldquo;madvise&rdquo; 表示仅对明确要求该特性的程序启用. 建议选 &ldquo;always&rdquo;.
Enable cleancache driver to cache clean pages if tmem is present
CONFIG_CLEANCACHE
Cleancache 是内核 VFS 层新增的特性, 可以被看作是内存页的 &quot; Victim Cache&quot;( 受害者缓存), 当回收内存页时, 先不把它清空, 而是把其加入到内核不能直接访问的 &quot; transcendent memory&quot;中, 这样支持 Cleancache 的文件系统再次访问这个页时可以直接从&quot;transcendent memory&quot; 加载它, 从而减少磁盘 IO 的损耗. 目前只有 zcache 和 XEN 支持 &ldquo;transcendent memory&rdquo;, 不过将来会有越来越多的应用支持. 开启此项后即使此特性不能得到利用, 也仅对性能有微小的影响, 所以建议开启. 更多细节请参考 &quot; Documentation/vm/cleancache.txt&quot; 文件.
Enable frontswap to cache swap pages if tmem is present
CONFIG_FRONTSWAP
Frontswap 是和 Cleancache 非常类似的东西, 在传统的 swap 前加一道内存缓冲 (同样位于 &ldquo;transcendent memory&rdquo; 中). 目的也是减少 swap 时的磁盘读写. CONFIG_ZSWAP 依赖于它, 建议开启.
Contiguous Memory Allocator
CONFIG_CMA
这是一个分配连续物理内存页面的分配器. 一些比较低端的 DMA 设备只能访问连续的物理内存, 同时透明大内存页也需要连续的物理内存. 传统的解决办法是在系统启动时, 在内存还很充足的时候, 先预留一部分连续物理内存页面, 留作后用, 但这部分内存就无法被挪作他用了, 为了可能的分配需求, 预留这么一大块内存, 并不是一个明智的方法. 而 连续内存分配器 ( Contiguous Memory Allocator) 可以做到允许这部分预留的内存被正常使用, 仅在确实需要的时候才将大块的连续物理内存分配给相应的驱动程序. 这个机制对于那些不支持 I/O map 和 scatter-gather 的设备很有作用. 详情参见 &ldquo;include/linux/dma-contiguous.h&rdquo; 文件. 此选项仅对嵌入式系统有意义, 不确定的选 &ldquo;N&rdquo;.
Track memory changes
CONFIG_MEM_SOFT_DIRTY
在内核页表的 PTE(Page Table Entry) 数据结构上添加一个 &ldquo;soft-dirty&rdquo; 位以追踪内存页内容的变化. 此特性基本上专用于 CRIU(Checkpoint/Restore In Userspace) 项目 (可以帮助容器进行热迁移). 不确定的选 &ldquo;N&rdquo;.
Compressed cache for swap pages
CONFIG_ZSWAP
ZSWAP 是一个放置在 swap 前面的压缩缓存, 它可以将需要换出的页压缩存放在内存中的压缩池里, 这样在压缩池没有满的时候, 可以避免使用真正的 swap 设备. 当压缩池满的时候, 则把最老的页解压后写入 swap 设备. 压缩池默认是内存总量的 20%(/sys/module/zswap/parameters/max_pool_percent). ZSWAP 不仅提升了 swap 的整体性能, 也变相的增加了 swap 空间. 选中此项后, 可以通过 &ldquo;zswap.enabled=1&rdquo; 内核引导参数开启此功能.
Common API for compressed memory storage
CONFIG_ZPOOL
通用的 内存压缩 API, 主要用于给 zbud(zswap) 或 zsmalloc 提供支持. 不确定的选 &ldquo;N&rdquo;, 如果内核有其他选项依赖于它会自动选中.
Low density storage for compressed pages
CONFIG_ZBUD
专用于 zswap 内部的低密度内存压缩 API, 最多允许将两个物理内存页压缩为一个压缩内存页, 这既有优势 (简单的空间收集及空闲空间复用) 也有劣势(潜在的低内存利用率). 此种算法还能确保压缩后的内存页不会比最初未压缩页数多. 不确定的选 &ldquo;N&rdquo;.
Memory allocator for compressed pages
CONFIG_ZSMALLOC
zsmalloc 压缩内存分配器主要用于给 zram 提供支持, 建议与 CONFIG_ZRAM 同开关. 参考: 3 种内存压缩方案对比.
Use page table mapping to access object in zsmalloc
CONFIG_PGTABLE_MAPPING
zsmalloc 默认使用基于内存复制的对象映射方法来访问跨越不同页面的区域, 但如果某些架构 (例如 ARM) 执行虚拟内存映射的速度快于内存复制, 那么应该将此项选 &ldquo;Y&rdquo;, 这将导致 zsmalloc 使用页表映射而不是内存复制来进行对象的映射. 你可以在你的系统上使用 &ldquo;<a href="https://github.com/spartacus06/zsmapbench%22">https://github.com/spartacus06/zsmapbench&quot;</a> 脚本来测试这两种方法的速度差异. 在 x86_64 平台上, Debian8 与 Fedora22 与 openSUSE13 此项默认为 &ldquo;N&rdquo;, 而 Ubuntu15 此项默认为 &ldquo;Y&rdquo;, 作者本人未测试过哪个更合理.
Enable idle page tracking
CONFIG_IDLE_PAGE_TRACKING
此特性跟踪哪些用户页面需要被工作负载使用, 哪些用户页面处于闲置状态. 此信息 (/sys/kernel/mm/page_idle) 可用于确定工作负载需要的用户内存大小. 从而帮助调优内存 cgroup 限制以及决定将此任务放置到集群中的那台机器上. 参见 Documentation/vm/idle_page_tracking.txt 文档. 不确定的选 &ldquo;N&rdquo;.
Support non-standard NVDIMMs and ADR protected memory
CONFIG_X86_PMEM_LEGACY
支持 Intel Sandy Bridge-EP 处理器使用的不符合 NVDIMM 规范的 非易失内存 (以电容做后备电力且掉电后不会丢失数据的内存). 仅有某些高端服务器才会使用这种外带电容供电的内存.
Check for low memory corruption
CONFIG_X86_CHECK_BIOS_CORRUPTION
低位内存脏数据检查, 即使开启此选项, 默认也不会开启此功能 (需要明确使用 &ldquo;memory_corruption_check=1&rdquo; 内核引导选项). 这些脏数据通常被认为是有 bug 的 BIOS 引起的, 默认每 60 秒(可以通过 memory_corruption_check_period 内核参数进行调整) 扫描一次 0-64k(可以通过 memory_corruption_check_size 内核参数进行调整)之间的区域. 这种检查所占用的开销非常小, 基本可以忽略不计. 如果始终检查到错误, 则可以通过 &ldquo;memmap=&rdquo; 内核引导参数来避免使用这段内存. 一般没必要选中, 如果你对 BIOS 不放心, 带着它试运行一段时间, 确认没问题之后再去掉.
Set the default setting of memory_corruption_check
CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK
设置 memory_corruption_check 的默认值, 选中表示默认开启 (相当于使用 &ldquo;memory_corruption_check=1&rdquo; 内核引导选项), 不选中表示默认关闭.
Amount of low memory, in kilobytes, to reserve for the BIOS
CONFIG_X86_RESERVE_LOW
为 BIOS 设置保留的低端地址 (默认是 64K). 内存的第一页(4K) 存放的必定是 BIOS 数据, 内核不能使用, 所以必须要保留. 但是有许多 BIOS 还会在 suspend/resume / 热插拔等事件发生的时候使用更多的页(一般在 0-64K 范围), 所以默认保留 0-64K 范围. 如果你确定自己的 BIOS 不会越界使用内存的话, 可以设为 &ldquo;4&rdquo;, 否则请保持默认值. 但是也有一些很奇葩的 BIOS 会使用更多的低位内存, 这种情况下可以考虑设为 &ldquo;640&rdquo; 以保留所有 640K 的低位内存区域.
MTRR (Memory Type Range Register) support
CONFIG_MTRR
MTRR( Memory type range registers)是 CPU 内的一组 MSR(Model-specific registers), 其作用是告诉 CPU 以哪种模式 (write-back/uncachable) 存取各内存区段效率最高. 这对于 AGP/PCI 显卡意义重大, 因为 write-combining 技术可以将若干个总线写传输捆绑成一次较大的写传输操作, 可以将图像写操作的性能提高 2.5 倍或者更多. 这段代码有着通用的接口, 其他 CPU 的寄存器同样能够使用该功能. 简而言之, 开启此选项是个明智的选择.
MTRR cleanup support
CONFIG_MTRR_SANITIZER
MTRR cleanup 的意思是将 MTRR 的连续输出转为离散的输出, 这样 X 驱动就可以在其中添加 writeback 项, 算是一种优化措施. 建议开启. 可以使用 &ldquo;mtrr_chunk_size&rdquo; 来限制最大的连续块尺寸.
MTRR cleanup enable value (0-1)
CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT
&ldquo;1&rdquo; 表示默认开启 CONFIG_MTRR_SANITIZER 特性, 相当于使用 &ldquo;enable_mtrr_cleanup&rdquo;,&ldquo;0&rdquo; 表示默认关闭 CONFIG_MTRR_SANITIZER 特性, 相当于使用 &ldquo;disable_mtrr_cleanup&rdquo;. 建议设为 &ldquo;1&rdquo;.
MTRR cleanup spare reg num (0-7)
CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT
这里设定的值等价于使用内核引导参数 &ldquo;mtrr_spare_reg_nr=N&rdquo; 中的 &ldquo;N&rdquo;. 也就是告诉内核 reg0N 可以被清理或改写 (参见 &ldquo;/proc/mtrr&rdquo; 文件). 在多数情况下默认值是 &ldquo;1&rdquo;, 其含义是 /proc/mtrr 中的 reg01 将会被映射. 一般保持其默认值即可. 修改此项的值通常是为了解决某些 MTRR 故障.
x86 PAT support
CONFIG_X86_PAT
PAT(Page Attribute Table) 是对 MTRR 的补充, 且比 MTRR 更灵活. 如果你的 CPU 支持 PAT(grep pat /proc/cpuinfo), 那么建议开启. 仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭.
x86 architectural random number generator
CONFIG_ARCH_RANDOM
Intel 从  Ivy Bridge 微架构开始 (对于 Atom 来说是从 Silvermont 开始), 在 CPU 中集成了一个高效的硬件随机数生成器 (称为 &ldquo;Bull Mountain&rdquo; 技术), 并引入了一个新的 x86 指令 &quot; RDRAND&rdquo;, 可以非常高效的产生随机数. 此选项就是对此特性的支持.
Supervisor Mode Access Prevention
CONFIG_X86_SMAP
SMAP(Supervisor Mode Access Prevention) 是 Intel 从 Haswell 微架构开始引入的一种新特征, 它在 CR4 寄存器上引入一个新标志位 SMAP, 如果这个标志为 1, 内核访问用户进程的地址空间时就会触发一个页错误, 目的是为了防止内核因为自身错误意外访问用户空间, 这样就可以避免一些内核漏洞所导致的安全问题. 但是由于内核在有些时候仍然需要访问用户空间, 因此 intel 提供了两条指令 STAC 和 CLAC 用于临时打开 / 关闭这个功能, 反复使用 STAC 和 CLAC 会带来一些轻微的性能损失, 但考虑到增加的安全性, 还是建议开启.
Intel MPX (Memory Protection Extensions)
CONFIG_X86_INTEL_MPX
Intel MPX(内存保护扩展) 是一种用于检测缓冲区溢出 bug 的硬件特性. 此选项并非用于保护内核自身, 而是用于允许应用程序利用 MPX 特性. 可以通过 &ldquo;grep mpx /proc/cpuinfo&rdquo; 检查你的 CPU 是否支持 MPX 特性. 详见 Documentation/x86/intel_mpx.txt 文档. 不确定的选 &ldquo;N&rdquo;.
EFI runtime service support
CONFIG_EFI
EFI/UEFI 支持. 如果你打算 在 UEFI/EFI 平台上安装 Linux(2010 年之后的机器基本都已经是 UEFI 规格了), 那么就必须开启此项 (开启后也依然可以在传统的 BIOS 机器上启动). UEFI 启动流程与传统的 BIOS 相差很大. 虽然 Linux 受到了所谓 &quot; 安全启动 &quot; 问题的阻挠 (已经 解决), 但是 UEFI 依然将迅速一统江湖.[提示] 在 UEFI 平台上安装 Linux 的关键之一是首先要用一个支持 UEFI 启动的 LiveCD 以 UEFI 模式启动机器.
EFI stub support
CONFIG_EFI_STUB
EFI stub 支持. 如果开启此项, 就可以不通过 GRUB2 之类的引导程序来加载内核, 而直接由 EFI 固件进行加载, 这样就可以不必安装引导程序了. 不过这是一个看上去很美的特性, 由于 EFI 固件灵活性比 GRUB2 差许多, 所以缺点有三:(1)不能在传统的 BIOS 机器上启动.(2)给内核传递引导参数很麻烦 (需要使用 &ldquo;efibootmgr -u&rdquo;).(3) 不能使用 intrd. 不过, 针对后两点的解决办法是: 使用 CONFIG_CMDLINE 和 CONFIG_INITRAMFS_SOURCE. 更多细节可参考 &quot; Documentation/x86/efi-stub.txt&quot; 文档.
EFI mixed-mode support
CONFIG_EFI_MIXED
允许在 32 位固件上启动 64 位内核. 选 &ldquo;N&rdquo;.
Enable seccomp to safely compute untrusted bytecode
CONFIG_SECCOMP
允许使用 SECCOMP 技术安全地运算非信任代码. 通过使用管道或其他进程可用的通信方式作为文件描述符 (支持读 / 写调用), 就可以利用 SECCOMP 把这些应用程序隔离在它们自己的地址空间. 这是一种有效的安全沙盒技术. systemd 也强烈建议开启它. 除非你是嵌入式系统, 否则不要关闭.
Enable -fstack-protector buffer overflow detection
CONFIG_CC_STACKPROTECTOR
开启 GCC 的 &ldquo;-fstack-protector&rdquo; 命令行选项, 以使用 GCC 中的编译器堆栈保护技术. 这样可以有效的防御以堆栈溢出为代表的缓冲区溢出攻击, 不过系统的运行速度也会受到一些影响. 服务器之类强调安全的场合建议开启, 个人 PC 之类的就不是很有必要了.
Timer frequency
内核时钟频率. 对于要求快速响应的场合, 比如桌面环境, 建议使用 1000Hz, 而对于不需要快速响应的 SMP/NUMA 服务器, 建议使用 250Hz 或 100Hz 或 300Hz(主要处理多媒体数据).
kexec system call
CONFIG_KEXEC
提供 kexec 系统调用, 可以 不必重启而切换到另一个内核 (不一定必须是 Linux 内核), 不过这个特性并不总是那么可靠. 如果你不确定是否需要它, 那么就是不需要.
kernel crash dumps
CONFIG_CRASH_DUMP
当内核崩溃时自动导出运行时信息的功能, 主要用于调试目的. 更多信息请参考 &quot; Documentation/kdump/kdump.txt&quot; 文件.
kexec jump
CONFIG_KEXEC_JUMP
kexec jump 支持. 这是对 CONFIG_KEXEC 的增强功能, 仅在你确实明白这是干啥的情况下再开启, 否则请关闭.
Physical address where the kernel is loaded
CONFIG_PHYSICAL_START
加载内核的物理地址. 如果内核不是可重定位的 (CONFIG_RELOCATABLE=n), 那么 bzImage 会将自己解压到该物理地址并从此地址开始运行, 否则, bzImage 将忽略此处设置的值, 而从引导装载程序将其装入的物理地址开始运行. 仅在你确实知道自己是在干什么的情况下才可以改变该值, 否则请保持默认.
Build a relocatable kernel
CONFIG_RELOCATABLE
使内核可以 在浮动的物理内存位置加载, 主要用于调试目的. 仅在你确实知道为什么需要的时候再开启, 否则请关闭.
Support for hot-pluggable CPUs
CONFIG_HOTPLUG_CPU
热插拔 CPU 支持 (通过 /sys/devices/system/cpu 进行控制).
Set default setting of cpu0_hotpluggable
CONFIG_BOOTPARAM_HOTPLUG_CPU0
开启 / 关闭此项的意思是设置 &ldquo;cpu0_hotpluggable&rdquo; 的默认值为 &ldquo;on/off&rdquo;. 开启此项表示默认将 CPU0 设置为允许热插拔.
Debug CPU0 hotplug
CONFIG_DEBUG_HOTPLUG_CPU0
仅用于调试目的.
Compat VDSO support
CONFIG_COMPAT_VDSO
是否将 VDSO(Virtual Dynamic Shared Object) 映射到旧式的确定性地址. 如果 Glibc 版本大于等于 2.3.3 选 &ldquo;N&rdquo;, 否则就选 &ldquo;Y&rdquo;.
vsyscall table for legacy applications
设置内核引导参数 &ldquo;vsyscall=[native|emulate|none]&rdquo; 的值. 对于使用 Glibc-2.14 以上版本的系统来说, 如果不需要使用特别老旧的静态二进制程序, 应该将此项设为 &ldquo;None&rdquo; 以提升性能与安全性.
Built-in kernel command line
CONFIG_CMDLINE_BOOL
将内核引导参数直接编进来. 在无法向内核传递引导参数的情况下 (比如在嵌入式系统上, 或者想使用 EFI stub kernel), 这就是唯一的救命稻草了. 如果你使用 grub 之类的引导管理器, 那么就可以不需要此特性.
Built-in kernel command string
CONFIG_CMDLINE
将要编译进内核的引导参数字符串.
Built-in command line overrides boot loader arguments
CONFIG_CMDLINE_OVERRIDE
开启此项表示完全忽略引导加载器传递过来的参数, 并仅仅只使用 CONFIG_CMDLINE 所指定的参数. 通常情况下建议关闭此项, 除非你确定引导加载器在传递内核引导参数的时候不能正常工作.
Enable the LDT (local descriptor table)
CONFIG_MODIFY_LDT_SYSCALL
Linux 允许用户空间的应用程序使用 modify_ldt(2) 系统调用针对每个 CPU 安装 Local Descriptor Table (LDT). 某些老旧的程序或者运行在 DOSEMU/Wine 中的程序需要使用此接口. 不确定的选 &ldquo;N&rdquo;(尤其是嵌入式系统与服务器).
Power management and ACPI options
电源管理和 ACPI 选项
Suspend to RAM and standby
CONFIG_SUSPEND
&ldquo;休眠到内存&rdquo;(ACPI S3) 支持. 也就是系统休眠后, 除了内存之外, 其他所有部件都停止工作, 重开机之后可以直接从内存中恢复运行状态. 要使用此功能, 你需要执行 &ldquo;echo mem &gt; /sys/power/state&rdquo; 命令, 还需要在 BIOS 中开启 S3 支持, 否则可能会有问题.
Enable freezer for suspend to RAM/standby
CONFIG_SUSPEND_FREEZER
选 &ldquo;Y&rdquo;. 除非你知道自己在做什么
Hibernation (aka &lsquo;suspend to disk&rsquo;)
CONFIG_HIBERNATION
&ldquo;休眠到硬盘&rdquo;(ACPI S4) 支持. 也就是将内存的内容保存到硬盘 (hibernation), 所有部件全都停止工作. 要使用此功能, 你首先需要使用内核引导参数 &ldquo;resume=/dev/swappartition&rdquo;, 然后执行 &ldquo;echo disk &gt; /sys/power/state&rdquo; 命令. 如果你不想从先前的休眠状态中恢复, 那么可以使用 &ldquo;noresume&rdquo; 内核引导参数. 更多信息, 可以参考 &quot; Documentation/power/swsusp.txt&quot; 文件.
Default resume partition
CONFIG_PM_STD_PARTITION
默认的休眠分区. 这个分区必须是 swap 分区. 不过这里设置的值会被明确的内核引导参数中的值覆盖.
Opportunistic sleep
CONFIG_PM_AUTOSLEEP
这是一种从 安卓借鉴过来的休眠方式. 这个特性在安卓系统上被称为 &ldquo;suspend blockers&rdquo; 或 &ldquo;wakelocks&rdquo;. 这是一种更激进的电源管理模式, 以尽可能节约电力为目的. 系统默认就处于休眠状态, 仅为内存和少数唤醒系统所必须的设备供电, 当有任务 (唤醒源) 需要运行的时候才唤醒相关组件工作, 工作完成后又立即进入休眠状态. 不过这些特性需要相应的设备驱动程序的支持. 目前除了安卓设备, 在 PC 和服务器领域, 能够利用此特性的驱动还比较少, 不过这是一项非常有前途的电源技术, 喜欢尝鲜的可以考虑开启.
User space wakeup sources interface
CONFIG_PM_WAKELOCKS
允许用户空间的程序通过 sys 文件系统接口, 创建 / 激活 / 撤销系统的 &ldquo;唤醒源&rdquo;. 需要与 CONFIG_PM_AUTOSLEEP 配合使用.
Maximum number of user space wakeup sources (0 = no limit)
CONFIG_PM_WAKELOCKS_LIMIT
用户空间程序允许使用的 &ldquo;唤醒源&rdquo; 数量,&ldquo;0&rdquo; 表示无限, 最大值是 &ldquo;100000&rdquo;.
Garbage collector for user space wakeup sources
CONFIG_PM_WAKELOCKS_GC
对 &ldquo;唤醒源&rdquo; 对象使用垃圾回收. 主要用于调试目的和 Android 环境.
Run-time PM core functionality[Device power management core functionality]
CONFIG_PM_RUNTIME
CONFIG_PM
允许 IO 设备 (比如硬盘 / 网卡 / 声卡) 在系统运行时进入省电模式, 并可在收到 (硬件或驱动产生的) 唤醒信号后恢复正常. 此功能通常需要硬件的支持. 建议在笔记本 / 嵌入式等需要节约电力的设备上选 &ldquo;Y&rdquo;.
Power Management Debug Support
CONFIG_PM_DEBUG
仅供调试使用
Enable workqueue power-efficient mode by default
CONFIG_WQ_POWER_EFFICIENT_DEFAULT
因为 &ldquo;per-cpu workqueue&rdquo; 的缓存更靠近对应的 CPU, 所以它比 &ldquo;unbound workqueue&rdquo; 拥有更好的性能, 但另一方面 &ldquo;per-cpu workqueue&rdquo; 通常又比 &ldquo;unbound workqueue&rdquo; 需要消耗更多的电能. 选中此项表示默认开启 &ldquo;workqueue.power_efficient&rdquo; 内核引导参数, 以使用 &ldquo;unbound workqueue&rdquo; 而不是 &ldquo;per-cpu workqueue&rdquo; 以降低功耗, 但是性能会有微小的损失.
ACPI (Advanced Configuration and Power Interface) Support
CONFIG_ACPI
高级配置与电源接口 ( Advanced Configuration and Power Interface) 包括了软件和硬件方面的规范, 目前已被软硬件厂商广泛支持, 并且取代了许多过去的配置与电源管理接口, 包括 PnP BIOS (Plug-and-Play BIOS), MPS(CONFIG_X86_MPPARSE), APM(Advanced Power Management) 等. 总之, ACPI 已经成为 x86 平台必不可少的组件, 如果你没有特别的理由, 务必选中此项.
AML debugger interface (EXPERIMENTAL)
CONFIG_ACPI_DEBUGGER
仅供调试使用.
Deprecated /proc/acpi files
CONFIG_ACPI_PROCFS
过时的 /proc/acpi 接口支持, 建议关闭.
Deprecated power /proc/acpi directories
CONFIG_ACPI_PROCFS_POWER
过时的 /proc/acpi 接口支持, 建议关闭.
Allow supported ACPI revision to be overriden
CONFIG_ACPI_REV_OVERRIDE_POSSIBLE
某些笔记本固件会根据操作系统支持的 ACPI 版本决定硬件的工作模式. 例如 Dell XPS 13 (2015) 期望操作系统支持 &ldquo;ACPI v5&rdquo; 规范, 但 Linux 实际上只支持 &ldquo;ACPI v4&rdquo; 规范, 此时固件会将声卡的工作模式从 HDA 模式 (Linux 支持此模式, 且为首选模式) 转换成 I2S 模式(次选模式). 选中此项后, 将强制 Linux 内核哄骗固件说它支持 &ldquo;ACPI v5&rdquo; 规范, 相当于使用了 &ldquo;acpi_rev_override&rdquo; 内核引导参数.
EC read/write access through /sys/kernel/debug/ec
CONFIG_ACPI_EC_DEBUGFS
仅供调试使用.
Deprecated /proc/acpi/event support
CONFIG_ACPI_PROC_EVENT
过时的 /proc/acpi/event 接口支持, 建议关闭.
AC Adapter
CONFIG_ACPI_AC
允许在外接交流电源和内置电池之间进行切换.
Battery
CONFIG_ACPI_BATTERY
允许通过 /proc/acpi/battery 接口查看电池信息.
Button
CONFIG_ACPI_BUTTON
允许守护进程通过 /proc/acpi/event 接口捕获 power/sleep/lid(合上笔记本)按钮事件, 并执行相应的动作, 软关机 (poweroff) 也需要它的支持.
Video
CONFIG_ACPI_VIDEO
对主板上的集成显卡提供 ACPI 支持. 注意: 仅支持集成显卡.
Fan
CONFIG_ACPI_FAN
允许用户层的程序对风扇进行控制 (开 / 关 / 查询状态)
Dock
CONFIG_ACPI_DOCK
支持兼容 ACPI 规范的扩展坞 (比如 IBM Ultrabay 和 Dell Module Bay) 支持.
Processor
CONFIG_ACPI_PROCESSOR
在支持 ACPI C2/C3 的 CPU 上, 将 ACPI 安装为 idle 处理程序. 有几种 CPU 频率调节驱动依赖于它. 而且目前的 CPU 都已经支持 ACPI 规范, 建议开启此项.
IPMI
CONFIG_ACPI_IPMI
允许 ACPI 使用 IPMI(智能平台管理接口) 的请求 / 应答消息访问 BMC(主板管理控制器).IPMI 通常出现在服务器中, 以允许通过诸如 ipmitool 这样的工具监视服务器的物理健康特征 (温度 / 电压 / 风扇状态 / 电源状态).
Processor Aggregator
CONFIG_ACPI_PROCESSOR_AGGREGATOR
支持 ACPI 4.0 加入的处理器聚合器 ( processor Aggregator)功能, 以允许操作系统对系统中所有的 CPU 进行统一的配置和控制. 目前只支持逻辑处理器 (也就是利用 Intel 超线程技术虚拟出来的 CPU)idling 功能, 其目标是降低耗电量. 不确定的应该选 &ldquo;N&rdquo;. 在某些服务器上此驱动(acpi_pad) 可能 与 BIOS 中的节能功能冲突
Thermal Zone
CONFIG_ACPI_THERMAL
ACPI thermal zone 支持. 系统温度过高时可以及时调整风扇的工作状态以避免你的 CPU 被烧毁. 目前所有 CPU 都支持此特性. 务必开启. 参见 CONFIG_THERMAL 选项.
NUMA support
CONFIG_ACPI_NUMA
通过读取系统固件中的 ACPI 表, 获得 NUMA 系统的 CPU 及物理内存分布信息. NUMA 系统必选.
Custom DSDT Table file to include
CONFIG_ACPI_CUSTOM_DSDT_FILE
允许将一个定制过的 DSDT 编译进内核. 详情参见 &quot; Documentation/acpi/dsdt-override.txt&quot; 文档. 看不懂的请保持空白.
ACPI tables override via initrd
CONFIG_ACPI_INITRD_TABLE_OVERRIDE
允许 initrd 更改  ACPI tables 中的任意内容. ACPI tables 是 BIOS 提供给 OS 的硬件配置数据, 包括系统硬件的电源管理和配置管理. 详情参见 &quot; Documentation/acpi/initrd_table_override.txt&quot; 文件.
Debug Statements
CONFIG_ACPI_DEBUG
详细的 ACPI 调试信息, 不搞开发就别选.
PCI slot detection driver
CONFIG_ACPI_PCI_SLOT
将每个 PCI 插槽都作为一个单独的条目列在 /sys/bus/pci/slots/ 目录中, 有助于将设备的物理插槽位置与逻辑的 PCI 总线地址进行对应. 不确定的选 &ldquo;No&rdquo;.
Power Management Timer Support
CONFIG_X86_PM_TIMER
ACPI PM Timer, 简称 &ldquo;ACPI Timer&rdquo;, 是一种集成在主板上的硬件时钟发生器, 提供 3.579545MHz 固定频率. 这是比较传统的硬件时钟发生器 (HPET 则是比较新型的硬件时钟发生器), 目前所有的主板都支持, 而且是 ACPI 规范不可分割的部分. 除非你确定不需要, 否则必选.
Container and Module Devices
CONFIG_ACPI_CONTAINER
支持 NUMA 节点 / CPU / 内存 的热插拔. Device ID: ACPI0004, PNP0A05, PNP0A06 (find /sys/devices/ -name &ldquo;PNP0A0[56]<em>&rdquo; -or -name &ldquo;ACPI0004</em>&rdquo;)
Memory Hotplug
CONFIG_ACPI_HOTPLUG_MEMORY
内存热插拔支持. Device ID: PNP0C80 (find /sys/devices/ -name &ldquo;PNP0C80*&rdquo;)
Smart Battery System
CONFIG_ACPI_SBS
智能电池系统 ( Smart Battery System) 可以让笔记型电脑显示及管理详细精确的电池状态信息. 使用锂电池的笔记本电脑必备利器. 但遗憾的是并不是所有笔记本都支持这项特性.
Hardware Error Device
CONFIG_ACPI_HED
Hardware Error Device (Device ID: PNP0C33) 能够通过 SCI 报告一些硬件错误 (通常是已经被纠正的错误). 如果你的系统中有设备 ID 为 &ldquo;PNP0C33&rdquo; 的设备 (find /sys/devices/ -name &ldquo;PNP0C33*&rdquo;), 那么就选上.
Allow ACPI methods to be inserted/replaced at run time
CONFIG_ACPI_CUSTOM_METHOD
允许在不断电的情况下直接对 ACPI 的功能进行删改, 包含一定危险性, 它允许 root 任意修改内存中内核空间的内容. 仅用于调试.
Boottime Graphics Resource Table support
CONFIG_ACPI_BGRT
在 /sys/firmware/acpi/bgrt/ 中显示 ACPI Boottime Graphics Resource Table , 以允许操作系统获取固件中的启动画面 (splash).
Hardware-reduced ACPI support only
CONFIG_ACPI_REDUCED_HARDWARE_ONLY
以 &ldquo;reduced hardware&rdquo; 模式编译内核的 ACPI 代码, 从而获得体积更小的内核但仅能运行在 ACPI &ldquo;reduced hardware&rdquo; 模式的硬件上. 不确定的选 &ldquo;N&rdquo;.
ACPI NVDIMM Firmware Interface Table (NFIT)
CONFIG_ACPI_NFIT
非易失性内存 ( NVDIMM) 支持. 此种内存使用超级电容作为后备电力, 并且使用非挥发性的 flash 存储介质来保存数据, 以使数据能够在掉电之后依然保存. 这是一种很有前途的技术, 但是目前笔记本与普通服务器并不使用这种内存.
ACPI Platform Error Interface (APEI)
CONFIG_ACPI_APEI
高级平台错误接口 (ACPI Platform Error Interface) 是 RAS(Reliability, Availability and Serviceability) 的一部分, 是定义在 ACPI 4.0 规范中的一个面向硬件错误管理的接口, 主要是为了统一 firmware/BIOS 和 OS 之间的错误交互机制, 使用标准的错误接口进行管理, 同时也扩展了错误接口的内容以便实现更加灵活丰富的功能.
APEI Generic Hardware Error Source
CONFIG_ACPI_APEI_GHES
&ldquo;Firmware First Mode&rdquo; 支持. 由于 BIOS/FIRMWARE 是平台相关的, 因此 BIOS/FIRMWARE 比 OS 更清楚硬件平台的配置情况, 甚至包含各种必须的修正 / 定制 / 优化. 这样, 在 &ldquo;Firmware First&rdquo; 模式下, BIOS/FIRMWARE 利用这一优势, 可以有针对性的对发生的硬件错误进行分析 / 处理 / 分发, 也可以更准确的记录错误的现场信息. 这样, 不但对硬件错误可以做出更准确, 更复杂的处理, 而且可以降低 OS 的复杂性和冗余度. 建议开启.
APEI PCIe AER logging/recovering support
CONFIG_ACPI_APEI_PCIEAER
让 PCIe AER errors 首先通过 APEI firmware 进行报告.
APEI memory error recovering support
CONFIG_ACPI_APEI_MEMORY_FAILURE
让 Memory errors 首先通过 APEI firmware 进行报告.
APEI Error INJection (EINJ)
CONFIG_ACPI_APEI_EINJ
仅供调试使用.
APEI Error Record Serialization Table (ERST) Debug Support
CONFIG_ACPI_APEI_ERST_DEBUG
仅供调试使用
Extended Error Log support
CONFIG_ACPI_EXTLOG
服务器 CPU 一般都会在非核心寄存器中记录比 CONFIG_X86_MCE 故障更详细的额外信息, 诸如 PFA(Predictive Failure Analysis) 之类的故障预警系统需要收集这些信息. 但由于这些非核心寄存器的位置差别很大没有统一标准, 系统软件难以直接读取这些扩展的错误信息. 此驱动可以在 MCE 或 CMCI 机制之外, 将系统固件提供的这些额外扩展错误信息导出到用户空间. 不确定的选 &ldquo;N&rdquo;.
PMIC (Power Management Integrated Circuit) operation region support
CONFIG_PMIC_OPREGION
电源管理芯片 ( PMIC) 支持. 此种芯片常用于以电池作为电源的嵌入式装置.
SFI (Simple Firmware Interface) Support
CONFIG_SFI
简单固件接口规范 ( Simple Firmware Interface)使用一种轻量级的简单方法 (通过内存中的一张静态表格) 从 firmware 向操作系统传递信息. 目前这个规范仅用于第二代 Intel Atom 平台, 其核心名称是 &quot; Moorestown&quot;.
CPU Frequency scaling
CONFIG_CPU_FREQ
CPUfreq 子系统允许动态改变 CPU 主频, 达到省电和降温的目的. 现如今的 CPU 都已经支持动态频率调整, 建议开启. 不过, 如果你是为虚拟机编译内核, 就没有必要开启了, 由宿主机内核去控制就 OK 了.
CPU frequency translation statistics
CONFIG_CPU_FREQ_STAT
通过 sysfs 文件系统输出 CPU 频率变化的统计信息
CPU frequency translation statistics details
CONFIG_CPU_FREQ_STAT_DETAILS
输出更详细的 CPU 频率变化统计信息
Default CPUFreq governor
默认的 CPU 频率 调节策略. 不同策略拥有不同的 调节效果.
&lsquo;performance&rsquo; governor
CONFIG_CPU_FREQ_GOV_PERFORMANCE
&lsquo;性能&rsquo;优先, 静态的将频率设置为 cpu 支持的最高频率. 最耗电, 发热量最大, 性能 / 效率比最低. 不建议使用.
&lsquo;powersave&rsquo; governor
CONFIG_CPU_FREQ_GOV_POWERSAVE
&lsquo;节能&rsquo;优先, 静态的将频率设置为 cpu 支持的最低频率, 严重影响性能. 此调控器事实上并不能节省电能, 因为系统需要花更长的时间才能进入空闲状态 (C1E,C3,C6). 不建议使用.
&lsquo;userspace&rsquo; governor for userspace frequency scaling
CONFIG_CPU_FREQ_GOV_USERSPACE
既允许手动调整 cpu 频率, 也允许用户空间的程序动态的调整 cpu 频率 (需要额外的调频软件). 比较麻烦, 不建议使用.
&lsquo;ondemand&rsquo; cpufreq policy governor
CONFIG_CPU_FREQ_GOV_ONDEMAND
&lsquo;随需应变&rsquo;, 内核周期性的考察 CPU 负载, 当 CPU 负载超过 / 低于设定的百分比阈值 (/sys/devices/system/cpu/cpufreq/ondemand/up_threshold) 时, 就自动将 cpu 频率设为最高 / 最低值 (也就是仅在最高和最低频率间切换), 比较适合台式机.[优化建议] 将 &ldquo;up_threshold&rdquo; 设为 95 左右, 可以获得更高的 &ldquo;性能 / 瓦特&rdquo; 比.
&lsquo;conservative&rsquo; cpufreq governor
CONFIG_CPU_FREQ_GOV_CONSERVATIVE
&lsquo;保守&rsquo;, 和&rsquo;ondemand&rsquo;相似, 内核同样周期性的考察 CPU 负载, 但是频率的升降是渐变式的 (通常只在相邻的两档频率间切换, 但具体取决于 &ldquo;/sys/devices/system/cpu/cpufreq/conservative/freq_step&rdquo; 的百分比设置, 设为 &ldquo;100&rdquo; 则等价于仅允许在最高和最低频率间切换): 当 CPU 负载超过百分比上限(/sys/devices/system/cpu/cpufreq/conservative/up_threshold) 时, 就自动提升一档 CPU 频率; 当 CPU 负载低于百分比下限 (/sys/devices/system/cpu/cpufreq/conservative/down_threshold) 时, 就自动降低一档 CPU 频率. 更适合用于笔记本 / PDA/x86_64 环境.[优化建议]&lsquo;conservative&rsquo;在默认设置下的 &ldquo;性能 / 瓦特&rdquo; 比通常不如&rsquo;ondemand&rsquo;优秀, 但是优化设置之后情况则可能反转. 例如, 在 &ldquo;down_threshold=93,up_threshold=97&rdquo; 的情况下, 可以比 &ldquo;up_threshold=95&rdquo; 的&rsquo;ondemand&rsquo;略有优势.
x86 CPU frequency scaling drivers
CPU 频率调节器驱动
Intel P state control
CONFIG_X86_INTEL_PSTATE
此驱动是专用于 Intel 的 &quot; Sandy Bridge&quot;/&quot; Ivy Bridge&quot;/&quot; Haswell&quot;或更新 CPU 微架构的首选驱动, 可以更好的支持&quot; Turbo Boost 2.0&quot; 技术.
Processor Clocking Control interface driver
CONFIG_X86_PCC_CPUFREQ
PCC(Processor Clocking Control) 接口支持. 此种接口仅对某些 HP Proliant 系列服务器有意义. 更多细节可以参考 &quot; Documentation/cpu-freq/pcc-cpufreq.txt&quot; 文件.
ACPI Processor P-States driver
CONFIG_X86_ACPI_CPUFREQ
此驱动同时支持 Intel 和 AMD 的 CPU, 这是较老的 intel cpu 与非 intel cpu 首选的驱动 (除非你的 CPU 是古董级别). 注意: 对于可以使用 P-state 驱动的 Intel CPU 来说, 应该选 &ldquo;N&rdquo;.
Legacy cpb sysfs knob support for AMD CPUs
CONFIG_X86_ACPI_CPUFREQ_CPB
为了兼容旧的用户空间程序而设置, 建议关闭.
AMD Opteron/Athlon64 PowerNow!
CONFIG_X86_POWERNOW_K8
过时的驱动, 仅为老旧的 K8 核心的 AMD 处理器提供支持. K10 以及更新的 CPU 应该使用 CONFIG_X86_ACPI_CPUFREQ 驱动.
AMD frequency sensitivity feedback powersave bias
CONFIG_X86_AMD_FREQ_SENSITIVITY
如果你使用 AMD Family 16h 或者更高级别的处理器, 同时又使用 &ldquo;ondemand&rdquo; 频率调节器, 开启此项可以更有效的进行频率调节 (在保证性能的前提下更节能).
Intel Enhanced SpeedStep (deprecated)
CONFIG_X86_SPEEDSTEP_CENTRINO
已被时代抛弃的驱动, 仅对老旧的迅驰平台 Intel Pentium M 或者 Intel Xeons 处理器有意义.
Intel Pentium 4 clock modulation
CONFIG_X86_P4_CLOCKMOD
已被时代抛弃的驱动, 仅对支持老旧的 Speedstep 技术的 Intel Pentium 4 / XEON 处理器有意义. 而且即便是在这样的 CPU 上, 因为种种兼容性问题可能导致的不稳定, 也不建议开启.
CPU idle PM support
CONFIG_CPU_IDLE
CPU idle 指令支持, 该指令可以让 CPU 在空闲时 &ldquo;打盹&rdquo; 以节约电力和减少发热. 只要是支持 ACPI 的 CPU 就应该开启. 由于所有 64 位 CPU 都已支持 ACPI, 所以不必犹豫, 开启![提示] 为虚拟机编译的内核就没有必要开启了, 由宿主机内核去控制就 OK 了.
Support multiple cpuidle drivers
CONFIG_CPU_IDLE_MULTIPLE_DRIVERS
允许 CONFIG_CPU_IDLE 为每个不同的 CPU 使用不同的驱动. 仅在你的系统由多个不同型号的 CPU 组成, 并且具有不同的唤醒潜伏时间和状态的时候才需要开启.
Cpuidle Driver for Intel Processors
CONFIG_INTEL_IDLE
专用于 Intel CPU 的 cpuidle 驱动. 而 CONFIG_CPU_IDLE 则可用于非 Intel 的 CPU.
Memory power savings
内存节能
Intel chipset idle memory power saving driver
CONFIG_I7300_IDLE
在某些具备内存节能特性的 intel 服务器芯片组上, 让内存也可以在空闲时通过 idle 指令 &ldquo;打盹&rdquo;. 这些 芯片组必须具备  I/O AT 支持 (例如 Intel 7300). 同时内存也需要支持此特性.
Bus options (PCI etc.)
总线选项
PCI support
CONFIG_PCI
PCI 是最重要的内部总线, 不但 PCI 与 PCI Express 设备依赖于它, 而且 USB/IDE/SATA/SCSI / 火线 (IEEE 1394)/PCMCIA/CardBus 等各种内部和外部总线也都依赖于它. 所以必须选 &ldquo;Y&rdquo;, 除非你知道自己在干什么.
Support mmconfig PCI config space access
CONFIG_PCI_MMCONFIG
允许通过 mmconfig 方式访问 PCI config space, 这种访问方式比传统的 IO 方式速度更快. 建议开启. MMCONFIG 的意思是 &ldquo;Memory-Mapped config&rdquo;, 它是 PCI Express 引入的新 总线枚举方式. 背景知识: PCI 设备都有一组叫做&rsquo;Configuration Space&rsquo;的寄存器, PCI-E 设备在 PCI 的基础上又增加了一组叫做&rsquo;Extended Configuration Space&rsquo;的寄存器. 这些寄存器都被映射到了内存中 (Memory-Mapped), 操作系统理应提供相应的 API 供设备驱动和诊断程序访问这些&rsquo;Configuration Space&rsquo;. 但如果操作系统没有提供 Memory-Mapped 方式的 API 的话, 这些驱动程序和诊断程序就必须自己根据操作系统的底层规则(IO 方式) 去访问, 这显然就增加了开发难度. 这个选项的目的就是提供 Memory-Mapped 方式的 API.
Read CNB20LE Host Bridge Windows
CONFIG_PCI_CNB20LE_QUIRK
CNB20LE 芯片组 PCI 热插拔支持. 除非你非常明确的知道你需要它, 否则请关闭此项.
PCI Express support
CONFIG_PCIEPORTBUS
PCI Express 是 PCI 的升级版并在软件层与 PCI 兼容, 其目标是统一电脑内部总线. 基本上只要不是古董机, 都早已支持 PCI-E 了. 选 &ldquo;Y&rdquo;.
PCI Express Hotplug driver
CONFIG_HOTPLUG_PCI_PCIE
如果你的主板和设备都支持 PCI Express 热插拔就可以选上.
Root Port Advanced Error Reporting support
CONFIG_PCIEAER
PCI Express Root Port Advanced Error Reporting (AER) 驱动支持. 这样, 发送到 Root Port 的 Error reporting messages 就会由 PCI Express AER 处理. 建议开启. 背景知识: PCI Express 定义了两种错误报告范例:(1)baseline, 所有 PCI-E 组件都必须要支持, 功能也比较基础.(2)AER(Advanced Error Reporting), 功能比较高级, 也更可靠, 但并不要求所有组件都支持.
PCI Express ECRC settings control
CONFIG_PCIE_ECRC
允许覆写 firmware/bios 设置的 PCI Express ECRC(端对端循环冗余校验). 建议关闭, 除非你确实知道为什么要开启.
PCIe AER error injector support
CONFIG_PCIEAER_INJECT
允许 PCI-E AER 注入, 仅用于测试目的.
PCI Express ASPM control
CONFIG_PCIEASPM
PCI Express  ASPM(Active State Power Management) 和 Clock Power Management 支持. 这是 PCI-E 规范制定的一种电源管理方案, 可以在设备空闲时采用节电模式. 建议开启. ASPM 可以在运行时通过 /sys/module/pcie_aspm/parameters/policy 进行开启或关闭.
Debug PCI Express ASPM
CONFIG_PCIEASPM_DEBUG
仅供调试.
Default ASPM policy
默认的 ASPM 电源管理策略. 下面的三个选项:&ldquo;BIOS default&rdquo; 表示使用 BIOS 中的设置作为默认.&ldquo;Powersave&rdquo; 表示在可能的情况下, 默认使用 &ldquo;L0s&rdquo; 和 &ldquo;L1&rdquo;, 以尽可能节约电力.&ldquo;Performance&rdquo; 表示禁止使用 &ldquo;L0s&rdquo; 和 &ldquo;L1&rdquo;(即使 BIOS 开启也同样禁止), 以保证最高性能.
Message Signaled Interrupts (MSI and MSI-X)
CONFIG_PCI_MSI
PCI/PCI-E 支持三类中断:(1)INTx 使用传统的 IRQ 中断, 可以与现行的驱动程序和操作系统兼容.(2)MSI 是 PCI2.2 规范中新增的, 通过写入特殊的内存地址来触发和发送中断, 该种方式脱离了中断引脚带来的数目限制, 并且延迟小 / 效率高. 不过 MSI 方式将中断全部落在单个 CPU 上, 对多核 CPU 利用不佳.(3)MSI-X 是在 PCI3.0 规范中新增的, 在 MSI 的基础上, 支持更多的消息数量以及独立的消息地址, 可以自动在多个 CPU 上分担中断, 更适合多 CPU 系统. 建议开启. 开启后, 也可以使用 &ldquo;pci=nomsi&rdquo; 内核引导参数关闭 MSI 特性.
PCI Debugging
CONFIG_PCI_DEBUG
将 PCI 调试信息输出到系统日志里. 如果你想诊断 PCI 设备的故障, 可以开启, 否则应该关闭.
Enable PCI resource re-allocation detection
CONFIG_PCI_REALLOC_ENABLE_AUTO
让内核自动检测 &ldquo;是否需要重新分配 PCI 资源&rdquo;. 即使此项已开启, 你依然可以用 &ldquo;pci=realloc=[on|off]&rdquo; 来覆盖它. 此项仅在已开启 CONFIG_PCI_IOV 的情况下才有意义. 此时, 如果 BIOS 没有为 SR-IOV(Single-Root I/O Virtualization) BAR(基地址寄存器) 分配资源, 那么内核将会自动对 PCI 资源进行重新分配. 不确定的选 &ldquo;N&rdquo;.
PCI Stub driver
CONFIG_PCI_STUB
PCI 设备穿透 ( PCI Stub) 的作用是将属主机的 PCI 设备跟目前绑定的驱动分离, 暂时由其接管, 最后再交给虚拟机内的客户操作系统自己去驱动这个 PCI 设备 (例如网卡穿透 / 显卡穿透), 以获得高性能. 由于 USB 等所有外围设备实际上也都是连接在 PCI 总线上的, 所以此功能同样适合各种外围设备, 例如 U 盘加密狗之类.
Xen PCI Frontend
CONFIG_XEN_PCIDEV_FRONTEND
如果你使用 XEN 的半虚拟化技术, 并且你的硬件支持 IOMMU, 那么可以开启此项, 否则应该关闭.
Interrupts on hypertransport devices
CONFIG_HT_IRQ
允许本地的 HyperTransport 设备使用中断. 这个只可用于 AMD 平台, Intel 平台不支持这个.
PCI IOV support
CONFIG_PCI_IOV
PCI I/O Virtualization 支持. 这需要硬件支持 IOMMU 技术 (AMD-Vi,Intel VT-d).
PCI PRI support
CONFIG_PCI_PRI
PCI Page Request Interface 支持. 它允许 IOMMU 之后的设备能够从页错误中恢复过来. 这需要硬件支持 IOMMU 技术 (AMD-Vi,Intel VT-d).
PCI PASID support
CONFIG_PCI_PASID
PASID(Process Address Space Identifiers)可以被 PCI 设备用来同时访问多个 IO 地址空间. 这需要硬件 IOMMU 技术 (AMD-Vi,Intel VT-d) 支持 PASID 特性. 不确定的选 &ldquo;N&rdquo;.
PCI IO-APIC hotplug support
CONFIG_PCI_IOAPIC
PCI  IO-APIC 热插拔支持.
ISA-style DMA support
CONFIG_ISA_DMA_API
ISA-style DMA 控制器支持. 目前基本只有 LPC 总线设备需要使用, 最常见的是串口, 并口, PS/2 键盘, Super I/O 芯片 (可以使用 Superiotool 和 sensors-detect 工具检测). 不确定的选 &ldquo;Y&rdquo;.[说明] 这是一个历史遗留问题, 对于 ISA 架构, DMA 操作是由一个专用的 &ldquo;DMA 控制器&rdquo;(最常见的是 Intel 8237) 来执行的, 但是到了 PCI 架构, 由于每一个 PCI 设备都可以控制 PCI 总线 (成为 &quot; bus master&quot;)并直接读写系统内存, 所以&quot;DMA 控制器 &ldquo;又消失了. 此选项只是为那些需要&quot;ISA-DMA 控制器 &quot; 的设备提供了兼容性接口 (API) 而已.
PCCard (PCMCIA/CardBus) support
CONFIG_PCCARD
PCCard(PCMCIA/CardBus/ExpressCard) 接口通常出现在笔记本电脑上, 这些接口卡通常大小与信用卡差不多, 厚度大约 3-5 毫米. 注意: 必须要配合 pcmciautils 工具才能正常使用 PCMCIA 设备.
16-bit PCMCIA support
CONFIG_PCMCIA
老旧的 16-bit PCMCIA 卡支持
Load CIS updates from userspace
CONFIG_PCMCIA_LOAD_CIS
有些 PCMCIA 卡需要从用户空间更新 CIS(Card Information Structure) 之后才能正常工作. 开启此项后, 内核将可以使用内置的固件加载器和热插拔子系统自动加载 CIS, 而不再需要用户空间工具的辅助. 建议选 &ldquo;Yes&rdquo;.
32-bit CardBus support
CONFIG_CARDBUS
常见的 PCMCIA 卡基本上都是 32 位的 CardBus 与 ExpressCard 设备. 如果你有这样的卡, 就选 &ldquo;Yes&rdquo;. 由于绝大多数的卡都是 &ldquo;yenta-compatible&rdquo; 的, 所以一般你还需要选中 CONFIG_YENTA 项.
CardBus yenta-compatible bridge support
CONFIG_YENTA
使用 PCMCIA 卡的基本上都需要选择这一项, 子项是一些拥有自己特定扩展的硬件, 请按实际情况选择.
{省略的部分请按照自己实际使用的 PCMCIA 卡选择}
Support for PCI Hotplug
CONFIG_HOTPLUG_PCI
PCI 热插拔不仅仅针对 PCI 和 PCI-E 设备, 也包括 CardBus 与 ExpressCard 设备. 请按需选择.
{省略的部分请按照自己实际使用 PCI 控制器进行选择} RapidIO support
CONFIG_RAPIDIO
RapidIO 总线支持. 这种总线主要用于嵌入式系统.
Discovery timeout duration (seconds)
CONFIG_RAPIDIO_DISC_TIMEOUT
等待主机完成枚举 (也就是初始化) 的超时秒数.
Enable RapidIO Input/Output Ports
CONFIG_RAPIDIO_ENABLE_RX_TX_PORTS
开启所有 RapidIO Input/Output 端口.
DMA Engine support for RapidIO
CONFIG_RAPIDIO_DMA_ENGINE
使用 DMA 引擎 (CONFIG_DMADEVICES) 进行 RapidIO 数据传输
RapidIO subsystem debug messages
CONFIG_RAPIDIO_DEBUG
将 RapidIO 调试信息输出到系统日志里. 如果你想诊断 RapidIO 设备的故障, 可以开启, 否则应该关闭.
{省略的部分请按照自己实际使用的控制器进行选择}
Mark VGA/VBE/EFI FB as generic system framebuffer
CONFIG_X86_SYSFB
此选项的主要是为 simplefb(可作为 VGA/VBE/EFI FB 的单一替代品通用于 BIOS 和 UEFI 平台) 提供支持, 仅在你确实需要开启 CONFIG_FB_SIMPLE 选项时才需要选 &ldquo;Y&rdquo;, 否则请选 &ldquo;N&rdquo;.
Executable file formats / Emulations
可执行文件格式 / 仿真
Kernel support for ELF binaries
CONFIG_BINFMT_ELF
ELF 是最常用的跨平台二进制文件格式, 支持动态连接, 支持不同的硬件平台, 支持不同的操作系统. 必选, 除非你知道自己在做什么.
Write ELF core dumps with partial segments
CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS
如果你打算在此 Linux 上开发应用程序或者帮助别人调试 bug, 那么就选 &ldquo;Y&rdquo;, 否则选 &ldquo;N&rdquo;. 注意这里的调试和开发不是指内核调试和开发, 是应用程序的调试和开发.
Kernel support for scripts starting with #!
CONFIG_BINFMT_SCRIPT
支持以 &ldquo;#!/path/to/interpreter&rdquo; 行开头的脚本. 务必 &ldquo;Y&rdquo;, 不要 &ldquo;M&rdquo; 或 &ldquo;N&rdquo;, 除非你知道自己在做什么.
Kernel support for MISC binaries
CONFIG_BINFMT_MISC
允许插入二进制封装层到内核中, 运行 Java,.NET(Mono-based),Python,Emacs-Lisp 等语言编译的 二进制程序时需要它, DOSEMU 也需要它. 想要更方便的使用此特性, 你还需要使用 &ldquo;mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc&rdquo; 挂载 binfmt_misc 伪文件系统. 具体详情可以参考 &quot; Documentation/binfmt_misc.txt&rdquo; 文档.
Enable core dump support
CONFIG_COREDUMP
核心转储 (core dump) 支持. 如果你打算在此 Linux 上开发应用程序或者帮助别人调试 bug, 那么就选 &ldquo;Y&rdquo;, 否则选 &ldquo;N&rdquo;. 注意这里的调试和开发不是指内核调试和开发, 是应用程序的调试和开发.
IA32 Emulation
CONFIG_IA32_EMULATION
允许在 64 位内核中运行 32 位代码. 除非你打算使用纯 64 位环境, 否则请开启此项. 提示: GRUB2 支持引导纯 64 位内核, 但是 GRUB 不支持.
IA32 a.out support
CONFIG_IA32_AOUT
早期 UNIX 系统的可执行文件格式 (32 位), 目前已经被 ELF 格式取代. 除非你需要使用古董级的二进制程序. 否则请关闭.
x32 ABI for 64-bit mode
CONFIG_X86_X32
允许 32 位程序使用完整的 64 位寄存器, 以减小内存占用 ( memory footprint). 这可以提高 32 位程序的运行性能. 如果你使用 binutils-2.22 以上的版本 (支持 elf32_x86_64), 就选 &ldquo;Y&rdquo;, 否则选 &ldquo;N&rdquo;.
Networking support
网络支持
Networking options
CONFIG_NET
网络选项. systemd 依赖于它
Packet socket
CONFIG_PACKET
链路层 PF_PACKET 套接字支持. 可以让应用程序 (比如: 抓包工具 tcpdump,DHCP 客户端 dhclient,WiFi 设置工具 wpa_supplicant) 直接与网络设备通讯, 而无需使用内核中的其它中介协议. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.
Packet: sockets monitoring interface
CONFIG_PACKET_DIAG
PF_PACKET 套接字监控接口, ss 这样的诊断工具需要它.
Unix domain sockets
CONFIG_UNIX
Unix domain sockets 支持. 许多程序都使用它在操作系统内部进行进程间通信 (IPC), 比如: X Window, syslog, udev 等等. 选 &ldquo;Y&rdquo;, 除非你确实知道自己在做什么.
UNIX: socket monitoring interface
CONFIG_UNIX_DIAG
UNIX 套接字监控接口, ss 这样的工具需要它.
Transformation user configuration interface
CONFIG_XFRM_USER
为 IPsec 相关的工具提供 Transformation(XFRM) 用户配置接口
Transformation sub policy support
CONFIG_XFRM_SUB_POLICY
XFRM 子策略支持, 不确定的选 &ldquo;N&rdquo;.
Transformation migrate database
CONFIG_XFRM_MIGRATE
用于动态的更新  IPsec  SA(security association) 的定位器 (locator). 这个特性对于手机这类移动设备来讲至关重要, 因为它需要在不同的基站之间迁移. 不确定的选 &ldquo;N&rdquo;.
Transformation statistics
CONFIG_XFRM_STATISTICS
转换统计, 这不是 SNMP/MIB 规范的内容. 用于调试目的. 不确定的选 &ldquo;N&rdquo;.
PF_KEY sockets
CONFIG_NET_KEY
PF_KEYv2 套接字支持 (与 KAME 兼容).PF_KEY 协议族主要用来处理 SA(安全关联), 对 SADB(SA 数据库) 进行管理, 主要用在 IPsec 协议中. PF_KEY_v2 的编程 API 在 RFC2367 中定义.
PF_KEY MIGRATE
CONFIG_NET_KEY_MIGRATE
向 PF_KEYv2 套接字中添加一个 PF_KEY MIGRATE 消息. PF_KEY MIGRATE 消息可用于动态的更新 IPsec SA(security association) 的定位器 (locator). 这个特性对于手机这类移动设备来讲至关重要, 因为它需要在不同的基站之间迁移. 不确定的选 &ldquo;N&rdquo;.
TCP/IP networking
CONFIG_INET
TCP/IP 协议, 必选!
IP: multicasting
CONFIG_IP_MULTICAST
IP 多播 (IP multicasting) 支持. 指的是一个发送者向一组特定的接收者发送数据, 但只需发送一份数据副本. 实际应用的场合很少, MBONE 算是其中之一, 与 RTP 等音视频协议相结合也算一种. 不确定的选 &ldquo;N&rdquo;.
IP: advanced router
CONFIG_IP_ADVANCED_ROUTER
高级路由支持, 需要开启内核的 IP 转发功能 (echo 1&gt; /proc/sys/net/ipv4/ip_forward) 才能正常工作. 如果这个 Linux 系统用作专业的路由器就选上, 选上之后还需要按需选择其下的子项. 一般的主机不需要这个.
FIB TRIE statistics
CONFIG_IP_FIB_TRIE_STATS
主要用于测试 TRIE 性能
IP: policy routing
CONFIG_IP_MULTIPLE_TABLES
策略路由
IP: equal cost multipath
CONFIG_IP_ROUTE_MULTIPATH
用于基于目的地址的负载均衡
IP: verbose route monitoring
CONFIG_IP_ROUTE_VERBOSE
显示冗余的路由监控信息
IP: kernel level autoconfiguration
CONFIG_IP_PNP
在内核启动时自动配置网卡的 ip 地址 / 路由表, 配置信息来自于以下途径: 内核引导参数, 自举协议 (BOOTP), 反向地址转换协议 (RARP), 动态主机配置协议 (DHCP). 通常, 需要从网络启动的无盘工作站才需要这个东西 (此时还需要开启 CONFIG_ROOT_NFS), 一般的发行版都通过启动脚本 ( dhcpcd/ dhclient/ ifconfig) 配置网络. 不确定的选 &ldquo;N&rdquo;.
IP: DHCP support
CONFIG_IP_PNP_DHCP
DHCP 协议支持
IP: BOOTP support
CONFIG_IP_PNP_BOOTP
BOOTP 协议支持
IP: RARP support
CONFIG_IP_PNP_RARP
RARP 协议支持
IP: tunneling
CONFIG_NET_IPIP
IP 隧道, 主要目的是为了在 TCP/IP 网络中传输其他协议的数据包, 当然也包括 IP 数据包 (例如用于实现 VPN).
IP: GRE demultiplexer
CONFIG_NET_IPGRE_DEMUX
GRE demultiplexer 支持. 被 CONFIG_NET_IPGRE 和 CONFIG_PPTP 所依赖.
IP: GRE tunnels over IP
CONFIG_NET_IPGRE
基于 IP 的 通用路由封装 ( Generic Routing Encapsulation) 隧道支持. 该驱动主要用于对端是 Cisco 路由器的场合, 因为 Cisco 的路由器特别偏好 GRE 隧道 (而不是 CONFIG_NET_IPIP), 并且 GRE 还允许通过隧道对组播进行再分发.
IP: broadcast GRE over IP
CONFIG_NET_IPGRE_BROADCAST
GRE/IP 的一种应用是构建一个广播 WAN( Wide Area Network), 而其看上去却很像一个跑在互联网上的 LAN( Local Area Network). 如果你想要创建这样的网络, 那么就选 &ldquo;Y&rdquo;(还要加上 CONFIG_IP_MROUTE).
IP: multicast routing
CONFIG_IP_MROUTE
组播路由支持. 实际应用的场合很少, MBONE 算是其中之一, 不确定的选 &ldquo;N&rdquo;.
IP: multicast policy routing
CONFIG_IP_MROUTE_MULTIPLE_TABLES
通常, 组播路由器上会运行一个单独的用户态守护进程, 根据源地址和目的地址来处理数据包. 开启此项后, 将能同时考虑数据包所带的标记 (mark) 和所通过的网络接口, 并可在用户空间同时运行多个守护进程, 每一个进程处理一张路由表.
IP: PIM-SM version 1 support
CONFIG_IP_PIMSM_V1
Sparse Mode PIM (Protocol Independent Multicast) version 1 支持. 该协议被 Cisco 路由器广泛支持, 你需要特定的软件 (pimd-v1) 才能使用它.
IP: PIM-SM version 2 support
CONFIG_IP_PIMSM_V2
Sparse Mode PIM (Protocol Independent Multicast) version 2 支持. 该协议的使用并不广泛, 你需要特定的软件 (pimd 或 gated-5) 才能使用它.
IP: ARP daemon support
CONFIG_ARPD
通常情况下, 内核自身会使用 ARP 协议解析本地网络中的 IP 地址与 MAC 地址的对应关系, 并进行缓存. 开启此项后, 内核将使用用户空间的守护进程进行 ARP 解析. 这主要是为了使用其他的替代解析协议 (比如 mGRE 隧道中的 NHRP), 或调试目的. 不确定的选 &ldquo;N&rdquo;.
IP: TCP syncookie support
CONFIG_SYN_COOKIES
TCP syncookie 支持, 这是抵抗 SYN flood 攻击的好东西. 此特性的开关可以通过 &ldquo;/proc/sys/net/ipv4/tcp_syncookies&rdquo; 文件控制, 写入 &ldquo;1&rdquo; 表示开启, 写入 &ldquo;0&rdquo; 表示关闭. 建议服务器环境开启此项.
Virtual (secure) IP: tunneling
CONFIG_NET_IPVTI
虚拟 IP 隧道. 可以和 xfrm 隧道一起使用, 以实现 IPSEC 安全隧道, 并在其上使用路由协议. 不确定的选 &ldquo;N&rdquo;.
IP: Foo (IP protocols) over UDP
CONFIG_NET_FOU
允许将任意 IP 层协议封装到 UDP 隧道中. 不确定的选 &ldquo;N&rdquo;.
IP: AH transformation
CONFIG_INET_AH
IPsec AH 支持. IPsec 验证头 (AH) 可对整个数据包 (IP 报头与数据) 提供身份验证 / 完整性 / 抗重播保护. 但是它不提供保密性, 即它不对数据进行加密. 由于这个原因, AH 头正在慢慢被 ESP 头取代.
IP: ESP transformation
CONFIG_INET_ESP
IPsec ESP 支持. IPsec 封装安全负载 (ESP) 不仅为 IP 负载提供身份验证 / 完整性 / 抗重播保护, 还提供保密性, 也就是还对数据进行加密. ESP 有两种使用模式: 传输模式 (ESP 不对整个数据包进行签名, 只对 IP 负载(不含 IP 报头) 进行保护)和隧道模式(将原始 IP 包封装进新的带有 ESP 头的 IP 包内, 可提供完整的保护).ESP 可以独立使用, 也可与 AH 组合使用(越来越少).
IP: IPComp transformation
CONFIG_INET_IPCOMP
IP 静荷载压缩协议 ( IP Payload Compression Protocol)(RFC3173) 支持. 用于支持 IPsec
IP: IPsec transport mode
CONFIG_INET_XFRM_MODE_TRANSPORT
IPsec 传输模式. 常用于对等通信, 用以提供内网安全. 数据包经过了加密但 IP 头没有加密, 因此任何标准设备或软件都可查看和使用 IP 头
IP: IPsec tunnel mode
CONFIG_INET_XFRM_MODE_TUNNEL
IPsec 隧道模式. 用于提供外网安全 (包括虚拟专用网络). 整个数据包(数据头和负载) 都已经过加密处理且分配有新的 ESP 头 / IP 头 / 验证尾, 从而能够隐藏受保护站点的拓扑结构
IP: IPsec BEET mode
CONFIG_INET_XFRM_MODE_BEET
IPsec BEET 模式.
Large Receive Offload (ipv4/tcp)
CONFIG_INET_LRO
LRO(Large Receive Offload) (ipv4/tcp) 支持. 它通过将多个 TCP 数据整合在一个 skb 结构中, 并在稍后的某个时刻作为一个大的数据包交付给上层的网络协议栈, 以减少上层协议栈处理 skb 的开销, 提高 Linux 系统接收 TCP 数据包的能力. 目前, 主流网卡驱动都已支持此特性. 建议开启. 不过, LRO 不应该在路由器上开启, 因为它破坏了 end-to-end 原则, 并会对路由性能造成显著的不利影响.
INET: socket monitoring interface
CONFIG_INET_DIAG
INET(TCP,DCCP,&hellip;) socket 监视接口, 一些 Linux 本地工具 (如: 包含 ss 的 iproute2) 需要使用它
UDP: socket monitoring interface
CONFIG_INET_UDP_DIAG
UDP socket 监视接口, 一些 Linux 本地工具 (如: 包含 ss 的 iproute2) 需要使用它
TCP: advanced congestion control
CONFIG_TCP_CONG_ADVANCED
高级 拥塞控制, 子项提供多种 拥塞控制算法供选用. 如果没有特殊需求就别选了, 内核会自动将默认的拥塞控制设为 &ldquo;CUBIC&rdquo; 并将 &ldquo;new Reno&rdquo; 作为候补. 仅在你确实知道自己需要的情况下选 &ldquo;Y&rdquo;. 不确定的选 &ldquo;N&rdquo;.
TCP: MD5 Signature Option support (RFC2385)
CONFIG_TCP_MD5SIG
RFC2385 中描述了一种对 TCP 会话进行 MD5 签名的保护机制. 目前仅用于保护互联网运营商骨干路由器间的 BGP 会话. 一般的路由器 / 服务器等设备根本不需要这个.
The IPv6 protocol
CONFIG_IPV6
引领未来的 IPv6 支持.
IPv6: Privacy Extensions (RFC 3041) support
CONFIG_IPV6_PRIVACY
IPv6 利用 &quot; Stateless Address Autoconfiguration&quot;在无 DHCP 服务器的情况下, 产生可用的&quot; 临时 IPv6 地址 &ldquo;. 而本选项则为这个机制增加&rdquo; 隐私扩展 &ldquo;( RFC4941) 保护. 默认状态下, 内核并不生产 &ldquo;临时地址&rdquo;, 需要 &ldquo;echo 2 &gt;/proc/sys/net/ipv6/conf/all/use_tempaddr&rdquo; 才能开启
IPv6: Router Preference (RFC 4191) support
CONFIG_IPV6_ROUTER_PREF
主机连上 IPv6 网络后, 会发出路由器邀请包 (Router Solicitation), 路由器则应答路由器公告包 (Router Advertisement), 其中包含网关地址 / IPv6 前缀 / DNS 地址, 这样主机就能取得 IPv6 地址, 并连接到互联网上, 这就是无状态地址自动分配 (StateLess Address AutoConfiguration).&rdquo; Router Preference&quot;是&quot;Router Advertisement&quot; 包的可选扩展. 它可以改进主机选中路由器的能力, 特别是在多归属 ( multi-homed) 网络中. 不确定的选 &ldquo;N&rdquo;.
IPv6: Route Information (RFC 4191) support
CONFIG_IPV6_ROUTE_INFO
对 &quot; Route Information&quot; 的实验性支持.
IPv6: Enable RFC 4429 Optimistic DAD
CONFIG_IPV6_OPTIMISTIC_DAD
乐观 重复地址检测 ( Optimistic Duplicate Address Detection) 的实验性支持. 可以更快的进行自动地址配置. 不确定的选 &ldquo;N&rdquo;.
IPv6: AH transformation
CONFIG_INET6_AH
IPsec AH 支持. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.AH 头正在慢慢被 ESP 头取代.
IPv6: ESP transformation
CONFIG_INET6_ESP
IPsec ESP 支持. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.
IPv6: IPComp transformation
CONFIG_INET6_IPCOMP
IPv6 静荷载压缩协议 ( IP Payload Compression Protocol)(RFC3173) 支持. 用于支持 IPsec. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.
IPv6: Mobility
CONFIG_IPV6_MIP6
移动 IPv6(RFC3775) 支持. 主要用于移动设备. 不确定的选 &ldquo;N&rdquo;.
IPv6: IPsec transport mode
CONFIG_INET6_XFRM_MODE_TRANSPORT
IPsec 传输模式. 常用于对等通信, 用以提供内网安全. 数据包经过了加密但 IP 头没有加密, 因此任何标准设备或软件都可查看和使用 IP 头. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.
IPv6: IPsec tunnel mode
CONFIG_INET6_XFRM_MODE_TUNNEL
IPsec 隧道模式. 用于提供外网安全 (包括虚拟专用网络). 整个数据包(数据头和负载) 都已经过加密处理且分配有新的 ESP 头 / IP 头 / 验证尾, 从而能够隐藏受保护站点的拓扑结构. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.
IPv6: IPsec BEET mode
CONFIG_INET6_XFRM_MODE_BEET
IPsec BEET 模式. 不确定的选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;.
IPv6: MIPv6 route optimization mode
CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION
移动 IPv6(Mobile IPv6) 路由优化模式. 主要用于移动设备. 不确定的选 &ldquo;N&rdquo;.
IPv6: IPv6-in-IPv4 tunnel (SIT driver)
CONFIG_IPV6_SIT
在 IPv4 网络上建立 IPv6 隧道. 如果你希望可以通过 IPv4 网络接入一个 IPv6 网络, 可以选 &ldquo;Y&rdquo; 或 &ldquo;M&rdquo;, 否则选 &ldquo;N&rdquo;.
IPv6: IPv6 Rapid Deployment (6RD)
CONFIG_IPV6_SIT_6RD
IPv6 快速部署 (6RD) 支持. 不确定的选 &ldquo;N&rdquo;.
IPv6: IP-in-IPv6 tunnel (RFC2473)
CONFIG_IPV6_TUNNEL
IPv6-in-IPv6/IPv4-in-IPv6 隧道 ( RFC2473) 支持. 不确定的选 &ldquo;N&rdquo;.
IPv6: GRE tunnel
CONFIG_IPV6_GRE
基于 IPv6 的 通用路由封装 ( Generic Routing Encapsulation) 隧道支持. 该驱动主要用于对端是 Cisco 路由器的场合, 因为 Cisco 的路由器特别偏好 GRE 隧道 (而不是 CONFIG_IPV6_TUNNEL), 并且 GRE 还允许通过隧道对组播进行再分发.
IPv6: Multiple Routing Tables
CONFIG_IPV6_MULTIPLE_TABLES
多重路由表 ( Multiple Routing Tables) 支持. 不确定的选 &ldquo;N&rdquo;.
IIPv6: source address based routing
CONFIG_IPV6_SUBTREES
允许根据源地址或前缀进行路由. 不确定的选 &ldquo;N&rdquo;.
IPv6: multicast routing
CONFIG_IPV6_MROUTE
测试性的 IPv6 组播路由支持. 实际应用的场合很少, 不确定的选 &ldquo;N&rdquo;.
IPv6: multicast policy routing
CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
通常, 组播路由器上会运行一个单独的用户态守护进程, 根据源地址和目的地址来处理数据包. 开启此项后, 将能同时考虑数据包所带的标记 (mark) 和所通过的网络接口, 并可在用户空间同时运行多个守护进程, 每一个进程处理一张路由表.
IPv6: PIM-SM version 2 support
CONFIG_IPV6_PIMSM_V2
IPv6 PIM multicast routing protocol PIM-SMv2 支持.
NetLabel subsystem support
CONFIG_NETLABEL
NetLabel 子系统支持. NetLabel 子系统为诸如 CIPSO 与 RIPSO 之类能够在分组信息上添加标签的协议提供支持, 看不懂就别选了.
Security Marking
CONFIG_NETWORK_SECMARK
对网络包进行安全标记, 类似于 nfmark, 但主要是为安全目的而设计. 看不懂的就别选了
Timestamping in PHY devices
CONFIG_NETWORK_PHY_TIMESTAMPING
允许在硬件支持的前提下, 为物理层 ( PHY) 数据包打上时间戳. 这会略微增加发送与接收的开销. 不确定的选 &ldquo;N&rdquo;.
Network packet filtering framework (Netfilter)
CONFIG_NETFILTER
Netfilter 可以对数据包进行过滤和修改, 可以作为防火墙 (&ldquo;packet filter&rdquo; 或 &ldquo;proxy-based&rdquo;) 或网关 (NAT) 或代理 (proxy) 或网桥使用.
Network packet filtering debugging
CONFIG_NETFILTER_DEBUG
仅供开发者调试 Netfilter 使用
Advanced netfilter configuration
CONFIG_NETFILTER_ADVANCED
选 &ldquo;Y&rdquo; 将会显示所有模块供用户选择, 选 &ldquo;N&rdquo; 则会隐藏一些不常用的模块, 并自动将常用模块设为 &ldquo;M&rdquo;.
Bridged IP/ARP packets filtering
CONFIG_BRIDGE_NETFILTER
如果你希望使用桥接防火墙就打开它. Docker 依赖于它. 不确定的选 &ldquo;N&rdquo;.
Core Netfilter Configuration
核心 Netfilter 配置 (当包流过 Chain 时如果 match 某个规则那么将由该规则的 target 来处理, 否则将由同一个 Chain 中的下一个规则进行匹配, 若不 match 所有规则那么最终将由该 Chain 的 policy 进行处理)
Netfilter ingress support
CONFIG_NETFILTER_INGRESS
允许将入站包进行分类.
Netfilter NFACCT over NFNETLINK interface
CONFIG_NETFILTER_NETLINK_ACCT
允许通过 NFNETLINK 接口支持 NFACCT(记账).
Netfilter NFQUEUE over NFNETLINK interface
CONFIG_NETFILTER_NETLINK_QUEUE
允许通过 NFNETLINK 接口支持 NFQUEUE(排队).
Netfilter LOG over NFNETLINK interface
CONFIG_NETFILTER_NETLINK_LOG
允许通过 NFNETLINK 接口支持 &ldquo;LOG&rdquo;(日志). 该选项废弃了 ipt_ULOG 和 ebg_ulog 机制, 并打算在将来废弃基于 syslog 的 ipt_LOG 和 ip6t_LOG 模块.
Netfilter connection tracking support
CONFIG_NF_CONNTRACK
连接追踪 (connection tracking) 支持, 连接跟踪把所有连接都保存在一个表格内, 并将每个包关联到其所属的连接. 可用于报文伪装或地址转换, 也可用于增强包过滤能力.
Connection mark tracking support
CONFIG_NF_CONNTRACK_MARK
允许对连接进行标记, 与针对单独的包进行标记的不同之处在于它是针对连接流的. CONNMARK target 和 connmark match 需要它的支持.
Connection tracking security mark support
CONFIG_NF_CONNTRACK_SECMARK
允许对连接进行安全标记, 通常这些标记包 (SECMARK) 复制到其所属连接(CONNSECMARK), 再从连接复制到其关联的包(SECMARK).
Connection tracking zones
CONFIG_NF_CONNTRACK_ZONES
&quot; conntrack zones&quot;支持. 通常, 每个连接需要一个全局唯一标示符, 而&quot;conntrack zones&quot; 允许在不同 zone 内的连接使用相同的标识符.
Supply CT list in procfs (OBSOLETE)
CONFIG_NF_CONNTRACK_PROCFS
已被废弃, 选 &ldquo;N&rdquo;.
Connection tracking events
CONFIG_NF_CONNTRACK_EVENTS
连接跟踪事件支持. 如果启用这个选项, 连接跟踪代码将提供一个 &ldquo;notifier&rdquo; 链, 它可以被其它内核代码用来获知连接跟踪状态的改变
Connection tracking timeout
CONFIG_NF_CONNTRACK_TIMEOUT
连接跟踪 &ldquo;timeout&rdquo; 扩展. 这样你就可以在网络流上通过 CT target 附加超时策略.
Connection tracking timestamping
CONFIG_NF_CONNTRACK_TIMESTAMP
时间戳支持. 这样你就能在连接建立和断开时打上时间戳.
DCCP protocol connection tracking support
CONFIG_NF_CT_PROTO_DCCP
DCCP 协议支持.
SCTP protocol connection tracking support
CONFIG_NF_CT_PROTO_SCTP
SCTP 协议支持.
UDP-Lite protocol connection tracking support
CONFIG_NF_CT_PROTO_UDPLITE
UDP-Lite 支持.
Amanda backup protocol support
CONFIG_NF_CONNTRACK_AMANDA
Amanda 备份协议支持.
FTP protocol support
CONFIG_NF_CONNTRACK_FTP
文件传输协议 (FTP) 支持. 跟踪 FTP 连接需要额外的帮助程序.
H.323 protocol support
CONFIG_NF_CONNTRACK_H323
H.323 协议支持.
IRC protocol support
CONFIG_NF_CONNTRACK_IRC
IRC 扩展协议 DCC(Direct Client-to-Client Protocol) 支持. 该协议允许用户之间绕开服务器直接聊天和传输文件.
NetBIOS name service protocol support
CONFIG_NF_CONNTRACK_NETBIOS_NS
NetBIOS 协议支持.
SNMP service protocol support
CONFIG_NF_CONNTRACK_SNMP
SNMP 协议支持.
PPtP protocol support
CONFIG_NF_CONNTRACK_PPTP
RFC2637  点对点隧道协议 (Point to Point Tunnelling Protocol) 协议支持.
SANE protocol support
CONFIG_NF_CONNTRACK_SANE
SANE 协议支持.
SIP protocol support
CONFIG_NF_CONNTRACK_SIP
SIP 协议支持.
TFTP protocol support
CONFIG_NF_CONNTRACK_TFTP
TFTP 协议支持.
Connection tracking netlink interface
CONFIG_NF_CT_NETLINK
基于 netlink 的用户接口支持.
Connection tracking timeout tuning via Netlink
CONFIG_NF_CT_NETLINK_TIMEOUT
通过 Netlink 机制支持对连接追踪超时进行细粒度的调节: 允许为特定的网络流指定超时策略, 而不是使用统一的全局超时策略.
Connection tracking helpers in user-space via Netlink
CONFIG_NF_CT_NETLINK_HELPER
通过 Netlink 机制为用户空间的连接追踪帮助程序提供基础框架.
NFQUEUE integration with Connection Tracking
CONFIG_NETFILTER_NETLINK_QUEUE_CT
开启此项后, 即使网络包已经在队列 (NFQUEUE) 中, 它依然可以包含连接追踪信息.
Transparent proxying support
CONFIG_NETFILTER_TPROXY
透明代理支持, 也就是可以处理非本地的 IPv4 TCP/UDP 套接字. 此功能需要配合一些 iptables 规则和策略路由才能工作. 详见 &quot; Documentation/networking/tproxy.txt&quot; 文档.
Netfilter Xtables support (required for ip_tables)
CONFIG_NETFILTER_XTABLES
如果你打算使用 ip_tables, ip6_tables, arp_tables 之一就必须选上
nfmark target and match support
CONFIG_NETFILTER_XT_MARK
&ldquo;nfmark&rdquo; 是用户给包打上的一个自定义标记. 用于 match 时, 允许基于 &ldquo;nfmark&rdquo; 值对包进行匹配. 用于 target 时, 允许在 &ldquo;mangle&rdquo; 表中创建规则以改变包的 &ldquo;nfmark&rdquo; 值.
ctmark target and match support
CONFIG_NETFILTER_XT_CONNMARK
&ldquo;ctmark&rdquo; 是用户以连接为组, 给同一连接中的所有包打上的自定义标记. 用法与 &ldquo;nfmark&rdquo; 相似.
set target and match support
CONFIG_NETFILTER_XT_SET
&ldquo;set&rdquo; 是 ipset 工具创建的 IP 地址集合. 使用 match 可以对 IP 地址集合进行匹配, 使用 target 可以对集合中的项进行增加和删除.
AUDIT target support
CONFIG_NETFILTER_XT_TARGET_AUDIT
为被 drop/accept 的包创建审计记录.
CHECKSUM target support
CONFIG_NETFILTER_XT_TARGET_CHECKSUM
用于 &ldquo;mangle&rdquo; 表, 为缺少校验和的包添加 checksum 字段的值. 主要是为了兼容一些老旧的网络程序 (例如某些 dhcp 客户端).
&ldquo;CLASSIFY&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CLASSIFY
允许为包设置优先级, 一些 qdiscs 排队规则 (atm,cbq,dsmark,pfifo_fast,htb,prio) 需要使用它
&ldquo;CONNMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CONNMARK
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_CONNMARK
&ldquo;CONNSECMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CONNSECMARK
针对链接进行安全标记, 同时还会将连接上的标记还原到包上 (如果链接中的包尚未进行安全标记), 通常与 SECMARK target 联合使用
&ldquo;CT&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_CT
允许为包加上连接追踪相关的参数, 比如 &ldquo;event&rdquo; 和 &ldquo;helper&rdquo;.
&ldquo;DSCP&rdquo; and &ldquo;TOS&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_DSCP
DSCP target 允许对 IPv4/IPv6 包头部的 DSCP(Differentiated Services Codepoint)字段 (常用于 Qos) 进行修改. TOS target 允许在 &ldquo;mangle&rdquo; 表创建规则以修改 IPv4 包头的 TOS(Type Of Service)字段或 IPv6 包头的 Priority 字段.
&ldquo;HL&rdquo; hoplimit target support
CONFIG_NETFILTER_XT_TARGET_HL
HL(IPv6)/TTL(IPv4) target 允许更改包头的 hoplimit/time-to-live 值.
&ldquo;HMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_HMARK
允许在 &ldquo;raw&rdquo; 和 &ldquo;mangle&rdquo; 表中创建规则, 以根据特定范围的哈希计算结果设置 &quot; skbuff&quot; 标记.
IDLETIMER target support
CONFIG_NETFILTER_XT_TARGET_IDLETIMER
每个被匹配的包的定时器都会被强制指定为规则指定的值, 当超时发生时会触发一个 sysfs 文件系统的通知. 剩余时间可以通过 sysfs 读取.
&ldquo;LED&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_LED
允许在满足特定条件的包通过的时候, 触发 LED 灯闪烁. 比如可以用于控制网卡的状态指示灯仅在有 SSH 活动的时候才闪烁.
LOG target support
CONFIG_NETFILTER_XT_TARGET_LOG
允许向 syslog 中记录包头信息.
&ldquo;MARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_MARK
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MARK
&ldquo;NETMAP&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_NETMAP
NETMAP 用于实现一对一的静态 NAT(地址转换).
&ldquo;NFLOG&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_NFLOG
通过 nfnetlink_log 记录日志.
&ldquo;NFQUEUE&rdquo; target Support
CONFIG_NETFILTER_XT_TARGET_NFQUEUE
用于替代老旧的 QUEUE target. 因为 NFQUEUE 能支持最多 65535 个队列, 而 QUEUE 只能支持一个.
&ldquo;NOTRACK&rdquo; target support (DEPRECATED)
CONFIG_NETFILTER_XT_TARGET_NOTRACK
已被废弃, 勿选.
&ldquo;RATEEST&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_RATEEST
RATEEST target 允许测量网络流的传输速率.[注: rateest match 允许根据速率进行匹配.]
REDIRECT target support
CONFIG_NETFILTER_XT_TARGET_REDIRECT
REDIRECT 是一种特别的 NAT: 所有进入的连接都被映射到其入口网卡的地址, 这样这些包就会 &ldquo;流入&rdquo; 本机而不是 &ldquo;流过&rdquo; 本机. 这主要用于实现透明代理.
&ldquo;TEE&rdquo; - packet cloning to alternate destination
CONFIG_NETFILTER_XT_TARGET_TEE
对包进行克隆, 并将克隆的副本路由到另一个临近的路由器 ( Next Hop).
&ldquo;TPROXY&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TPROXY
类似于 REDIRECT, 但并不依赖于连接追踪和 NAT, 也只能用于 &ldquo;mangle&rdquo; 表, 用于将网络流量重定向到透明代理.
&ldquo;TRACE&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TRACE
允许对包打标记, 这样内核就可以记录每一个匹配到的规则.
&ldquo;SECMARK&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_SECMARK
允许对包进行安全标记, 用于安全子系统
&ldquo;TCPMSS&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TCPMSS
允许更改 TCP SYN 包的 MSS(Maximum Segment Size) 值, 通常 = MTU-40.
&ldquo;TCPOPTSTRIP&rdquo; target support
CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP
允许从 TCP 包头中剥离所有 TCP 选项.
&ldquo;addrtype&rdquo; address type match support
CONFIG_NETFILTER_XT_MATCH_ADDRTYPE
根据地址类型进行匹配: UNICAST, LOCAL, BROADCAST, &hellip; Docker 依赖于它.
&ldquo;bpf&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_BPF
BPF(BSD Packet Filter) 是一个强大的包匹配模块, 用于匹配那些让过滤器返回非零值的包.
&ldquo;cluster&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CLUSTER
这个模块可以用于创建网络服务器 / 防火墙集群, 而无需借助价格昂贵的负载均衡设备. 通常, 在包必须被本节点处理的条件下, 这个 match 返回 &ldquo;true&rdquo;. 这样, 所有节点都可以看到所有的包, 但只有匹配的节点才需要进行处理, 这样就将负载进行了分摊. 而分摊算法是基于对源地址的哈希值.
&ldquo;comment&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_COMMENT
这是一个 &ldquo;伪 match&rdquo;, 目的是允许你在 iptables 规则集中加入注释
&ldquo;connbytes&rdquo; per-connection counter match support
CONFIG_NETFILTER_XT_MATCH_CONNBYTES
允许针对单个连接内部每个方向 (进 / 出) 匹配已经传送的字节数 / 包数
&ldquo;connlabel&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CONNLABEL
允许向连接分配用户自定义的标签名. 内核仅存储 bit 值, 而名称和 bit 之间的对应关系由用户空间处理. 与 &ldquo;connmark&rdquo; 的不同之处在于: 可以同时为一个连接分配 32 个标志位 (flag bit).
&ldquo;connlimit&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CONNLIMIT
允许根据每一个客户端 IP 地址 (或每一段客户端 IP 地址段) 持有的并发连接数进行匹配.
&ldquo;connmark&rdquo; connection mark match support
CONFIG_NETFILTER_XT_MATCH_CONNMARK
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_CONNMARK
&ldquo;conntrack&rdquo; connection tracking match support
CONFIG_NETFILTER_XT_MATCH_CONNTRACK
通用连接跟踪匹配, 是 &ldquo;state&rdquo; 的超集, 它允许额外的链接跟踪信息, 在需要设置一些复杂的规则 (比如网关) 时很有用. Docker 依赖于它.
&ldquo;cpu&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_CPU
根据处理包所使用的 CPU 是哪个进行匹配
&ldquo;dccp&rdquo; protocol match support
CONFIG_NETFILTER_XT_MATCH_DCCP
DCCP 是打算取代 UDP 的新传输协议, 它在 UDP 的基础上增加了流控和拥塞控制机制, 面向实时业务
&ldquo;devgroup&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_DEVGROUP
允许根据网卡所属的 &ldquo;设备组&rdquo; 进行匹配
&ldquo;dscp&rdquo; and &ldquo;tos&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_DSCP
dscp match 允许根据 IPv4/IPv6 包头的 DSCP 字段进行匹配, tos match 允许根据 IPv4 包头的 TOS 字段进行匹配
&ldquo;ecn&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_ECN
允许根据 IPv4 TCP 包头的 ECN 字段进行匹配
&ldquo;esp&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_ESP
允许对 IPSec 包的 ESP 头中的 SPI(安全参数序列) 范围进行匹配
&ldquo;hashlimit&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_HASHLIMIT
此项的目的是取代 &ldquo;limit&rdquo;, 它基于你选定的源 / 目的地址和 / 或端口动态创建 &ldquo;limit bucket&rdquo; 哈希表. 这样你就可以迅速创建类似这样的匹配规则:(1) 为给定的目的地址以每秒 10k 个包的速度进行匹配;(2) 为给定的源地址以每秒 500 个包的速率进行匹配
&ldquo;helper&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_HELPER
加载特定协议的连接跟踪辅助模块, 由该模块过滤所跟踪的连接类型的包, 比如 ip_conntrack_ftp 模块
&ldquo;hl&rdquo; hoplimit/TTL match support
CONFIG_NETFILTER_XT_MATCH_HL
基于 IPv6 包头的 hoplimit 字段, 或 IPv4 包头的 time-to-live 字段进行匹配
&ldquo;iprange&rdquo; address range match support
CONFIG_NETFILTER_XT_MATCH_IPRANGE
根据 IP 地址范围进行匹配, 而普通的 iptables 只能根据 &ldquo;IP/mask&rdquo; 的方式进行匹配.
&ldquo;ipvs&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_IPVS
允许根据包的 IPVS 属性进行匹配
&ldquo;length&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_LENGTH
允许对包的长度进行匹配
&ldquo;limit&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_LIMIT
允许根据包的进出速率进行规则匹配, 常和 &ldquo;LOG target&rdquo; 配合使用以抵抗某些 Dos 攻击
&ldquo;mac&rdquo; address match support
CONFIG_NETFILTER_XT_MATCH_MAC
允许根据以太网的 MAC 地址进行匹配
&ldquo;mark&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_MARK
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MARK
&ldquo;multiport&rdquo; Multiple port match support
CONFIG_NETFILTER_XT_MATCH_MULTIPORT
允许对 TCP 或 UDP 包同时匹配多个不连续的端口 (通常情况下只能匹配单个端口或端口范围)
&ldquo;nfacct&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_NFACCT
允许通过 nfnetlink_acct 使用扩展记账
&ldquo;osf&rdquo; Passive OS fingerprint match
CONFIG_NETFILTER_XT_MATCH_OSF
开启 Passive OS Fingerprinting 模块, 以允许通过进入的 TCP SYN 包被动匹配远程操作系统. 规则和加载程序可以从这里获取: <a href="http://www.ioremap.net/projects/osf">http://www.ioremap.net/projects/osf</a>
&ldquo;owner&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_OWNER
基于创建套接字的本地进程身份 (user/group) 进行匹配, 还可以用于检查一个套接字是否确实存在
IPsec &ldquo;policy&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_POLICY
基于 IPsec policy 进行匹配
&ldquo;physdev&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_PHYSDEV
允许对进入或离开所经过的物理网口进行匹配
&ldquo;pkttype&rdquo; packet type match support
CONFIG_NETFILTER_XT_MATCH_PKTTYPE
允许对封包目的地址类别 (广播 / 组播 / 直播) 进行匹配
&ldquo;quota&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_QUOTA
允许对总字节数的限额值进行匹配
&ldquo;rateest&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_RATEEST
根据 RATEEST target 评估的速率值进行匹配
&ldquo;realm&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_REALM
允许根据 iptables 中的路由子系统中的 realm 值进行匹配. 它与 tc 中的 CONFIG_NET_CLS_ROUTE4 非常类似.
&ldquo;recent&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_RECENT
recent match 用于创建一个或多个最近使用过的地址列表, 然后又可以根据这些列表再进行匹配.
&ldquo;sctp&rdquo; protocol match support
CONFIG_NETFILTER_XT_MATCH_SCTP
支持根据 流控制传输协议 (SCTP) 源 / 目的端口和 &ldquo;chunk type&rdquo; 进行匹配.
&ldquo;socket&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_SOCKET
can be used to match packets for which a TCP or UDP socket lookup finds a valid socket. It can be used in combination with the MARK target and policy routing to implement full featured non-locally bound sockets.
&ldquo;state&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_STATE
这是对包进行分类的有力工具, 它允许利用连接跟踪信息对连接中处于特定状态的包进行匹配
&ldquo;statistic&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_STATISTIC
允许根据一个给定的百分率对包进行周期性的或随机性的匹配
&ldquo;string&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_STRING
允许根据包所承载的数据中包含的特定字符串进行匹配
&ldquo;tcpmss&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_TCPMSS
允许根据 TCP SYN 包头中的 MSS(最大分段长度) 选项的值进行匹配
&ldquo;time&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_TIME
根据包的到达时刻 (外面进入的包) 或者离开时刻 (本地生成的包) 进行匹配
&ldquo;u32&rdquo; match support
CONFIG_NETFILTER_XT_MATCH_U32
&ldquo;u32&rdquo; 允许从包中提取拥有特定 mask 的最多 4 字节数据, 将此数据移动 (shift) 特定的位数, 然后测试其结果是否位于特定的集合范围内. 更多细节可以直接参考内核源码(net/netfilter/xt_u32.c)
IP set support
CONFIG_IP_SET
为内核添加 IP 集 (IP set) 支持, 然后就可以使用 CONFIG_NETFILTER_XT_SET 功能. 此特性必须配合用户态工具 ipset 一起使用.
Maximum number of IP sets
CONFIG_IP_SET_MAX
默认的最大 &ldquo;set&rdquo; 数, 取值范围是 [2,65534]. 此值也可以由 ip_set 模块的 max_sets 参数设置.
bitmap:ip set support
CONFIG_IP_SET_BITMAP_IP
&ldquo;bitmap:ip&rdquo; 集合类型. 根据 IP 地址范围设定集合.
bitmap:ip,mac set support
CONFIG_IP_SET_BITMAP_IPMAC
&ldquo;bitmap:ip,mac&rdquo; 集合类型. 根据 IP/MAC 地址对范围设定集合.
bitmap:port set support
CONFIG_IP_SET_BITMAP_PORT
&ldquo;bitmap:port&rdquo; 集合类型. 根据端口范围设定集合.
hash:ip set support
CONFIG_IP_SET_HASH_IP
&ldquo;hash:ip&rdquo; 集合类型. 为多个离散的 IP 地址设定集合.
hash:ip,port set support
CONFIG_IP_SET_HASH_IPPORT
&ldquo;hash:ip,port&rdquo; 集合类型. 为多个离散的 IP/MAC 地址对设定集合.
hash:ip,port,ip
CONFIG_IP_SET_HASH_IPPORTIP
&ldquo;hash:ip,port,ip&rdquo; 集合类型. 为多个离散的 IP / 端口 / IP 三元组设定集合.
hash:ip,port,net set support
CONFIG_IP_SET_HASH_IPPORTNET
&ldquo;hash:ip,port,net&rdquo; 集合类型. 为多个离散的 IP / 端口 / 网段三元组设定集合.
hash:net set support
CONFIG_IP_SET_HASH_NET
&ldquo;hash:net&rdquo; 集合类型. 为多个离散的网段设定集合
hash:net,port set support
CONFIG_IP_SET_HASH_NETPORT
&ldquo;hash:net,port&rdquo; 集合类型. 为多个离散的网段 / 端口对设定集合
hash:net,iface set support
CONFIG_IP_SET_HASH_NETIFACE
&ldquo;hash:net,iface&rdquo; 集合类型. 为多个离散的网段 / 网卡接口对设定集合
list:set set support
CONFIG_IP_SET_LIST_SET
&ldquo;list:set&rdquo; 集合类型. 将多个集合组成一个更大的集合
IP virtual server support
CONFIG_IP_VS
IPVS( IP Virtual Server) 支持. IPVS 可以帮助 LVS 基于多个后端真实服务器创建一个高性能的虚拟服务器. 可以使用三种具体的方法实现: NAT, 隧道, 直接路由 (使用较广).
IPv6 support for IPVS
CONFIG_IP_VS_IPV6
为 IPVS 添加 IPv6 支持
IP virtual server debugging
CONFIG_IP_VS_DEBUG
为 IPVS 添加调试支持
IPVS connection table size (the Nth power of 2)
CONFIG_IP_VS_TAB_BITS
设置 IPVS 连接哈希表的大小 (2 CONFIG_IP_VS_TAB_BITS), 取值范围是 [8,20], 默认值 12 的意思是哈希表的大小是 2 12=4096 项. IPVS 连接哈希表使用链表来处理哈希碰撞. 使用大的哈希表能够显著减少碰撞几率, 特别是哈希表中有成千上万连接的时候. 比较恰当的值差不多等于每秒的新建连接数乘以每个连接的平均持续秒数. 太小的值会造成太多碰撞, 从而导致性能大幅下降; 太大的值又会造成占用太多不必要的内存 (每个表项 8 字节 + 每个连接 128 字节). 该值也可以通过 ip_vs 模块的 conn_tab_bits 参数进行设置.
TCP load balancing support
CONFIG_IP_VS_PROTO_TCP
TCP 传输协议负载均衡支持
UDP load balancing support
CONFIG_IP_VS_PROTO_UDP
UDP 传输协议负载均衡支持
ESP load balancing support
CONFIG_IP_VS_PROTO_ESP
IPSec ESP(Encapsulation Security Payload) 传输协议负载均衡支持
AH load balancing support
CONFIG_IP_VS_PROTO_AH
IPSec AH(Authentication Header) 传输协议负载均衡支持.
SCTP load balancing support
CONFIG_IP_VS_PROTO_SCTP
SCTP 传输协议负载均衡支持
round-robin scheduling
CONFIG_IP_VS_RR
循环分散算法: 最简单的调度算法, 将连接简单的循环分散到后端服务器上
weighted round-robin scheduling
CONFIG_IP_VS_WRR
基于权重的循环分散算法: 在循环分散的基础上, 权重较高的后端服务器接纳较多的连接
least-connection scheduling
CONFIG_IP_VS_LC
最少连接算法: 将连接优先分配到活动连接最少的后端服务器
weighted least-connection scheduling
CONFIG_IP_VS_WLC
基于权重的最少连接算法: 结合考虑活动连接数与服务器权重
locality-based least-connection scheduling
CONFIG_IP_VS_LBLC
基于目的 IP 的最少连接算法 (常用于缓存集群): 优先根据目的 IP 地址将连接分配到特定的后端, 仅在这些后端过载时(活动连接数大于其权重) 才分散到其他后端.
locality-based least-connection with replication scheduling
CONFIG_IP_VS_LBLCR
与 LBLC 类似, 不同之处在于: 前端负载均衡器会像 NAT 一样同时记住客户端 IP 与后端的对应关系, 并在新的连接到来的时候, 复用这个对应关系.
destination hashing scheduling
CONFIG_IP_VS_DH
目标地址哈希表算法: 简单的根据静态设定的目标 IP 地址哈希表将连接分发到后端
source hashing scheduling
CONFIG_IP_VS_SH
源地址哈希表算法: 简单的根据静态设定的源 IP 地址哈希表将连接分发到后端
shortest expected delay scheduling
CONFIG_IP_VS_SED
最小期望延迟算法: 将连接分配到根据期望延迟公式 ((Ci+1)/Ui) 算得的延迟最小的后端.&ldquo;i&rdquo; 是后端服务器编号,&ldquo;Ci&rdquo; 是该服务器当前的连接数,&ldquo;Ui&rdquo; 是该服务器的权重.
never queue scheduling
CONFIG_IP_VS_NQ
无排队算法: 这是一个两阶段算法, 如果有空闲服务器, 就直接分发到空闲服务器 (而不是等待速度最快的服务器), 如果没有空闲服务器, 就分发到期望延迟最小的服务器 (SED 算法).
IPVS source hashing table size (the Nth power of 2)
CONFIG_IP_VS_SH_TAB_BITS
将源 IP 地址映射到后端服务器所使用的哈希表的大小 (2 CONFIG_IP_VS_SH_TAB_BITS), 取值范围是 [4,20], 默认值 8 的意思是哈希表的大小是 2 8=256 项. 理想的大小应该是所有后端的权重乘以后端总数?
FTP protocol helper
CONFIG_IP_VS_FTP
FTP 协议连接追踪帮助
Netfilter connection tracking
CONFIG_IP_VS_NFCT
Netfilter 连接追踪支持
SIP persistence engine
CONFIG_IP_VS_PE_SIP
基于 SIP Call-ID 提供持久连接支持
IP: Netfilter Configuration
针对 IPv4 的 Netfilter 配置
IPv4 connection tracking support (required for NAT)
CONFIG_NF_CONNTRACK_IPV4
IPv4 链接跟踪. 可用于包伪装或地址转换, 也可用于增强包过滤能力
proc/sysctl compatibility with old connection tracking
CONFIG_NF_CONNTRACK_PROC_COMPAT
用于兼容老旧的连接追踪用户态程序
IP tables support (required for filtering/masq/NAT)
CONFIG_IP_NF_IPTABLES
要用 iptables 就肯定要选上
&ldquo;ah&rdquo; match support
CONFIG_IP_NF_MATCH_AH
允许对 IPSec 包头的 AH 字段进行匹配
&ldquo;ecn&rdquo; match support
CONFIG_IP_NF_MATCH_ECN
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MATCH_ECN
&ldquo;rpfilter&rdquo; reverse path filter match support
CONFIG_IP_NF_MATCH_RPFILTER
对进出都使用同一个网络接口的包进行匹配
&ldquo;ttl&rdquo; match support
CONFIG_IP_NF_MATCH_TTL
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_MATCH_HL
Packet filtering
CONFIG_IP_NF_FILTER
定义 filter 表, 以允许对包进行过滤. Docker 依赖于它.
REJECT target support
CONFIG_IP_NF_TARGET_REJECT
允许返回一个 ICMP 错误包而不是简单的丢弃包
ULOG target support
CONFIG_IP_NF_TARGET_ULOG
反对使用该选项, 因为它已经被 CONFIG_NETFILTER_NETLINK_LOG 代替
IPv4 NAT
CONFIG_NF_NAT_IPV4
允许进行伪装 / 端口转发以及其它的 NAT 功能, 仅在你需要使用 iptables 中的 nat 表时才需要选择. Docker 依赖于它.
MASQUERADE target support
CONFIG_IP_NF_TARGET_MASQUERADE
SNAT 是指在数据包从网卡发送出去的时候, 把数据包中的源地址部分替换为指定的 IP, 这样, 接收方就认为数据包的来源是被替换的那个 IP 的主机. 伪装 (MASQUERADE) 是一种特殊类型的 SNAT:MASQUERADE 是用发送数据的网卡上的 IP 来替换源 IP, 用于那些 IP 不固定的场合(比如拨号或者通过 DHCP 分配).Docker 依赖于它.
NETMAP target support
CONFIG_IP_NF_TARGET_NETMAP
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_TARGET_NETMAP.
REDIRECT target support
CONFIG_IP_NF_TARGET_REDIRECT
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_TARGET_REDIRECT.
Basic SNMP-ALG support
CONFIG_NF_NAT_SNMP_BASIC
为 SNMP 荷载实现 ALG(Application Layer Gateway) 支持 ( RFC2962).
Packet mangling
CONFIG_IP_NF_MANGLE
在 iptables 中启用 mangle 表以便对包进行各种修改, 常用于改变包的路由
CLUSTERIP target support
CONFIG_IP_NF_TARGET_CLUSTERIP
CLUSTERIP target 允许你无需使用昂贵的负载均衡设备也能创建廉价的负载均衡集群
ECN target support
CONFIG_IP_NF_TARGET_ECN
用于 mangle 表, 可以去除 IPv4 包头的 ECN(Explicit Congestion Notification) 位, 主要用于在保持 ECN 功能的前提下, 去除网络上的 &ldquo;ECN 黑洞&rdquo;.
&ldquo;TTL&rdquo; target support
CONFIG_IP_NF_TARGET_TTL
这只是一个兼容旧配置的选项, 等价于 CONFIG_NETFILTER_XT_TARGET_HL.
raw table support (required for NOTRACK/TRACE)
CONFIG_IP_NF_RAW
在 iptables 中添加一个 raw 表, 该表在 netfilter 框架中非常靠前, 并在 PREROUTING 和 OUTPUT 链上有钩子, 从而可以对收到的数据包在连接跟踪前进行处理
Security table
CONFIG_IP_NF_SECURITY
在 iptables 中添加一个 security 表, 以支持 强制访问控制 (Mandatory Access Control) 策略
ARP tables support
CONFIG_IP_NF_ARPTABLES
arptables 支持
ARP packet filtering
CONFIG_IP_NF_ARPFILTER
ARP 包过滤. 对于进入和离开本地的 ARP 包定义一个 filter 表, 在桥接的情况下还可以应用于被转发的 ARP 包
ARP payload mangling
CONFIG_IP_NF_ARP_MANGLE
允许对 ARP 包的荷载部分进行修改, 比如修改源和目标物理地址
IPv6: Netfilter Configuration
针对 IPv6 的 Netfilter 配置. 其子项内容类似于 IPv4, 需要的话可以参考前面 IPv4 的 Netfilter 配置进行选择
DECnet: Netfilter Configuration
针对 DECnet 的 Netfilter 配置
Ethernet Bridge tables (ebtables) support
CONFIG_BRIDGE_NF_EBTABLES
针对以太网桥的 ebtables Netfilter 配置
The DCCP Protocol
CONFIG_IP_DCCP
数据报拥塞控制协议 ( Datagram Congestion Control Protocol) 在 UDP 的基础上增加了流控和拥塞控制机制, 使数据报协议能够更好地用于流媒体业务的传输
The SCTP Protocol
CONFIG_IP_SCTP
流控制传输协议 ( Stream Control Transmission Protocol) 是一种新兴的传输层协议. TCP 协议一次只能连接一个 IP 地址而在 SCTP 协议一次可以连接多个 IP 地址且可以自动平衡网络负载, 一旦某一个 IP 地址失效会自动将网络负载转移到其他 IP 地址上
The RDS Protocol
CONFIG_RDS
可靠数据报套接字 (Reliable Datagram Sockets) 协议支持. RDS 可以使用 Infiniband 和 iWARP 作为支持 RDMA(远程直接内存访问) 的传输方式, RDMA 用于一台远程计算机访问另一台计算机的内存而无需本机计算机操作系统的辅助, 这就像直接内存访问 (DMA), 但是这里远程代替了本地计算机.
The TIPC Protocol
CONFIG_TIPC
透明内部进程间通信协议 ( Transparent Inter Process Communication), 以共享内存为基础实现任务和资源的调度, 专门用于集群内部通信
Asynchronous Transfer Mode (ATM)
CONFIG_ATM
异步传输模式 ( ATM) 支持. 主要用于高速 LAN 和 WAN. 目前已经日薄西山了.
Layer Two Tunneling Protocol (L2TP)
CONFIG_L2TP
第二层隧道协议 (RFC2661) 是一种对应用透明的隧道协议, VPN 经常使用它.
802.1d Ethernet Bridging
CONFIG_BRIDGE
802.1d 以太网桥 (例如为 QEMU 虚拟机或 Docker 容器提供桥接网卡支持)
IGMP/MLD snooping
CONFIG_BRIDGE_IGMP_SNOOPING
选 &ldquo;Y&rdquo; 可以允许以太网桥根据 IGMP( Internet Group Management Protocol, IPv4)/ MLD( Multicast Listener Discovery, IPv6) 负载选择性的转发不同端口上的多播包. 选 &ldquo;N&rdquo; 可以减小二进制文件的体积. 确定需要使用组播的选 &ldquo;Y&rdquo;.
802.1Q/802.1ad VLAN Support
CONFIG_VLAN_8021Q
802.1Q 虚拟局域网
DECnet Support
CONFIG_DECNET
DECnet 协议
ANSI/IEEE 802.2 LLC type 2 Support
CONFIG_LLC2
PF_LLC 类型套接字支持. 也就是 IEEE 802.2 LLC 2
The IPX protocol
CONFIG_IPX
IPX 协议是由 Novell 公司提出的运行于 OSI 模型第三层的协议, 具有可路由的特性, IPX 的地址分为网络地址和主机地址, 网络地址由管理员分配, 主机地址为 MAC 地址. 由于 IP 协议的广泛使用, IPX 的应用早已日薄西山.
Appletalk protocol support
CONFIG_ATALK
Appletalk 是苹果公司创建的一组网络协议, 仅用于苹果系列计算机.
CCITT X.25 Packet Layer
CONFIG_X25
CCITT X.25 协议集支持.
LAPB Data Link Driver
CONFIG_LAPB
LAPB 协议支持.
Phonet protocols family
CONFIG_PHONET
PhoNet 是 Nokia 开发的面相数据包的通信协议, 仅用于 Nokia maemo/meego 产品.
IEEE Std 802.15.4 Low-Rate Wireless Personal Area Networks support
CONFIG_IEEE802154
IEEE Std 802.15.4 定义了一个低速率 / 低功耗 / 低复杂度的短距离个人无线网络规范. 主要用于物联网中的传感器 / 交换器之类设备之间的互联.
6lowpan support over IEEE 802.15.4
CONFIG_IEEE802154_6LOWPAN
在 IEEE 802.15.4 上支持 IPv6 压缩.
Generic IEEE 802.15.4 Soft Networking Stack (mac802154)
CONFIG_MAC802154
为 SoftMAC 设备 (仅实现了 PHY 层) 实现硬件独立的 IEEE Std 802.15.4 协议栈. 使用 HardMAC 设备的用户应该选 &ldquo;N&rdquo;.[注意] 这里的实现既未经过认证, 也未进行充分的兼容性测试.
QoS and/or fair queueing
CONFIG_NET_SCHED
QoS( Quality of Service) 支持. 当内核有多个包需要通过网络发送的时候, 它需要决定哪个包先发, 那个包后发, 哪个包丢弃. 这就是包调度算法. 关闭此项表示内核使用最简单的 FIFO 算法, 开启此项后就可以使用多种不同的调度算法 (需要配合用户层工具 iproute2+tc).QoS 还用于支持 diffserv(Differentiated Services) 和 RSVP(Resource Reservation Protocol) 功能. 包调度的状态信息可以从 &ldquo;/proc/net/psched&rdquo; 文件中获取. 仅在你确实需要的时候选 &ldquo;Y&rdquo;.
Data Center Bridging support
CONFIG_DCB
DCB(Data Center Bridging) 支持. 数据中心桥接是一组可增强传统以太网功能, 以管理通信的功能, 尤其适用于网络通信流量和传输率都很高的环境中. 光纤通道可专用于承载此类型的通信. 但是, 如果使用专用链路来仅提供光纤通道通信, 则成本可能会很高. 因此, 更多情况下使用以太网光纤通道. DCB 功能可满足光纤通道对遍历以太网时包丢失的敏感度要求. DCB 允许对等方基于优先级区分通信. 通过区分优先级, 可确保在主机之间发生拥塞时, 保持较高优先级通信的包完整性. 使用 DCB 交换协议, 通信主机可以交换会影响高速网络通信的配置信息. 然后, 对等方可对公用配置进行协商, 确保通信流不中断, 同时防止高优先级包出现包丢失. 这些功能都需要底层的网卡支持. 一般网卡都是不支持的. 所以不确定的可以选 &ldquo;N&rdquo;.
DNS Resolver support
CONFIG_DNS_RESOLVER
内核 DNS 解析支持. 用于支持 CONFIG_AFS_FS/CONFIG_CIFS/CONFIG_CIFS_SMB2/NFS_V4 模块. 此功能需要用户态程序 &ldquo;/sbin/dns.resolve&rdquo; 和配置文件 &ldquo;/etc/request-key.conf&rdquo; 的支持. 更多信息参见 &quot; Documentation/networking/dns_resolver.txt&quot;文档, 不确定的选&quot;N&quot;.
B.A.T.M.A.N. Advanced Meshing Protocol
CONFIG_BATMAN_ADV
B.A.T.M.A.N.(更好的移动无线网络方案) 是一种用于 multi-hop ad-hoc  mesh 网络的路由协议. 它是一种去中心化分布式无线 Adhoc 模式, 特别适用于自然灾害等紧急情况下, 创建临时的无线网络. 不确定的选 &ldquo;N&rdquo;.
Open vSwitch
CONFIG_OPENVSWITCH
Open vSwitch 是一个多层虚拟交换标准. 此选项提供了内核级的高速转发功能 (需要配合用户态守护进程 ovs-vswitchd 来实现).
Virtual Socket protocol
CONFIG_VSOCKETS
这是一个类似于 TCP/IP 的协议, 用于虚拟机之间以及虚拟机与宿主之间的通信. 开启此项后, 还需要从子项中选择适用于特定虚拟化技术的传输协议.
VMware VMCI transport for Virtual Sockets
CONFIG_VMWARE_VMCI_VSOCKETS
适用于 VMware 虚拟化技术的 VMCI 传输协议支持.
NETLINK: mmaped IO
CONFIG_NETLINK_MMAP
基于内存映射机制的  netlink IO 支持. 可以避免在用户空间与内存空间之间复制数据, 从而提升操作速度. 不确定的选 &ldquo;N&rdquo;.
NETLINK: socket monitoring interface
CONFIG_NETLINK_DIAG
NETLINK socket 监视接口. ss 这样的诊断工具需要它.
MultiProtocol Label Switching
CONFIG_MPLS
多协议标签交换 ( MPLS) 是新一代的 IP 高速骨干网络交换标准. 不确定的选 &ldquo;N&rdquo;.
High-availability Seamless Redundancy (HSR)
CONFIG_HSR
以太网 HSR(高可用性无缝冗余)规范 (IEC 62439-3:2010) 支持. 不确定的选 &ldquo;N&rdquo;.
Network priority cgroup
CONFIG_NETPRIO_CGROUP
CONFIG_CGROUP_NET_PRIO
Cgroup 子系统支持: 基于每个网络接口为每个进程分配网络使用优先级. Docker 依赖于它.</p>
<p>Network testing
网络测试, 仅供调试使用
Amateur Radio support
CONFIG_HAMRADIO
业余无线电支持. 供无线电爱好者进行自我训练 / 相互通讯 / 技术研究
CAN bus subsystem support
CONFIG_CAN
CAN(Controller Area Network) 是一个低速串行通信协议. 被广泛地应用于工业自动化 / 船舶 / 医疗设备 / 工业设备等嵌入式领域. 更多信息参见 &quot; Documentation/networking/can.txt&quot; 文件.
IrDA (infrared) subsystem support
CONFIG_IRDA
红外线通讯技术支持, 主要用于嵌入式环境, 某些老旧的笔记本上也可能会有红外接口.
Bluetooth subsystem support
CONFIG_BT
蓝牙支持. 蓝牙目前已经基本取代红外线, 成为嵌入式设备 / 智能设备 / 笔记本的标配近距离 (小于 10 米) 通信设备. 在 Linux 上通常使用来自 BlueZ 的 hciconfig 和 bluetoothd 工具操作蓝牙通信.
RFCOMM protocol support
CONFIG_BT_RFCOMM
虚拟串口协议 ( RFCOMM) 是一个面向连接的流传输协议, 提供 RS232 控制和状态信号, 从而模拟串口的功能. 它被用于支持拨号网络, OBEX(Object Exchange), 以及某些蓝牙程序 (例如文件传输).
RFCOMM TTY support
CONFIG_BT_RFCOMM_TTY
允许在 RFCOMM 通道上模拟 TTY 终端
BNEP protocol support
CONFIG_BT_BNEP
蓝牙网络封装协议 (Bluetooth Network Encapsulation Protocol) 可以在蓝牙上运行其他网络协议(TCP/IP).  Bluetooth PAN(Personal Area Network) 需要它的支持.
Multicast filter support
CONFIG_BT_BNEP_MC_FILTER
组播支持
Protocol filter support
CONFIG_BT_BNEP_PROTO_FILTER
协议过滤器支持
CMTP protocol support
CONFIG_BT_CMTP
CMTP(CAPI 消息传输协议) 用于支持已在上世纪被淘汰的 ISDN 设备. 不确定的选 &ldquo;N&rdquo;.
HIDP protocol support
CONFIG_BT_HIDP
人机接口设备协议 (Human Interface Device Protocol) 用于支持各种人机接口设备(比如鼠标 / 键盘 / 耳机等).
Bluetooth device drivers
各种蓝牙设备驱动
HCI USB driver
CONFIG_BT_HCIBTUSB
使用 USB 接口的蓝牙设备支持
HCI SDIO driver
CONFIG_BT_HCIBTSDIO
使用 SDIO 接口的蓝牙设备支持
HCI UART driver
CONFIG_BT_HCIUART
使用串口的蓝牙设备支持. 此外, 基于 UART 的蓝牙 PCMCIA 和 CF 设备也需要此模块的支持.
UART (H4) protocol support
CONFIG_BT_HCIUART_H4
大多数使用 UART 接口的蓝牙设备 (包括 PCMCIA 和 CF 卡) 都使用这个协议.
BCSP protocol support
CONFIG_BT_HCIUART_BCSP
基于 CSR(Cambridge Silicon Radio)公司的 BlueCore 系列芯片的蓝牙设备 (包括 PCMCIA 和 CF 卡) 支持
Atheros AR300x serial support
CONFIG_BT_HCIUART_ATH3K
基于 Atheros AR300x 系列芯片的蓝牙设备支持
HCILL protocol support
CONFIG_BT_HCIUART_LL
基于 Texas Instruments 公司的 BRF 芯片的蓝牙设备支持
Three-wire UART (H5) protocol support
CONFIG_BT_HCIUART_3WIRE
Three-wire UART (H5) 协议假定 UART 通信可能存在各种错误, 从而使得 CTS/RTS 引脚线变得可有可无. 看不懂就可以不选.
HCI VHCI (Virtual HCI device) driver
CONFIG_BT_HCIVHCI
模拟蓝牙设备支持. 主要用于开发
{大多数蓝牙设备并不需要特定的独立驱动, 此处省略的独立驱动仅是为了驱动那些不严格遵守蓝牙规范的芯片}
RxRPC session sockets
CONFIG_AF_RXRPC
RxRPC 会话套接字支持 (仅包括传输部分, 不含表示部分).CONFIG_AFS_FS 依赖于它. 不确定的选 &ldquo;N&rdquo;. 详情参见 &quot; Documentation/networking/rxrpc.txt&quot; 文档.
Wireless
CONFIG_WIRELESS
无线网络支持.
cfg80211 - wireless configuration API
CONFIG_CFG80211
cfg80211 是 Linux 无线局域网 ( 802.11) 配置接口, 是使用 WiFi 的前提. 注意:&quot; WiFi&quot; 是一个无线网路通信技术的品牌, 由 WiFi 联盟所持有. 目的是改善基于 IEEE 802.11 标准的无线网路产品之间的互通性. 现时一般人会把 WiFi 及 IEEE 802.11 混为一谈, 甚至把 WiFi 等同于无线网路 (WiFi 只是无线网络的一种).
nl80211 testmode command
CONFIG_NL80211_TESTMODE
仅供调试和特殊目的使用.
enable developer warnings
CONFIG_CFG80211_DEVELOPER_WARNINGS
仅供调试开发使用
cfg80211 regulatory debugging
CONFIG_CFG80211_REG_DEBUG
仅供调试开发使用
cfg80211 certification onus
CONFIG_CFG80211_CERTIFICATION_ONUS
仅在你确实明白此项含义的情况下, 才考虑选 &ldquo;Y&rdquo;, 否则请选 &ldquo;N&rdquo;.
enable powersave by default
CONFIG_CFG80211_DEFAULT_PS
若开启此项则表示默认开启省电模式 (也就是默认 &ldquo;Soft blocked: yes&rdquo;). 关闭此项则表示默认使用 BIOS 中的状态 (通常是上一次关机时的状态). 详情参见 &quot; Documentation/power/pm_qos_interface.txt&quot; 文档.
cfg80211 DebugFS entries
CONFIG_CFG80211_DEBUGFS
仅供调试
use statically compiled regulatory rules database
CONFIG_CFG80211_INTERNAL_REGDB
由于绝大多数发行版都含有 CRDA 软件包, 所以绝大多数人应该选 &ldquo;N&rdquo;. 如果你确实需要选 &ldquo;Y&rdquo;, 那么请认真阅读 &ldquo;net/wireless/db.txt&rdquo; 文件.
cfg80211 wireless extensions compatibility
CONFIG_CFG80211_WEXT
为那些老旧的用户空间程序提供兼容性, 建议关闭.
lib80211 debugging messages
CONFIG_LIB80211_DEBUG
仅供调试
Generic IEEE 802.11 Networking Stack (mac80211)
CONFIG_MAC80211
独立于硬件的通用 IEEE 802.11 协议栈模块 (mac80211). 它是驱动开发者用来编写 softMAC 无线设备驱动的框架, softMAC 设备允许用软件实现帧的管理 (包括解析和产生 80211 无线帧), 从而让系统能更好的控制硬件, 现在大多数的无线网卡都是 softMAC 设备. 不确定的选 &ldquo;Y&rdquo;.
PID controller based rate control algorithm
CONFIG_MAC80211_RC_PID
基于 比例 - 积分 - 微分控制器 ( PID controller)的发送速率 (TX rate) 控制算法. 用于 CONFIG_MAC80211 模块. 不确定的选 &ldquo;N&rdquo;.
Minstrel
CONFIG_MAC80211_RC_MINSTREL
minstrel 发送速率 (TX rate) 控制算法. 用于 CONFIG_MAC80211 模块. 这是首选的算法, 不确定的选 &ldquo;Y&rdquo;.
Minstrel 802.11n support
CONFIG_MAC80211_RC_MINSTREL_HT
minstrel_ht 发送速率 (TX rate) 控制算法. 适用于 802.11n 规范. 不确定的选 &ldquo;Y&rdquo;.
Default rate control algorithm
默认发送速率 (TX rate) 控制算法. 相当于 mac80211 模块 &ldquo;ieee80211_default_rc_algo&rdquo; 参数的值. 建议选择 &ldquo;Minstrel&rdquo; 算法.
Enable mac80211 mesh networking (pre-802.11s) support
CONFIG_MAC80211_MESH
802.11s 草案是无线网状网络 (Mesh Networking) 的延伸与增补标准 (amendment). 它扩展了 IEEE 802.11 MAC(介质访问控制) 标准, 定义了利用自我组态的多点跳跃拓朴(multi-hop topologies), 进行无线感知(radio-aware metrics), 以支援广播 / 组播 / 单播传送网络封包的架构与协定. 不确定的选 &ldquo;N&rdquo;.
Enable LED triggers
CONFIG_MAC80211_LEDS
允许在接受 / 发送数据时触发无线网卡的 LED 灯闪烁.
Export mac80211 internals in DebugFS
CONFIG_MAC80211_DEBUGFS
在 DebugFS 中显示 mac80211 模块内部状态的扩展信息, 仅用于调试目的.
Trace all mac80211 debug messages
CONFIG_MAC80211_MESSAGE_TRACING
跟踪所有 mac80211 模块的调试信息, 仅用于调试目的.
Select mac80211 debugging features
CONFIG_MAC80211_DEBUG_MENU
仅供调试
WiMAX Wireless Broadband support
CONFIG_WIMAX
WiMAX(IEEE 802.16) 协议支持. 随着 2010 年英特尔放弃 WiMAX 以及 LTE 在 4G 市场成了唯一的主流标准, WiMAX 的电信运营商也逐渐向 LTE 转移, WiMAX 论坛也于 2012 年将 TD-LTE 纳入 WiMAX2.1 规范, 一些 WiMAX 运营商也开始将设备升级为 TD-LTE.
WiMAX debug level
CONFIG_WIMAX_DEBUG_LEVEL
设置允许使用的最大调试信息详细等级, 推荐使用默认值 &ldquo;8&rdquo;, 设为 &ldquo;0&rdquo; 表示允许使用所有调试信息. 运行时默认禁止使用调试信息, 但可通过 sysfs 文件系统中的 debug-levels 文件开启调试信息.
RF switch subsystem support
CONFIG_RFKILL
为了节约电力, 很多无线网卡和蓝牙设备都有内置的射频开关 ( RF switche) 用于开启和关闭设备 (通过 rfkill 命令). 建议选 &ldquo;Y&rdquo;. 更多详情参见 &quot; Documentation/rfkill.txt&quot; 文档
RF switch input support
CONFIG_RFKILL_INPUT
这是个反对使用的特性, 一般情况下建议关闭. 若关闭此项导致某些笔记本的无线网卡开关按钮失效, 可以考虑开启.
Generic rfkill regulator driver
CONFIG_RFKILL_REGULATOR
通用射频开关驱动, 其射频开关连接在电压调节器 (voltage regulator) 上. 依赖于 CONFIG_REGULATOR 框架. 不确定的选 &ldquo;N&rdquo; 或 &ldquo;M&rdquo;
GPIO RFKILL driver
CONFIG_RFKILL_GPIO
通用 GPIO 射频开关驱动. 仅用于嵌入式环境, 其射频开关连接在 GPIO 总线上, 比如 NVIDIA 的 Tegra 和三星的 Exynos 4 智能手机 SoC 芯片.
Plan 9 Resource Sharing Support (9P2000)
CONFIG_NET_9P
实验性的支持 Plan 9 的 9P2000 协议.
CAIF support
CONFIG_CAIF
除非你为 Android/MeeGo 系统编译内核, 并且需要使用 PF_CAIF 类型的 socket, 否则请选 &ldquo;N&rdquo;.
Ceph core library
CONFIG_CEPH_LIB
仅在你需要使用 Ceph 分布式文件系统, 或者 rados 块设备 (rbd) 时选 &ldquo;Y&rdquo;. 否则应选 &ldquo;N&rdquo;.
NFC subsystem support
CONFIG_NFC
NFC( 近场通信) 子系统. 这些设备主要用于智能手机之类的嵌入式领域.
Network light weight tunnels
CONFIG_LWTUNNEL
为 MPLS( 多协议标签交换) 之类的轻量级隧道提供基础结构支持. 不确定的选 &ldquo;N&rdquo;.
Device Drivers
设备驱动程序
Generic Driver Options
驱动程序通用选项.[提示] Linux Kernel Driver DataBase 网站是搜索驱动程序与硬件型号对应关系的绝佳网站. 如果你不知道某个驱动 (例如 &ldquo;CONFIG_INTEL_IOATDMA&rdquo;) 究竟对应着哪些型号的硬件, 那么可以直接根据该驱动选项的首字母 (本例是 &ldquo;I&rdquo;) 进入对应的索引页去查找到该驱动的详情页面 (本例是 &ldquo;<a href="https://cateee.net/lkddb/web-lkddb/INTEL_IOATDMA.html%22).%5B">https://cateee.net/lkddb/web-lkddb/INTEL_IOATDMA.html&quot;).[</a>提示] 可以使用 &ldquo;lspci -nn&rdquo; 与 &ldquo;lsusb&rdquo; 命令查看本机所有 PCI/USB 设备的 &ldquo;vendor id&rdquo; 与 &ldquo;device id&rdquo; 及文本名称. 也可以根据已知的 id 到 pci.ids 与 usb.ids 数据库中搜索设备的名称.
Support for uevent helper
CONFIG_UEVENT_HELPER
早年的内核 (切换到基于 netlink 机制之前), 在发生 uevent 事件 (通常是热插拔) 时, 需要调用用户空间程序(通常是 &ldquo;/sbin/hotplug&rdquo;), 以帮助完成 uevent 事件的处理. 此选项就是用于开启此功能. 由于目前的发行版都已不再需要此帮助程序, 所以请选 &ldquo;N&rdquo;. 此外, 如果你使用了 systemd 或 udev 则必须选 &ldquo;N&rdquo;.
path to uevent helper
CONFIG_UEVENT_HELPER_PATH
早年的内核 (切换到基于 netlink 机制之前), 在发生 uevent 事件 (通常是热插拔) 时, 需要调用用户空间程序(通常是 &ldquo;/sbin/hotplug&rdquo;), 以帮助完成 uevent 事件的处理. 此选项就是用于设定这个帮助程序的路径. 由于目前的发行版都已不再需要此帮助程序, 所以请保持空白. 此外, 如果你使用了 systemd 或 udev 则必须保持空白.
Maintain a devtmpfs filesystem to mount at /dev
CONFIG_DEVTMPFS
devtmpfs 是一种基于 CONFIG_TMPFS 的文件系统 (与 proc 和 sys 有几分相似). 在系统启动过程中, 随着各个设备的初始化完成, 内核将会自动在 devtmpfs 中创建相应的设备节点(使用默认的文件名和权限) 并赋予正确的主次设备号. 更进一步, 在系统运行过程中, 随着各种设备插入和拔除, 内核也同样会自动在 devtmpfs 中创建和删除的相应的设备节点 (使用默认的文件名和权限) 并赋予正确的主次设备号. 如果将 devtmpfs 挂载到 &ldquo;/dev&rdquo; 目录(通常是系统启动脚本), 那么便拥有了一个全自动且全功能的 &ldquo;/dev&rdquo; 目录, 而且用户空间程序(通常是 udevd) 还可以对其中的内容进行各种修改 (增删节点, 改变权限, 创建符号链接). 目前的发行版和各种嵌入式系统基本都依赖于此, 除非你知道自己在做什么, 否则请选 &ldquo;Y&rdquo;.
Automount devtmpfs at /dev, after the kernel mounted the rootfs
CONFIG_DEVTMPFS_MOUNT
在内核挂载根文件系统的同时, 立即自动将 devtmpfs 挂载到 &ldquo;/dev&rdquo; 目录. 因为此时 init 进程都还尚未启动, 所以这就确保在进入用户空间之前, 所有设备文件就都已经准备完毕. 开启此选项相当于设置内核引导参数 &ldquo;devtmpfs.mount=1&rdquo;, 关闭此选项相当于设置内核引导参数 &ldquo;devtmpfs.mount=0&rdquo;. 开启此项后, 你就可以放心的使用 &ldquo;init=/bin/sh&rdquo; 直接进入救援模式, 而不必担心 &ldquo;/dev&rdquo; 目录空无一物. 注意: 此选项并不影响基于 initramfs 的启动, 此种情况下, devtmpfs 必须被手动挂载. 所以, 如果你的系统使用 initrd 或者有专门的启动脚本用于挂载 &ldquo;/dev&rdquo; 目录 (大多数发行版都有这样的脚本), 或者你看了前面的解释, 还是不确定, 那就选 &ldquo;N&rdquo;. 对于实在想要使用 &ldquo;init=/bin/sh&rdquo; 直接进入救援模式的人来说, 还是使用 &ldquo;init=/bin/sh devtmpfs.mount=1&rdquo; 吧!
Select only drivers that don&rsquo;t need compile-time external firmware
CONFIG_STANDALONE
只显示那些编译时不需要额外固件支持的驱动程序, 除非你有某些怪异硬件, 否则请选 &ldquo;Y&rdquo;.
Prevent firmware from being built
CONFIG_PREVENT_FIRMWARE_BUILD
不编译固件 (firmware). 固件一般是随硬件的驱动程序提供的, 仅在更新固件的时候才需要重新编译. 建议选 &ldquo;Y&rdquo;.
Userspace firmware loading support
CONFIG_FW_LOADER
用户空间固件加载支持. 如果内核自带的模块需要它, 它将会被自动选中. 但某些内核树之外的模块也可能需要它, 这时候就需要你根据实际情况手动开启了.
Include in-kernel firmware blobs in kernel binary
CONFIG_FIRMWARE_IN_KERNEL
内核源码树中包含了许多驱动程序需要的二进制固件 (blob), 推荐的方法是通过 &ldquo;make firmware_install&rdquo; 将 &ldquo;firmware&rdquo; 目录中所需的固件复制到系统的 &ldquo;/lib/firmware/&rdquo; 目录中, 然后由用户空间帮助程序在需要的时候进行加载. 开启此项后, 将会把所需的 &ldquo;blob&rdquo; 直接编译进内核, 这样就可以无需用户空间程序的帮助, 而直接使用这些固件了 (例如: 当根文件系统依赖于此类固件, 而你又不想使用 initrd 的时候). 每个需要此类二进制固件的驱动程序, 都会有一个 &ldquo;Include firmware for xxx device&rdquo; 的选项, 如果此处选 &ldquo;Y&rdquo;, 那么这些选项都将被隐藏. 建议选 &ldquo;N&rdquo;.
External firmware blobs to build into the kernel binary
CONFIG_EXTRA_FIRMWARE
指定要额外编译进内核的二进制固件 (blob). 此选项的值是一个空格分隔的固件文件名字符串, 这些文件必须位于 CONFIG_EXTRA_FIRMWARE_DIR 目录中 (其默认值是内核源码树下的 &ldquo;firmware&rdquo; 目录).
Firmware blobs root directory
CONFIG_EXTRA_FIRMWARE_DIR
指定 CONFIG_EXTRA_FIRMWARE 中列出的文件位于哪个目录. 默认值是当前内核源码树下的 &ldquo;firmware&rdquo; 目录. 若有需要, 你也可以修改成其他目录 (例如 &ldquo;/lib/firmware/&rdquo;).
Fallback user-helper invocation for firmware loading
CONFIG_FW_LOADER_USER_HELPER
在内核自己直接加载固件失败后, 作为补救措施, 调用用户空间帮助程序 (通常是 udev) 再次尝试加载. 通常这个动作是不必要的, 因此应该选 &ldquo;N&rdquo;, 如果你使用了 udev 或 systemd, 则必须选 &ldquo;N&rdquo;. 仅在某些特殊的固件位于非标准位置时, 才需要选 &ldquo;Y&rdquo;.
Allow device coredump
CONFIG_ALLOW_DEV_COREDUMP
为驱动程序开启 coredump 机制, 仅供调试.
Driver Core verbose debug messages
CONFIG_DEBUG_DRIVER
让驱动程序核心在系统日志中产生冗长的调试信息, 仅供调试
Managed device resources verbose debug messages
CONFIG_DEBUG_DEVRES
为内核添加一个 &ldquo;devres.log&rdquo; 引导参数. 当被设为非零值时, 将会打印出设备资源管理驱动 (devres) 的调试信息. 仅供调试使用.
Bus devices
总线设备. 此类设备仅出现在 ARM 平台.
Connector - unified userspace &lt;-&gt; kernelspace linker
CONFIG_CONNECTOR
统一的用户空间和内核空间连接器, 工作在 netlink socket 协议的顶层. 连接器是非常便利的用户态与内核态的通信方式, 这些驱动使内核知道当进程 fork 并使用 proc 连接器更改 UID/GID/SID(会话 ID). 内核需要知道什么时候进程 fork(CPU 中运行多个任务) 并执行, 否则, 内核可能会低效管理资源. 内核有几个连接器应用实例: CONFIG_HYPERV_UTILS,CONFIG_FB_UVESA,CONFIG_W1_CON,CONFIG_DM_LOG_USERSPACE. 另外还有一个 给 Gentoo 装上启动画面的例子. 建议选 &ldquo;Y&rdquo;.
Report process events to userspace
CONFIG_PROC_EVENTS
提供一个向用户空间报告进程事件 (fork,exec,id 变化(uid,gid,suid)) 的连接器. 建议选 &ldquo;Y&rdquo;.
Memory Technology Device (MTD) support
CONFIG_MTD
MTD 子系统是一个 闪存转换层. 其主要目的是提供一个介于闪存硬件驱动程序与高级应用程序之间的抽象层, 以简化闪存设备的驱动. 注意: MTD 常用于嵌入式系统, 而我们常见的 U 盘 / MMC 卡 / SD 卡 / CF 卡等移动存储设备以及固态硬盘 (SSD), 虽然也叫 &ldquo;flash&rdquo;, 但它们并不是使用 MTD 技术的存储器. 仅在你需要使用主设备号为 31 的 MTD 块设备(/dev/romX,/dev/rromX,/dev/flashX,/dev/rflashX), 或者主设备号为 90 的 MTD 字符设备(/dev/mtdX,/dev/mtdrX) 时选 &ldquo;Y&rdquo;, 否则选 &ldquo;N&rdquo;.
Device Tree and Open Firmware support
CONFIG_OF
Device Tree 基础架构与 Open Firmware 支持. 主要用于嵌入式环境. 不确定的选 &ldquo;N&rdquo;. 内核中若有其它选项依赖于它, 则会自动选中此项.
Parallel port support
CONFIG_PARPORT
25 针并口 ( LPT 接口) 支持. 古董级的打印机或扫描仪可能使用这种接口. 目前已被淘汰.
Plug and Play support
CONFIG_PNP
即插即用 (PnP) 支持. 选 &ldquo;Y&rdquo; 表示让 Linux 为 PnP 设备分配中断和 I/O 端口 (需要在 BIOS 中开启 &ldquo;PnP OS&rdquo;), 选 &ldquo;N&rdquo; 则表示让 BIOS 来分配 (需要在 BIOS 中关闭 &ldquo;PnP OS&rdquo;). 建议选 &ldquo;Y&rdquo;.
PNP debugging messages
CONFIG_PNP_DEBUG_MESSAGES
允许使用 &ldquo;pnp.debug&rdquo; 内核参数在系统启动过程中输出 PnP 设备的调试信息, 建议选 &ldquo;N&rdquo;.
Block devices
CONFIG_BLK_DEV
块设备, 建议选 &ldquo;Y&rdquo;.
Null test block driver
CONFIG_BLK_DEV_NULL_BLK
仅供调试使用
Normal floppy disk support
CONFIG_BLK_DEV_FD
通用 软驱支持. 已被时代抛弃的设备
Parallel port IDE device support
CONFIG_PARIDE
通过并口与计算机连接的 IDE 设备, 比如某些老旧的外接光驱或硬盘之类. 此类设备早就绝种了
Block Device Driver for Micron PCIe SSDs
CONFIG_BLK_DEV_PCIESSD_MTIP32XX
Micron P320/P325/P420/P425 系列固态硬盘支持
Compressed RAM block device support
CONFIG_ZRAM
zram 是一种基于压缩内存的虚拟块设备, 它允许你创建 &ldquo;/dev/zramN&rdquo; 块设备文件, 并将它当作普通的磁盘一样使用. 它完全位于物理内存中, 并被实时压缩与解压以节约物理内存的用量, 所有对 &ldquo;/dev/zramN&rdquo; 的读写实质上都是对内存的读写, 从而可以获得比一般的磁盘快的多的 IO 速度. 常将它用做&rsquo;/tmp&rsquo;分区或作为 swap 分区挂载. 你可以把它看作是 CONFIG_BLK_DEV_RAM 的升级版. 具体用法可以参考内核文档&rsquo; Documentation/blockdev/zram.txt&rsquo;.
Compaq SMART2 support
CONFIG_BLK_CPQ_DA
基于 Compaq SMART2 控制器的磁盘阵列卡
Compaq Smart Array 5xxx support
CONFIG_BLK_CPQ_CISS_DA
基于 Compaq Smart 控制器的磁盘阵列卡
SCSI tape drive support for Smart Array 5xxx
CONFIG_CISS_SCSI_TAPE
在基于 Compaq Smart 控制器的磁盘阵列卡上使用的磁带机
Mylex DAC960/DAC1100 PCI RAID Controller support
CONFIG_BLK_DEV_DAC960
Mylex DAC960, AcceleRAID, eXtremeRAID PCI RAID 控制器. 很古董的设备了.
Micro Memory MM5415 Battery Backed RAM support
CONFIG_BLK_DEV_UMEM
一种使用电池做后备电源的内存, 但被用作块设备, 可以像硬盘一样被分区
Loopback device support
CONFIG_BLK_DEV_LOOP
loop 是指拿文件来模拟块设备 (/dev/loopX), 比如可以将一个 iso9660 镜像文件当成文件系统来挂载. 建议选 &ldquo;Y&rdquo;.
Number of loop devices to pre-create at init time
CONFIG_BLK_DEV_LOOP_MIN_COUNT
系统预先初始化的 loop 设备个数. 此值可以通过内核引导参数 &ldquo;loop.max_loop&rdquo; 修改. 如果你使用 util-linux-2.21 以上版本, 建议设为 &ldquo;0&rdquo;(loop 设备将通过 / dev/loop-control 动态创建), 否则保持默认值即可.
Cryptoloop Support
CONFIG_BLK_DEV_CRYPTOLOOP
使用系统提供的 CryptoAPI 对 loop 设备加密. 注意: 因为不能在 Cryptoloop 上创建日志型文件系统 (CONFIG_DM_CRYPT 模块可以), 所以 Cryptoloop 已经逐渐淡出了. 建议选 &ldquo;N&rdquo;.
DRBD Distributed Replicated Block Device support
CONFIG_BLK_DEV_DRBD
DRBD(Distributed Replicated Block Device) 是一种分布式储存系统. DBRD 处于文件系统之下, 比文件系统更加靠近操作系统内核及 IO 栈. DRBD 类似 RAID1 磁盘阵列, 只不过 RAID1 是在同一台电脑内, 而 DRBD 是透过网络. 注意: 为了进行连接认证, 你还需要选中 CONFIG_CRYPTO_HMAC 以及相应的哈希算法. 不确定的选 &ldquo;N&rdquo;.
DRBD fault injection
CONFIG_DRBD_FAULT_INJECTION
模拟 IO 错误, 以用于测试 DRBD 的行为. 主要用于调试目的
Network block device support
CONFIG_BLK_DEV_NBD
让你的电脑成为网络块设备的客户端, 也就是可以挂载远程服务器通过 TCP/IP 网络提供的块设备 (/dev/ndX). 提示: 这与 NFS 或 Coda 没有任何关系. 更多详情参见 &quot; Documentation/blockdev/nbd.txt&rdquo;. 不确定的选&quot;N&quot;.
OSD object-as-blkdev support
CONFIG_BLK_DEV_OSD
允许将一个单独的  SCSI OSD(Object-Based Storage Devices) 对象当成普通的块设备来使用. 举例来说, 你可以在 OSD 设备上创建一个 2G 大小的对象, 然后通过本模块将其模拟成一个 2G 大小的块设备使用. 不确定的选 &ldquo;N&rdquo;.
STEC S1120 Block Driver
CONFIG_BLK_DEV_SKD
STEC 公司的 S1120 PCIe SSD
Promise SATA SX8 support
CONFIG_BLK_DEV_SX8
基于 Promise 公司的 SATA SX8 控制器的 RAID 卡
RAM block device support
CONFIG_BLK_DEV_RAM
内存中的虚拟磁盘, 大小固定. 详情参阅 &quot; Documentation/blockdev/ramdisk.txt&quot;. 由于其功能比 CONFIG_TMPFS 和 CONFIG_ZRAM 弱许多, 使用上也不方便, 所以除非你有明确的理由, 否则应该选&quot;N&quot;, 并转而使用 CONFIG_TMPFS 或 CONFIG_ZRAM.
Default number of RAM disks
CONFIG_BLK_DEV_RAM_COUNT
默认 RAM disk 的数量. 请保持默认值, 除非你知道自己在做什么.
Default RAM disk size (kbytes)
CONFIG_BLK_DEV_RAM_SIZE
默认 RAM disk 的大小. 请保持默认值, 除非你知道自己在做什么.
Support XIP filesystems on RAM block device
CONFIG_BLK_DEV_XIP
XIP(eXecute In Place) 支持 (指应用程序可以直接在 flash 闪存内运行, 不必再把代码读到系统 RAM 中). 一般用于嵌入式设备.
Packet writing on CD/DVD media
CONFIG_CDROM_PKTCDVD
CD/DVD 刻录机支持. 详情参见 &quot; Documentation/cdrom/packet-writing.txt&quot; 文档
Free buffers for data gathering
CONFIG_CDROM_PKTCDVD_BUFFERS
用于收集写入数据的缓冲区个数 (每个占用 64Kb 内存), 缓冲区越多性能越好.
Enable write caching
CONFIG_CDROM_PKTCDVD_WCACHE
为 CD-R/W 设备启用写入缓冲, 目前这是一个比较危险的选项. 建议关闭.
ATA over Ethernet support
CONFIG_ATA_OVER_ETH
以太网 ATA 设备 ( ATA over Ethernet) 支持.
Xen virtual block device support
CONFIG_XEN_BLKDEV_FRONTEND
XEN 虚拟块设备前端驱动. 此驱动用于与实际驱动块设备的后端驱动 (通常位于 domain0) 通信.
Xen block-device backend driver
CONFIG_XEN_BLKDEV_BACKEND
XEN 块设备后端驱动 (通常位于 domain0) 允许内核将实际的块设备通过高性能的共享内存接口导出给其他客户端的前端驱动 (通常位于非 domain0) 使用.
Virtio block driver
CONFIG_VIRTIO_BLK
Virtio 虚拟块设备驱动. 仅可用在基于 lguest 或 QEMU 的半虚拟化客户机中 (一般是 KVM 或 XEN).
Very old hard disk (MFM/RLL/IDE) driver
CONFIG_BLK_DEV_HD
又老又旧的 MFM/RLL/ESDI 硬盘驱动. 无需犹豫, 选 &ldquo;N&rdquo;.
Rados block device (RBD)
CONFIG_BLK_DEV_RBD
rados 块设备 (rbd) 支持. 它可以与分布式文件系统 Ceph 合作, 也能独立工作.
IBM Flash Adapter 900GB Full Height PCIe Device Driver
CONFIG_BLK_DEV_RSXX
IBM Flash Adapter 900GB Full Height PCIe SSD 驱动
NVM Express block device
CONFIG_BLK_DEV_NVME
NVM Express 是专门针对 PCI-E 接口高性能固态硬盘的标准规范. 有了这一标准, 操作系统厂商只需要编写一种驱动, 就可以支持不同厂商的不同 PCI-E SSD 设备, 以解决过去 PCI-E SSD 产品形态与规格五花八门, 缺乏通用性和互用性的问题. 如果你有一块较新的 PCIE 固态硬盘, 那么很大可能就是 NVMe 接口.
Misc devices
杂项设备
{省略的部分请按照实际的硬件状况进行选择} Integrated Circuits ICS932S401
CONFIG_ICS932S401
IDT ICS932S401 系列时钟频率控制芯片支持 (可能会出现在某些主板上).
Enclosure Services
CONFIG_ENCLOSURE_SERVICES
SES( SCSI Enclosure Services)是 SCSI 协议中用于查询设备状态 (温度 / 风扇 / 电源 / 指示灯) 的一项服务. 这里的设备可以是移动硬盘盒 / 磁盘阵列柜 / 硬盘托架等. SES 可以让主机端透过 SCSI 命令去控制外接 SCSI 设备的电源 / 风扇以及其他与数据传输无关的东西. 要使用这项技术, 外置设备和主机上的 SCSI/ATA 控制芯片都需要支持 SES 技术才 OK. 事实上, 目前大多数外置移动硬盘和所有磁盘阵列柜都支持 SES 规范.
VMware Balloon Driver
CONFIG_VMWARE_BALLOON
VMware 物理内存 balloon 驱动 (将客户机操作系统不需要的物理内存页交还给宿主机). 参见 CONFIG_BALLOON_COMPACTION 选项.
Generic on-chip SRAM driver
CONFIG_SRAM
许多 SoC 系统都有芯片内嵌的 SRAM. 开启此项后, 就可以声明将此段内存范围交给通用内存分配器 ( genalloc) 管理. 不确定的选 &ldquo;N&rdquo;.
EEPROM support
EEPROM 主要用于保存主板或板卡的 BIOS, 如果你想通过此 Linux 系统刷写 BIOS 可以考虑开启相应的子项. 不确定的全部选 &ldquo;N&rdquo;.
Intel Management Engine Interface
CONFIG_INTEL_MEI
Intel 芯片组管理引擎, 是一种面向企业环境的远程管理技术, 其中的重头戏是 英特尔主动管理技术. 如果你的芯片组位于 &ldquo;CONFIG_INTEL_MEI_ME&rdquo; 中, 可以考虑选 &ldquo;Y&rdquo;, 不过如果你不明白这是什么东西, 那就说明你不需要它, 就应该选 &ldquo;N&rdquo;. 此外, 在某些服务器上此驱动 (mei) 还可能 可能导致监视程序计时器错误, 还可能导致无法正常关机.
ME Enabled Intel Chipsets
CONFIG_INTEL_MEI_ME
请根据帮助中列出的芯片组对照实际情况选择.
VMware VMCI Driver
CONFIG_VMWARE_VMCI
VMware VMCI(Virtual Machine Communication Interface) 是一个在 host 和 guest 之间以及同一 host 上的 guest 和 guest 之间进行高速通信的虚拟设备. VMCI 主要是提供一个接口让 guest 内的程序来调用, 通过这个接口能在一个主机上的多个虚拟机之间进行直接的通信, 而且无需经过更上层的其他途径, 这样将有效地降低网络通信所产生的开支, 但是这需要修改虚拟机上的软件, 所以 VMCI 只适用于对虚拟机间通信要求非常高的情况. 不确定的选 &ldquo;N&rdquo;.
ATA/ATAPI/MFM/RLL support (DEPRECATED)
CONFIG_IDE
已被废弃的 IDE 硬盘和 ATAPI 光驱等接口的驱动 (已被 CONFIG_ATA 取代). 选 &ldquo;N&rdquo;, 除非你确实知道自己在干什么.
SCSI device support
SCSI 子系统
RAID Transport Class
CONFIG_RAID_ATTRS
这只是用来得到 RAID 信息以及将来可能用于配置 RAID 方式的一个类. 不管你的系统使用的是哪种 RAID, 都可以放心的关闭此项. 不确定的选 &ldquo;N&rdquo;.
SCSI device support
CONFIG_SCSI
SCSI 协议支持. 有任何 SCSI/SAS/SATA/USB/Fibre Channel/FireWire 设备之一就必须选上. 选 &ldquo;Y&rdquo;.
SCSI target support
CONFIG_SCSI_TGT
内核态的通用 SCSI Target 实现 (原 LIO 项目).SCSI 子系统使用了一种客户机 - 服务器 (C/S) 模型. 通常, 一台计算机是这个模型中的客户机 (称为 &ldquo;initiator&rdquo;), 向目标(target) 发起块操作请求, 这个 &ldquo;target&rdquo; 通常是一个存储设备(例如一块硬盘). 此模块的功能是将一台计算机变成一个 &ldquo;target&rdquo;(就像一个普通的硬盘一样), 响应其他 &ldquo;initiator&rdquo; 节点的操作请求, 从而让 &ldquo;target&rdquo; 能够提供更加高级的功能: 复制, 自动精简配置, 重复数据删除, 高可用性, 自动备份等. 不确定的选 &ldquo;N&rdquo;.
SCSI: use blk-mq I/O path by default
CONFIG_SCSI_MQ_DEFAULT
对所有 SCSI 块设备默认使用新式的多重队列 I/O 调度机制 ( blk-mq), 也就是将 I/O 请求分散至多个 CPU 处理以提高性能. 相当于开启 &ldquo;scsi_mod.use_blk_mq&rdquo; 内核模块参数. 尤其适合于 SSD(高 IOP)/ 磁盘阵列 (多通道) 这类存储设备.
legacy /proc/scsi/ support
CONFIG_SCSI_PROC_FS
过时的 / proc/scsi / 接口. 某些老旧的刻录程序可能需要它, 建议选 &ldquo;N&rdquo;.
SCSI disk support
CONFIG_BLK_DEV_SD
使用 SCSI/SAS/SATA/PATA/USB/Fibre Channel 存储设备的必选. 选 &ldquo;Y&rdquo;.
SCSI tape support
CONFIG_CHR_DEV_ST
通用 SCSI 磁带驱动
SCSI OnStream SC-x0 tape support
CONFIG_CHR_DEV_OSST
专用于 OnStream SC-x0/USB-x0/DI-x0 的 SCSI 磁带 / USB 盘驱动
SCSI CDROM support
CONFIG_BLK_DEV_SR
通过 SCSI/FireWire/USB/SATA/IDE 接口连接的 DVD/CD 驱动器 (基本上涵盖了所有常见的接口).
Enable vendor-specific extensions (for SCSI CDROM)
CONFIG_BLK_DEV_SR_VENDOR
仅在某些古董级的 SCSI CDROM 设备上才需要: NEC/TOSHIBA cdrom, HP Writers
SCSI generic support
CONFIG_CHR_DEV_SG
通用 SCSI 协议 (/dev/sg*) 支持. 也就是除硬盘 / 光盘 / 磁带之外的 SCSI 设备 (例如光纤通道). 这些设备还需要额外的用户层工具支持才能正常工作. 例如: SANE, Cdrtools, CDRDAO, Cdparanoia
SCSI media changer support
CONFIG_CHR_DEV_SCH
SCSI 介质转换设备 (SCSI Medium Changer device) 是一种控制多个 SCSI 介质的转换器(例如在多个磁带 / 光盘之间进行切换), 常用于控制磁带库或者 CD 自动点歌机(jukeboxes). 此种设备会在 / proc/scsi/scsi 中以 &ldquo;Type: Medium Changer&rdquo; 列出. 控制此类设备的用户层工具包是 scsi-changer. 更多细节参见 &quot; Documentation/scsi/scsi-changer.txt&quot;文档. 不确定的选&quot;N&quot;.
SCSI Enclosure Support
CONFIG_SCSI_ENCLOSURE
&ldquo;Enclosure&rdquo; 是一种用于管理 SCSI 设备的背板装置. 移动硬盘盒与磁盘阵列柜就是最常见的 &ldquo;Enclosure&rdquo; 设备. 此项主要用于向用户层报告一些 &ldquo;Enclosure&rdquo; 设备的状态, 这些状态对于 SCSI 设备的正常运行并非必须. 此项依赖于 CONFIG_ENCLOSURE_SERVICES 选项.
Probe all LUNs on each SCSI device
CONFIG_SCSI_MULTI_LUN
默认强制在每个 SCSI 设备上探测所有的逻辑设备数量 (Logical Unit Number), 其值会被该模块的内核引导参数 &ldquo;max_luns&rdquo; 覆盖. 只在一个 SCSI 设备上有多个逻辑设备时才需要选它, 一般的 SCSI 设备并不需要. 一个 SCSI 设备上有多个逻辑设备的典型例子: 多端口 USB 读卡器, CD 点唱机 (jukebox), 处于 &ldquo;mass storage&rdquo; 模式的智能手机, 量产为多个设备后的 U 盘. 注意: 此项并不影响符合 SCSI-3 或更高标准的设备, 因为这些设备会明确的向内核报告逻辑设备数.
Verbose SCSI error reporting (kernel size +=75K)
CONFIG_SCSI_CONSTANTS
以易读的方式报告 SCSI 错误, 内核将会增大 75K
SCSI logging facility
CONFIG_SCSI_LOGGING
启用 SCSI 日志 (默认并不开启, 需要 &ldquo;echo [bitmask] &gt; /proc/sys/dev/scsi/logging_level&rdquo;), 可用于跟踪和捕获 SCSI 设备的错误. 关于[bitmask] 的说明可以查看 &ldquo;drivers/scsi/scsi_logging.h&rdquo; 文件. 不确定的选 &ldquo;N&rdquo;.
Asynchronous SCSI scanning
CONFIG_SCSI_SCAN_ASYNC
异步扫描的意思是, 在内核引导过程中, SCSI 子系统可以在不影响其他子系统引导的同时进行 SCSI 设备的探测 (包括同时在多个总线上进行检测), 这样可以加快系统的引导速度. 但是如果 SCSI 设备驱动被编译为模块, 那么异步扫描将会导致内核引导出现问题 (解决方法是加载 scsi_wait_scan 模块, 或者使用 &ldquo;scsi_mod.scan=sync&rdquo; 内核引导参数). 不确定的选 &ldquo;N&rdquo;.
SCSI Transports
SCSI 接口类型, 下面的子项可以全不选, 内核中若有其他部分依赖它, 会自动选上
Parallel SCSI (SPI) Transport Attributes
CONFIG_SCSI_SPI_ATTRS
传统的并行 SCSI(Ultra320/160 之类), 已逐渐被淘汰
FiberChannel Transport Attributes
CONFIG_SCSI_FC_ATTRS
光纤通道接口
SCSI target support for FiberChannel Transport Attributes
CONFIG_SCSI_FC_TGT_ATTRS
为光纤通道添加 &ldquo;target&rdquo; 模式驱动
iSCSI Transport Attributes
CONFIG_SCSI_ISCSI_ATTRS
iSCSI 协议是利用 TCP/IP 网络传送 SCSI 命令和数据的 I/O 技术
SAS Transport Attributes
CONFIG_SCSI_SAS_ATTRS
串行 SCSI 传输属性支持 ( SAS 对于 SPI 的关系犹如 SATA 对于 IDE), 这是目前的主流接口
SAS Domain Transport Attributes
CONFIG_SCSI_SAS_LIBSAS
为使用了 SAS Domain 架构的驱动程序提供帮助. SAS Domain 即整个 SAS 交换构架, 由 &ldquo;SAS device&rdquo; 和 &ldquo;SAS expander device&rdquo; 组成, 其中 Device 又区分为 Initiator 和 Target, 它们可以直接对接起来, 也可以经过 Expander 进行连接, Expander 起到通道交换或者端口扩展的作用. 看不懂就说明你不需要它.
ATA support for libsas (requires libata)
CONFIG_SCSI_SAS_ATA
在 libsas 中添加 ATA 支持, 从而让 libata 和 libsas 协同工作.
Support for SMP interpretation for SAS hosts
CONFIG_SCSI_SAS_HOST_SMP
在 libsas 中添加 SMP 解释器, 以允许主机支持 SAS SMP 协议.
SRP Transport Attributes
CONFIG_SCSI_SRP_ATTRS
SCSI  RDMA 协议 (SCSI RDMA Protocol) 通过将 SCSI 数据传输阶段映射到 Infiniband 远程直接内存访问 (Remote Direct Memory Access) 操作加速了 SCSI 协议.
SCSI target support for SRP Transport Attributes
CONFIG_SCSI_SRP_TGT_ATTRS
为 SRP 添加 &ldquo;target&rdquo; 模式驱动
SCSI low-level drivers
CONFIG_SCSI_LOWLEVEL
底层 SCSI 驱动程序
iSCSI Initiator over TCP/IP
CONFIG_ISCSI_TCP
iSCSI 协议利用 TCP/IP 网络在 &ldquo;initiator&rdquo; 与 &ldquo;targets&rdquo; 间传送 SCSI 命令和数据. 此选项便是 iSCSI initiator 驱动. 相关的用户层工具 / 文档 / 配置示例, 可以在 open-iscsi 找到.
iSCSI Boot Sysfs Interface
CONFIG_ISCSI_BOOT_SYSFS
通过 sysfs 向用户空间显示 iSCSI 的引导信息. 不确定的选 &ldquo;N&rdquo;.
{此处省略的部分按照实际使用的控制器进行选择} VMware PVSCSI driver support
CONFIG_VMWARE_PVSCSI
VMware 半虚拟化的 SCSI HBA 控制器
Microsoft Hyper-V virtual storage driver
CONFIG_HYPERV_STORAGE
微软的 Hyper-V 虚拟存储控制器
Intel(R) C600 Series Chipset SAS Controller
CONFIG_SCSI_ISCI
Intel C600 系列芯片组 6Gb/s SAS 控制器
virtio-scsi support
CONFIG_SCSI_VIRTIO
virtio 虚拟 HBA 控制器. 仅可用在基于 lguest 或 QEMU 的半虚拟化客户机中 (一般是 KVM 或 XEN).
PCMCIA SCSI adapter support
CONFIG_SCSI_LOWLEVEL_PCMCIA
通过 PCMCIA 卡与计算机连接的 SCSI 设备
SCSI Device Handlers
CONFIG_SCSI_DH
针对某些多路径安装的 SCSI 设备的驱动, 用在每个节点都需要一个到 SCSI 存储单元的直接路径的集群中, 具体子项请按照实际使用的控制器进行选择
OSD-Initiator library
CONFIG_SCSI_OSD_INITIATOR
OSD(Object-Based Storage Device) 协议是一个 T10 SCSI 命令集, 和 SCSI 处于同一级别, 也跟 SCSI 很类似, 分成 osd-initiator/osd-target 两部分, 用于 对象存储文件系统, 此选项实现了 OSD-Initiator 库 (libosd.ko). 更多细节参见 &quot; Documentation/scsi/osd.txt&quot; 文件. 看不懂就说明你不需要.[提示] 此选项依赖于 CONFIG_CRYPTO_SHA1 和 CONFIG_CRYPTO_HMAC 模块.
OSD Upper Level driver
CONFIG_SCSI_OSD_ULD
提供 OSD 上层驱动 (也就是向用户层提供 / dev/osdX 设备). 从而允许用户层控制 OSD 设备 (比如挂载基于 OSD 的 exofs 文件系统).
Serial ATA and Parallel ATA drivers
CONFIG_ATA
SATA 与 PATA(IDE) 设备. 桌面级 PC 以及低端服务器的硬盘基本都是此种接口
Verbose ATA error reporting
CONFIG_ATA_VERBOSE_ERROR
输出详细的 ATA 命令描述信息. 大约会让内核增大 6KB. 禁用它将会导致调试 ATA 设备错误变得困难.
ATA ACPI Support
CONFIG_ATA_ACPI
与 ATA 相关的 ACPI 对象支持. 这些对象与性能 / 安全 / 电源管理等相关. 不管你使用的是 IDE 硬盘还是 SATA 硬盘, 都建议开启 (可以使用内核引导参数 &ldquo;libata.noacpi=1&rdquo; 关闭).
SATA Zero Power Optical Disc Drive (ZPODD) support
CONFIG_SATA_ZPODD
这是 SATA-3.1 版规范新增的节能相关内容, 用新的电源管理策略降低了整个系统的电力需求, 可以让处于空闲状态的光驱耗电量近乎于零. 这需要主板和光驱两者都支持 SATA-3.1 规范才行.
SATA Port Multiplier support
CONFIG_SATA_PMP
SATA 端口复用器 ( Port Multiplier) 是一个定义在 SATA 规范里面的可以选择的功能, 可以把一个活动主机连接多路复用至多个设备连接, 相当于一个 SATA HUB. 不确定的选 &ldquo;N&rdquo;.
AHCI SATA support
CONFIG_SATA_AHCI
AHCI SATA 支持. 这是最佳的 SATA 模式 (NCQ 功能依赖于它). 某些主板还需要在 BIOS 中将硬盘明确设为 AHCI 模式. 使用 SATA 硬盘者必选 &ldquo;Y&rdquo;.[提示] 由于各厂商芯片组内的 SATA 控制器都遵循同一种规范, 所以并不需要各种各样针对不同 SATA 控制器的驱动, 就这一个驱动基本就能通吃所有 SATA 控制器了, 这比丰富多彩的网卡驱动省事多了.
Platform AHCI SATA support
CONFIG_SATA_AHCI_PLATFORM
这是用于嵌入式系统的与 AHCI 接口兼容的 SATA 驱动. 并不是常见的芯片组中的 SATA 控制器驱动. 不确定的选 &ldquo;N&rdquo;.
{此处省略几个特殊且不常见的 SATA 控制器驱动} ATA SFF support (for legacy IDE and PATA)
CONFIG_ATA_SFF
使用 SATA 硬盘的用户可无视此项, 选 &ldquo;N&rdquo; 即可. 对于依然使用老旧的 IDE/PATA 硬盘的用户而言, 按照实际情况在子项中选择相应的控制器驱动即可.
{此处省略几个罕见的 Pacific/Promise 芯片组} ATA BMDMA support
CONFIG_ATA_BMDMA
这是 IDE 控制器的事实标准. 除了上世纪的古董外, 绝大多数芯片组都遵守这个标准, 选 &ldquo;Y&rdquo;, 然后从子项中选择恰当的芯片组 / 控制器.
{此处省略的 PIO-only SFF 芯片组都是早就绝迹的老古董} ACPI firmware driver for PATA
CONFIG_PATA_ACPI
通过 ACPI BIOS 去操作 IDE 控制器. 仅用于某些比较奇特的 IDE 控制器. 选 &ldquo;N&rdquo;.
Generic ATA support
CONFIG_ATA_GENERIC
这是通用的 IDE 控制器驱动. 如果你无法确定 IDE 控制器的具体型号 (比如需要面对未知的硬件状况), 或者不想使用针对特定芯片组的 IDE 驱动, 就选 &ldquo;Y&rdquo; 吧.
Multiple devices driver support (RAID and LVM)
CONFIG_MD
多设备支持 ( RAID 和 LVM).RAID 和 LVM 的功能是使用多个物理设备组建成一个单独的逻辑设备
RAID support
CONFIG_BLK_DEV_MD
&quot; Software RAID&quot;(需要使用 mdadm 工具) 支持. 也就是 &quot; 软 RAID&quot;. 使用硬件 RAID 卡的用户并不需要此项.
Autodetect RAID arrays during kernel boot
CONFIG_MD_AUTODETECT
在内核启动过程中自动检测 RAID 模式. 如果你没有使用 RAID, 那么选中此项将会让内核在启动过程中增加几秒延迟. 如果你使用了 &ldquo;raid=noautodetect&rdquo; 内核引导参数关闭了自动检测, 或者此处选了 &ldquo;N&rdquo;, 那么你必须使用 &ldquo;md=???&rdquo; 内核引导参数明确告诉内核 RAID 模式及配置.
Linear (append) mode
CONFIG_MD_LINEAR
线性模式 (简单的将一个分区追加在另一个分区之后), 一般不使用这种模式.
RAID-0 (striping) mode
CONFIG_MD_RAID0
RAID-0(等量分割) 模式, 可以获取最高性能, 但是却损害了可靠性, 一般也不使用这种模式.
RAID-1 (mirroring) mode
CONFIG_MD_RAID1
RAID-1(镜像) 模式. 包含内核的引导分区只能使用这种模式.
RAID-10 (mirrored striping) mode
CONFIG_MD_RAID10
RAID 1+0 模式
RAID-4/RAID-5/RAID-6 mode
CONFIG_MD_RAID456
RAID-4/RAID-5/RAID-6 模式
Multipath I/O support
CONFIG_MD_MULTIPATH
多路径 IO 支持是指在服务器和存储设备之间使用冗余的物理路径组件创建 &ldquo;逻辑路径&rdquo;, 如果这些组件发生故障并造成路径失败, 多路径逻辑将为 I/O 使用备用路径以使应用程序仍然可以访问其数据. 该选项已废弃, 并已被 CONFIG_DM_MULTIPATH 所取代. 选 &ldquo;N&rdquo;.
Faulty test module for MD
CONFIG_MD_FAULTY
用于 MD(Multi-device) 的缺陷测试模块, 仅用于调试.
Block device as cache
CONFIG_BCACHE
将一个块设备用作其他块设备的缓存 ( Bcache). 此缓存使用 btree(平衡树) 索引, 并专门为 SSD 进行了优化. 仅在你打算 使用高速 SSD 作为普通硬盘的缓存时才需要此功能. 详情参见 &quot; Documentation/bcache.txt&quot; 文档.
Bcache debugging
CONFIG_BCACHE_DEBUG
仅供内核开发者调试使用
Extended runtime checks
CONFIG_BCACHE_EDEBUG
仅供内核开发者调试使用
Debug closures
CONFIG_BCACHE_CLOSURES_DEBUG
仅供内核开发者调试使用
Device mapper support
CONFIG_BLK_DEV_DM
Device-mapper 是一个底层的卷管理器, 提供了一种从逻辑设备到物理设备的映射框架, 用户可以很方便的根据自己的需要制定存储资源的管理策略. 它不像 RAID 那样工作在设备层, 而是通过块和扇区的映射机制, 将不同磁盘的不同部分组合成一个大的块设备供用户使用. LVM2 和 EVMS 都依赖于它. 此外, 那些集成在南桥 (例如 ICH8R/ICH9R/ICH10R 系列等) 中所谓的 &ldquo;硬 RAID&rdquo;(准确的称呼应该是 &quot; Device Mapper RAID&quot;, 又称为&quot;Fake RAID&quot;/&ldquo;BIOS RAID&rdquo;) 也依赖于它. 还有企业级高可用环境中经常使用的多路径设备也依赖于它.
request-based DM: use blk-mq I/O path by default
CONFIG_DM_MQ_DEFAULT
对所有 Device-mapper 块设备默认使用新式的多重队列 I/O 调度机制 ( blk-mq), 也就是将 I/O 请求映射至多个硬件或软件队列以提高性能. 相当于开启 &ldquo;dm_mod.use_blk_mq&rdquo; 内核模块参数. 推荐选 &ldquo;Y&rdquo;.
Device mapper debugging support
CONFIG_DM_DEBUG
仅供内核开发者调试使用
Keep stack trace of persistent data block lock holders
CONFIG_DM_DEBUG_BLOCK_STACK_TRACING
仅供内核开发者调试使用
Crypt target support
CONFIG_DM_CRYPT
此模块允许你创建一个经过透明加密的逻辑设备 (使用 cryptsetup 工具), 要使用加密功能, 除此项外, 还需要在 &ldquo;Cryptographic API&rdquo; 里选中相应的加密算法, 例如 CONFIG_CRYPTO_AES. 更多文档请参考 LUKS FAQ.
Snapshot target
CONFIG_DM_SNAPSHOT
允许卷管理器为 DM 设备创建可写的快照 (定格于特定瞬间的一个设备虚拟映像). LVM2 Snapshot 需要它的支持. 更多详情参见 &quot; Documentation/device-mapper/snapshot.txt&quot;文档. 不确定的选&quot;N&quot;.
Thin provisioning target
CONFIG_DM_THIN_PROVISIONING
&quot; Thin provisioning&quot;(某些地方翻译为&quot; 精简配置 &ldquo;) 的意思是允许分配给所有用户的总存储容量超过实际的存储容量 (使用 thin-provisioning-tools 工具). 例如给 100 个用户分配空间, 每个用户最大允许 10G 空间, 共计需要 1000G 空间. 但实际情况是 95% 的用户都只使用了不到 1G 的空间, 那么实际准备 1000G 空间就是浪费. 有了 &ldquo;thin provisioning&rdquo; 的帮助, 你实际只需要准备 150G 的空间就可以了, 之后, 可以随着用户需求的增加, 添加更多的实际存储容量, 从而减少存储投资和避免浪费. 更多详情参见 &quot; Documentation/device-mapper/thin-provisioning.txt&rdquo; 文档.
Keep stack trace of thin provisioning block lock holders
CONFIG_DM_DEBUG_BLOCK_STACK_TRACING
仅用于调试目的
Cache target
CONFIG_DM_CACHE
dm-cache 通过将频繁使用的热点数据缓存到一个容量较小但性能很高的存储设备上, 从而提升块设备的性能. 它支持 writeback 和 writethrough 两种模式, 并可以使用多种 缓存策略 (policy) 以判断哪些是热点数据以及哪些数据需要从缓存中移除. 更多详情参见 &quot; Documentation/device-mapper/cache.txt&quot;文档. 不确定的选&quot;N&quot;.
MQ Cache Policy
CONFIG_DM_CACHE_MQ
MQ 缓存策略. 这是目前唯一真正可用的缓存策略.
Cleaner Cache Policy
CONFIG_DM_CACHE_CLEANER
Cleaner 简单的把所有数据都同步写入到原始设备上, 相当于关闭缓存.
Era target
CONFIG_DM_ERA
跟踪块设备上的哪些部分被写入, 用于在使用 vendor 快照时维护缓存一致性. 不确定的选 &ldquo;N&rdquo;.
Mirror target
CONFIG_DM_MIRROR
允许对逻辑卷进行镜像, 同时实时数据迁移工具 pvmove 也需要此项的支持.
RAID 1/4/5/6/10 target
CONFIG_DM_RAID
RAID 1/4/5/6/10 支持. 即使使用 ICH8R/ICH9R/ICH10R 这样的南桥, 也不推荐使用 &ldquo;Device Mapper RAID&rdquo;(既无性能优势又依赖于特定硬件), 应该直接使用更成熟的 CONFIG_BLK_DEV_MD 模块.
Mirror userspace logging
CONFIG_DM_LOG_USERSPACE
device-mapper 用户空间日志功能由内核模块和用户空间程序两部分组成, 此选项是内核模块 (API 定义于 &ldquo;linux/dm-dirty-log.h&rdquo; 文件). 不确定的选 &ldquo;N&rdquo;.
Zero target
CONFIG_DM_ZERO
&ldquo;Zero target&rdquo; 类似于 &ldquo;/dev/zero&rdquo;, 所有的写入都被丢弃, 所有的读取都可以得到无限多个零. 可用于某些恢复场合.
Multipath target
CONFIG_DM_MULTIPATH
设备映射多路径 (DM-Multipath) 支持. 常用于对可靠性要求比较苛刻的场合.
I/O Path Selector based on the number of in-flight I/Os
CONFIG_DM_MULTIPATH_QL
这是一个动态负载均衡路径选择器: 选择当前正在处理中的 I/O 数量最小的通路.
I/O Path Selector based on the service time
CONFIG_DM_MULTIPATH_ST
这是一个动态负载均衡路径选择器: 选择完成此 I/O 操作预期时间最少的通路.
I/O delaying target
CONFIG_DM_DELAY
对读 / 写操作进行延迟, 并可将其发送到不同的设备. 仅用于测试 DM 子系统.
DM uevents
CONFIG_DM_UEVENT
为 DM 事件透过 netlink 向用户层的 udevd 发出 uevent 通知, 这样就允许 udevd 在 &ldquo;/dev/&rdquo; 目录中执行相应的操作.
Flakey target
CONFIG_DM_FLAKEY
模拟间歇性的 I/O 错误, 以用于调试 DM 子系统.
Verity target support
CONFIG_DM_VERITY
Verity target 可以创建一个只读的逻辑设备, 然后根据预先生成的哈希校验和 (存储在其他设备上), 校验底层设备上的数据正确性. 要使此模块正常工作, 还需要在 &ldquo;Cryptographic API&rdquo; 部分选中相应的哈希算法.
Switch target support
CONFIG_DM_SWITCH
Switch target 可以创建这样的逻辑设备: 将固定尺寸区块的 I/O 操作任意映射到一组固定的路径上. 通过向 target 发送一个消息, 即可动态的切换指定区块的 I/O 操作所使用的路径.
Log writes target support
CONFIG_DM_LOG_WRITES
此种 target 需要两个设备: 主设备按照常规方式使用, 辅设备则专门记录所有主设备的写操作. 主要用于帮助文件系统的开发者验证文件系统的一致性, 仅供开发调试使用.
Generic Target Core Mod (TCM) and ConfigFS Infrastructure
CONFIG_TARGET_CORE
通用 TCM 存储引擎与 ConfigFS 虚拟文件系统 (/sys/kernel/config) 支持. 看不懂就说明你不需要.
Fusion MPT device support
CONFIG_FUSION
Fusion MPT(Message Passing Technology) 是 LSI Logic 公司为了更容易实现 SCSI 和光纤通道而提出的技术, 支持 Ultra320 SCSI / 光纤通道 / SAS.
IEEE 1394 (FireWire) support
火线 ( IEEE 1394) 是苹果公司开发的串行接口, 类似于 USB, 但 PC 上并不常见, 算得上是个没有未来的技术了.
I2O device support
CONFIG_I2O
智能输入输出 ( Intelligent Input/Output) 架构让硬件驱动分成了两部分: OSM(特定于操作系统)+HDM(特定于硬件, 与操作系统无关). 由于 I2O 设备上集成有专用的 I/O 处理器, 从而加快 I/O 速度 (因为避免了 CPU 的参与).I2O 属于已被废弃的技术, 目前能见到的此类设备都属于老古董了.
Macintosh device drivers
CONFIG_MACINTOSH_DRIVERS
苹果的 Macintosh 电脑上的专有设备驱动
Network device support
CONFIG_NETDEVICES
网络设备. 除非你不想连接任何网络, 否则必选 &ldquo;Y&rdquo;.
Network core driver support
CONFIG_NET_CORE
如果你不想使用任何高级网络功能 (拨号网络 / EQL/VLAN/bridging/bonding/team / 光纤通道 / 虚拟网络等), 仅仅是一般性质的联网 (普通低端服务器, 通过路由器或者局域网上网的常规个人电脑或办公电脑), 可以选 &ldquo;N&rdquo;.
Bonding driver support
CONFIG_BONDING
链路聚合技术拥有多个不同的称谓: Linux 称为 &quot; Bonding&quot;,IEEE 称为&quot; 802.3ad&quot;,Sun 称为&quot;Trunking&quot;,Cisco 称为&quot; Etherchannel&quot;. 该技术可以将多个以太网通道聚合为一个单独的虚拟适配器, 例如将两块网卡聚合成一个逻辑网卡, 可以用来实现负载均衡或硬件冗余. 此项技术目前已逐渐被 CONFIG_NET_TEAM 取代.
Dummy net driver support
CONFIG_DUMMY
Dummy 网络接口本质上是一个可以配置 IP 地址的 bit-bucket(位桶, 所有发送到此设备的流量都将被湮灭), 以使应用程序看上去正在和一个常规的网络接口进行通信. 使用 SLIP(小猫拨号, 目前应该已经绝迹了) 或 PPP(常用于 PPPoE ADSL) 的用户需要它
EQL (serial line load balancing) support
CONFIG_EQUALIZER
串行线路的负载均衡. 如果有两个 MODEM 和两条 SLIP/PPP 线路, 该选项可以让你同时使用这两个通道以达到双倍速度 (网络的对端也要支持 EQL 技术). 曾经昙花一现的 ISDN 就这项技术的一个实例.
Fibre Channel driver support
CONFIG_NET_FC
光纤通道 (Fibre Channel) 是一种高速网络串行协议, 主要用于存储局域网 (SAN), 与传统的 iSCSI 技术相比, 除了提供更高的数据传输速度(此优势不是绝对的), 更远的传输距离, 更多的设备连接支持, 更稳定的性能, 更简易的安装以外, 最重要的是支持网络区域存储(SAN) 技术. FC 与 SCSI 兼容, 并意在取代 iSCSI(看起来难以如愿, 并且有可能被 40Gb 以上的 iSCSI 反超). 如果你的机器上有光纤通道卡(FC 卡), 除了需要开启此项外, 还需要开启相应的 FC 卡驱动, 以及 CONFIG_CHR_DEV_SG 选项.
Generic Media Independent Interface device support
CONFIG_MII
媒体独立接口 ( Media Independent Interface) 又称介质无关接口, 是 IEEE-802.3(规定了以太网相关协议的具体内容) 定义的以太网行业标准. 它包括一个数据接口, 以及一个位于 MAC 和 PHY 之间的控制接口.[提示] 大多数以太网卡都有 MII 收发器, 其驱动都依赖于此项, 也会自动选中此项.
Intermediate Functional Block support
CONFIG_IFB
IFB 是一个中间层驱动, 可以用来灵活的配置资源共享. 更多信息参见 iproute2 文档. 看不懂就说明你不需要.
Ethernet team driver support
CONFIG_NET_TEAM
team 驱动. 允许通过 &ldquo;ip link add link [address MAC] [ NAME ] type team&rdquo; 命令, 或者使用将多个以太网卡 (称为 &ldquo;port&rdquo;) 组合在一起, 创建一个虚拟的 &quot; team&quot;网络设备, 从而允许故障转移或者提高吞吐率, 其目的是取代传统的&quot;Bonding&quot;(CONFIG_BONDING) 驱动.&ldquo;ip&quot;是 iproute2 包中的一个命令. 不确定的选&quot;N&rdquo;.
Broadcast mode support
CONFIG_NET_TEAM_MODE_BROADCAST
广播模式: 所有网卡共用同一个 MAC 地址, 每一个包都从所有网卡同时发送, 不做负载均衡, 仅做链路冗余, 需要和交换机的 &ldquo;聚合强制不协商&rdquo; 方式配合使用. 此模式最浪费资源, 但可靠性最高, 容错能力最强. 常用于强调极端可靠的金融业.
Round-robin mode support
CONFIG_NET_TEAM_MODE_ROUNDROBIN
循环均衡模式: 所有网卡共用同一个 MAC 地址, 数据包依次从每个网卡循环分发 (例如, 在三个网卡一组的情况下, 第 0 个包走 eth0, 第 1 个包走 eth1, 第 2 个包走 eth2, 第 3 个包走 eth0, 第 4 个包走 eth1, 第 5 个包走 eth2, 第 6 个包走 eth0,&hellip; 一直循环分发下去, 直到传输完毕), 带宽增加, 支持容错 (故障链路会被自动踢出), 交换机需要配置聚合口 (思科叫 &ldquo;port channel&rdquo;). 数据包从不同的网卡发出, 若中途再经过不同的链路, 在到达客户端时可能会乱序, 从而造成吞吐量达不到理论上的翻倍效果.
Random mode support
CONFIG_NET_TEAM_MODE_RANDOM
随机均衡模式: 所有网卡共用同一个 MAC 地址, 数据包依次随机选择一个网卡分发 (例如, 在三个网卡一组的情况下, 第 0 个包走 eth2, 第 1 个包走 eth0, 第 2 个包走 eth2, 第 3 个包走 eth1, 第 4 个包走 eth1, 第 5 个包走 eth0, 第 6 个包走 eth2,&hellip; 一直随机分发下去, 直到传输完毕), 带宽增加, 支持容错 (故障链路会被自动踢出), 交换机需要配置聚合口 (思科叫 &ldquo;port channel&rdquo;). 数据包从不同的网卡发出, 若中途再经过不同的链路, 在到达客户端时可能会乱序, 从而造成吞吐量达不到理论上的翻倍效果.
Active-backup mode support
CONFIG_NET_TEAM_MODE_ACTIVEBACKUP
主备模式: 无需更改每个网卡的原生 MAC 地址, 但是 team 的 MAC 地址对外仅在主网卡上可见并且保持不变, 同一时刻仅有主网卡处于激活状态, 其他备用网卡都处于等待状态, 所有流量仅通过主网卡发送, 仅在主网卡故障时, 某个备用网卡才会被激活成主网卡. 此模式仅提供容错能力, 可靠性高, 但是资源利用率最低. 此模式最大的好处是不需要在交换机上做特别的设置.
Load-balance mode support
CONFIG_NET_TEAM_MODE_LOADBALANCE
BPF 均衡模式: 均衡算法由用户空间通过 BPF 接口 (bpf_hash_func) 设置.
MAC-VLAN support
CONFIG_MACVLAN
MAC-VLAN 是通过 MAC 地址来划分 VLAN 的方式, 在 Linux 则用来给网卡添加多个 MAC 地址. 你可以使用 &ldquo;ip link add link <real dev> [ address MAC ] [ NAME ] type macvlan&rdquo; 命令创建一个虚拟的 &ldquo;macvlan&rdquo; 设备 (系统会自动打开网卡的 混杂模式), 然后就可以在同一个物理网卡上虚拟出多个以太网口. Docker 依赖于它.
MAC-VLAN based tap driver
CONFIG_MACVTAP
基于 MAC-VLAN 接口的 tap(虚拟以太网设备) 字符设备 ( macvtap) 驱动, 旨在简化虚拟化的桥接网络, 目的是替代 TUN/TAP(CONFIG_TUN) 和 Bridge(CONFIG_BRIDGE) 内核模块. 可以通过与创建 macvlan 设备相同的 &ldquo;ip&rdquo; 命令创建一个虚拟的 &ldquo;macvtap&rdquo; 设备, 并通过 TAP 用户空间接口进行访问.
Virtual eXtensible Local Area Network (VXLAN)
CONFIG_VXLAN
&quot; vxlan&quot; 虚拟接口可以在第三层网络上创建第二层网络 (跨多个物理 IP 子网的虚拟二层子网), 是一种在 UDP 中封装 MAC 的简单机制, 主要用于虚拟化环境下的隧道虚拟网络 (tunnel virtual network).
Network console logging support
CONFIG_NETCONSOLE
网络控制台 (netconsole) 的作用是通过网络记录内核日志信息. 详情参见 &quot; Documentation/networking/netconsole.txt&quot;文档. 不确定的选&quot;N&quot;.
Dynamic reconfiguration of logging targets
CONFIG_NETCONSOLE_DYNAMIC
允许通过 configfs 导出的用户空间接口, 在运行时更改日志目标 (网口, IP 地址, 端口号, MAC 地址).
Netpoll traffic trapping
CONFIG_NETPOLL_TRAP
netpoll 的目的是让内核在网络和 I/O 子系统尚不能完整可用时, 依然能发送和接收数据包. 主要用于网络控制台 (netconsole) 和远程内核调试 (KGDBoE) 中. 不确定的选 &ldquo;N&rdquo;.
Virtual Ethernet over NTB
CONFIG_NTB_NETDEV
PCI-E 非透明桥 (CONFIG_NTB) 上的虚拟网卡. 不确定的选 &ldquo;N&rdquo;.
RapidIO Ethernet over messaging driver support
CONFIG_RIONET
在标准的 RapidIO 通信方式上发送以太网数据包. 不确定的选 &ldquo;N&rdquo;.
Universal TUN/TAP device driver support
CONFIG_TUN
TUN/TAP 可以为用户空间提供包的接收和发送服务, 可以用来虚拟一张网卡或点对点通道 (例如为 QEMU 提供虚拟网卡支持). 当程序打开 &ldquo;/dev/net/tun&rdquo; 设备时, 驱动程序就会注册相应的 &ldquo;tunX&rdquo; 或 &ldquo;tapX&rdquo; 网络设备, 当程序关闭 &ldquo;/dev/net/tun&rdquo; 设备时, 驱动程序又会删除相应的 &ldquo;tunX&rdquo; 或 &ldquo;tapX&rdquo; 网络设备以及所有与之相关联的路由. 详情参见 &quot; Documentation/networking/tuntap.txt&quot; 文档. 看不懂就表明你不需要.
Support for cross-endian vnet headers on little-endian kernels
CONFIG_TUN_VNET_CROSS_LE
允许小端序 (little-endian) 内核中的 TUN/TAP 与 MACVTAP 设备驱动解析来自大端序 (big-endian) 内核的老旧的 virtio 设备的 vnet 头. 不确定的选 &ldquo;N&rdquo;.
Virtual ethernet pair device
CONFIG_VETH
该驱动提供了一个本地以太网隧道 (设备会被成对的创建).Docker 依赖于它.
Virtio network driver
CONFIG_VIRTIO_NET
virtio 虚拟网卡驱动. 仅可用在基于 lguest 或 QEMU 的半虚拟化客户机中 (一般是 KVM 或 XEN).
Virtual netlink monitoring device
CONFIG_NLMON
提供一个可以监视 netlink skbs 的网络设备, 以允许 tcpdump 之类的工具通过 packet socket 来分析 netlink 消息. 仅供调试使用.
ARCnet support
CONFIG_ARCNET
ARCnet 是 1977 年由 Datapoint 公司开发的一种局域网技术, 它采用令牌总线方案来管理 LAN 上工作站和其他设备之间的共享线路, 主要用于工业控制领域中.
ATM drivers
CONFIG_ATM_DRIVERS
可怜的 ATM(异步传输模式), 曾经在 90 年代风靡一时, 现在已经消失的无影无踪了.
{这里省略几个专用于 Android/MeeGo 系统的 PF_CAIF 类型套接字相关的选项} Distributed Switch Architecture drivers
分布式交换架构驱动, 其子项都是 Marvell 系列以太网交换机芯片组的驱动
Ethernet driver support
CONFIG_ETHERNET
最常见的以太网卡驱动
{省略的部分请按照实际的硬件状况进行选择, 这里仅以两个常见公司的以太网芯片为例进行说明} AMD devices
CONFIG_NET_VENDOR_AMD
AMD 出品的以太网控制芯片
AMD PCnet32 PCI support
CONFIG_PCNET32
这是 VMware/VirtualBox 虚拟机中常用的网卡
Broadcom devices
CONFIG_NET_VENDOR_BROADCOM
博通 (Broadcom) 公司的网卡
Broadcom 440x/47xx ethernet support
CONFIG_B44
Broadcom 44xx/47xx 10/100M PCI
Broadcom NetXtremeII support
CONFIG_BNX2
NetXtreme II 1 Gigabit (BCM5706/5708/5709/5716)
Broadcom CNIC support
CONFIG_CNIC
NetXtremeII 系列网卡的 TCP 减负引擎 ( TCP Offload Engine) 特性支持. 不过, TOE 并不适合高连接数 / 小文件的 Web 服务器类应用, 它的主要目的是和 IP 存储协议 (iSCSI/NFS) 一起使用.[注意]TOE 与 &ldquo;Large Receive Offload&rdquo; 是两个不同的东西, 不要混淆.
Broadcom Tigon3 support
CONFIG_TIGON3
这是最流行的驱动, 其涵盖的型号特别多, 但是 &ldquo;Tigon3&rdquo; 的名称却非常具有迷惑性. 简单说来, 除了 B44,BNX2,BNX2X 中明确列出的型号外, 其他型号用的都是这个驱动.[注意] 某些型号还需要额外到固件支持, 例如: BCM5703/BCM5704 需要 tigon/tg3_tso.bin,BCM5701A0 需要 tigon/tg3.bin,BCM5705 需要 tigon/tg3_tso5.bin
Broadcom NetXtremeII 10Gb support
CONFIG_BNX2X
NetXtreme II 10 Gigabit (BCM57710/57711/57711E/57712/57800/57810)
Broadcom 578xx and 57712 SR-IOV support
CONFIG_BNX2X_SRIOV
支持 578xx/57712 的 单根 I/O 虚拟化 ( Single Root IOV) 技术
FDDI driver support
CONFIG_FDDI
光纤分布式数据接口 (FDDI)
HIPPI driver support
CONFIG_HIPPI
高性能并行接口 (HIgh Performance Parallel Interface) 是一个在短距离内高速传送大量数据的点对点协议. 常用于集群和超级计算机.
General Instruments Surfboard 1000
CONFIG_NET_SB1000
SURFboard 1000 插卡式 Cable Medem(ISA 接口), 这玩意早就绝种了
PHY Device support and infrastructure
CONFIG_PHYLIB
数据链路层芯片简称为 MAC 控制器, 物理层芯片简称之为 PHY, 通常的网卡把 MAC 和 PHY 的功能做到了一颗芯片中, 但也有一些仅含 PHY 的 &ldquo;软网卡&rdquo;. 此选项就是对这些 &ldquo;软网卡&rdquo; 的支持. 请根据实际情况选择其下的子项.
Micrel KS8995MA 5-ports 10/100 managed Ethernet switch
CONFIG_MICREL_KS8995MA
Micrel KS8995MA 5 端口 10/100M 以太网交换芯片
PLIP (parallel port) support
CONFIG_PLIP
PLIP(Parallel Line Internet Protocol) 用于将两台电脑通过并口进行联网, 组成一个简单的客户机 / 服务器结构. 详情参见 &quot; Documentation/networking/PLIP.txt&quot;. 现在的电脑都使用网卡进行互联, 并口早就经被丢进历史的垃圾箱了.
PPP (point-to-point protocol) support
CONFIG_PPP
点对点协议 ( Point to Point Protocol) 是 SLIP 的继任者, 使用 PPP 需要用户层程序 pppd 的帮助. PPP 实际上有两个版本: 基于普通模拟电话线的 &ldquo;异步 PPP&rdquo; 和基于数字线路 (例如 ISDN 线路) 的 &ldquo;同步 PPP&rdquo;. 使用电脑直接拨号的 PPPoE ADSL 用户需要此项.
PPP BSD-Compress compression
CONFIG_PPP_BSDCOMP
为 PPP 提供 BSD(等价于 LZW 压缩算法, 没有 gzip 高效) 压缩算法支持, 需要通信双方的支持才有效. 大多数 ISP 都不支持此算法.
PPP Deflate compression
CONFIG_PPP_DEFLATE
为 PPP 提供 Deflate(等价于 gzip 压缩算法) 压缩算法支持, 需要通信双方的支持才有效. 这是比 BSD 更好的算法 (压缩率更高且无专利障碍).
PPP filtering
CONFIG_PPP_FILTER
允许对通过 PPP 接口的包进行过滤. 仅在你需要使用 pppd 的 pass-filter/active-filter 选项时才需要开启. 不确定的选 &ldquo;N&rdquo;.
PPP MPPE compression (encryption)
CONFIG_PPP_MPPE
为 PPP 提供 MPPE 加密协议支持, 它被用于微软的 P2P 隧道协议中. 此特性需要 PPTP Client 工具的支持.
PPP multilink support
CONFIG_PPP_MULTILINK
多重链路协议 (RFC1990) 允许你将多个线路 (物理的或逻辑的) 组合为一个 PPP 连接一充分利用带宽, 这不但需要 pppd 的支持, 还需要 ISP 的支持
PPP over ATM
CONFIG_PPPOATM
在 ATM 上跑的 PPP. 果断 &ldquo;N&rdquo;.
PPP over Ethernet
CONFIG_PPPOE
这就是 ADSL 用户最常见的 PPPoE, 也就是在以太网上跑的 PPP 协议. 这需要 RP-PPPoE 工具的帮助
PPP over IPv4 (PPTP)
CONFIG_PPTP
点对点隧道协议 ( Point-to-Point Tunneling Protocol) 是一种主要用于 VPN 的数据链路层网络协议. 此功能需要 ACCEL-PPTP 工具的支持.
PPP over L2TP
CONFIG_PPPOL2TP
第二层隧道协议 ( L2TP) 是一种通过 UDP 隧道传输 PPP 流量的技术, 对于 VPN 用户来说, L2TP VPN 是比 PPTP VPN 的更好解决方案.
PPP support for async serial ports
CONFIG_PPP_ASYNC
基于普通模拟电话线或标准异步串口 (COM1,COM2) 的 &ldquo;异步 PPP&rdquo; 支持. PPPoE ADSL 使用的就是这个. 不能与下面的 CONFIG_PPP_SYNC_TTY 同时并存.
PPP support for sync tty ports
CONFIG_PPP_SYNC_TTY
基于同步 tty 设备 (比如 SyncLink 适配器) 的 &ldquo;同步 PPP&rdquo; 支持. 常用于高速租用线路(比如 T1/E1). 不确定的选 &ldquo;N&rdquo;.
SLIP (serial line) support
CONFIG_SLIP
一个在串行线上 (例如电话线) 传输 IP 数据报的 TCP/IP 协议. 最原始的通过电话线拨号上网就用这个协议, 如今基本绝迹了. 不确定的选 &ldquo;N&rdquo;.
CSLIP compressed headers
CONFIG_SLIP_COMPRESSED
CSLIP 协议基于 SLIP, 但比 SLIP 快, 它将 TCP/IP 头 (而非数据) 进行压缩传送, 需要通信双方的支持才有效
Keepalive and linefill
CONFIG_SLIP_SMART
让 SLIP 驱动支持 RELCOM linefill 和 keepalive 监视, 这在信号质量比较差的模拟线路上是个好主意
Six bit SLIP encapsulation
CONFIG_SLIP_MODE_SLIP6
这种线路非常罕见, 选 &ldquo;N&rdquo;.
USB Network Adapters
USB 网络适配器
Wireless LAN
CONFIG_WLAN
无线网卡
{省略的部分请按照实际的硬件状况进行选择, 这里仅以 Intel 公司的主流无线网卡为例进行说明} Intel Wireless WiFi Next Gen AGN - Wireless-N/Advanced-N/Ultimate-N (iwlwifi)
CONFIG_IWLWIFI
这是目前主流 Intel 无线网卡的驱动. 此驱动依赖于 二进制 uCode 微代码, 它通常被安装到 &ldquo;/lib/firmware&rdquo; 目录, 不过你最好亲自用眼睛检查一下其中是否存在 &ldquo;iwlwifi-<em>.ucode&rdquo; 这样的文件.
Intel Wireless WiFi DVM Firmware support
CONFIG_IWLDVM
DVM 固件支持 (这也是当前唯一可用的固件). 选 &ldquo;Y/M&rdquo;.[提示] 如果你将此驱动静态编译进内核, 那么务必使用 CONFIG_EXTRA_FIRMWARE 功能将固件也一起编译进内核.
Intel Wireless WiFi MVM Firmware support
CONFIG_IWLMVM
MVM 固件支持 (这是专用于 7000 系列无线网卡的固件).
Debugging Options
仅供调试使用, 其下所有选项都选 &ldquo;N&rdquo;.
iwlwifi experimental P2P support
CONFIG_IWLWIFI_P2P
iwlwifi 驱动实验性的 P2P 支持. 不确定的选 &ldquo;N&rdquo;.
WiMAX Wireless Broadband devices
WiMAX 无线设备
Wan interfaces support
CONFIG_WAN
广域网 (Wide Area Network) 网卡支持. 这种网卡很罕见. 不确定的选 &ldquo;N&rdquo;.
IEEE 802.15.4 drivers
CONFIG_IEEE802154_DRIVERS
IEEE 802.15.4 描述了低速率无线个人局域网的物理层和媒体接入控制协议
Xen network device frontend driver
CONFIG_XEN_NETDEV_FRONTEND
XEN 半虚拟化网络设备前端驱动 (通常是被 &ldquo;domain 0&rdquo; 导出的)
Xen backend network device
CONFIG_XEN_NETDEV_BACKEND
XEN 半虚拟化网络设备后端驱动, 通常被用在 &ldquo;domain 0&rdquo; 内核上, 用于向其他 domain 导出半虚拟化网络设备.
VMware VMXNET3 ethernet driver
CONFIG_VMXNET3
VMware vmxnet3 虚拟以太网卡驱动
FUJITSU Extended Socket Network Device driver
CONFIG_FUJITSU_ES
FUJITSU PRIMEQUEST 2000 E2 系列网卡
Microsoft Hyper-V virtual network driver
CONFIG_HYPERV_NET
Microsoft  Hyper-V 虚拟以太网卡驱动
ISDN support
CONFIG_ISDN
上世纪在 ADSL 流行之前曾经有过短暂流行, 但现在已经绝迹了
Open-Channel SSD target support
CONFIG_NVM
Open-channel SSD 是一种遵守 NVMe 规范且不使用 FTL 技术的固态硬盘. 目前此种 SSD 由于过于前卫还非常罕见. 但是非常有前途.
Open-Channel SSD debugging support
CONFIG_NVM_DEBUG
提供 /sys/module/lnvm/parameters/configure_debug 调试接口以允许创建 / 删除 &ldquo;target&rdquo;. 仅供调试使用.
Generic NVM manager for Open-Channel SSDs
CONFIG_NVM_GENNVM
为 Open-Channel SSD 提供 NVM 介质管理 (media manager) 支持, 也就是将数据存放位置与垃圾回收策略的决定权收归操作系统内核, 以剥夺固态硬盘设备自身的介质管理功能, 或者说允许使用自身不包含介质管理功能的固态硬盘.
Round-robin Hybrid Open-Channel SSD target
CONFIG_NVM_RRPC
允许将 open-channel SSD 在主机上显示为一个块设备: 使用线性映射表实现, 使用基于开销 (cost-based) 的垃圾回收机制, 并对 4K 大小的 IO 操作进行了优化.
Input device support
输入设备
Generic input layer (needed for keyboard, mouse, &hellip;)
CONFIG_INPUT
通用输入层. 只要你有任何输入设备 (键盘, 鼠标, 手写板, 触摸板, 游戏杆, 方向盘, 游戏键盘&hellip;), 就必须选 &ldquo;Y&rdquo;.
Export input device LEDs in sysfs
CONFIG_INPUT_LEDS
将输入设备上的 LED 指示灯当作标准的 LED 类设备导出到 sysfs 中. 不确定的选 &ldquo;Y&rdquo;.
Support for memoryless force-feedback devices
CONFIG_INPUT_FF_MEMLESS
游戏玩家使用的 力反馈设备, 例如:  Logitech WingMan Force 3D 飞行摇杆,  ThrustMaster FireStorm Dual Power 2. 如果你有此类设备, 除了本项之外, 还需要开启特定于硬件的驱动.
Polled input device skeleton
CONFIG_INPUT_POLLDEV
使用轮询机制的输入设备支持, 此项主要是为源码树之外的驱动准备的, 内核自带的驱动若有需要会自动选中. 不确定的选 &ldquo;N&rdquo;.
Sparse keymap support library
CONFIG_INPUT_SPARSEKMAP
使用 &ldquo;sparse keymap&rdquo; 的输入设备支持, 此项主要是为源码树之外的驱动准备的, 内核自带的驱动若有需要会自动选中. 不确定的选 &ldquo;N&rdquo;.
Matrix keymap support library
CONFIG_INPUT_MATRIXKMAP
使用 &ldquo;matrix keymap&rdquo; 的输入设备支持, 此项主要是为源码树之外的驱动准备的, 内核自带的驱动若有需要会自动选中. 不确定的选 &ldquo;N&rdquo;.
Mouse interface
CONFIG_INPUT_MOUSEDEV
鼠标接口 (/dev/input/mouseX,/dev/input/mice). 用鼠标的必选(包括 USB 鼠标).[提示] 如果系统上有多个鼠标, 那么, mouseX 对应单个特定的鼠标, 而 mice 则是所有鼠标的集合(所有鼠标的事件都会被发送到这个设备文件中).
Provide legacy /dev/psaux device
CONFIG_INPUT_MOUSEDEV_PSAUX
仍然支持传统的 / dev/psaux 接口, 这是为兼容老旧的程序而设置. 选 &ldquo;N&rdquo;.
Horizontal screen resolution
CONFIG_INPUT_MOUSEDEV_SCREEN_X
作为鼠标使用的数字化转换器 (digitizer) 或 手写板 (graphic tablet) 需要知道 X window 的水平分辩率. 一般可理解为显示屏的水平分辨率.
Vertical screen resolution
CONFIG_INPUT_MOUSEDEV_SCREEN_Y
作为鼠标使用的数字化转换器 (digitizer) 或 手写板 (graphic tablet) 需要知道 X window 的垂直分辩率. 一般可理解为显示屏的垂直分辨率.
Joystick interface
CONFIG_INPUT_JOYDEV
游戏杆 ( joystick) 和游戏键盘 ( gamepad) 支持 (/dev/input/jsX)
Event interface
CONFIG_INPUT_EVDEV
将所有的输入设备事件都通过 &ldquo;/dev/input/eventX&rdquo; 以一种通用的方式进行处理. Xorg 需要使用此接口. 不确定的选 &ldquo;Y&rdquo;.
Event debugging
CONFIG_INPUT_EVBUG
将所有输入设备的动作 (键盘按下, 鼠标移动等) 都记录到系统日志当中. 主要用于调试, 同时也会带来安全漏洞(键盘输入中很可能包含你的密码). 选 &ldquo;N&rdquo;.
Keyboards
CONFIG_INPUT_KEYBOARD
键盘驱动
AT keyboard
CONFIG_KEYBOARD_ATKBD
标准 AT 键盘或者 PS/2 键盘.[提示]除了台式机 PS/2 接口上的键盘外, 许多笔记本的键盘其实也是 PS/2 键盘. 使用 USB 键盘或者 ADB 键盘 (旧式苹果键盘) 的可以选 &ldquo;N&rdquo;.
{此处被省略的键盘都很罕见, 基本上不必考虑}
Mice
CONFIG_INPUT_MOUSE
鼠标驱动
PS/2 mouse
CONFIG_MOUSE_PS2
标准的两键或三键的 PS/2 鼠标, 同时兼容 Microsoft/Logitech/Genius 生产的带有滚轮或者额外按键的 PS/2 鼠标. 使用 Synaptics/ALPS/Elantech 触摸板的用户还可以看看其 专用的 X 驱动, 这些驱动可以提供更多的高级功能. 使用 USB 鼠标的可以选 &ldquo;N&rdquo;. 其下的子项是针对各厂商特定产品的扩展协议支持. 按需选择即可.[提示] 除了台式机 PS/2 接口上的鼠标外, 许多笔记本的触摸板其实也是 PS/2 鼠标.
{此处被省略的鼠标都很罕见, 基本上不必考虑}
Joysticks/Gamepads
游戏杆, 6 自由度摇杆, 游戏键盘, 方向盘, 射击武器&hellip; 等各种游戏装置
Tablets
CONFIG_INPUT_TABLET
平板输入设备
Touchscreens
CONFIG_INPUT_TOUCHSCREEN
触摸屏输入设备
Miscellaneous devices
CONFIG_INPUT_MISC
其他杂项输入设备
PC Speaker support
CONFIG_INPUT_PCSPKR
标准 蜂鸣器. 建议开启.
{此处被省略的其他设备都很罕见, 基本上不必考虑}
Hardware I/O ports
硬件 I/O 端口
Serial I/O support
CONFIG_SERIO
串行 I/O 硬件支持. 标准 AT 键盘, PS/2 鼠标, 串口鼠标, Sun 键盘, 游戏杆, 6 自由度摇杆等设备都依赖于它. 不确定的选 &ldquo;Y&rdquo;.
i8042 PC Keyboard controller
CONFIG_SERIO_I8042
标准 AT 键盘, PS/2 鼠标, 这两种设备需要它的支持.
Serial port line discipline
CONFIG_SERIO_SERPORT
RS232 串口 (COM). 串口鼠标, 游戏杆, 6 自由度摇杆等设备都依赖于它.
ct82c710 Aux port controller
CONFIG_SERIO_CT82C710
一种德州仪器 TravelMate 笔记本上使用 QuickPort 接口的鼠标
Parallel port keyboard adapter
CONFIG_SERIO_PARKBD
并口键盘适配器, 用于将 AT/XT 键盘或 PS/2 鼠标转接到并口上. 非常罕见.
PCI PS/2 keyboard and PS/2 mouse controller
CONFIG_SERIO_PCIPS2
接在移动式扩展坞 (Docking station) 上的 PS/2 键盘或鼠标
PS/2 driver library
CONFIG_SERIO_LIBPS2
为 PS/2 接口上的设备提供驱动 (比如 PS/2 鼠标和标准 AT 键盘)
Raw access to serio ports
CONFIG_SERIO_RAW
以 raw 方式访问 serio 接口 (echo -n &ldquo;serio_raw&rdquo;&gt; /sys/bus/serio/devices/serioX/drvctl), 例如 i8042 键盘控制器的 AUX 端口. 看不懂的就别选了.
Altera UP PS/2 controller
CONFIG_SERIO_ALTERA_PS2
Altera University Program PS/2 端口支持. 不确定的选 &ldquo;N&rdquo;.
TQC PS/2 multiplexer
CONFIG_SERIO_PS2MULT
TQC 板上的 PS/2 端口复用器 (multiplexer)
ARC PS/2 support
CONFIG_SERIO_ARC_PS2
ARC FPGA 平台上的 PS/2 控制器
Gameport support
CONFIG_GAMEPORT
15 针电脑游戏接口 ( Gameport). 图
Character devices
字符设备
Enable TTY
CONFIG_TTY
字符终端和串口都需要 TTY 的支持. 选 &ldquo;Y&rdquo;, 除非你知道自己在干什么.[提示] 你想 在控制台上显示汉字吗? 试试 CJKTTY 补丁吧!
Virtual terminal
CONFIG_VT
虚拟终端可以在一个物理终端设备上虚拟出多个 &ldquo;显示器 + 键盘&rdquo; 的组合 (可以使用 &ldquo;Alt+Fn&rdquo; 组合键在多个虚拟终端间切换). 除非是嵌入式系统, 否则必选 &ldquo;Y&rdquo;.
Enable character translations in console
CONFIG_CONSOLE_TRANSLATIONS
在虚拟控制台 (console) 上支持字体映射和 Unicode 转换. 建议选 &ldquo;Y&rdquo;, 否则将无法在控制台上显示 Unicode 字符.[提示]如果已经使用了 CJKTTY 补丁, 则必选 &ldquo;Y&rdquo;.
Support for console on virtual terminal
CONFIG_VT_CONSOLE
内核默认将第一个虚拟终端 (/dev/tty0) 用作系统控制台(可以通过 &ldquo;console=tty3&rdquo; 这样的参数去修改), 将诸如模块错误 / 内核错误 / 启动信息之类的警告信息发送到这里, 而且以单用户模式登录时也需要使用这个控制台. 若选 &ldquo;N&rdquo; 则会导致黑屏. 除非是嵌入式系统, 否则必选 &ldquo;Y&rdquo;.
Support for binding and unbinding console drivers
CONFIG_VT_HW_CONSOLE_BINDING
虚拟终端是通过控制台驱动程序与物理终端交互的, 但在某些系统上可以使用多个控制台驱动程序 (如 framebuffer 控制台驱动程序), 该选项使得你可以选择其中之一. 如果你需要使用多个控制台驱动, 可以选 &ldquo;Y&rdquo;, 不确定的选 &ldquo;N&rdquo;. 参见 &quot; Documentation/console/console.txt&quot;和&quot; Documentation/fb/fbcon.txt&quot; 获取更多细节.
Unix98 PTY support
CONFIG_UNIX98_PTYS
伪终端 (PTY) 是指一个 &ldquo;软件终端&rdquo;, 它是由 slave(等价于一个物理终端)和 master(被一个诸如 xterm 之类的进程用来读写 slave 设备)两部分组成的软设备. 图形界面用户与需要支持 ssh/telnet 远程登录者必选.
Support multiple instances of devpts
CONFIG_DEVPTS_MULTIPLE_INSTANCES
允许多个 &ldquo;devpts&rdquo; 文件系统实例 (使用 &ldquo;-o newinstance&rdquo; 挂载选项), 以允许相互隔离的 PTY 命名空间 (比如在虚拟化容器中).Docker 依赖于它. systemd 的 PrivateNetwork/PrivateDevices 特性依赖于它.
Legacy (BSD) PTY support
CONFIG_LEGACY_PTYS
使用过时的 BSD 风格的 / dev/ptyxx 作为 master,/dev/ttyxx 作为 slave, 这个方案有一些安全问题, 选 &ldquo;N&rdquo;.
Non-standard serial port support
CONFIG_SERIAL_NONSTANDARD
非标准串口支持. 这样的设备非常罕见, 选 &ldquo;N&rdquo;.
HSDPA Broadband Wireless Data Card - Globe Trotter
CONFIG_NOZOMI
一种 PCMCIA 接口的 HSDPA(WCDMA) 3G 无线上网卡
Multi-Tech multiport card support
CONFIG_ISI
Multi-Tech 公司生产的多端口卡 (拥有多个串口) 实验性支持. 不确定的选 &ldquo;N&rdquo;.
HDLC line discipline support
CONFIG_N_HDLC
Microgate SyncLink. 不确定的选 &ldquo;N&rdquo;.
GSM MUX line discipline support
CONFIG_N_GSM
GSM MUX(多路复用器) 支持. 不确定的选 &ldquo;N&rdquo;.
Trace data router for MIPI P1149.7 cJTAG standard
CONFIG_TRACE_ROUTER
仅用于调试内含 modem 设备的手机系统.
Trace data sink for MIPI P1149.7 cJTAG standard
CONFIG_TRACE_SINK
仅用于调试内含 modem 设备的手机系统.
KCopy
内核 Copy
Memory-to-memory copies using kernel assist
CONFIG_KCOPY
高性能的进程间内存复制 (可以减少一次向共享内存的复制动作). 主要用于高性能并行计算领域, 比如基于 消息传递接口 ( Message Passing Interface) 协议的开发的并行程序. 不确定的选 &ldquo;N&rdquo;.
/dev/mem virtual device support
CONFIG_DEVMEM
&quot; /dev/mem&quot; 虚拟设备是整个处理器地址空间的全映射 (包括所有物理内存 / 设备 IO 空间 / 总线映射空间), 可以用来直接存取物理内存, 常用于访问物理 IO 设备, 例如 dmidecode 工具可以从中提取系统识别信息 (序列号, 制造商, 型号, 等等), 或者 Xorg 可以用来访问显卡的物理内存或者 实现用户空间驱动, 同时拥有 root 权限的攻击者也可以使用它完成很多标准 rootkit 的行为. 如果你需要使用用户空间的驱动或不确定, 那么选 &ldquo;Y&rdquo;. 如果你觉得安全特别重要, 可以选 &ldquo;N&rdquo;.
/dev/kmem virtual device support
CONFIG_DEVKMEM
&ldquo;/dev/kmem&rdquo; 虚拟设备是内核看到的虚拟内存的全镜像, 可以用来访问内核内存. 一般可以用来查看内核变量或者用作 rootkit 之类 (! 危险!). 仅供调试, 不确定的选 &ldquo;N&rdquo;.
Serial drivers
串口 (COM) 驱动. 串口在台式机主板上正在逐渐消亡, 而在笔记本和服务器上早就已经绝迹了. 大多数人应该将所有子项都选 &ldquo;N&rdquo;.
8250/16550 and compatible serial support
CONFIG_SERIAL_8250
这是标准 串口 (COM) 驱动. 只要你想使用串口, 就必选此项. 不过, 大多数人应该选 &ldquo;N&rdquo;.
Support 8250_core.</em> kernel options
CONFIG_SERIAL_8250_DEPRECATED_OPTIONS
选 &ldquo;N&rdquo;.
8250/16550 PNP device support
CONFIG_SERIAL_8250_PNP
即插即用串口支持, 不确定的选 &ldquo;Y&rdquo;.
Console on 8250/16550 and compatible serial port
CONFIG_SERIAL_8250_CONSOLE
将串口当做系统控制台 (接受所有内核消息, 单用户模式登录) 使用(需要使用 &ldquo;console=ttyS1&rdquo; 参数). 仅在没有显示接口嵌入式设备上有用. 不确定的选 &ldquo;N&rdquo;.
DMA support for 16550 compatible UART controllers
CONFIG_SERIAL_8250_DMA
与标准 8250/16650 兼容的 通用异步收发传输器 ( Universal Asynchronous Receiver/Transmitter) 的 DMA 支持. 在嵌入式设计中, UART 用来主机与辅助设备通信, 如汽车音响与外接 AP 之间的通信, 与 PC 机通信包括与监控调试器和其它器件 (如 EEPROM) 通信. 不确定的选 &ldquo;Y&rdquo;.
8250/16550 PCI device support
CONFIG_SERIAL_8250_PCI
PCI 串口支持. 选 &ldquo;N&rdquo; 表示仅支持传统的标准串口.
8250/16550 PCMCIA device support
CONFIG_SERIAL_8250_CS
16-bit PCMCIA 串口支持. 选 &ldquo;N&rdquo; 表示仅支持传统的标准串口.
Maximum number of 8250/16550 serial ports
CONFIG_SERIAL_8250_NR_UARTS
允许的最大串口数量, 保持默认值即可.
Number of 8250/16550 serial ports to register at runtime
CONFIG_SERIAL_8250_RUNTIME_UARTS
内核在启动时注册的串口数量 (可以通过 &ldquo;8250.nr_uarts&rdquo; 参数修改), 保持默认即可.
Extended 8250/16550 serial driver options
CONFIG_SERIAL_8250_EXTENDED
非标准的串口驱动选项 (例如 HUB6, 中断共享, 多端口, 超过 4 个 COM 口). 不确定的选 &ldquo;N&rdquo;.
Support more than 4 legacy serial ports
CONFIG_SERIAL_8250_MANY_PORTS
如果你的板子上有超过 4 个 COM 接口就选 &ldquo;Y&rdquo;.
Support for sharing serial interrupts
CONFIG_SERIAL_8250_SHARE_IRQ
有些板子上集成了共享 IRQ 的硬件支持. 如果有就选 &ldquo;Y&rdquo;.
Autodetect IRQ on standard ports (unsafe)
CONFIG_SERIAL_8250_DETECT_IRQ
让内核去猜串口的 IRQ 号. 不安全, 选 &ldquo;N&rdquo;.
Support RSA serial ports
CONFIG_SERIAL_8250_RSA
RSA(Remote Supervisor Adapter) 串口, 是一种 IBM 特定的硬件. 看不懂的选 &ldquo;N&rdquo;.
Support for Synopsys DesignWare 8250 quirks
CONFIG_SERIAL_8250_DW
Synopsys DesignWare APB UART 中非标准特性的支持.
Medfield High Speed UART support
CONFIG_SERIAL_MFD_HSU
Medfield 是 Intel 以 x86 为架构开发的 SoC 手机芯片.
{此处被省略的都是非标准的串口设备, 按实际情况选择即可}
TTY driver to output user messages via printk
CONFIG_TTY_PRINTK
通过 &ldquo;/dev/ttyprintk&rdquo; 设备使用 printk 发送用户消息. 用于在内核中嵌入用户消息. 不确定的选 &ldquo;N&rdquo;.
Parallel printer support
CONFIG_PRINTER
并口打印机
Support for user-space parallel port device drivers
CONFIG_PPDEV
用户空间的原始并口设备 (/dev/parportN) 支持, 这样用户空间的程序就可以用原始模式直接访问并口(相当于并口版本的 CONFIG_CHR_DEV_SG). 并口打印机 / CD-ROM / 硬盘都不依赖于此项, 所以大部分人可以关闭该选项.
Xen Hypervisor Console support
CONFIG_HVC_XEN
XEN 虚拟控制台设备驱动
Xen Hypervisor Multiple Consoles support
CONFIG_HVC_XEN_FRONTEND
如果你需要多个虚拟控制台, 可以选 &ldquo;Y&rdquo;.
Virtio console
CONFIG_VIRTIO_CONSOLE
Virtio 虚拟控制台设备驱动. 此外, 该驱动还可以作为普通的串口设备 (/dev/vportNpX), 用于客户机和宿主机之间的通信. 仅可用在基于 lguest 或 QEMU 的半虚拟化客户机中 (一般是 KVM 或 XEN).
IPMI top-level message handler
CONFIG_IPMI_HANDLER
智能平台管理接口 ( Intelligent Platform Management Interface)是标准的传感器 (温度, 电压, 风扇, 电源, 机箱入侵) 管理规范. IPMI 的核心是专用的基板管理控制器 (BMC) 硬件, BMC 并不依赖于服务器的 CPU/BIOS/OS, 是一个独立运行的管理子系统, 只要有 BMC 与 IPMI 固件便可工作. BMC 通常是一个安装在服务器主板上的独立的板卡(也有少数服务器主板内置).IPMI 良好的独立特性便克服了以往基于操作系统的管理方式所受的限制, 例如操作系统不响应或未加载的情况下, 仍然可以进行开关机等操作. 更多详情参见 &quot; Documentation/IPMI.txt&quot; 文档. 此项技术主要用于服务器领域, 个人 PC 和笔记本上是没有的.
Generate a panic event to all BMCs on a panic
CONFIG_IPMI_PANIC_EVENT
当内核 panic(发生紧急情况)时, IPMI 消息处理器将会向每一个已注册的底板管理控制器 (BMC) 接口生成一个描述该 panic 的 IPMI 事件, 这些事件可以引发日志记录 / 报警 / 重启 / 关机等动作.
Generate OEM events containing the panic string
CONFIG_IPMI_PANIC_STRING
当发生紧急情况 (panic) 时, IPMI 消息处理器将会产生 OEM 类型 (f0) 的事件
Device interface for IPMI
CONFIG_IPMI_DEVICE_INTERFACE
为 IPMI 消息处理器提供一个 IOCTL 接口以便用户空间进程也可以使用 IPMI, 目前支持 poll() 和 select()
IPMI System Interface handler
CONFIG_IPMI_SI
向系统提供接口 (KCS,SMIC), 建议选 &ldquo;Y&rdquo;.
Probe for all possible IPMI system interfaces by default
CONFIG_IPMI_SI_PROBE_DEFAULTS
较新的硬件通常使用 ACPI 或 DMI 机制导出 IPMI 接口, 但是老旧的硬件并不这么做, 所以驱动程序必须直接探测硬件, 这会导致启动延迟. 选 &ldquo;N&rdquo; 表示禁止直接探测. 选 &ldquo;Y&rdquo; 表示强制直接探测 (相当于使用 &ldquo;ipmi_si_intf.trydefaults=1&rdquo; 内核引导选项).
IPMI SMBus handler (SSIF)
CONFIG_IPMI_SSIF
使用 I2C 总线上的 SMBus 接口访问 BMC(而不是标准接口). 建议选 &ldquo;N&rdquo;.
IPMI Watchdog Timer
CONFIG_IPMI_WATCHDOG
启用 IPMI Watchdog 定时器. 如果硬件有这种功能, 推荐选 &ldquo;Y&rdquo;.
IPMI Poweroff
CONFIG_IPMI_POWEROFF
允许通过 IPMI 消息处理器关闭机器
Hardware Random Number Generator Core support
CONFIG_HW_RANDOM
硬件随机数发生器设备 (/dev/hw_random) 支持. 此设备并不会直接向内核的随机数发生器填充(这是 &quot; rngd&quot;守护进程的职责). 详情参见&quot; Documentation/hw_random.txt&quot; 文档.
Timer IOMEM HW Random Number Generator support
CONFIG_HW_RANDOM_TIMERIOMEM
Technologic Systems 的 TS-7800 单板计算机, 这是一个嵌入式设备.
Intel HW Random Number Generator support
CONFIG_HW_RANDOM_INTEL
Intel 基于 i8xx 芯片组 (这是 2005 年以前的老产品了) 的硬件随机数发生器
AMD HW Random Number Generator support
CONFIG_HW_RANDOM_AMD
AMD 基于 76x 芯片组的硬件随机数发生器
Atmel Random Number Generator support
CONFIG_HW_RANDOM_ATMEL
Atmel AT91 硬件随机数发生器
VIA HW Random Number Generator support
CONFIG_HW_RANDOM_VIA
VIA 芯片组的硬件随机数发生器
VirtIO Random Number Generator support
CONFIG_HW_RANDOM_VIRTIO
Virtio 虚拟的硬件随机数发生器. 仅可用在基于 lguest 或 QEMU 的半虚拟化客户机中 (一般是 KVM 或 XEN).
EXYNOS HW random number generator support
CONFIG_HW_RANDOM_EXYNOS
基于 EXYNOS 的 SOC 嵌入式系统上的硬件随机数发生器
TPM HW Random Number Generator support
CONFIG_HW_RANDOM_TPM
可信赖平台模块 ( Trusted Platform Module) 提供的硬件随机数发生器
/dev/nvram support
CONFIG_NVRAM
直接存取主板上 &ldquo;CMOS RAM&rdquo; 的接口, 太危险! 建议选 &ldquo;N&rdquo;.
Siemens R3964 line discipline
CONFIG_R3964
与使用西门子 R3964 协议的设备同步通信, 除非你有一些诸如 PLC 之类的特殊设备, 否则别选
Applicom intelligent fieldbus card support
CONFIG_APPLICOM
Applicom international 公司生产的用于现场总线 (fieldbus) 的连接卡. 不确定的选 &ldquo;N&rdquo;.
PCMCIA character devices
PCMCIA 接口的字符设备
ACP Modem (Mwave) support
CONFIG_MWAVE
IBM Thinkpad 上的一种软猫, 古董产品
RAW driver (/dev/raw/rawN)
CONFIG_RAW_DRIVER
裸设备的含义是将一个原始块设备 (可以是一整块磁盘, 也可以是一个分区) 当做一个线性的字节流来访问. 它是一种没有经过格式化, 不经过操作系统缓存, 也不能通过文件系统来访问的特殊字符设备. 与 FreeBSD 不同, Linux 反对使用裸设备, 且被列入了废除计划(建议的做法是使用 &ldquo;O_DIRECT&rdquo; 标志打开对应的块设备文件, 例如 &ldquo;/dev/hda1&rdquo;). 不确定的选 &ldquo;N&rdquo;.
HPET - High Precision Event Timer
CONFIG_HPET
高精度事件定时器 ( HPET Timer), 又被称为 &ldquo;Multimedia Timer&rdquo;, 是一种取代传统 &ldquo;ACPI Timer&rdquo;(CONFIG_X86_PM_TIMER) 的硬件时钟发生器, 提供 14.31818MHz 固定频率. 2007 年以后的芯片组一般都支持 (有的主板还需要在 BIOS 里面明确开启 HPET 支持), 建议开启.
Allow mmap of HPET
CONFIG_HPET_MMAP
允许对 HPET 寄存器进行映射以提高访问速度. 但是某些包含 HPET 硬件寄存器的页中同时还含有其他不该暴露给用户的信息, 在此种情况下, 需要选 &ldquo;N&rdquo;.
Enable HPET MMAP access by default
CONFIG_HPET_MMAP_DEFAULT
默认开启 HPET 寄存器映射
Hangcheck timer
CONFIG_HANGCHECK_TIMER
宕机检测定时器周期性地检查系统任务调度程序以确定系统的运行状况, 如果超过阈值, 计算机将重新启动. 不确定的选 &ldquo;N&rdquo;.
TPM Hardware Support
CONFIG_TCG_TPM
基于硬件的 可信赖平台模块 ( Trusted Platform Module), 它实际上是一个含有密码运算部件和存储部件的小芯片上的系统, 由 CPU, 存储器, I/O, 密码运算器, 随机数产生器和嵌入式操作系统等部件组成. 使用此功能需要 TrouSerS 工具的帮助.
TPM Interface Specification 1.2 Interface
CONFIG_TCG_TIS
TCG TIS 1.2 TPM 规范支持
TPM Interface Specification 1.2 Interface (I2C - Infineon)
CONFIG_TCG_TIS_I2C_INFINEON
仅需要对 Infineon 的 TPM 设备选 &ldquo;Y&rdquo;.
National Semiconductor TPM Interface
CONFIG_TCG_NSC
仅需要对 National 的 TPM 设备选 &ldquo;Y&rdquo;.
Atmel TPM Interface
CONFIG_TCG_ATMEL
仅需要对 Atmel 的 TPM 设备选 &ldquo;Y&rdquo;.
Infineon Technologies TPM Interface
CONFIG_TCG_INFINEON
仅需要对 Infineon 的 TPM 设备 (SLD 9630 TT 1.1 或 SLB 9635 TT 1.2) 选 &ldquo;Y&rdquo;. 此驱动支持的 硬件列表.
STMicroelectronics ST33 I2C TPM
CONFIG_TCG_ST33_I2C
意法半导体 (STMicroelectronics) 出品的 I2C 总线的 TPM 安全芯片.
Telecom clock driver for ATCA SBC
CONFIG_TELCLOCK
没见过这种硬件, 选 &ldquo;N&rdquo;.
Xillybus generic FPGA interface
CONFIG_XILLYBUS
Xillybus 是一个通用的 FPGA 接口, 仅用于嵌入式设备.
I2C support
CONFIG_I2C
I2C 与 SMBus 支持. I2C(读着 &ldquo;I-squared-C&rdquo;) 是用于 单片机 (又称 &ldquo;微控制器&rdquo;) 的低速串行总线协议, 它为 微控制器 (Microcontroller) 与各种不同的低速设备通信提供了一种廉价的总线 (因为只需要使用两个引脚, 称为 &ldquo;2 线&rdquo;), 因此广泛的应用于嵌入式环境. SMBus(System Management Bus)差不多相当于是 I2C 的子集, 最初的目的是为了管理智能电池, 现在常用于硬件监控 (电压 / 风扇转速 / 温度 / 电池等) 以及内存模块的配置(使用 I2C EEPROM), 因此所有 PC 主板都依赖于 SMBus 协议. 系统硬件监控工具 lm_sensors 和 i2c-tools 依赖于此模块, 硬件传感器和 &ldquo;Video For Linux&rdquo; 也需要该模块的支持. 详情参见 &quot; Documentation/i2c/summary&quot;文档及整个&quot;i2c&quot;文件夹. 不确定的选&quot;Y&quot;.
ACPI I2C Operation region support
CONFIG_ACPI_I2C_OPREGION
3.17 版内核新增功能, 允许 BIOS 中的代码通过 I2C 主机控制器驱动访问 I2C slave 设备 (例如智能电池).
Enable compatibility bits for old user-space
CONFIG_I2C_COMPAT
为了与 lm-sensors 3.1.2 之前的版本兼容而设置. 某些 2011 年之前版本的 i2c 相关程序也需要此兼容性.
I2C device interface
CONFIG_I2C_CHARDEV
I2C 设备通常都是由内核控制的, 但此选项可以向用户空间提供 I2C 设备接口, 以允许用户空间的程序通过 / dev/i2c-* 字符设备文件使用 I2C 总线.&quot; sensors-detect&quot;工具依赖于此功能. 详情参见&quot; Documentation/i2c/dev-interface&quot;文档. 建议选&quot;M&quot;.
I2C bus multiplexing support
CONFIG_I2C_MUX
多路复用 I2C 总线支持. 不确定的选 &ldquo;N&rdquo;.
Multiplexer I2C Chip support
I2C 多路复用芯片, 其下的子项按实际情况选择就 OK 了
Autoselect pertinent helper modules
CONFIG_I2C_HELPER_AUTO
有一些 I2C 驱动程序需要 &ldquo;I2C algorithm&rdquo; 的帮助才能工作. 而 &ldquo;I2C 算法&rdquo; 本质上是 I2C 接口的纯软件抽象. 开启此项后, 如有需要, 则会自动选上这些算法, 而无需你再手动选择. 推荐选 &ldquo;Y&rdquo;. 仅在你想使用额外的算法时, 才选 &ldquo;N&rdquo;.
SMBus-specific protocols
CONFIG_I2C_SMBUS
SMBus 特有的扩展支持. 目前唯一实际支持的扩展是 SMBus 报警协议. 建议选 &ldquo;Y&rdquo;.
I2C Algorithms
I2C 算法, 子项可以全不选, 若有其他部分依赖其子项时, 会自动选上
I2C Hardware Bus support
I2C 硬件支持
*** PC SMBus host controller drivers ***
这部分按照主板芯片组的实际情况选择就 OK 了.[提示] 可用 &quot; sensors-detect&quot; 工具帮助检测
SMBus Control Method Interface
CONFIG_I2C_SCMI
SMBus 控制方法接口 (Control Method Interface) 是 SMBus 的 ACPI 接口. 用于在 ACPI 环境中使用 SMBus 设备. 不确定的选 &ldquo;M&rdquo;(i2c-scmi).
{其余被省略的都是用于嵌入式系统或者额外的 I2C/SMBus 扩展卡, 按实际情况选择即可}
I2C/SMBus Test Stub
CONFIG_I2C_STUB
用于帮助开发 SMBus client 驱动 (特别是某些传感器芯片). 详情参见 &quot; Documentation/i2c/i2c-stub&quot;文档. 不确定的选&quot;N&quot;.
I2C slave support
CONFIG_I2C_SLAVE
I2C slave 模式支持. 不确定的选 &ldquo;N&rdquo;.
I2C Core debugging messages
CONFIG_I2C_DEBUG_CORE
向系统日志中传递大量的 I2C Core 调试信息. 仅用于调试 I2C 设备故障
I2C Algorithm debugging messages
CONFIG_I2C_DEBUG_ALGO
向系统日志中传递大量的 I2C Algorithm 调试信息. 仅用于调试 I2C 设备故障
I2C Bus debugging messages
CONFIG_I2C_DEBUG_BUS
向系统日志中传递大量的 I2C Bus 调试信息. 仅用于调试 I2C 设备故障
SPI support
CONFIG_SPI
串行外设接口 (Serial Peripheral Interface) 是一种标准的四线同步双向串行总线. SPI 类似于 I2C, 但比 I2C 的 &ldquo;2 线&rdquo; 稍微复杂一些, SPI 需要 4 个引脚 (&ldquo;4 线&rdquo;), 不但传输速率比 I2C 更高, 还能实现全双工通信. 大多数 SPI 设备不支持动态设备检测, 有些甚至是只读或者只写的. SPI 常用于微控制器(Microcontroller) 与外围设备 (RTC, 传感器, EEPROM,FLASH, 解 / 编码器, 模数转换器, 数字信号处理器) 之间的通信, MMC 和 SD 卡也可以通过 SPI 协议访问, 而 MMC 接口的 DataFlash 卡则必须通过 SPI 才能访问. 仅用于嵌入式环境, PC 平台上没有这样的设备.
SPMI support
CONFIG_SPMI
系统电源管理接口 (SPMI, System Power Management Interface) 是一种连接 PMIC(Power Management Integrated Circuits)的双线串行接口. 仅用于嵌入式环境.
Qualcomm MSM SSBI bus support
CONFIG_SSBI
高通 (Qualcomm) 骁龙系列智能手机处理器内嵌的单线串行总线接口 (Single-wire Serial Bus Interface)
HSI support
CONFIG_HSI
高速同步串行接口 ( High speed synchronous Serial Interface) 是移动产业处理器接口 ( MIPI)联盟的高速同步接口工作组发布的一项技术规范. MIPI(Mobile Industry Processor Interface)是 2003 年由 ARM,Nokia,ST,TI 等公司成立的一个联盟, 目的是把手机内部的接口 (如摄像头, 显示屏接口, 射频 / 基带接口等) 标准化, 从而减少手机设计的复杂程度和增加设计灵活性. MIPI 联盟下面有不同的工作组, 分别定义了一系列的手机内部接口标准, 比如摄像头接口 CSI, 显示接口 DSI, 射频接口 DigRF, 麦克风 / 扬声器接口 SLIMbus 等. 统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组, 更改设计和功能时更加快捷方便. 目前, MIPI 联盟的董事成员包括英特尔, 摩托罗拉, 诺基亚, 三星, 意法半导体, 德州仪器.
PPS support
CONFIG_PPS
秒脉冲 (Pulse Per Second) 驱动用来控制电流脉冲速率, 可用于计时. PPS 的精度可以到纳秒级, 而且没有累积误差. 这通常是 GPS 天线的一项功能, 用于获取 GPS 卫星的授时.
PTP clock support
CONFIG_PTP_1588_CLOCK
精密时间协议 ( Precision Time Protocol) 是 IEEE 1588 定义的一种基于以太网的高精度时间同步协议. PTP 采用硬件与软件结合设计, 可以提供比纯软件方式的 NTP(网络时间协议) 高的多的精度 (微秒级). 与 GPS 授时相比, 在提供和 GPS 相同的精度情况下, PTP 不需要为每个设备安装 GPS 那样昂贵的组件, 只需要一个高精度的本地时钟和提供高精度时钟戳的部件, 成本较低. 一般的 PC 和服务器上没有 PTP 硬件.
Pin controllers
Pin 控制器. 其下的各选项请根据实际硬件状况选择 (皆为低功耗或嵌入式平台).
GPIO Support
CONFIG_GPIOLIB
每个芯片都会有至少一个引脚 (PIN), 像 CPU 或者芯片组这种复杂的芯片, 其引脚会有成白上千个, 这些 PIN 就是芯片与外部沟通的渠道, 每个 PIN 都会有它特定的功能. GPIO( General Purpose I/O) 就是芯片上的一种通用功能的引脚, 其功能可由使用者通过编程的方式自定义 (所谓 &ldquo;可编程引脚&rdquo;), 比如使用两条 PIN 就可以组成 I2C, 使用 4 条 PIN 就可以组成 SPI. 嵌入式系统经常需要控制结构简单但数量众多的外部设备 (比如 LED 的亮与灭), 使用传统的串口或者并口就太 &ldquo;大炮打蚊子&rdquo;, 而 GPIO 则非常适合用于控制此类数量众多的简单设备. GPIO 在嵌入式设备中使用广泛, 但 PC 平台的芯片组南桥大多也集成有 GPIO 引脚 (但只有 BIOS 才知道如何使用他们), 以支持某些特殊的定制硬件. 详情参见 &quot; Documentation/gpio/gpio.txt&quot;文档. 不确定的选&quot;N&quot;.
Debug GPIO calls
CONFIG_DEBUG_GPIO
仅供调试使用
/sys/class/gpio/&hellip; (sysfs interface)
CONFIG_GPIO_SYSFS
为 GPIO 设备添加 sysfs 接口. 主要用于调试和问题排查. 不确定的选 &ldquo;N&rdquo;.
Generic memory-mapped GPIO controller support (MMIO platform device)
CONFIG_GPIO_GENERIC_PLATFORM
这是最简单的 GPIO 控制器驱动 ( platform 总线驱动), 仅支持单独一个 &ldquo;data&rdquo; 寄存器, 用于读 / 写 GPIO 的状态. 不确定的选 &ldquo;Y&rdquo;.
{这里被省略的部分, 按主板上实际集成的芯片选择即可}
Dallas&rsquo;s 1-wire support
CONFIG_W1
Dallas 公司发明的单总线是比 I2C 更简单的总线, 仅使用一个引脚 (1-wire), 使用 Master-Slave 结构, 用于连接慢速的单引脚设备, 比如 iButton 和热传感器. 主要用于嵌入式系统.
Power supply class support
CONFIG_POWER_SUPPLY
允许用户空间程序通过 sysfs/uevent 接口对电源 (电池, 交流电, USB) 进行监控. 主要用于笔记本与嵌入式设备.
Power supply debug
CONFIG_POWER_SUPPLY_DEBUG
仅供调试使用
Generic PDA/phone power driver
CONFIG_PDA_POWER
通用的 PDA/phone 电源切换驱动. 用于在内部电池和外部电源 (AC/USB) 之间进行切换.
Generic battery support using IIO
CONFIG_GENERIC_ADC_BATTERY
为使用 IIO 总线 (CONFIG_IIO) 的电池提供的通用驱动
Test power driver
CONFIG_TEST_POWER
仅供测试使用
SBS Compliant gas gauge
CONFIG_BATTERY_SBS
与 智能电池系统 ( Smart Battery System)规范兼容的气压计 (集成在电池组中) 支持.
GPIO charger
CONFIG_CHARGER_GPIO
支持充电器通过 GPIO 引脚报告其在线状态.
Board level reset or power off
CONFIG_POWER_RESET
允许通过操作板载的主电源, 关闭或重启整个系统. 仅用于嵌入式系统.
{这里被省略的部分, 按实际电池控制芯片选择即可}
Adaptive Voltage Scaling class support
CONFIG_POWER_AVS
自适应电压调节 (Adaptive Voltage Scaling) 技术能够动态的对设备工作电压进行精细的调整, 拥有比 DVFS 更佳的电力利用效率, 是一种降低功耗与优化性能并举的电源与性能管理技术. AVS 在 OMAP 设备上也被称为 &quot; SmartReflex&quot;. 目前仅用于嵌入式领域.
Hardware Monitoring support
CONFIG_HWMON
当前主板大多都有一个监控硬件温度 / 电压 / 风扇转速等状况的设备, 请按照主板实际使用的芯片选择相应的子项. 如果你不知道究竟需要使用哪个驱动, 可以使用 Superiotool 和 sensors-detect 工具进行检测. 另外, 某些子项可能还需要 CONFIG_I2C 的支持. 更多详情参见 &quot; Documentation/hwmon/userspace-tools&quot; 文档.
Hardware Monitoring Chip debugging messages
CONFIG_HWMON_DEBUG_CHIP
在系统日志中输出大量的 I2C 调试信息, 仅用于故障调试
{被省略的部分, 按实际的硬件监控芯片选择即可} GPIO fan
CONFIG_SENSORS_GPIO_FAN
连接在 GPIO 引脚上的风扇
PMBus support
CONFIG_PMBUS
电源管理总线 (Power Management Bus) 是一种基于 SMBus(CONFIG_I2C) 的开放标准的数字电源管理协议, 可以用于配置 / 监控 / 操作电源变换器, 目前全球有 超过 40 个 IC 厂商提供 满足 PMBus 标准的产品. 最新的 PMBus+ 1.3 标准增加 AVS(CONFIG_POWER_AVS) 支持, 可以动态控制设备的工作电压. 根据你的实际硬件状况选择子项.
ACPI 4.0 power meter
CONFIG_SENSORS_ACPI_POWER
将 ACPI 4.0(2009 年 6 月发布)中定义的瓦特表 (用于测量功耗) 当做硬件监控设备导出到用户空间. 需要固件支持 ACPI 4.0 规范, 并且有一个瓦特表. 不确定的选 &ldquo;N&rdquo;.
ASUS ATK0110
CONFIG_SENSORS_ATK0110
许多华硕主板都有这种 ACPI 硬件监控接口. 此驱动可以通过主板固件读取风扇 / 电压 / 温度信息.
Generic Thermal sysfs driver
CONFIG_THERMAL
为 ACPI 规范中定义的 &ldquo;thermal&rdquo;(发热控制) 提供一个通用的 sysfs 接口, 以方便与诸如温度传感器和风扇之类的设备通信. 由于目前所有 PC 和服务器都已支持 ACPI, 并且发热控制也越来越重要, 所以建议选 &ldquo;Y&rdquo;. 详情参见 &quot; Documentation/thermal/sysfs-api.txt&quot; 文档.
Expose thermal sensors as hwmon device
CONFIG_THERMAL_HWMON
将温度传感器同时注册为一个硬件监控设备, 从而让温度传感器同样在 sysfs 中拥有 hwmon 接口.
Enable writable trip points
CONFIG_THERMAL_WRITABLE_TRIPS
允许用户空间程序更改温度报警阀值 (trip temperature).
Default Thermal governor
选择默认的热调节器, 建议选 &ldquo;step_wise&rdquo;.
Fair-share thermal governor
CONFIG_THERMAL_GOV_FAIR_SHARE
此调节器根据设备对所属区域的 &ldquo;贡献&rdquo;(contribution) 进行调节.
Step_wise thermal governor
CONFIG_THERMAL_GOV_STEP_WISE
此调节器以线性方式进行调节, 也就是每次调节都只在紧邻的两档之间进行切换.
Bang Bang thermal governor
CONFIG_THERMAL_GOV_BANG_BANG
此调节器仅能让散热风扇处于开 / 关两种状态 (根据温度阀值) 而不能调节风扇的速度. 某些 Acer 笔记本风扇驱动 (acerhdf) 依赖于此调节器. 不能将此调节器设为默认调节器.
User_space thermal governor
CONFIG_THERMAL_GOV_USER_SPACE
此调节器让用户空间程序去决定如何调节
Power allocator thermal governor
CONFIG_THERMAL_GOV_POWER_ALLOCATOR
此调节器可对特定的设备动态分配和限制能量的使用. 不确定的选 &ldquo;N&rdquo;.
generic cpu cooling support
CONFIG_CPU_THERMAL
通用的 CPU 降温机制 (通过降低频率来实现, 而不是通过 ACPI 接口). 显然通过 ACPI 接口是更好的机制, 所以建议选 &ldquo;N&rdquo;.
Thermal emulation mode support
CONFIG_THERMAL_EMULATION
&ldquo;Thermal&rdquo; 模拟. 仅供调试使用, 切勿用于生产系统!!
Intel PowerClamp idle injection driver
CONFIG_INTEL_POWERCLAMP
Intel  PowerClamp 驱动通过利用 Nehalem 之后的 CPU 支持的 &ldquo;package-level C-state&rdquo; 特性, 强制为在线的 CPU 注入 &ldquo;idle&rdquo; 指令 (通过 &ldquo;/sys/class/thermal/&rdquo; 接口设定 &ldquo;idle&rdquo; 百分比), 以确保 CPU 的功耗不会超过特定的阈值 (发热量也就不会超过特定的阈值). 这样刻意的降低系统性能峰值还有一个好处, 那就是相对于传统的动态频率调节技术而言, 能够达到更高的每瓦特性能. 详见 Documentation/thermal/intel_powerclamp.txt 文档. 如果你对节能和限制发热量特别在意, 同时又不在乎系统峰值性能的降低, 可以选 &ldquo;Y&rdquo;.
X86 package temperature thermal driver
CONFIG_X86_PKG_TEMP_THERMAL
所谓 &quot; CPU 温度 &ldquo;实际上是个多重概念:(1)Socket 温度, 是指 CPU 插座里的测温二极管探测到的温度, 相当于 CPU 外表面的温度;(2)Package 温度, 是封装在 CPU 内部的测温二极管探测到的温度, 是真正的 CPU 内部的温度, 此温度永远比 Socket 温度高;(3)Core 温度, 是每个 CPU 核心内嵌的温度传感器检测到的温度, 有多少个核心就有多少个 Core 温度; 此选项提供了检测 Package 温度的驱动. 并将此温度用于监控 CPU 温度 (对于拥有多颗物理 CPU 的服务器来说每颗物理 CPU 对应一个 Package 温度). 同时, 选中此项后, 温度报警阀值也变为可以设置两个严重级别不同的值. 建议选&quot;Y&rdquo;.
Intel SoCs DTS thermal driver
CONFIG_INTEL_SOC_DTS_THERMAL
专用于 Intel SoC(BayTrail 等) 平台的 CPU 内嵌温度传感器驱动.
ACPI INT340X thermal drivers
CONFIG_INT340X_THERMAL
除了 CPU/SOC 内置的温度传感器之外, 新式笔记本或平板电脑还经常包含探测整机不同位置温度的传感器, 这些温度传感器以 INT3400 ACPI 设备作为主设备 (master), 并以 INT3401~INT340B ACPI 设备为从设备 (slave), 此选项提供了对此类温度传感器的驱动支持.
Intel PCH Thermal Reporting Driver
CONFIG_INTEL_PCH_THERMAL
专用于 Intel PCH 芯片组内置温度传感器的驱动.
Watchdog Timer Support
CONFIG_WATCHDOG
选 &ldquo;Y&rdquo; 并选中下面相应的驱动之后, 再创建一个主 / 次设备号为 10/130 的字符设备 &ldquo;/dev/watchdog&rdquo;, 即可拥有一只 看门狗. 其工作原理是: 当 / dev/watchdog 设备被打开后, 如果 喂狗守护进程超过 60 秒没有喂狗 (写入 &ldquo;/dev/watchdog&rdquo;), 那么底层的看门狗硬件将会触发整个机器硬重启 (相当于按下面板上的 &ldquo;RESET&rdquo; 按钮). 这对于提高服务器的在线率来说意义重大. 详情参见 &quot; Documentation/watchdog/watchdog-api.txt&quot; 文档.
WatchDog Timer Driver Core
CONFIG_WATCHDOG_CORE
看门狗核心驱动, 它为所有特定于具体硬件的看门狗驱动提供了统一的框架和 &ldquo;/dev/watchdog&rdquo; 接口 (未来还会包括 sysfs 接口). 使用看门狗的必选.
Disable watchdog shutdown on close
CONFIG_WATCHDOG_NOWAYOUT
默认情况下 (此项 =&ldquo;N&rdquo;) 如果喂狗进程关闭 &ldquo;/dev/watchdog&rdquo; 文件, 那么表示停止看门狗功能. 开启此项后, 看门狗一旦启用就不能被停止(即使关闭 &ldquo;/dev/watchdog&rdquo; 文件也不会停止).
Software watchdog
CONFIG_SOFT_WATCHDOG
内核提供的 &ldquo;软看门狗&rdquo;. 使用它不需要有任何硬件的支持, 但可靠性不如硬件看门狗, 仅能应对喂狗进程的崩溃, 不能应对内核本身的崩溃. 在某些情况下 (例如 Oracle 数据库),CONFIG_HANGCHECK_TIMER 是比 &ldquo;软看门狗&rdquo; 更好的选择.
{此处省略的看门狗硬件请按照实际使用的芯片进行选择}
Sonics Silicon Backplane support
CONFIG_SSB
SSB(Sonics Silicon Backplane) 是一种仅在嵌入式环境中使用的总线.
Broadcom specific AMBA
CONFIG_BCMA
Broadcom 特有的 AMBA(Advanced Microcontroller Bus Architecture) 总线支持. 仅用于嵌入式环境
Multifunction device drivers
MFD(多功能设备)的含义是 &ldquo;在单个芯片上集成多个功能 (GPIO, 触摸屏, 键盘, 电流调节, 电源管理&hellip;)&rdquo;. 此种芯片通常通过一个或多个 IRQ 线和低速数据总线(SPI/I2C/GPIO) 与主 CPU 进行通信. 对于主系统来说, 它们通过数据总线显示为一个单独的 MFD 设备. 但透过 MFD 框架, 又可以拥有多个相互独立的子设备(子功能).
Intel ICH LPC
CONFIG_LPC_ICH
LPC(Low Pin Count) 总线是 Intel 于 1998 年发布的一个旨在取代传统 ISA 总线的接口规范, 用于连接南桥和 Super I/O 芯片 (用于连接低速外设: 串口, 并口, PS/2 键鼠, 软盘控制器, TPM(可信平台模块), 温度传感器, 风扇速度监测器) 以及 Flash 芯片(BIOS). 以往南桥必须保留 ISA 总线, 以连接老旧的 ISA 插槽和 Super I/O 芯片 (可以使用 Superiotool 和 sensors-detect 工具检测) 以及 Flash 芯片. 但是 ISA 需要占用大量针脚, 主板的线路设计也比较复杂. 随着 ISA 插槽的消失, LPC 就顺理成章的出现了, 它与 ISA 在软件层面是类似的, 同时 LPC 工作速率由 PCI 总线速率同步驱动, 但是引脚数大大降低, 以方便在拥挤的现代主板上布局, 这也是取名 &ldquo;Low Pin Count&rdquo; 的原因. 此选项支持几乎所有 Intel 芯片组的 LPC 总线, 以方便其他驱动控制 MFD(目前仅有 GPIO 和 watchdog). 具体 支持的芯片可以查看 &ldquo;drivers/mfd/lpc_ich.c&rdquo; 文件. 不确定的选 &ldquo;Y&rdquo;.
Intel SCH LPC
CONFIG_LPC_SCH
用于 Intel Atom 处理器的 Intel SCH(System Controller Hub) LPC 总线支持. 目前仅支持 SMBus 和 GPIO.
{此处省略的硬件请按照实际使用的芯片进行选择}
Voltage and Current Regulator Support
CONFIG_REGULATOR
通用的电压与电流调节器框架. 除了提供通用的电压与电流调节接口外, 还能通过 sysfs 向用户空间提供电压与电流的状态信息. 目的在于通过动态调节电压和电流, 降低能耗, 延长电池寿命. 主要用于嵌入式环境.
Multimedia support
CONFIG_MEDIA_SUPPORT
多媒体设备: 摄像头, 视频采集, 模拟电视, 数字电视, 机顶盒, 收音机, 遥控器, 数字视频广播 (DVB)&hellip; 内核多媒体子系统由 LinuxTV 项目负责维护.
Cameras/video grabbers support
CONFIG_MEDIA_CAMERA_SUPPORT
摄像头, 视频采集卡
Analog TV support
CONFIG_MEDIA_ANALOG_TV_SUPPORT
模拟电视信号接收器, 包括那些既能接收模拟信号又能接收数字信号的电视卡
Digital TV support
CONFIG_MEDIA_DIGITAL_TV_SUPPORT
数字电视信号接收器, 包括那些既能接收模拟信号又能接收数字信号的电视卡
AM/FM radio receivers/transmitters support
CONFIG_MEDIA_RADIO_SUPPORT
AM/FM 无线电接收机和发射机, 包括那些带有收音机功能的电视卡
Remote Controller support
CONFIG_MEDIA_RC_SUPPORT
基于红外线 / 射频的遥控器, 用于控制视频采集卡或者电视卡. 大多数电视卡和视频采集卡都需要它的支持, 即使这些卡实际并不需要遥控器.
Media Controller API
CONFIG_MEDIA_CONTROLLER
此 API 用于查询多媒体设备内部的拓扑结构, 并进行动态配置. 主要用于嵌入式环境中的摄像头配置.
V4L2 sub-device userspace API
CONFIG_VIDEO_V4L2_SUBDEV_API
此 API 用于配置视频的格式 / 尺寸 / 帧率. 主要用于嵌入式环境中的摄像头配置.
Enable advanced debug functionality on V4L2 drivers
CONFIG_VIDEO_ADV_DEBUG
开启 V4L2 驱动程序的高级调试特性, 不确定的选 &ldquo;N&rdquo;.
Enable old-style fixed minor ranges on drivers/video devices
CONFIG_VIDEO_FIXED_MINOR_RANGES
仅在你使用 mknod 而不是 udev 进行设备管理时才需要开启. 不确定的选 &ldquo;N&rdquo;.
V4L2 int device (DEPRECATED)
CONFIG_VIDEO_V4L2_INT_DEVICE
仅用于旧式的图像传感器驱动 (omap24xxcam 和 tcm825x), 反对使用此项. 选 &ldquo;N&rdquo;.
DVB Network Support
CONFIG_DVB_NET
DVB( 数字视频广播)是一系列国际公认的数字电视标准. 此项提供了 DVB 网络 (DVB 标准的一部分) 支持, 可用于数字机顶盒 (Set-Top-Box) 的自动固件升级以及通过 DVB 卡访问互联网.
maximum number of DVB/ATSC adapters
CONFIG_DVB_MAX_ADAPTERS
最大允许的 DVB/ATSC 电视卡数量. 取值范围是 [1,255], 但经过测试的范围是 [4,32]. 不确定的请保持默认值 &ldquo;8&rdquo;.
Dynamic DVB minor allocation
CONFIG_DVB_DYNAMIC_MINORS
为 DVB 设备节点动态分配次设备号, 这样每张 DVB 卡就可以拥有最多 4 个同类型的设备 (例如 demux(分离器) 和 frontend(前端)). 此特性需要 udev 的支持.
Compile Remote Controller keymap modules
CONFIG_RC_MAP
将各种遥控器的 keymap 表编译进内核. 这些表都很小, 但是如果你不打算使用遥控器, 或者更喜欢使用 v4l-utils 包内的 ir-keytable 工具从用户空间加载这些表, 可以选 &ldquo;N&rdquo;.
Remote controller decoders
CONFIG_RC_DECODERS
遥控器解码器. 其下的子项是各种不同的遥控通信协议.
Remote Controller devices
CONFIG_RC_DEVICES
各种遥控器产品. 其下子项按实际的厂商和型号选择即可.
Media USB Adapters
CONFIG_MEDIA_USB_SUPPORT
各种 USB 总线的多媒体设备
USB Video Class (UVC)
CONFIG_USB_VIDEO_CLASS
UVC( USB Video Class) 是一个开放的通用 USB 视频捕获标准. 目前大多数摄像头都是 UVC 摄像头, 也就是俗称的 &ldquo;免驱摄像头&rdquo;. 所有符合 UVC 规格的硬件都可以使用 通用 UVC 驱动程序, 而无需再使用专用驱动.
UVC input events device support
CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV
某些 UVC 摄像头上会带有按钮 (常用于开关 LED 灯 / 拍照), 此选项可以将此按钮注册为一个输入设备, 以用于报告按钮事件.
GSPCA based webcams
CONFIG_USB_GSPCA
基于 GSPCA 框架的摄像头驱动 (依赖于 CONFIG_VIDEO_V4L2), 这是 一位 60 岁的法国医生的杰作. 该驱动适用于大多数常见的非 UVC 摄像头. 具体支持的芯片列表可以查看 &quot; Documentation/video4linux/gspca.txt&quot; 文档.
{此处省略的非 GSPCA 摄像头, 电视卡, 电视棒等其他硬件请按照实际使用的芯片进行选择}
Media PCI Adapters
CONFIG_MEDIA_PCI_SUPPORT
各种 PCI/PCIe 总线的多媒体设备
V4L platform devices
CONFIG_V4L_PLATFORM_DRIVERS
特定于平台的 V4L(Video For Linux) 设备, 这些设备不是通过 USB/PCI 这样的总线连接的. 一般用于单片机之类的嵌入式环境.
SoC camera support
CONFIG_SOC_CAMERA
所谓 &ldquo;SoC Camera&rdquo; 是指那些不通过 PCI 或 USB 总线连接的摄像头 (例如通过 I2C 直接与 SoC 数据总线连接). 此选项为这类摄像头提供了通用的支持.
platform camera support
CONFIG_SOC_CAMERA_PLATFORM
仅用于调试目的
{此处省略的部分请按照实际使用的芯片进行选择}
Memory-to-memory multimedia devices
CONFIG_V4L_MEM2MEM_DRIVERS
使用系统内存作为源和目标缓存 (Memory-to-memory) 的多媒体设备. 一般的采集输出驱动仅将系统内存用于源或目标缓存之一. 不确定的选 &ldquo;N&rdquo;.
Media test drivers
CONFIG_V4L_TEST_DRIVERS
仅用于调试目的.
Siano SMS1xxx based MDTV via SDIO interface
CONFIG_SMS_SDIO_DRV
使用 SDIO 接口的一种移动数字电视 (MDTV) 卡, 基于 Siano SMS1xxx 芯片. 主要用于嵌入式设备
ISA and parallel port devices
CONFIG_MEDIA_PARPORT_SUPPORT
使用 ISA 或并口的多媒体设备, 古董级别的设备
Radio Adapters
CONFIG_RADIO_ADAPTERS
AM/FM 无线电广播接收设备
FireDTV and FloppyDTV
CONFIG_DVB_FIREDTV
Digital Everywhere 生产的 FireWire(IEEE 1394) 接口的 DVB 电视接收卡
Cypress firmware helper routines
CONFIG_CYPRESS_FIRMWARE
Cypress( 赛普拉斯) 多媒体产品的固件加载帮助程序.
Enable Remote Controller support for Siano devices
CONFIG_SMS_SIANO_RC
Siano 多媒体设备遥控器
Enable debugfs for smsdvb
CONFIG_SMS_SIANO_DEBUGFS
仅供调试使用, 当前仅可用于 Siano USB 设备
Autoselect ancillary drivers (tuners, sensors, i2c, frontends)
CONFIG_MEDIA_SUBDRV_AUTOSELECT
为多媒体设备驱动自动选择所有相关的辅助驱动 (tuner[调谐器],sensor[传感器], 视频编 / 解码器以及前端), 以免去手动选择的麻烦. 通常这是个好主意, 建议选 &ldquo;Y&rdquo;. 但是对于某些嵌入式环境来说, 却希望去掉部分有用的辅助驱动以保持内核尽可能短小, 这时应该选 &ldquo;N&rdquo;.
I2C module for IR
CONFIG_VIDEO_IR_I2C
大多数板子都通过 GPIO 总线连接红外线芯片, 但少数板子却使用 I2C 总线连接. 此项即是对 I2C 总线连接的红外线芯片提供支持.
Encoders, decoders, sensors and other helper chips
编码器, 解码器, 传感器, 混频器&hellip; 等辅助芯片
Sensors used on soc_camera driver
用于 &ldquo;SoC Camera&rdquo;(CONFIG_SOC_CAMERA) 的各种传感器
Customize TV tuners
各种专用的电视调谐器
Customise DVB Frontends
各种专用的数字电视前端
Graphics support
图形设备 / 显卡支持. 对于不需要使用图形界面的服务器环境来说, 必须的最小选项集取决于平台 (BIOS/UEFI) 和引导程序 (GRUB/LILO/GRUB4DOS) 的设置 (全选 &ldquo;N&rdquo; 则屏幕将无任何显示). 具体如下:(1) 以 UEFI 方式启动的, 一律都必须 &ldquo;CONFIG_FB=y,CONFIG_FB_EFI=y,CONFIG_FRAMEBUFFER_CONSOLE=y&rdquo;[补充说明: 对于 3.12 或以上版本, 则应该是 &ldquo;CONFIG_X86_SYSFB=y,CONFIG_FB=y,CONFIG_FB_SIMPLE=y,FRAMEBUFFER_CONSOLE=y&rdquo;];(2)以 BIOS+GRUB2 启动, 且在&rsquo;grub.cfg&rsquo;中明确将 &ldquo;gfxpayload&rdquo; 变量设置为非&rsquo;text&rsquo;值或者内核引导参数中存在&rsquo;vga=&hellip;&rsquo;, 那么必须 &ldquo;CONFIG_FB=y,CONFIG_FB_VESA=y,CONFIG_FRAMEBUFFER_CONSOLE=y&rdquo;[补充说明: 对于 3.12 或以上版本, 则应该是 &ldquo;CONFIG_X86_SYSFB=y,CONFIG_FB=y,CONFIG_FB_SIMPLE=y,FRAMEBUFFER_CONSOLE=y&rdquo;];(3)以 BIOS 方式启动的其他情况, 必须 &ldquo;CONFIG_VGA_CONSOLE=y&rdquo;
/dev/agpgart (AGP Support)
CONFIG_AGP
GART( 图形地址重映射表) 可以看做一种被各种显卡 (不只是 AGP 显卡, 还包括 PCI-E 显卡与 集成显卡以及 核心显卡) 使用的 &quot; 伪 IOMMU&quot;(参见 CONFIG_GART_IOMMU 选项), 它将物理地址不连续的系统内存映射成连续的&quot; 显存 &quot; 供 GPU 使用. 当物理显存容量不够时 (大多数集成显卡甚至根本没有物理显存),GART 允许通过 DMA( 直接内存访问) 方式将这部分 &ldquo;显存&rdquo; 用于 纹理贴图, Z 轴缓冲, ALPHA 混合, 多边形网格生成&hellip; 等各种 3D 操作. 如果没有 GART 支持, OpenGL 直接渲染将会变得特别慢. GLX 与 DRI(CONFIG_DRM) 也依赖于此. 简而言之, 需要使用图形化界面的人都应该选 &ldquo;Y&rdquo;. 不需要图形界面的用户应该选 &ldquo;N&rdquo;.[注意] 对于使用 304 或更老版本的 nVidia 闭源驱动的用户, 如果使用的是 某些老旧的芯片组, 那么此处应该选 &ldquo;N&rdquo;. 因为在这些特定的芯片组上, 闭源驱动自己的 agpgart 实现 ( NvAGP) 是更好的选择.[提示] 老版本的 AMD/ATI/NVIDIA 闭源驱动都曾经有自己的 agpgart 实现, 但在新版本中都已经被移除. 而 Intel 显卡一直使用的都是内核的 agpgart 实现.
AMD Opteron/Athlon64 on-CPU GART support
CONFIG_AGP_AMD64
该项仅适用于如下 AMD 处理器:(1) AMD K8 微架构 CPU[cpu family : 15] (2) AMD K10 微架构 CPU[cpu family : 16] (3) AMD 推土机微架构 CPU[cpu family : 21 并且 model: 小于 15].[提示]除了前面列出的三种 CPU 外, 其他 AMD 处理器 (例如 A4/A6/A8 系列 APU) 并不需要此选项. 具体支持的 CPU 可以查看 &ldquo;arch/x86/kernel/amd_nb.c&rdquo; 文件中的 &ldquo;AMD_NB_GART&rdquo; 常量的使用.
Intel 440LX/BX/GX, I8xx and E7x05 chipset support
CONFIG_AGP_INTEL
该项仅适用于:(1) 某些 Intel 芯片组 (440LX/BX/GX, 8xx 系列, E7205/E7505/E7221, 9xx 系列, 所有 3/4 系列). (2) 全部 Intel 集成显卡 (包括 Intel 核心显卡). 具体支持的芯片组和集显可以查看 &ldquo;drivers/char/agp/intel-<em>&rdquo; 系列文件.[提示] 如果你使用的既不是此处所列的芯片组 (例如 Xeon 芯片组或者 5/6/7/8/9 系列芯片组) 也不是 Intel 的集成显卡 (例如 AMD/nVidia 独立显卡), 那么应该选 &ldquo;N&rdquo;.
SiS chipset support
CONFIG_AGP_SIS
该项仅适用于 SiS 芯片组, 但不包括上世纪古董级的 SiS 5591/5592 芯片组.
VIA chipset support
CONFIG_AGP_VIA
该项仅适用于 VIA 芯片组. 具体支持的芯片组型号可以查看 &ldquo;drivers/char/agp/via-agp.c&rdquo; 中的 &ldquo;via_agp_device_ids&rdquo; 数组.
VGA Arbitration
CONFIG_VGA_ARB
图形设备是通过 I/O 或内存的特定地址范围进行访问的. 大多数现代的显卡都允许对这个范围进行重新定位, 但是某些基于 PCI 的 &ldquo;传统&quot;VGA 设备仍然使用 &ldquo;硬编码&rdquo; 的地址范围, 无法对其进行重新定位. 如果系统上有多个这样的 &ldquo;传统&quot;VGA 设备, 就会造成地址冲突, 这时候就需要进行 VGA 仲裁. 此选项主要用于处理多个显卡 (比如集成显卡和独立显卡) 之间的切换. 如果你的系统上有多个显卡, 可以选 &ldquo;Y&rdquo;, 否则应该选 &ldquo;N&rdquo;. 详情参见 &quot; Documentation/vgaarbiter.txt&rdquo; 文档.
Maximum number of GPUs
CONFIG_VGA_ARB_MAX_GPUS
最多允许支持多少个显卡
Laptop Hybrid Graphics - GPU switching support
CONFIG_VGA_SWITCHEROO
支持多个显卡之间的切换 (通常是在集显和独显之间), 这项技术有多个不同的名称:&rdquo; Hybrid Graphics&quot;,&quot; PowerXpress&quot;,&quot; HybridPower&quot;. 这项特性主要用于笔记本, 台式机一般不支持.
Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)
CONFIG_DRM
DRI( Direct Rendering Infrastructure) 允许应用程序以高效安全的方式直接访问 GPU, 主要用于硬件 3D 加速. 不需要图形界面的用户应该选 &ldquo;N&rdquo;. 桌面用户建议选 &ldquo;Y&rdquo;.[提示]KMS+DRI2+GEM+UXA+ Wayland 是 Linux 图形革命的基石, 这里还有两篇需要越墙的文章可以帮助加深对 Linux 图形技术的理解:(1) 关于 Xorg 的一些整理,(2) 厘清了 xorg 里的一些概念.
Enable legacy fbdev support for your modesetting driver
CONFIG_DRM_FBDEV_EMULATION
为传统的 fbdev 设备提供支持, 由于 CONFIG_FRAMEBUFFER_CONSOLE 依赖于 fbdev 设备, 因此务必选 &ldquo;Y&rdquo;, 否则将会遭遇控制台黑屏.
Allow to specify an EDID data set instead of probing for it
CONFIG_DRM_LOAD_EDID_FIRMWARE
EDID( 扩展显示器识别数据) 是一种 VESA(视频电子标准协会) 制定的标准数据格式, 其中包含有关显示器的各种参数: 供应商信息, 最大图像尺寸, 颜色设置, 厂商预设置, 频率范围, 显示器名, 序列号字符串等等. EDID 保存在显示器的 PROM 或 EEPROM 中, 显卡或 read-edid 一般通过 I2C 总线使用 DDC 协议进行读取. 但是在某些脑残的硬件 (显示器或显卡) 上却不能正确获取 EDID 数据. 此选项就是为了解决这个问题而设置的. 此选项可以允许从 &ldquo;/lib/firmware/&rdquo; 目录加载 EDID 数据, 或者将 EDID 数据在编译时直接嵌入内核. 不确定的选 &ldquo;N&rdquo;. 详情参见 &quot; Documentation/EDID/HOWTO.txt&quot; 文档.[提示]EDID 的继任者是 DisplayID, 但目前 DisplayID 尚未被广泛应用.
I2C encoder or helper chips
I2C 编码器或辅助芯片
Chrontel ch7006 TV encoder
CONFIG_DRM_I2C_CH7006
Chrontel ch7006 电视解码器支持. 某些 nVidia 显卡上有这个芯片. 此选项仅对 NVIDIA 显卡开源驱动 ( nouveau) 有意义.
Silicon Image sil164 TMDS transmitter
CONFIG_DRM_I2C_SIL164
Silicon Image SIL164  最小化传输差分信号 ( TMDS) 发送器, 用于实现 DVI 信号的合成和发送. TMDS 不如 LVDS 应用广泛, 仅在某些 nVidia 显卡上有出现.
NXP Semiconductors TDA998X HDMI encoder
CONFIG_DRM_I2C_NXP_TDA998X
NXP(恩智浦) TDA998X  HDMI 发射器. 用于实现 HDMI 信号的合成和发送.
3dfx Banshee/Voodoo3+
CONFIG_DRM_TDFX
3dfx Banshee/Voodoo3+ 系列古董显卡
ATI Rage 128
CONFIG_DRM_R128
ATI Rage 128 系列古董显卡
ATI Radeon
CONFIG_DRM_RADEON
Radeon 系列显卡开源驱动 ( radeon).[提示]R600 及更新的 GPU 需要额外的固件 / 微代码 ( radeon-ucode)的帮助才能使用开源驱动. 如果你打算在 R600 及更新的 GPU 上使用此开源驱动, 那么建议选 &ldquo;M&rdquo; 而不是 &ldquo;Y&rdquo;. 因为 &ldquo;Y&rdquo; 需要将微代码 (通常位于 &ldquo;/lib/firmware/radeon/&rdquo; 目录) 一起编译进内核(使用 CONFIG_EXTRA_FIRMWARE=&ldquo;radeon/ GPU-MODEL.bin&rdquo;).[注意] 如果你打算使用目前尚不支持 KMS 的 Radeon 闭源驱动 ( Catalyst/fglrx), 那么此项必须选 &ldquo;N&rdquo;.
Enable userspace modesetting on radeon (DEPRECATED)
CONFIG_DRM_RADEON_UMS
禁用 KMS 支持. 目的是为了兼容远古版本的 DDX 驱动. 除非你有充足的理由, 否则请选 &ldquo;N&rdquo;.
Nouveau (nVidia) cards
CONFIG_DRM_NOUVEAU
nVidia 系列显卡开源驱动 ( nouveau).[注意] 如果你打算使用也许永远不会支持 KMS 的 nVidia 闭源驱动 ( nvidia-drivers), 那么此项必须选 &ldquo;N&rdquo;.
Maximum debug level
CONFIG_NOUVEAU_DEBUG
最大调试级别, 也就是最高允许显示的调试信息详细程度. 取值范围是 [0,7], 数字越大, 在内核中编入的调试信息就越多, 建议设为 &ldquo;4&rdquo;, 过大的级别会导致驱动运行缓慢.
Default debug level
CONFIG_NOUVEAU_DEBUG_DEFAULT
默认调试级别, 必须小于等于 CONFIG_NOUVEAU_DEBUG 的值. 数字越大, 输出的调试信息就越详细, 建议设为 &ldquo;2&rdquo;, 过大的级别会导致驱动运行缓慢.
Support for backlight control
CONFIG_DRM_NOUVEAU_BACKLIGHT
允许调整显示器背光亮度, 主要用于液晶显示屏等使用背光技术的显示器. 建议选 &ldquo;Y&rdquo;.
Intel I810
CONFIG_DRM_I810
专为古董级 Intel 集成显卡 (i810/i815) 准备的驱动
Intel 8xx/9xx/G3x/G4x/HD Graphics
CONFIG_DRM_I915
Intel  GMA(芯片组集成显卡) 与 HD Graphics(核心集成显卡) 开源驱动 ( intel). 除了个别老古董 (i810/i815) 与基于 PowerVR 的芯片 (Atom z5xx) 之外, 此驱动支持所有 Intel 集成显卡(包括 Atom 中的集成显卡).[提示] 三大主流显卡厂商对 Linux 的驱动支持,Intel 是最彻底的, 官方只提供开源驱动.
Enable modesetting on intel by default
CONFIG_DRM_I915_KMS
默认开启 KMS( Kernel Mode Setting)特性, 作用是可以在内核级别 (而不是用户级别) 设置显示分辨率和颜色深度. KMS 使用了更新的技术, 可以减少失真, 增强 3D 性能, 甚至可以使用内核的节能功能. KMS 是大势所趋, 只要用户层软件不太旧 (2010 年之后), 都建议开启.[注意] 开启此项后, 应该:(1)关闭 CONFIG_FB_INTEL 选项并禁止加载任何 framebuffer 驱动 (包括 CONFIG_FB_UVESA),(2) 取消内核引导参数 &ldquo;vga=xxx&rdquo; 和 &ldquo;video=xxx&rdquo;,(3)必须开启 CONFIG_FRAMEBUFFER_CONSOLE 选项.
Enable legacy fbdev support for the modesetting intel driver
CONFIG_DRM_I915_FBDEV
使用此驱动为传统的 fbdev 设备提供支持, 由于 CONFIG_FRAMEBUFFER_CONSOLE 依赖于 fbdev 设备, 因此务必选 &ldquo;Y&rdquo;, 否则将会遭遇控制台黑屏.
Enable preliminary support for prerelease Intel hardware by default
CONFIG_DRM_I915_PRELIMINARY_HW_SUPPORT
为尚未正式发布的显卡提供支持, 相当于设置 &ldquo;i915.preliminary_hw_support=1&rdquo; 引导参数. 一般应该选 &ldquo;N&rdquo;
Enable userspace modesetting on Intel hardware (DEPRECATED)
CONFIG_DRM_I915_UMS
为古董级的 DDX 驱动提供用户空间模式设置支持. 选 &ldquo;N&rdquo;.
Matrox g200/g400
CONFIG_DRM_MGA
Matrox G200, G400, G450 系列古董显卡
SiS video cards
CONFIG_DRM_SIS
SiS 630 系列古董显卡
Via unichrome video cards
CONFIG_DRM_VIA
Via unichrome 系列古董显卡
Savage video cards
CONFIG_DRM_SAVAGE
Savage3D/4/SuperSavage/Pro/Twister 系列古董显卡
DRM driver for VMware Virtual GPU
CONFIG_DRM_VMWGFX
VMware SVGA2 虚拟显卡驱动. 支持 3D 加速, 支持 KMS. 如果你打算在 VMware 内使用图形化界面, 建议选 &ldquo;Y&rdquo;.
Enable framebuffer console under vmwgfx by default
CONFIG_DRM_VMWGFX_FBCON
如果你使用的 VMware Tools 不太旧就选 &ldquo;Y&rdquo;.
Intel GMA5/600 KMS Framebuffer
CONFIG_DRM_GMA500
Intel 基于 Poulsbo 架构的集成显卡实验性支持. 此类显卡并不常见, 仅用于 Atom z5xx 系列处理器.
DisplayLink
CONFIG_DRM_UDL
DisplayLink 是一个通过 USB 接口实现显示器连接到电脑的连接技术, 可以非常简单的连接电脑和多个显示设备, 常用于通过 USB 接口扩展虚拟的电脑的桌面. 目前 DisplayLink 技术最多可以支持 6 台显示器同时显示 32 位色彩的任意分辨率画面.
AST server chips
CONFIG_DRM_AST
AST 系列显卡实验性支持. 此种显卡仅出现在服务器环境.
Kernel modesetting driver for MGA G200 server engines
CONFIG_DRM_MGAG200
MGA G200 系列服务器显卡芯片的 KMS 支持.[注意] 仅用于服务器芯片, 不要用于桌面芯片! 此驱动需要 v0.3.0 版本的用户空间 modesetting 驱动.
Cirrus driver for QEMU emulated device
CONFIG_DRM_CIRRUS_QEMU
这是 QEMU 虚拟的 cirrus 显卡 KMS 驱动, 仅可用于客户机中. 千万不要用于真正的物理 cirrus 显卡.
QXL virtual GPU
CONFIG_DRM_QXL
用于 SPICE 的虚拟桌面的 QXL 虚拟显卡 (cirrus)KMS 支持.
Lowlevel video output switch controls
CONFIG_VIDEO_OUTPUT_CONTROL
底层视频输出开关控制 (通过 sysfs 接口). 这是 ACPI 视频控制所依赖的功能, 也被许多显卡驱动所依赖. 可以选 &ldquo;N&rdquo;, 若有其它驱动需要它, 会被自动选中.
Support for frame buffer devices
CONFIG_FB
帧缓冲 ( framebuffer)设备 (/dev/fb</em>) 是一种对图形硬件的抽象, 它把屏幕上的所有像素点都直接映射到一段线性的内存空间, 这样就为软件提供了访问图形硬件的统一接口, 这些软件不需要了解硬件的底层细节(例如寄存器), 只要简单的改变相应内存位置的值, 就能改变屏幕上显示的内容(颜色 / 亮度等).Xorg 的高度可移植性也就根源于此. 图形界面用户必选. CJKTTY 补丁也依赖于它.
Enable firmware EDID
CONFIG_FIRMWARE_EDID
EDID( 扩展显示器识别数据) 保存在显示器的 PROM 或 EEPROM 中, 显卡或 read-edid 一般通过 I2C 总线使用 DDC 协议进行读取. 但是在某些脑残的硬件 (显示器或显卡) 上却不能正确获取 EDID 数据. 此选项就是为了解决这个问题而设置的 (参见 CONFIG_DRM_LOAD_EDID_FIRMWARE). 开启此项后, 将允许三种驱动(nvidiafb,i810fb,savagefb) 通过 Video BIOS 获取 EDID. 建议选 &ldquo;N&rdquo;, 仅在你确实遭遇 EDID 读取失败, 并且确实需要使用 nvidiafb/i810fb/savagefb 驱动的时候才需要考虑选 &ldquo;Y&rdquo;.[提示]EDID 的继任者是 DisplayID, 但目前 DisplayID 尚未被广泛应用.
Framebuffer foreign endianness support
CONFIG_FB_FOREIGN_ENDIAN
如果你想混合使用不同 字节序的主板和显卡 (在 Little-Endian 主板上使用 Big-Endian 显卡, 或者相反), 可以选 &ldquo;Y&rdquo;. 绝大多数人都应该选 &ldquo;N&rdquo;. 除非你确实知道自己在做什么.
Enable Video Mode Handling Helpers
CONFIG_FB_MODE_HELPERS
使用 GTF 和 EDID 解析程序来帮助处理显示模式, 建议选 &ldquo;N&rdquo;, 若有其他选项依赖于它时, 会自动选上.
Enable Tile Blitting Support
CONFIG_FB_TILEBLITTING
此项仅对 matroxfb 驱动有意义, 建议选 &ldquo;N&rdquo;, 若有其他选项依赖于它时, 会自动选上
{虽然此处省略的各种 Framebuffer 驱动提供了对图形硬件的统一抽象, 让 Xorg 不必与硬件直接对话, 但这些 Framebuffer 驱动仅能提供 2D 功能, 在如今 3D 硬件加速和视频硬件解码早已铺天盖地的情况下, 让 Xorg 直接与 GPU 硬件对话才更符合潮流, 而传统的 Framebuffer 驱动 (CONFIG_FB_<em>) 反而成为了绊脚石, 不但没有必要与新的 DRI 驱动 (CONFIG_DRM_</em>) 共存, 而且还会相互冲突. 所以切勿选中这里省略的任何 Framebuffer 驱动. 除非你确实知道自己在做什么.}
Exynos Video driver support
CONFIG_EXYNOS_VIDEO
三星基于 ARM 构的 EXYNOS 处理器内置显卡
Backlight &amp; LCD device support
CONFIG_BACKLIGHT_LCD_SUPPORT
背光与液晶支持.
Lowlevel LCD controls
CONFIG_LCD_CLASS_DEVICE
液晶 (LCD) 底层控制框架. 用于控制对比度和 LCD 开关(而不是背光亮度). 这些 LCD 硬件目前仅用于智能手机 / 平板电脑等嵌入式环境.
Lowlevel Backlight controls
CONFIG_BACKLIGHT_CLASS_DEVICE
背光 (Backlight) 底层控制框架. 用于控制背光源的亮度和开关. 选中此项后还需要从子项中选择特定于硬件的驱动.
Generic PWM based Backlight Driver
CONFIG_BACKLIGHT_PWM
液晶显示器 (包括台式机和笔记本) 的 背光亮度调整方式有两种:(1) PWM 调光,(2) 非 PWM 调光. 目前主流的液晶显示器基本上都是 PWM 调光, 仅有少数是 非 PWM 调光型号 (而且越来越少).
Apple Backlight Driver
CONFIG_BACKLIGHT_APPLE
基于 Intel 处理器的苹果 Macbook 笔记本和 iMac 台式机显示器背光控制
{其它省略的驱动仅用于智能手机 / 平板电脑等嵌入式环境}
Console display driver support
控制台显示驱动. 每个人都需要. 下面的 &ldquo;VGA text&rdquo; 与 &ldquo;Framebuffer&rdquo; 至少应该选中一个.
VGA text console
CONFIG_VGA_CONSOLE
VGA 文本模式控制台. 建议选 &ldquo;N&rdquo;. 仅某些服务器环境可以考虑选 &ldquo;Y&rdquo;.
Enable Scrollback Buffer in System RAM
CONFIG_VGACON_SOFT_SCROLLBACK
标准的 VGA 控制台回滚缓冲区位于 VGA RAM 中, 但是其空间非常小, 并且是固定的. 开启此项后, 就可以在内存中开辟更大的屏幕回滚缓冲区, 这将允许你回滚更多的屏幕 (Shift+PageUp), 但是控制台的速度会略有下降. 经常使用文本控制台的可以选 &ldquo;Y&rdquo;, 不确定的选 &ldquo;N&rdquo;.
Scrollback Buffer Size (in KB)
CONFIG_VGACON_SOFT_SCROLLBACK_SIZE
在内存中开辟的屏幕回滚缓冲区大小. 每个 80x25 屏幕需要 4KB 内存
Framebuffer Console support
CONFIG_FRAMEBUFFER_CONSOLE
基于 Framebuffer 的图形模式控制台. KMS 特性依赖于它. CJKTTY 补丁也依赖于它. 桌面用户必选 &ldquo;Y&rdquo;(使用了 CONFIG_DRM_* 的用户必须开启), 服务器以 UEFI 方式启动的也必选 &ldquo;Y&rdquo;.
Map the console to the primary display device
CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY
选 &ldquo;Y&rdquo; 表示自动将控制台映射到 &ldquo;主&rdquo; 显卡, 选 &ldquo;N&rdquo; 表示自动将控制台映射到第一个加载的显卡驱动. 无论是否选中此项, 都可以通过 &ldquo;fbcon=map:N&rdquo; 内核引导参数更改映射关系. 仅在系统拥有多个显卡时此选项才有意义. 参见 &quot; Documentation/fb/fbcon.txt&quot; 文档.
Framebuffer Console Rotation
CONFIG_FRAMEBUFFER_CONSOLE_ROTATION
显示画面旋转, 由于是纯软件方式实现, 所以会大大降低显示速度, 除非你确实需要, 否则建议选 &ldquo;N&rdquo;. 若使用了 CJKTTY 补丁, 则必须选 &ldquo;N&rdquo;.
Support for the Framebuffer Console Decorations
CONFIG_FB_CON_DECOR
允许在控制台上显示 背景图像, 例如在系统启动时, 在一堆滚动的字符背后显示漂亮的 背景图像. 当然, 要实现这个功能, 还需要用户空间程序的帮助. 详见 &quot; Documentation/fb/fbcondecor.txt&quot; 文档以及 fbsplash 的 wiki 页.
Bootup logo
CONFIG_LOGO
启动时显示 linux 的 logo(一幅企鹅图像), 企鹅的数量表示内核检测到的 CPU 数目, 喜欢炫一下的就选吧. 子项是三种不同质量的图片, 分别是黑白, 16 色, 224 色. 按需选择.
Sound card support
CONFIG_SOUND
声卡支持
Preclaim OSS device numbers
CONFIG_SOUND_OSS_CORE_PRECLAIM
开启此项后, 只要 OSS 支持被开启, 无论相应的模块是否被加载, 内核都会预先声明所有 OSS 设备号. 当其中一个设备被打开时, 将会尝试使用 &ldquo;sound-slot/service-<em>&rdquo; 与 &ldquo;char-major-</em>&rdquo; 两种别名去加载相应的模块. 关闭此项后, 内核将仅声明实际使用中的 OSS 设备号. 当打开一个不存在的设备时, 将会仅尝试使用标准的 &ldquo;char-major-<em>&rdquo; 别名去加载相应的模块. 由于 &ldquo;sound-slot/service-</em>&rdquo; 将会在未来移除, 此选项仅是一个为了兼容性而保留的过渡选项, 未来会被移除 (相当于设为 &ldquo;N&rdquo;).
Advanced Linux Sound Architecture
CONFIG_SND
ALSA(高级 Linux 声音架构) 是内核默认的声音子系统. ALSA 除了提供了声音设备的驱动, 还提供了一个用户空间的函数库, 这样用户空间程序就可以通过统一的 API 使用驱动功能, 而不必直接与内核驱动交互.[吐槽] Linux 音频系统, 比意大利面条更混乱的系统!
Sequencer support
CONFIG_SND_SEQUENCER
MIDI 音序器支持, 如果你是 MIDI 玩家, 请选 &ldquo;Y&rdquo;, 但如果你不知道 MIDI 是什么, 请选 &ldquo;N&rdquo;.
Sequencer dummy client
CONFIG_SND_SEQ_DUMMY
除非你要同时连接到多个 MIDI 设备或应用程序, 否则请不要选中
OSS Mixer API
CONFIG_SND_MIXER_OSS
模拟 OSS 混音器 API(/dev/mixer*), 某些老旧的程序仍然使用它, 建议不选
OSS PCM (digital audio) API
CONFIG_SND_PCM_OSS
模拟 OSS 数字音频 ( PCM)API(/dev/dsp*), 某些老旧的程序仍然使用它, 建议不选.
OSS PCM (digital audio) API - Include plugin system
CONFIG_SND_PCM_OSS_PLUGINS
让 ALSA 模拟的 OSS PCM API 支持 channel/format/rate 的转换. 选 &ldquo;N&rdquo;, 除非你确实知道为什么要选 &ldquo;Y&rdquo;.
OSS Sequencer API
CONFIG_SND_SEQUENCER_OSS
模拟 OSS 音序器 (/dev/sequencer,/dev/music), 某些老旧的程序仍然使用它, 建议不选
HR-timer backend support
CONFIG_SND_HRTIMER
允许将高精度定时器 (CONFIG_HIGH_RES_TIMERS) 用作 ALSA 高精度时间源, 建议选中
Use HR-timer as default sequencer timer
CONFIG_SND_SEQ_HRTIMER_DEFAULT
将高精度定时器 (HR-timer) 当作默认的时序脉冲发生器时间源, 建议选中
Dynamic device file minor numbers
CONFIG_SND_DYNAMIC_MINORS
动态分配 ALSA 设备的次设备号. 如果你有 8 个以上的声卡, 可以选 &ldquo;Y&rdquo;, 否则应该选 &ldquo;N&rdquo;.
Support old ALSA API
CONFIG_SND_SUPPORT_OLD_API
支持已被废弃的老旧版本的 ALSA PCM API, 选 &ldquo;N&rdquo;.
Verbose procfs contents
CONFIG_SND_VERBOSE_PROCFS
仅供调试使用
Verbose printk
CONFIG_SND_VERBOSE_PRINTK
仅供调试使用
Debug
CONFIG_SND_DEBUG
仅供调试使用
Generic sound devices
CONFIG_SND_DRIVERS
通用声音设备
PC-Speaker support (READ HELP!)
CONFIG_SND_PCSP
如果你有声卡, 务必选 &ldquo;N&rdquo;. 如果你的系统没有声卡, 仅在认真阅读了帮助之后, 确实知道自己在干什么的情况下, 才可以开启此项.
Dummy (/dev/null) soundcard
CONFIG_SND_DUMMY
仅供调试使用
Generic loopback driver (PCM)
CONFIG_SND_ALOOP
PCM 环回 (loopback) 设备非常类似于网卡的环回接口(127.0.0.1), 它会将输入的音频流原封不动的返回给用户空间. PCM 回环设备常用来将 A 程序输出的音频流作为 B 程序的输入(A 以写模式打开环回设备, 而 B 以读模式打开), 比如用 B 程序记录 A 程序的输出, 或做进一步的处理.
Virtual MIDI soundcard
CONFIG_SND_VIRMIDI
虚拟 MIDI 驱动, 允许将使用原始 MIDI 设备的应用程序连接到音序器客户端, 如果你不知道 MIDI 是什么就选 &ldquo;N&rdquo;.
{此处省略几种 MIDI 设备 (事实上大部分人都没有这些设备)} AC97 Power-Saving Mode
CONFIG_SND_AC97_POWER_SAVE
AC97(Audio Codec 97) 自动节能模式支持. 在此模式下, 如果音频设备闲置超过 &ldquo;/sys/module/snd_ac97_codec/parameters/power_save&rdquo; 设定的秒数 (&ldquo;0&rdquo; 表示关闭节能模式), 那么驱动程序将会关闭音频设备以节约电力. 建议选 &ldquo;Y&rdquo;. 详见 &quot; Documentation/sound/alsa/powersave.txt&quot; 文档.
Default time-out for AC97 power-save mode
CONFIG_SND_AC97_POWER_SAVE_DEFAULT
默认的超时秒数, 也就是 &ldquo;/sys/module/snd_ac97_codec/parameters/power_save&rdquo; 的默认值.&ldquo;0&rdquo; 表示关闭节能模式. 建议设为 &ldquo;10&rdquo; 这个久经考验的合理数字.
ISA sound devices
CONFIG_SND_ISA
基于 ISA 总线的声卡, 已经绝种了.
PCI sound devices
CONFIG_SND_PCI
基于 PCI 总线的声卡, 绝大多数声卡都是 PCI 接口
{此处省略的声卡按实际情况选择即可 (都是些比较旧的 AC97 声卡)} Intel HD Audio
CONFIG_SND_HDA_INTEL
符合 Intel HD Audio 规范的声卡是目前的主流声卡. 如果选 &ldquo;M&rdquo;, 那么下面的每个驱动也都会被编译成模块, 如果选 &ldquo;Y&rdquo;, 那么下面的每个驱动也都会直接编译进内核.
Pre-allocated buffer size for HD-audio driver
CONFIG_SND_HDA_PREALLOC_SIZE
为 HD-audio 驱动程序预先分配的缓冲区大小 (kB), 较大的值拥有更好的性能, 例如对于使用 PulseAudio 声音服务器的系统来说, 推荐使用 &ldquo;4096&rdquo;. 默认值 &ldquo;64&rdquo; 仅仅是为了历史兼容的原因.[提示]ALSA+PulseAudio 是目前的主流搭配.
Build hwdep interface for HD-audio driver
CONFIG_SND_HDA_HWDEP
为 HD-audio 驱动添加 hwdep 接口. 仅用于调试目的
Support digital beep via input layer
CONFIG_SND_HDA_INPUT_BEEP
为 HD-audio 驱动添加数字蜂鸣 (beep) 接口. 如果你的主板没有 蜂鸣器 (不是能够播放音乐的扬声器), 可以考虑选 &ldquo;Y&rdquo;.
Digital beep registration mode (0=off, 1=on)
CONFIG_SND_HDA_INPUT_BEEP_MODE
设为 &ldquo;0&rdquo; 表示默认禁用数字蜂鸣接口, 设为 &ldquo;1&rdquo; 表示默认启用数字蜂鸣接口.
Support jack plugging notification via input layer
CONFIG_SND_HDA_INPUT_JACK
通过输入层支持 JACK 插件通知. JACK 是一个比 PulseAudio 更专业的声音服务器, 重点是低延迟, 是专业音频软件 (例如: Ardour,Rezound,LinuxSampler) 首选的音频服务器. 如果你打算使用 JACK, 可以选 &ldquo;Y&rdquo;.[提示] 如果要 将 JACK 和 PulseAudio 一起使用, 需要安装 PulseAudio 的 JACK 支持模块.
Support initialization patch loading for HD-audio
CONFIG_SND_HDA_PATCH_LOADER
仅用于调试目的
{此处省略的 HD-audio 声卡按实际情况选择即可.[提示] 如果 CONFIG_SND_HDA_INTEL 被编译为模块, 这里的每一个驱动也都会被编译成模块.} Build HDMI/DisplayPort HD-audio codec support
CONFIG_SND_HDA_CODEC_HDMI
在 HD-audio 驱动中添加 HDMI 和 DisplayPort 支持. 如果你需要使用 HDMI/DisplayPort 接口, 可以选 &ldquo;Y&rdquo;.
Enable generic HD-audio codec parser
CONFIG_SND_HDA_GENERIC
通用 HD-audio 编解码器 ( codec) 支持, 必选.
Default time-out for HD-audio power-save mode
CONFIG_SND_HDA_POWER_SAVE_DEFAULT
HD-audio 自动节能模式默认的超时秒数.&ldquo;0&rdquo; 表示关闭节能模式. 建议设为 &ldquo;10&rdquo; 这个久经考验的合理数字. 详见 &quot; Documentation/sound/alsa/powersave.txt&quot; 文档与 CONFIG_SND_AC97_POWER_SAVE_DEFAULT 选项.
SPI sound devices
CONFIG_SND_SPI
基于 SPI 总线的声卡, 仅出现在嵌入式设备上
USB sound devices
CONFIG_SND_USB
基于 USB 总线的声卡, 主要是外接声卡, 并不常用
FireWire sound devices
CONFIG_SND_FIREWIRE
基于 IEEE-1394/FireWire/iLink 总线的声卡, 主要用于苹果的产品
PCMCIA sound devices
CONFIG_SND_PCMCIA
基于 PCMCIA 接口的声卡, 主要是外接声卡, 并不常用
ALSA for SoC audio support
CONFIG_SND_SOC
SoC 系统音频设备支持, 重点是节能支持. 仅用于嵌入式设备
Open Sound System (DEPRECATED)
CONFIG_SOUND_PRIME
OSS 早已被废弃 (已被 ALSA 取代). 选 &ldquo;N&rdquo;.
HID support
HID( 人机接口设备) 是一种定义计算机如何与人类交互的规范, 常与 USB 或蓝牙搭配使用, 常见的设备有: 键盘, 鼠标, 触摸板, 游戏杆, 遥控器, 蓝牙耳机, 游戏手柄, 手写板, 等等. 不过 HID 设备不一定要有人机接口, 只要符合 HID 规范, 就是 HID 设备.
HID bus support
CONFIG_HID
HID(human interface device) 总线及通用 HID 层. 要使用 HID 设备就必须开启.[提示]PS/2 接口的鼠标和键盘不是 HID 设备, USB 或蓝牙接口的才是 HID 设备.
Battery level reporting for HID devices
CONFIG_HID_BATTERY_STRENGTH
为那些支持 power_supply 类的 HID 电池, 向用户空间报告电池的剩余电量 (可以通过 upower 工具显示).
/dev/hidraw raw HID device support
CONFIG_HIDRAW
如果你想支持那些严格说来并不属于人机交互设备的硬件 (使用额外的 / dev/hidraw 接口), 例如显示控制装置(monitor control) 或不间断电源 (UPS) 以及某些罗技的无线鼠标接收器, 可以选 &ldquo;Y&rdquo;. 与 CONFIG_USB_HIDDEV 选项 (/dev/hiddev) 相比,/dev/hidraw 设备直接无视一切 hid 事件(既不解析也不查找), 这样就允许应用程序直接处理和操作原始的 hid 事件, 从而避免使用用户层 libhid/libusb 库. 详见 &quot; Documentation/hid/hidraw.txt&quot; 文档.
User-space I/O driver support for HID subsystem
CONFIG_UHID
HID 子系统需要两种驱动:(1)&ldquo;HID I/O Driver&rdquo; 是特定于硬件的驱动, 直接与底层总线交互, 并向 &ldquo;HID Device Driver&rdquo; 提供了一致接口用于收发 HID 数据.(2)&ldquo;HID Device Driver&rdquo; 是硬件无关的通用驱动, 其任务是按照 HID 规范解析和处理来自于 &ldquo;HID I/O Driver&rdquo; 的 HID 数据, 并将组装好的数据通过 &ldquo;HID I/O Driver&rdquo; 提供的统一接口发送给底层硬件. 开启此项后, 将允许在用户空间实现 &ldquo;HID I/O Driver&rdquo;. 不确定的选 &ldquo;N&rdquo;. 详见 &quot; Documentation/hid/uhid.txt&quot; 文档.
Generic HID driver
CONFIG_HID_GENERIC
HID 总线通用驱动, 也就是前面说的 &ldquo;HID Device Driver&rdquo;. 它实现了对各种常见 HID 协议的支持: 键盘, 鼠标, 游戏杆, 手写板, 数字画板. 不确定的选 &ldquo;Y&rdquo;.
Special HID drivers
各种不严格遵守 HID 协议的 &ldquo;HID Device Driver&rdquo;
{此处省略的硬件按实际情况选择即可} Lenovo ThinkPad USB Keyboard with TrackPoint
CONFIG_HID_LENOVO_TPKBD
带有 &ldquo;小红帽 (TrackPoint)&rdquo; 的联想 (Lenovo) ThinkPad USB 键盘.
Logitech devices
CONFIG_HID_LOGITECH
某些并不完全遵从 HID 标准的罗技 (Logitech) 外设
HID Multitouch panels
CONFIG_HID_MULTITOUCH
HID 多点触控 ( Multitouch) 板的通用支持
HID Sensors framework support
CONFIG_HID_SENSOR_HUB
HID 传感器支持框架. 详见 &quot; Documentation/hid/hid-sensor.txt&quot; 文档
USB HID support
基于 USB 接口的 HID 设备, 这是目前最常见的 HID 设备
USB HID transport layer
CONFIG_USB_HID
特定于 USB 接口的 &ldquo;HID I/O Driver&rdquo;. 用于和 USB 总线上的硬件进行交互. 只要你想使用任何基于 USB 接口的 HID 设备 (键盘, 鼠标, 游戏杆, 手写板, 手绘板, 不间断电源(UPS), 显示控制装置(monitor control), 等等), 就必须选 &ldquo;Y&rdquo;.[例外] 在嵌入式环境中使用的 HIDBP(HID Boot Protocol)键盘和鼠标不在此列, 而且两者也不能共存.
PID device support
CONFIG_HID_PID
PID 兼容的力反馈设备, 例如: Microsoft Sidewinder Force Feedback 2
/dev/hiddev raw HID device support
CONFIG_USB_HIDDEV
如果你想支持那些严格说来并不属于人机交互设备的硬件 (使用额外的 / dev/usb/hiddevX[char 180:96~111] 接口), 例如显示控制装置 (monitor control) 或不间断电源 (UPS) 以及某些罗技的无线鼠标接收器, 可以选 &ldquo;Y&rdquo;. 参见 CONFIG_HIDRAW 选项.
USB HID Boot Protocol drivers
如果你有绝对的把握确信不为自己的键盘和鼠标使用常规的 HID 驱动, 而要使用 Boot Protocol 模式的 HID 驱动 (常见于嵌入式环境) 就选吧
I2C HID support
基于 I2C 总线的 HID 设备
HID over I2C transport layer
CONFIG_I2C_HID
特定于 I2C 总线的 &ldquo;HID I/O Driver&rdquo;. 用于和 I2C 总线上的硬件进行交互. 只要你想使用任何基于 I2C 总线的 HID 设备 (键盘, 触摸板, 触摸屏, 等等), 就必须选 &ldquo;Y&rdquo;.I2C-HID 主要用于嵌入式设备.
USB support
CONFIG_USB_SUPPORT
通用串行总线 ( Universal Serial Bus) 的目标是统一电脑的外设接口. 目前几乎找不到没有 USB 接口的电脑, 而且各种智能设备也大多带有 USB 接口. 不要犹豫, 选 &ldquo;Y&rdquo;.
Support for Host-side USB
CONFIG_USB
主机端 (Host-side)USB 支持. 通用串行总线(USB) 是一个串行总线子系统规范, 它比传统的串口速度更快并且特性更丰富 (供电, 热插拔, 最多可接 127 个设备等), 其目标是统一 PC 外设接口. USB 总体上呈现一种树型结构, USB 的 &ldquo;Host&rdquo;(主设备) 被称为 &ldquo;根&rdquo;(也可以理解为是主板上的 USB 控制器),USB 的 &ldquo;Slave&rdquo;(从设备)被称为 &ldquo;叶子&rdquo;, 而内部的节点则称为 &ldquo;hub&rdquo;(集线器). 只要使用任何 USB 设备都必须选中此项. 另外, 你还需要从下面选中至少一个 HCD(Host Controller Driver), 比如适用于 USB1.1 的 &ldquo;UHCI HCD support&rdquo; 或 &ldquo;OHCI HCD support&rdquo;, 适用于 USB2.0 的 &ldquo;EHCI HCD (USB 2.0) support&rdquo;. 如果你拿不准的话把他们都选中一般也不会出问题. 如果你的系统有设备端的 USB 接口(也就是你的系统可以作为 &ldquo;叶子&rdquo; 使用), 请到 &ldquo;USB Gadget&rdquo; 中进行选择.
USB verbose debug messages
CONFIG_USB_DEBUG
仅供调试使用
USB announce new devices
CONFIG_USB_ANNOUNCE_NEW_DEVICES
在 syslog 中记录每个新接入系统的 USB 设备的详细标识信息 (idVendor,idProduct,Manufacturer,Product,SerialNumber), 主要用于系统调试. 不确定的选 &ldquo;N&rdquo;.
Enable USB persist by default
CONFIG_USB_DEFAULT_PERSIST
根据 USB 规范, 当 USB 总线被挂起 (休眠) 后, 它必须继续提供挂起电流 (1-5 毫安), 以确保 USB 设备能保持其内部状态, 并且 USB 集线器(HUB) 能够检测连接变化 (设备插入和拔出). 这在技术上被称为 &ldquo;电力会话&rdquo;(power session). 如果一个 USB 设备的电力会话被中断, 那么系统必须按照该设备已经被拔出进行处理, 这是一种保守的做法, 因为没有挂起电流, 计算机不可能知道外围设备究竟发生了什么变化: 也许依然保持连接, 也许已经被拔出并在同一端口上插入了一个新设备. 系统必须做最坏的打算. 默认情况下, Linux 的行为符合 USB 规范的要求. 当整个电脑进入休眠状态(例如挂起到硬盘) 时, 包括 USB 总线在内所有总线都将掉电, 然后当系统被唤醒, 所有 USB 设备都会被当做在休眠前就已经被拔出来处理. 这样做始终是安全的, 并且也是 &ldquo;官方正确&rdquo; 的做法. 对于大多数 USB 设备来说, 这样做没有任何问题, 但是对于 USB 存储设备 (例如移动硬盘 / U 盘) 来说, 如果在休眠前有尚未卸载的文件系统 (特别是根文件系统), 当系统被唤醒之后, 由于无法访问该文件系统, 系统可能会立即崩溃! 其实不只有掉电, 只要 &ldquo;power session&rdquo; 被中断(例如 BIOS 在唤醒过程中重置了 USB 控制器), 都会导致这种故障. 此选项(USB-persist) 就是为了解决这个问题而设置的, 虽然解决的不甚完美(参见 &quot; Documentation/usb/persist.txt&quot;), 但是依然推荐选&quot;Y&quot;, 除非你确实有选&quot;N&quot; 的理由. 当然, 最保险的做法是在休眠之前先卸载所有 USB 设备上的文件系统, 而如果根文件系统位于 USB 设备上, 就根本不使用任何休眠功能 (不论是挂起到硬盘还是挂起到内存).
Dynamic USB minor allocation
CONFIG_USB_DYNAMIC_MINORS
动态分配 USB 设备的次设备号 (仅限于主设备号为 180 的字符设备[通常位于 &ldquo;/dev/usb/&rdquo; 目录下]). 除非你有超过 16 个同类型(仅限: 打印机, 鼠标, 扫描仪) 的 USB 设备, 否则应选 &ldquo;N&rdquo;.[提示]即使你有 100 个 U 盘或者 USB 移动硬盘, 也不需要开启此项, 因为他们不是 &ldquo;主设备号为 180 的字符设备&rdquo;.
OTG support
CONFIG_USB_OTG
传统上, 码照相机, 手机, 打印机, 播放器, 移动硬盘等设备之间要交换数据, 都要作为 PC 的外围设备, 在 PC 的控制下进行数据交换. 一旦离开了 PC, 由于没有一个设备能够充当 PC 的 &ldquo;Host&rdquo; 角色, 所以无法直接通信. USB-OTG(On-The-Go) 就是为了解决这个问题而诞生的, 它是 USB2.0 规格的补充标准, 支持 &ldquo;双角色&rdquo; 设备 (既可以当 Host, 也可以当 Slave), 从而实现外围设备之间的数据传送. 例如, 将数码相机直接连接到打印机上将相片打印出来. 仅在你的主板上有 Mini-AB/ Micro-AB 接口 (目前仅用于嵌入式设备) 时才需要选 &ldquo;Y&rdquo;.
Rely on OTG and EH Targeted Peripherals List
CONFIG_USB_OTG_WHITELIST
将 &ldquo;otg_whitelist.h&rdquo; 文件用作 &ldquo;OTG Targeted Peripherals List&rdquo;(外设白名单), 白名单之外的 USB 外设将按照 OTG 规范的要求不被枚举 (也就是初始化). 同样,&ldquo;Embedded Host&rdquo; 也只支持限定的外设. 如果选 &ldquo;N&rdquo;, 那么白名单之外的外设也同样会被枚举 (但会产生一个警告), 这将大大方便嵌入式产品的开发.
Disable external hubs
CONFIG_USB_OTG_BLACKLIST_HUB
选 &ldquo;Y&rdquo; 将禁止枚举 (也就是初始化) 外部 USB 集线器(HUB). 这样, OTG 主机就可以通过省去对外部集线器的支持, 降低系统软硬件的成本. 不确定的选 &ldquo;N&rdquo;.
USB ULPI PHY interface support
CONFIG_USB_ULPI_BUS
ULPI(UTMI+ Low Pin Interface) 是一种 2005 年开始兴起的通用 USB 2.0 PHY 接口. 可有效地减少主机 / 外设 / On-The-Go(OTG)USB 收发器的针脚数量 (从 32 个减少到 12 个). 仅用于嵌入式设备.
USB Monitor
CONFIG_USB_MON
选 &ldquo;Y&rdquo; 后, 将可以捕获特定 USB 外设与 USB 主控器之间的数据流量, usbdump 和 usbmon 工具依赖于此项. 详见 &quot; Documentation/usb/usbmon.txt&quot; 文档.
Enable Wireless USB extensions
CONFIG_USB_WUSB
主机端的 WUSB( 无线 USB) 支持.
Support WUSB Cable Based Association (CBA)
CONFIG_USB_WUSB_CBAF
WUSB CBA(Cable Based Association) 是一项保障主机和 WUSB 设备之间通信安全的技术. 如果你的 WUSB 设备在建立无线连接前必须先建立有线连接, 可以选 &ldquo;Y&rdquo;.
Enable CBA debug messages
CONFIG_USB_WUSB_CBAF_DEBUG
仅供调试使用
Cypress C67x00 HCD support
CONFIG_USB_C67X00_HCD
Cypress C67x00 ( EZ-Host/ EZ-OTG) USB 1.1 &ldquo;双角色&rdquo; 控制器
xHCI HCD (USB 3.0) support
CONFIG_USB_XHCI_HCD
xHCI( eXtensible Host Controller Interface) 就是当下大红大紫的 USB3.0(SuperSpeed USB) 主机控制器规范.[提示] 因为 xHCI 移除了 EHCI 中为兼容 USB1.1 而引入的 &ldquo;Companion&rdquo; 模式, 所以仅用一个单独的 xHCI 驱动就可以兼容所有 USB3.0/2.0/1.1 外设. 也就是说, 对于蓝色的 USB3.0 接口来说, 开启此项之后, 就不需要再额外开启 EHCI/OHCI/UHCI 选项了.[注意] 如果你的电脑上除了蓝色的 USB3.0 接口, 还存在黑色的 USB2.0 接口, 那么你仍然需要开启 EHCI/OHCI/UHCI 选项, 除非你不想使用这些黑色的 USB2.0 接口.
Debugging for the xHCI host controller
CONFIG_USB_XHCI_HCD_DEBUGGING
仅供调试使用
Generic xHCI driver for a platform device
CONFIG_USB_XHCI_PLATFORM
通用 platform 设备的 xHCI 驱动. 仅用于嵌入式环境. 不确定的选 &ldquo;N&rdquo;.
EHCI HCD (USB 2.0) support
CONFIG_USB_EHCI_HCD
EHCI(Enhanced Host Controller Interface) 就是渐成昨日黄花的 USB2.0(HighSpeed USB) 主机控制器规范.[提示] 因为 EHCI 通过 &ldquo;Companion&rdquo; 模式来支持 USB1.1 设备, 所以一般还需要额外再开启 OHCI 或 UHCI 选项 (除非你不想兼容任何 USB1.1 设备). 详见 &quot; Documentation/usb/ehci.txt&quot; 文档.
Root Hub Transaction Translators
CONFIG_USB_EHCI_ROOT_HUB_TT
带有 USB2.0 接口的主板上都有一个 &ldquo;根集线器&rdquo;(Root Hub)以允许在无需额外购买 hub 的情况下就可以提供多个 USB 插口, 而大多数主板还在其中集成了事务转换 (Transaction Translator) 功能, 这样就不需要再额外使用一个 OHCI 或 UHCI 控制器来兼容 USB1.1, 建议选 &ldquo;Y&rdquo;, 除非你不想兼容任何 USB1.1 设备.
Improved Transaction Translator scheduling
CONFIG_USB_EHCI_TT_NEWSCHED
改变周期性调度代码的工作方式, 当多个 USB1.1 设备连接在同一个 USB2.0 集线器上时, 可以获得更高的运行速度. 建议选 &ldquo;Y&rdquo;
Generic EHCI driver for a platform device
CONFIG_USB_EHCI_HCD_PLATFORM
通用 platform 设备的 EHCI 驱动. 仅用于嵌入式环境. 不确定的选 &ldquo;N&rdquo;.
OHCI HCD support
CONFIG_USB_OHCI_HCD
OHCI(Open Host Controller Interface) 是主要用于嵌入式环境的 USB1.1(LowSpeed/FullSpeed USB) 主机控制器规范. 但也存在于某些老旧的 SiS 芯片组的 PC 上.
UHCI HCD (most Intel and VIA) support
CONFIG_USB_UHCI_HCD
UHCI(Universal Host Controller Interface) 是主要用于 PC 环境的 USB1.1(LowSpeed/FullSpeed USB) 主机控制器规范.
{此处省略的 USB 控制器请按照实际硬件状况选择 (基本上都仅用于嵌入式环境)} Wireless USB Host Controller Interface (WHCI) driver
CONFIG_USB_WHCI_HCD
WHCI( Wireless USB Host Controller Interface) 是 无线 USB 主机控制器规范. 目前市场上带有 WUSB 主控器的主板很少. 不确定的选 &ldquo;N&rdquo;.
Host Wire Adapter (HWA) driver
CONFIG_USB_HWA_HCD
USB 接口的 3G/4G 无线上网卡 (通常需要搭配 SIM 卡使用), 常见制式有: WCDMA/LTE/HSPA 等.
BCMA usb host driver
CONFIG_USB_HCD_BCMA
BCMA(Broadcom specific AMBA) 总线上的 EHCI/OCHI 主机控制器支持. 仅用于嵌入式环境.
SSB usb host driver
CONFIG_USB_HCD_SSB
BCMA(Broadcom specific AMBA) 总线上的 EHCI/OCHI 主机控制器支持. 仅用于嵌入式环境.
Inventra Highspeed Dual Role Controller (TI, ADI, &hellip;)
CONFIG_USB_MUSB_HDRC
一系列基于 Mentor Graphics 公司 silicon  IP 核的 USB 控制器. 仅用于嵌入式环境.
Renesas USBHS controller
CONFIG_USB_RENESAS_USBHS
一系列基于 Renesas 公司 USBHS  IP 核的 USB 控制器. 仅用于嵌入式环境.
USB Modem (CDC ACM) support
CONFIG_USB_ACM
USB 接口的猫或 ISDN 适配器, 基本没人用的东西.
USB Printer support
CONFIG_USB_PRINTER
USB 接口的打印机, 这是主流的打印机
USB Wireless Device Management support
CONFIG_USB_WDM
为符合 CDC(Communication Device CIass) 和 WMC(Wireless Mobile Communication) 标准的手机提供 WMC 设备管理支持, 这样你可以在这些手机上使用 AT 命令 (被所有调制解调器制造商采用的一个调制解调器命令语言).
USB Test and Measurement Class support
CONFIG_USB_TMC
USBTMC(USB Test and Measurement Class) 协议支持. 主要适用于测试仪器的 USB 通信开发. 不确定的选 &ldquo;N&rdquo;.
USB Mass Storage support
CONFIG_USB_STORAGE
USB 存储设备 (U 盘, USB 硬盘, USB 软盘, USB 光盘, USB 磁带, 记忆棒, 数码相机, 读卡器 [包括某些笔记本内置的 SD 卡读卡器] 等等). 该选项依赖于 CONFIG_SCSI 和 CONFIG_BLK_DEV_SD 选项. 选 &ldquo;Y&rdquo;, 除非你确实知道自己在干什么.
USB Mass Storage verbose debug
CONFIG_USB_STORAGE_DEBUG
仅供调试使用
{省略的部分请按照自己实际使用的硬件选择 (事实上大部分人都没有这些设备)}
USB Mustek MDC800 Digital Camera support
CONFIG_USB_MDC800
一款上世纪生产的数码相机
Microtek X6USB scanner support
CONFIG_USB_MICROTEK
几款上世纪生产的扫描仪
DesignWare USB3 DRD Core Support
CONFIG_USB_DWC3
基于 DesignWare USB3 IP 核的 USB3.0 控制器. 仅用于嵌入式环境.
ChipIdea Highspeed Dual Role Controller
CONFIG_USB_CHIPIDEA
基于 ChipIdea silicon IP 核的 USB2.0 控制器. 仅用于嵌入式环境.
USS720 parport driver
CONFIG_USB_USS720
一种 USB 转并口的转换设备. 不确定的选 &ldquo;N&rdquo;.
USB Serial Converter support
CONFIG_USB_SERIAL
USB - 串口转换支持:(1)USB - 串口转换器,(2) 连接在 USB 口上的串口设备. 详情参见 &quot; Documentation/usb/usb-serial.txt&quot;文档. 不确定的选&quot;N&quot;.
{此处省略的各种杂七杂八的 USB 设备, 要么是老古董, 要么是很罕见, 不确定的可以全部选 &ldquo;N&rdquo;} USB testing driver
CONFIG_USB_TEST
仅供调试使用
USB DSL modem support
CONFIG_USB_ATM
USB DSL modem 已经是绝迹的古董猫了
USB Physical Layer drivers
CONFIG_USB_PHY
这类设备仅在嵌入式系统上存在
USB Gadget Support
CONFIG_USB_GADGET
USB 是一个主 / 从协议, 一个主机最多控制 127 个外设, 其结构是非对称的, 所以你无法把一个 &ldquo;到主机&rdquo; 的插头连接到外设上. Linux 既可以在 USB 主机上运行, 也可以在 USB 外设上运行. 外设 USB 控制器可以是单独的芯片, 也可以是集成在 CPU 中的微控制器, 而常见的主机端控制器通常集成在芯片组的南桥中 (xHCI/EHCI/OHCI/UHCI). 如果你打算在外设中运行 Linux, 那么就必须开启此项, 然后还需要为外设段的总线控制器配置一个硬件驱动, 以及一个用于外设协议的 &ldquo;配件驱动&rdquo;. 不过对于大多数人来说, 并不将 Linux 运行于外设端, 因此可以放心的选 &ldquo;N&rdquo;. 仅那些嵌入式设备(例如智能手机) 上运行的 Linux 才可能由此需求.
Ultra Wideband devices
CONFIG_UWB
UWB( Ultra Wideband)是一种高带宽, 低能耗, 点对点, 抗干扰性能强的无载波通信技术. UWB 在较宽的频谱 (3.1-10.6GHz) 上, 使用极低的功率 (约为蓝牙的 1/20), 以时间间隔极短(小于 1ns) 的脉冲信号进行通信. UWB 主要应用于室内通信(2 米范围内实现 480Mbps 速率, 10 米范围内实现 110Mbps 速率), 例如 作为 WUSB(Wireless USB) 协议的传输层. 如果你有 UWB 无线控制器, 可以选 &ldquo;Y&rdquo;, 不确定的选 &ldquo;N&rdquo;. 详见 &quot; Documentation/usb/WUSB-Design-overview.txt&quot; 文档.
MMC/SD/SDIO card support
CONFIG_MMC
MMC( MultiMediaCard)/ SD( Secure Digital)/ SDIO( Secure Digital I/O) 主机控制器。[提示] 虽然许多笔记本上有 SD 卡插槽, 但其实它们大多使用的是 CONFIG_USB_STORAGE 驱动, 而不是这里的驱动.
MMC debugging
CONFIG_MMC_DEBUG
仅供调试使用
Assume MMC/SD cards are non-removable (DANGEROUS)
CONFIG_MMC_UNSAFE_RESUME
假定在系统休眠的过程中, 所有 MMC/SD/SDIO 卡依然插在各自的插槽上没有变动. 也许只有嵌入式系统才可以做这样的假定. 不确定的选 &ldquo;N&rdquo;. 参见 CONFIG_USB_DEFAULT_PERSIST 选项.
MMC host clock gating
CONFIG_MMC_CLKGATE
尝试激进的 &ldquo;gate the clock to the MMC card&rdquo;(啥意思?). 这样当 MMC 卡不使用的时候, 就可以进入节电状态. 主机控制器必须支持此特性. 不确定的选 &ldquo;N&rdquo;.
MMC block device driver
CONFIG_MMC_BLOCK
MMC 块设备驱动. 基本上 MMC 卡都是作为块设备 (就像 U 盘一样) 使用. 所以只要使用 MMC 卡就应该开启.
Number of minors per block device
CONFIG_MMC_BLOCK_MINORS
为每个 MMC 块设备保留的次设备号数量. 取值范围是 [4,256]. 这里设置的值应该等于 &ldquo;最大可能的分区数 + 1&rdquo;. 因为总的次设备号只有 256 个, 所以最大能支持的 MMC 块设备数量就等于 256 除以此处设置的值. 默认值 &ldquo;8&rdquo; 可以保证最大的向后兼容性. 不确定的请保持默认值.
Use bounce buffer for simple hosts
CONFIG_MMC_BLOCK_BOUNCE
为 SD/MMC 控制器提供更多的缓存 (最大 64KB), 从而可以大幅提升其性能. 建议选 &ldquo;Y&rdquo;.
SDIO UART/GPS class support
CONFIG_SDIO_UART
实现了 UART 类的 SDIO 卡支持. 包括那些表现的像 UART 一样的 GPS 类支持. 主要用于嵌入式设备. 不确定的选 &ldquo;N&rdquo;.
MMC host test driver
CONFIG_MMC_TEST
仅供调试使用
Secure Digital Host Controller Interface support
CONFIG_MMC_SDHCI
通用 SD 主控支持. 笔记本电脑上用的 SD 主控 (TI(德州仪器)/Ricoh(理光)/Toshiba(东芝) 等厂商)基本上都是这个驱动. 选中此项后, 还需要选中相应的总线驱动(见下, 通常是 CONFIG_MMC_SDHCI_PCI).
SDHCI support on PCI bus
CONFIG_MMC_SDHCI_PCI
PCI 总线的 SD 主控支持, 目前的笔记本的 SD 主控基本都接在 PCI 总线上.
Ricoh MMC Controller Disabler
CONFIG_MMC_RICOH_MMC
用于修正 Ricoh(理光)MMC 主控的 bug, 如果你需要使用 Ricoh 主控, 就选 &ldquo;Y&rdquo;.
SDHCI support for ACPI enumerated SDHCI controllers
CONFIG_MMC_SDHCI_ACPI
专用于 &ldquo;ACPI Compatibility ID&rdquo; 等于 &ldquo;PNP0D40&rdquo; 的 SD 主控, 以及 &ldquo;ACPI Hardware ID&rdquo; 等于 &ldquo;INT33C6,INT33BB,80860F14&rdquo; 的 SD 主控.
SDHCI platform and OF driver helper
CONFIG_MMC_SDHCI_PLTFM
基于 platform 总线和 OpenFirmware 的 SD 主控.
{此处省略的 SD 主控请按照实际使用的芯片进行选择} MMC/SD/SDIO over SPI
CONFIG_MMC_SPI
基于 SPI 总线的 MMC/SD/SDIO 主控. 仅用于嵌入式环境.
Sony MemoryStick card support
CONFIG_MEMSTICK
Sony 记忆棒是一种 Sony 专用的存储设备.
MemoryStick debugging
CONFIG_MEMSTICK_DEBUG
仅供调试使用
Allow unsafe resume (DANGEROUS)
CONFIG_MEMSTICK_UNSAFE_RESUME
假定在系统休眠的过程中, 所有记忆棒依然插在各自的插槽上没有变动. 也许只有嵌入式系统才可以做这样的假定. 不确定的选 &ldquo;N&rdquo;. 参见 CONFIG_USB_DEFAULT_PERSIST 选项.
MemoryStick Pro block device driver
CONFIG_MSPRO_BLOCK
&ldquo;Memory Stick PRO&rdquo; 是 SONY 从 2003 开始引入的升级版标准, 早已成为主流, 所以应该选 &ldquo;Y&rdquo;(除非你仍在使用十年前的老 VAIO 笔记本).
{此处省略的 MemoryStick 主控请按照实际使用的芯片进行选择}
LED Support
CONFIG_NEW_LEDS
发光二级管 (LED) 支持.[提示]标准键盘上的 LED 灯不在此列(由 input 子系统控制)
Accessibility support
CONFIG_ACCESSIBILITY
无障碍 (Accessibility) 支持. 各种帮助残疾人使用计算机的软硬件技术. 例如: 盲文设备, 语音合成, 键盘映射, 等等.
InfiniBand support
CONFIG_INFINIBAND
InfiniBand 是一种低延迟 / 高带宽数据中心互联架构, 采用远程直接内存存取 (RDMA) 实现高性能处理器间通信 (IPC), 同时对虚拟化技术也提供了良好的支持. 主要用于服务器集群与高性能计算(HPC) 领域.
EDAC (Error Detection And Correction) reporting
CONFIG_EDAC
在电磁环境比较恶劣的情况下, 一些大规模集成电路常常会受到干扰, 特别是像 RAM 这种利用双稳态进行存储的器件, 往往会在强干扰下发生翻转, 使原来存储的 &ldquo;0&rdquo; 变为 &ldquo;1&rdquo;, 或者 &ldquo;1&rdquo; 变为 &ldquo;0&rdquo;, 造成严重的后果 (例如控制程序跑飞, 关键数据出错). 随着芯片集成度的增加, 发生错误的可能性也在增大, 这已经成为一个不能忽视的问题. 错误检测与纠正 ( EDAC) 技术的目标就是发现并报告甚至纠正在计算机系统中发生的错误, 这些错误是由 CPU 或芯片组报告的底层错误 (内存错误 / 缓存错误 / PCI 错误 / 温度过高, 等等), 建议选 &ldquo;Y&rdquo;. 如果这些代码报告了一个错误, 请到 <a href="http://bluesmoke.sourceforge.net/">http://bluesmoke.sourceforge.net/</a> 和 <a href="http://buttersideup.com/edacwiki">http://buttersideup.com/edacwiki</a> 查看更多信息. 详见 &quot; Documentation/edac.txt&quot; 文档.
EDAC legacy sysfs
CONFIG_EDAC_LEGACY_SYSFS
仅在你需要使用老版本 edac-utils 的情况下才需要选 &ldquo;Y&rdquo;.
Debugging
CONFIG_EDAC_DEBUG
仅供调试使用
Decode MCEs in human-readable form (only on AMD for now)
CONFIG_EDAC_DECODE_MCE
将 MCE( Machine Check Exception) 解码为人类可读的形式 (目前仅支持 AMD). 建议选 &ldquo;Y&rdquo;.
Simple MCE injection interface over /sysfs
CONFIG_EDAC_MCE_INJ
仅供调试使用
Main Memory EDAC (Error Detection And Correction) reporting
CONFIG_EDAC_MM_EDAC
一些系统能够检测和修正主内存中的错误, EDAC 能够报告这些信息 (EDAC 自己检测到的或者根据 ECC 得到的).EDAC 还会尽量检测这些错误发生在哪里以便于替换损坏的内存. 建议选 &ldquo;Y&rdquo; 并按照你实际硬件状况选取子项
Output ACPI APEI/GHES BIOS detected errors via EDAC
CONFIG_EDAC_GHES
并不是所有机器都提供基于硬件的 EDAC 技术, 有部分机器提供的是基于 ACPI BIOS 的报告机制 (使用 CONFIG_ACPI_APEI_GHES 驱动). 开启此项后, 如果检测到 GHES BIOS, 那么 CONFIG_ACPI_APEI_GHES 驱动提供的错误报告将会通过 EDAC API 发送到用户空间, 同时, 硬件 EDAC 也会被禁用, 也就是进入 &ldquo;固件优先&rdquo; 模式. 注意: GHES BIOS 和硬件 EDAC 两者不能共存, 因为 BIOS 和操作系统在读取 error 寄存器时会相互竞争. 所以如果你不想使用 &ldquo;固件优先&rdquo; 模式, 应该选 &ldquo;N&rdquo;, 或者使用 &ldquo;ghes.disable=1&rdquo; 内核引导参数. 否则应该选 &ldquo;Y&rdquo;.
{此处省略的芯片请按照实际情况选择}
Real Time Clock
CONFIG_RTC_CLASS
通用 RTC(实时时钟) 类支持. 所有的 PC 机主板都包含一个电池动力的 实时时钟芯片, 以便在断电后仍然能够继续保持时间, RTC 通常与 CMOS 集成在一起, 因此 BIOS 可以从中读取当前时间 (精度一般是秒级). 选中此项后你就可以在操作系统中使用一个或多个 RTC 设备 (你还必须从下面启用一个或多个 RTC 接口).[注意]Clock 与 Timer 没有任何关系, Timer 是定时器 (用于计量时长),Clock 是时钟 (用于记录当前的时刻 &ldquo;年 - 月 - 日 时: 分: 秒&rdquo;)
Set system time from RTC on startup and resume
CONFIG_RTC_HCTOSYS
系统启动时从指定的 RTC 设备 (CONFIG_RTC_HCTOSYS_DEVICE) 中读取时间, 以设定系统时间, 这将有助于避免时间不准导致的麻烦 (例如不必要的文件系统检测(fsck) 以及网络故障). 建议选 &ldquo;Y&rdquo;.
Set the RTC time based on NTP synchronization
CONFIG_RTC_SYSTOHC
如果用户空间报告了 &quot; NTP 已同步 &ldquo;, 那么每隔大约 11 分钟, 内核将会自动把系统时间写入指定的 RTC 设备 (CONFIG_RTC_HCTOSYS_DEVICE) 中. 建议选&quot;Y&rdquo;.
RTC used to set the system time
CONFIG_RTC_HCTOSYS_DEVICE
默认的 RTC 设备 (通常是 &ldquo;rtc0&rdquo;). 该设备的驱动必须静态编译进内核 (而不能作为模块加载).
RTC debug support
CONFIG_RTC_DEBUG
仅供调试使用
/sys/class/rtc/rtcN (sysfs)
CONFIG_RTC_INTF_SYSFS
允许通过 sysfs 接口使用 RTC, 允许多个 RTC 设备, 也就是 / sys/class/rtc/rtc0~N
/proc/driver/rtc (procfs for rtcN)
CONFIG_RTC_INTF_PROC
允许通过 proc 接口使用 RTC, 仅允许一个 RTC 设备, 也就是 / proc/driver/rtc(若有多个 RTC 设备, 则其将对应 &ldquo;rtc0&rdquo;)
/dev/rtcN (character devices)
CONFIG_RTC_INTF_DEV
允许通过 dev 接口使用 RTC, 允许多个 RTC 设备, 也就是 / dev/rtc0~N, 某些程序 (比如 hwclock) 需要使用 / dev/rtc(这是个软连接, udev 会自动将其指向默认的 RTC 设备)
RTC UIE emulation on dev interface
CONFIG_RTC_INTF_DEV_UIE_EMUL
如果底层 rtc 芯片驱动没有提供 RTC_UIE 就仿真一个 RTC_UIE. 选 &ldquo;N&rdquo;, 除非你确实知道自己在做什么.
Test driver/device
CONFIG_RTC_DRV_TEST
仅供调试使用
{此处省略的其他 RTC 设备一般仅用于非 PC 环境} PC-style &lsquo;CMOS&rsquo;
CONFIG_RTC_DRV_CMOS
这是所有 PC 和基于 ACPI 的系统通用的 RTC 驱动. 必须选 &ldquo;Y&rdquo;(不能选 &ldquo;M&rdquo;), 除非你是嵌入式系统.
DMA Engine support
CONFIG_DMADEVICES
DMA 引擎 ( DMA Engine)可以看做是传统 DMA 控制器 (DMA controller) 的新生. 在 DMA 引擎的协助下, CPU 只需初始化一个传输动作, 其余的动作就可以由 DMA 引擎独立完成 (完成后以中断的方式通知 CPU), 这对于高速传输大量数据以及 &ldquo;分散 - 收集&rdquo; 操作大有益处, 可以节约大量的 CPU 资源(有时也可节约大量的内存操作). 目前, DMA 引擎有两个用途:(1) 卸载高速网络栈中的内存 COPY 操作,(2)加速 CONFIG_MD_RAID456 驱动中的 RAID 操作.&ldquo;DMA 引擎&rdquo; 只是一个统称, 在不同场合对应着不同的技术, 例如 Intel I/OAT(PC 平台) 和 AHB(嵌入式).[提示] 历史上, ISA 架构的电脑都有一个专用的 &ldquo;DMA 控制器&rdquo;(最常见的是 Intel 8237), 但是到了 PCI 架构, 由于每一个 PCI 设备都可以控制 PCI 总线 (成为 &quot; bus master&quot;) 并直接读写系统内存, 所以虽然 DMA 的操作方式依然存在, 但是&quot;DMA 控制器 &ldquo;却消失了. 现在新生的&quot;DMA 引擎 &quot; 目前仍然主要出现在 Intel 的高端芯片上.
DMA Engine debugging
CONFIG_DMADEVICES_DEBUG
仅供调试使用
Intel MID DMA support for Peripheral DMA controllers
CONFIG_INTEL_MID_DMAC
Intel  MID DMA 引擎, 搭配 Atom 处理器使用.
Intel integrated DMA 64-bit support
CONFIG_INTEL_IDMA64
为 Intel 低功耗子系统 (Intel Low Power Subsystem) 中整合的 64 位 DMA 提供支持. Intel  Skylake  PCH 就是一个支持 Intel 低功耗子系统的例子.
Intel I/OAT DMA support
CONFIG_INTEL_IOATDMA
带有 英特尔 I/O 加速技术 ( I/O Acceleration Technology) 的至强芯片组 DMA 引擎
Synopsys DesignWare AHB DMA support
CONFIG_DW_DMAC
基于 Synopsys DesignWare IP 核的 AHB 总线 DMA 引擎. 例如 Atmel  AT32ap7000 中就整合了这个引擎.
Timberdale FPGA DMA support
CONFIG_TIMB_DMA
Timberdale FPGA DMA 引擎.&ldquo;Timberdale FPGA&rdquo; 是一个多功能设备, 出现在基于 Intel Atom 的车载信息娱乐系统 IVI(In-Vehicle Infotainment) 上.
Intel EG20T PCH / LAPIS Semicon IOH(ML7213/ML7223/ML7831) DMA
CONFIG_PCH_DMA
所有与 Intel EG20T PCH 兼容的芯片的 DMA 引擎支持, 具体型号可以查看内核帮助. 都是嵌入式芯片.
Network: TCP receive copy offload
CONFIG_NET_DMA
通过在网络栈中利用 DMA 引擎来减少接收数据包时的 copy-to-user 操作以释放 CPU 资源, 仅在 CONFIG_INTEL_IOATDMA 开启的前提下才有意义.
Async_tx: Offload support for the async_tx api
CONFIG_ASYNC_TX_DMA
如果你开启了 CONFIG_MD_RAID456, 同时你的硬件又支持 DMA 引擎, 那么开启此项后可以加速 RAID 操作.
DMA Test client
CONFIG_DMATEST
仅供调试使用
Auxiliary Display support
CONFIG_AUXDISPLAY
辅助显示设备. 例如基于 KS0108 控制器的 Crystalfontz CFAG12864B 单色液晶屏 (分辨率: 128x64). 仅用于嵌入式系统.
Userspace I/O drivers
CONFIG_UIO
UIO(Userspace I/O) 是运行在用户空间的 I/O 技术, 它为开发用户空间的驱动提供了一个简单的架构 (/dev/uioN). 使用 uio 的设备一般都属于嵌入式系统. 不确定的选 &ldquo;N&rdquo;.[提示] lsuio 工具可以列出所有 UIO 的模块和其映射的内存地址.
VFIO Non-Privileged userspace driver framework
CONFIG_VFIO
VFIO 是一套无特权用户空间 I/O 驱动框架, 需要有 IOMMU 虚拟化硬件支持 (AMD-Vi/ Intel VT-d). 此选项仅用于宿主机内核. VFIO 的目标是在 IOMMU 硬件的帮助下, 取代 CONFIG_UIO 和 CONFIG_KVM_DEVICE_ASSIGNMENT.VFIO 主要用于编写高效的用户态驱动, 以及在虚拟化环境的属主机中高效的实现 设备直通 (passthrough) 且无须 root 特权, 可用于详见 &quot; Documentation/vfio.txt&rdquo; 文档.[提示] QEMU 1.3 以上版本才能利用 VFIO 特性. 不玩 KVM 虚拟化的选 &ldquo;N&rdquo;.
VFIO support for PCI devices
CONFIG_VFIO_PCI
允许 PCI 设备使用 VFIO 框架. 这是 VFIO 框架当前的主要用途. 选 &ldquo;Y&rdquo;.
VFIO PCI support for VGA devices
CONFIG_VFIO_PCI_VGA
让 VFIO PCI 支持 VGA 扩展, 此选项依赖于 CONFIG_VGA_ARB, 建议选 &ldquo;Y&rdquo;.
Virtualization drivers
CONFIG_VIRT_DRIVERS
这个选项仅对 PowerPC 架构有意义
Virtio drivers
仅可用于客户机内核的 Virtio 驱动. Virtio 的目标是为各种半虚拟化的 虚拟机管理程序 (特别是 KVM) 提供一组通用的模拟设备, 目前已实现: network/block/balloon/console/hw_random, 未来还会实现更多. 下列驱动仅可用在基于 lguest 或 QEMU 的半虚拟化客户机中 (一般是 KVM 或 XEN).
PCI driver for virtio devices
CONFIG_VIRTIO_PCI
半虚拟化 PCI 设备驱动. VMM(虚拟机管理程序) 必须要有相应的 &ldquo;PCI virtio backend&rdquo;. 基于 QEMU 的 VMM(KVM,Xen) 一般都支持该驱动.[提示] 由于目前的 ABI 尚不稳定, 建议使用时注意版本匹配.
Virtio balloon driver
CONFIG_VIRTIO_BALLOON
balloon 驱动支持按需扩展或减少 KVM 客户机内的内存大小.
Platform bus driver for memory mapped virtio devices
CONFIG_VIRTIO_MMIO
支持使用内存映射机制的 virtio 设备驱动
Memory mapped virtio devices parameter parsing
CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES
允许通过 &ldquo;virtio_mmio.device&rdquo; 内核模块参数实例化 virtio-mmio 设备. 注意, 错误的参数 (特别是 &ldquo;baseaddr&rdquo; 错误) 会导致系统崩溃. 详见 &quot; Documentation/kernel-parameters.txt&quot;文档中对&quot;virtio_mmio.device&quot; 的说明.
Microsoft Hyper-V guest support
仅在将此 Linux 内核作为 微软 Hyper-V 虚拟机的来宾操作系统运行时, 才需要开启这里的选项.
Microsoft Hyper-V client drivers
CONFIG_HYPERV
将 Linux 内核作为 Hyper-V 的来宾操作系统运行
Microsoft Hyper-V Utilities driver
CONFIG_HYPERV_UTILS
Hyper-V 管理工具驱动.
Microsoft Hyper-V Balloon driver
CONFIG_HYPERV_BALLOON
Hyper-V  Balloon 驱动
Xen driver support
仅在将此 Linux 内核作为半虚拟化模式的 XEN 虚拟机的来宾操作系统运行时, 才需要开启这里的选项. 由于 KVM 的高歌猛进, 特别是 Ubuntu 和 Redhat 的力挺, 与昔日的辉煌相比, XEN 现在已经没落许多了.
Staging drivers
CONFIG_STAGING
尚在开发中或尚未完成的, 目前尚不完善的驱动, 切勿用于生产环境. 仅供测试人员或者开发者试用.
X86 Platform Specific Device Drivers
CONFIG_X86_PLATFORM_DEVICES
特定于 X86 平台的设备驱动. 例如很多笔记本厂商的专有硬件和特色功能. 大多数笔记本用户都应该进去看看 (简单易懂, 一看即知).
{此处省略所有特定于笔记本厂商的驱动} Thermal Management driver for Intel menlow platform
CONFIG_INTEL_MENLOW
此驱动专用于 Intel Menlow 平台 (搭配 Atom 处理器), 提供了增强的 ACPI 热量管理能力.
WMI
CONFIG_ACPI_WMI
ACPI-WMI( Windows 管理规范)映射设备 (find /sys/devices/ -name &ldquo;PNP0C14*&rdquo;) 支持. WMI 是微软对 ACPI 规范的专有扩展, 可将部分 ACPI 固件内容通过 PNP0C14 设备映射到用户空间, 以方便用户空间调用 ACPI 固件的功能. 本选项仅为那些依赖于 WMI 的驱动提供支持 (并不真正导出到用户空间), 例如 CONFIG_DRM_NOUVEAU 驱动以及专用于 Acer/Asus/Dell/MSI/HP 等品牌笔记本的 WMI 驱动.
Intel Intelligent Power Sharing
CONFIG_INTEL_IPS
Intel  Calpella 平台支持 Intel 的智能电源共享 (Intelligent Power Sharing) 技术, 可以在保持功耗不变的前提下, 在 CPU 和 GPU 之间智能分配电力. 开启此项和 CONFIG_CPU_FREQ 以及 CONFIG_DRM_I915 之后, 即可实现此功能.
WMI support for MXM Laptop Graphics
CONFIG_MXM_WMI
MXM 接口笔记本显卡的 WMI 支持. 目前主要用于 nvidia 显卡.
Intel Oaktrail Platform Extras
CONFIG_INTEL_OAKTRAIL
Intel  Oak Trail 嵌入式平台需要此驱动来开关 WiFi / 相机 / 蓝牙等设备.
Intel Rapid Start Technology Driver
CONFIG_INTEL_RST
英特尔快速启动技术 ( Intel Rapid Start Technology) 通过在 SSD 上建立与本机内存容量一致的休眠分区, 在休眠时将内存数据保存到 SSD 休眠分区上, 从而实现快速唤醒.
Intel Smart Connect disabling driver
CONFIG_INTEL_SMARTCONNECT
禁用 英特尔智能连接技术 ( Intel Smart Connect Technology)的驱动. 此技术旨在通过定期将处于睡眠 / 待机状态的 PC 唤醒一小段时间, 联网一段时间让应用程序 (如电子邮件) 更新, 但是不打开屏幕, 然后又自动回到睡眠状态, 以此循环重复. 这意味着, 当您唤醒 PC 时, 程序数据已经处于最新状态. 主要针对超级本用户且需要 BIOS 支持, 必须在 BIOS 中将 Intel Smart Connect Technology 设为 &ldquo;Enabled&rdquo;. 如果你的超级本支持此技术且同时安装了 Windows 系统, 那么务必选 &ldquo;Y&rdquo;.
pvpanic device support
CONFIG_PVPANIC
pvpanic 是 QEMU 提供的一种准虚拟化 (paravirtualized) 设备, 允许客户机向宿主机报告 panic 事件. 此驱动仅可用于客户机内核.
Intel PMC IPC Driver
CONFIG_INTEL_PMC_IPC
为某些 Intel 平台的 PMC 控制器提供支持. 这里的 &ldquo;PMC&rdquo; 是一个 RISC 架构的 32 位 ARC 处理器 (Argonaut RISC Core processor). 不确定的选 &ldquo;N&rdquo;.
Platform support for Chrome hardware
CONFIG_CHROME_PLATFORMS
专用于 Google 公司的 Chromebook 笔记本 / Chromebox 迷你机的设备驱动.
Common Clock Framework
CCF( Common Clock Framework) 是从 3.4 内核开始引入的新时钟框架, 用于取代原有的 &ldquo;Clock Framework&rdquo;. 详见 &quot; Documentation/clk.txt&quot; 文档. 这里还有一个 讲解 CCF 的 PDF.
DebugFS representation of clock tree
CONFIG_COMMON_CLK_DEBUG
仅供调试使用
{此处省略的时钟设备请按实际情况选择 (主要用于嵌入式设备)}
Hardware Spinlock drivers
硬件 自旋锁驱动. 目前仅出现在嵌入式处理器上. 自旋锁是保护共享资源的一种锁机制, 与互斥锁比较类似, 都是为了解决对某项资源的互斥使用. 无论是互斥锁, 还是自旋锁, 在任何时刻, 最多只能有一个持有者. 也就是说, 在任何时刻最多只能有一个执行单元获得锁. 但是两者在调度机制上略有不同, 对于互斥锁, 如果资源已经被占用, 资源申请者只能进入睡眠状态. 但是自旋锁不会引起申请者睡眠, 如果自旋锁已经被别的执行单元保持, 调用者就一直在循环中 &ldquo;忙等&rdquo;(占用 CPU 但无事可做), 直到该自旋锁被释放.&ldquo;自旋&rdquo; 一词就是因此而得名. 自旋锁的使用非常方便, 但仅适用于需要极短时间锁定的场合 (例如 1 毫秒), 以避免消耗太多的 CPU 空等时间.
Clock Source drivers
&ldquo;时钟源&rdquo; 驱动. 主要面向嵌入式设备.
Mailbox Hardware Support
CONFIG_MAILBOX
Mailbox 硬件支持. 这里的 &ldquo;Mailbox&rdquo; 是一个框架, 通过消息队列和中断驱动信号, 控制芯片上的多个处理器之间的通信. 仅用于嵌入式环境.
IOMMU Hardware Support
CONFIG_IOMMU_SUPPORT
IOMMU 硬件主要出现在 带有 I/O 虚拟化技术的硬件上, 例如带有 AMD-Vi 或 VT-d 技术的芯片. IOMMU 主要作用:(1)内存地址转换 (例如 DMA 地址转换, scatter-gather),(2) 中断重映射,(3)对设备读取和写入的进行权限检查. 这对于提高虚拟化性能和安全性, 以及在 64 位系统上更好的使用 32 位设备, 意义重大.[提示]此选项仅对宿主机有意义, 如果此内核要作为来宾操作系统运行, 请选 &ldquo;N&rdquo;.
AMD IOMMU support
CONFIG_AMD_IOMMU
AMD IOMMU 硬件支持. 一般还需要在 BIOS 中开启相应选项.
Export AMD IOMMU statistics to debugfs
CONFIG_AMD_IOMMU_STATS
仅供调试使用
AMD IOMMU Version 2 driver
CONFIG_AMD_IOMMU_V2
新一代的 AMD IOMMUv2 硬件 (支持 PCI PRI 和 PASID 接口) 支持. 首次出现在 AMD Opteron 4000/6000 系列平台上.
Support for Intel IOMMU using DMA Remapping Devices
CONFIG_INTEL_IOMMU
让 Intel IOMMU 支持 DMA 重映射, 这是 IOMMU 的主要用途, 只要你的芯片支持 VT-d, 就选 &ldquo;Y&rdquo;.
Support for Shared Virtual Memory with Intel IOMMU
CONFIG_INTEL_IOMMU_SVM
共享虚拟内存 ( SVM, Shared Virtual Memory)允许不同设备 (例如 CPU 与 GPU) 以 PASID(Process Address Space ID)为各自的身份标识, 统一使用 CPU 地址空间访问系统内存的 DMA 资源, 也就是 内存统一寻址, 以提升异构计算性能. 传说 Skylake 会支持 SVM.
Enable Intel DMA Remapping Devices by default
CONFIG_INTEL_IOMMU_DEFAULT_ON
默认开启 DMA 重映射支持, 相当于设置 &ldquo;intel_iommu=on&rdquo; 内核引导参数. 选 &ldquo;Y&rdquo;.
Support for Interrupt Remapping
CONFIG_IRQ_REMAP
支持对 IO-APIC 和 MSI 设备开启中断重映射, 这也是 IOMMU 的主要用途, 只要你的芯片支持 VT-d, 就选 &ldquo;Y&rdquo;.
Remoteproc drivers
现代的 SoC 芯片一般都会以 AMP( 非对称多处理器) 方式集成多个不同的处理器 (例如 OMAP5432 就在单个芯片上集成了 2 个 Cortex-A15 处理器, 2 个 Cortex-M4 处理器, 1 个 C64x DSP), 这样就可在不同的处理器上分别运行多个不同的操作系统实例 (例如, 在 2 个 Cortex-A9 处理器上以 SMP(对称多处理器) 方式运行 Linux, 在 2 个 Cortex-M3 和 1 个 C64x 上分别运行不同的实时操作系统). 而 Remoteproc 驱动对此种场合下的处理器间通信非常有用. 详见 &quot; Documentation/remoteproc.txt&quot;和&quot; Documentation/rpmsg.txt&quot;文档. 目前仅对嵌入式系统有意义. 不确定的选&quot;N&quot;.
Rpmsg drivers
此项和上面的 Remoteproc 紧密相关, 目前其下尚无子项可选.
SOC (System On Chip) specific Drivers
专用于单片机的设备驱动. 皆为嵌入式系统.
Generic Dynamic Voltage and Frequency Scaling (DVFS) support
CONFIG_PM_DEVFREQ
DVFS( 动态电压与频率调整)可以根据系统负载动态调节设备的运行频率和电压 (对于同一芯片, 频率越高, 需要的电压也越高), 从而达到节能目的. 此选项提供了一个类似 CPUfreq(CONFIG_CPU_FREQ) 的通用 DVFS 框架 (devfreq). 目前 DVFS 技术进在嵌入式设备(例如 Exynos4/Exynos5) 上普遍存在. 不确定的选 &ldquo;N&rdquo;.
External Connector Class (extcon) support
CONFIG_EXTCON
extcon(外部连接器类) 允许用户空间通过 sysfs 和 uevent 监控外部连接器, 同时也支持多状态外部连接器 (也就是拥有多个连接线缆的外部连接器). 例如, 一端连接到主机 USB 端口的多状态外部连接器, 另一端可以同时连接一条 HDMI 线缆和一个 AC 适配器.30 针的 PDMI 连接器也是多状态外部连接器的常见例子. 不确定的选 &ldquo;N&rdquo;.
Memory Controller drivers
CONFIG_MEMORY
内存控制器驱动. 这里所说的 &ldquo;内存控制器&rdquo; 仅指嵌入式 SoC 系统中的各种控制器. 不确定的选 &ldquo;N&rdquo;.
Industrial I/O support
CONFIG_IIO
IIO 子系统为各种不同总线 (i2c,spi, 等) 的嵌入式传感器驱动提供了一个统一的框架. 例如:(1)模数转换器,(2)加速度传感器,(3)陀螺仪,(4)惯性测量仪,(5)电容 - 数字转换器,(6)压力 / 温度 / 光线传感器, 等等. 主要用于工业领域和嵌入式领域. 不确定的选 &ldquo;N&rdquo;.
Non-Transparent Bridge support
CONFIG_NTB
PCI-E 非透明桥是一个点对点 PCI-E 总线, 用于连接两条对等的 PCI-E 总线. 例如英特尔 Atom S1200 处理器, Xeon C5500/C3500 嵌入式处理器等. 具体支持的设备号 (PCI_DEVICE_ID) 可以查看 &ldquo;drivers/ntb/ntb_hw.h&rdquo; 文件或 NTB 驱动数据库. 不确定的选 &ldquo;N&rdquo;.
VME bridge support
CONFIG_VME_BUS
VME(VersaModule Eurocard) 总线是一种通用的计算机总线, 主要用于工业控制 / 军用系统 / 航空航天 / 交通运输 / 医疗等嵌入式领域. 而 VME 桥则是其他总线 (例如 PCI/PCI-E) 到 VME 总线之间的转换芯片. 不确定的选 &ldquo;N&rdquo;.
Pulse-Width Modulation (PWM) Support
CONFIG_PWM
PWM( 脉宽调制) 是将模拟信号转换为脉波的一种技术. 在计算机领域, 这项技术常被用于控制风扇转速和背光显示器的亮度. 很多微型处理器内部都包含有 PWM 控制器, 此选项为所有 PWM 控制器驱动提供了一个统一的框架. 不确定的选 &ldquo;N&rdquo;.
Intel LPSS PWM support
CONFIG_PWM_LPSS
适用于 &ldquo;Intel Low Power Subsystem&rdquo; PWM 控制器的通用框架驱动. 适用于 Atom Z36xxx/Z37xxx 系列处理器.
NXP PCA9685 PWM driver
CONFIG_PWM_PCA9685
适用于 NXP PCA9685 LED 亮度控制器.
IndustryPack bus support
CONFIG_IPACK_BUS
IndustryPack 是工业控制领域常用的一种总线. 不确定的选 &ldquo;N&rdquo;.
Reset Controller Support
CONFIG_RESET_CONTROLLER
为 GPIO 总线或者芯片内置的重启控制器提供通用支持. 仅用于嵌入式设备. 不确定的选 &ldquo;N&rdquo;.
FMC support
CONFIG_FMC
FMC(FPGA Mezzanine Carrier) 是一个定义如何将 FPGA 夹层卡 ( FPGA Mezzanine Card) 连接到主机电路板的接口标准, 仅用于嵌入式环境.
PHY Subsystem
PHY 子系统.
PHY Core
CONFIG_GENERIC_PHY
为内核中的所有 PHY 设备提供一个通用的 PHY 框架. 不确定的选 &ldquo;N&rdquo;. 内核中若有其他部分依赖它, 会自动选上.
{此处省略的部分请按照硬件的实际情况选择}
Generic powercap sysfs driver
CONFIG_POWERCAP
&quot; power capping&quot;的意思是允许用户把设备的总功耗限定在指定的范围内. 此选项允许内核子系统将&quot;power capping&quot;的设置以 sysfs 的方式导出到用户空间. 不确定的选&quot;N&quot;.
MCB support
CONFIG_MCB
MCB(MEN Chameleon Bus) 是专用于德国 MEN Mikro Elektronik 公司的 FPGA 设备的总线. MEN Mikro Elektronik 公司的嵌入式计算主要是为航空 / 航海 / 铁路及陆地车辆的应用, 以及自动化 / 电力 / 能源和医疗用途. 不确定的选 &ldquo;N&rdquo;.
Performance monitor support
专用于 ARM 架构的 CPU 性能监控框架.
Reliability, Availability and Serviceability (RAS) features
CONFIG_RAS
RAS(可靠, 可用, 可维护) 是一个计算机硬件术语, 可靠性描述系统能够持续正确工作多长时间, 可用性描述系统能够正确工作的时间百分比, 可维护性描述系统从错误恢复到正常需要多长时间. 具有高等级 RAS 的硬件会有一系列额外的技术保障数据的可靠性与正确性.
Thunderbolt support for Apple devices
CONFIG_THUNDERBOLT
苹果公司的 雷电接口支持.
Android Drivers
CONFIG_ANDROID
安卓平台专用驱动
NVDIMM (Non-Volatile Memory Device) Support
CONFIG_LIBNVDIMM
NVDIMM( 非易失性内存) 支持.
NVMEM Support
CONFIG_NVMEM
NVMEM(非易失性存储器) 设备支持. 包括: EEPROM,EFUSES&hellip; 不确定的选 &ldquo;N&rdquo;.
System Trace Module devices
CONFIG_STM
仅供调试使用
Dummy STM driver
CONFIG_STM_DUMMY
仅供调试使用
Kernel console over STM devices
CONFIG_STM_SOURCE_CONSOLE
仅供调试使用
Intel(R) Trace Hub controller
CONFIG_INTEL_TH
仅供调试使用
FPGA Configuration Framework
CONFIG_FPGA
FPGA 配置框架支持. 仅用于嵌入式系统.
Firmware Drivers
固件 (Firmware) 驱动
BIOS Enhanced Disk Drive calls determine boot disk
CONFIG_EDD
这是一个实验性选项, 支持 实模式 BIOS 中的增强磁盘服务 (EDD), 从而允许内核从 BIOS 中获取第一启动盘 (可以从 sysfs 中查看具体是哪个硬盘), 大多数 BIOS 提供商都没有实现这个特性. 不确定的选 &ldquo;N&rdquo;.
Sets default behavior for EDD detection to off
CONFIG_EDD_OFF
选 &ldquo;Y&rdquo; 相当于使用 &ldquo;edd=off&rdquo; 内核引导参数 (禁用 EDD), 选 &ldquo;N&rdquo; 相当于使用 &ldquo;edd=on&rdquo; 内核引导参数 (启用 EDD). 语法: edd={on|skipmbr|off}.
Add firmware-provided memory map to sysfs
CONFIG_FIRMWARE_MEMMAP
将原始的固件内容映射到 &ldquo;/sys/firmware/memmap&rdquo; 文件. 主要用于调试目的, 以及 kexec 为下一个内核设置参数. 详见 &quot; Documentation/ABI/testing/sysfs-firmware-memmap&quot;文档. 不确定的选&quot;N&quot;.
BIOS update support for DELL systems via sysfs
CONFIG_DELL_RBU
允许 Dell OpenManage 或 DUP(Dell Update Packages) 工具通过 sysfs 更新 DELL 服务器主板的 BIOS. 详见 &quot; Documentation/dell_rbu.txt&quot;文档. 即使你确实需要此功能, 也建议选&quot;M&quot;而不是&quot;Y&quot;. 毕竟刷 BIOS 不能当做家常便饭. 留着刷 BIOS 的接口, 总是件危险的事.
Dell Systems Management Base Driver
CONFIG_DCDBAS
该驱动为 DELL 服务器专用的系统管理软件 (Dell OpenManage) 提供了 sysfs 接口. 详见 &quot; Documentation/dcdbas.txt&quot; 文档.
Export DMI identification via sysfs to userspace
CONFIG_DMIID
将 SMBIOS( System Management BIOS)/ DMI( Desktop Management Interface)中的系统识别信息 (序列号, 制造商, 型号, 等等) 导出到用户空间(/sys/class/dmi/id/). 开启此项后, dmidecode 工具就可以显示与制造商相关的信息. 此外, 基于 DMI 的模块的自动加载也依赖于此项. 建议选 &ldquo;Y&rdquo;, 因为某些 Udev 规则和虚拟化检测需要它.
DMI table support in sysfs
CONFIG_DMI_SYSFS
将 SMBIOS/DMI 中的原始数据 (包含大量的系统硬件信息) 导出到用户空间(/sys/firmware/dmi/). 以允许 dmidecode 工具无需访问 / dev/mem 设备 (需要 root 权限) 即可将这些信息显示出来.
iSCSI Boot Firmware Table Attributes
CONFIG_ISCSI_IBFT_FIND
使内核能定位 iBFT( iSCSI Boot Firmware Table) 在内存中的位置. 目的是为了能够从 iSCSI 驱动器中启动操作系统. 不确定的选 &ldquo;N&rdquo;.
iSCSI Boot Firmware Table Attributes module
CONFIG_ISCSI_IBFT
将 iBFT( iSCSI Boot Firmware Table) 的内容通过 sysfs 导出到用户空间. 如果你想在系统引导过程中动态检测 iSCSI 引导参数, 可以选 &ldquo;Y&rdquo;, 否则应选 &ldquo;N&rdquo;.
Google Firmware Drivers
CONFIG_GOOGLE_FIRMWARE
仅用于 Google 自家的服务器
EFI (Extensible Firmware Interface) Support
EFI/UEFI( 统一可扩展固件接口) 支持. 2010 年之后, UEFI 已经基本全线取代了 BIOS.
EFI Variable Support via sysfs
CONFIG_EFI_VARS
通过 sysfs 接口操作 (读 / 写 / 新建 / 删除)EFI 变量的老旧方式, 并且可能与新方式(CONFIG_EFIVAR_FS) 冲突. 应该选 &ldquo;N&rdquo;.
Register efivars backend for pstore
CONFIG_EFI_VARS_PSTORE
将 efivars 模块 (CONFIG_EFI_VARS) 用作 pstore 文件系统 (CONFIG_PSTORE) 的后端. 这样就可以向 EFI 变量中写入各种 pstore 支持的信息, 例如, 控制台消息, 崩溃转储, 等等.
Disable using efivars as a pstore backend by default
CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE
禁止默认将 efivars 模块 (CONFIG_EFI_VARS) 用作 pstore 文件系统 (CONFIG_PSTORE) 的后端.
Enable EFI fake memory map
CONFIG_EFI_FAKE_MEMMAP
选 &ldquo;Y&rdquo; 等价于使用 &ldquo;efi_fake_mem&rdquo; 内核引导参数, 仅供调试使用.
File systems
文件系统
Second extended fs support
CONFIG_EXT2_FS
Ext2 文件系统, 无日志. 详见 &quot; Documentation/filesystems/ext2.txt&quot; 文档.
Ext2 extended attributes
CONFIG_EXT2_FS_XATTR
Ext2 文件系统 扩展属性 (与 inode 关联的 name:value 对) 支持. 详见 attr 手册. 不确定的选 &ldquo;N&rdquo;.
Ext2 POSIX Access Control Lists
CONFIG_EXT2_FS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
Ext2 Security Labels
CONFIG_EXT2_FS_SECURITY
&ldquo;安全标签&rdquo; 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 &ldquo;N&rdquo;.
Ext2 execute in place support
CONFIG_EXT2_FS_XIP
芯片内执行 ( execute in place) 的意思是程序在写入存储介质时就已经分配好运行时的地址, 因此不需要载入内存即可在芯片内执行, 一般仅在嵌入式系统上才使用这种技术.
Ext3 journalling file system support
CONFIG_EXT3_FS
Ext3 日志型文件系统. 详见 &quot; Documentation/filesystems/ext3.txt&quot; 文档.
Default to &lsquo;data=ordered&rsquo; in ext3
CONFIG_EXT3_DEFAULTS_TO_ORDERED
选 &ldquo;Y&rdquo; 表示将默认的日志模式设为 &ldquo;data=ordered&rdquo;(更安全), 选 &ldquo;N&rdquo; 表示将默认的日志模式设为 &ldquo;data=writeback&rdquo;(更危险). 选 &ldquo;Y&rdquo;, 仅在你确实明白 &ldquo;data=writeback&rdquo; 的风险, 以及确实有充足的理由的时候, 才能选 &ldquo;N&rdquo;.
Ext3 extended attributes
CONFIG_EXT3_FS_XATTR
Ext3 文件系统 扩展属性 (与 inode 关联的 name:value 对) 支持. 详见 attr 手册. 不确定的选 &ldquo;N&rdquo;.
Ext3 POSIX Access Control Lists
CONFIG_EXT3_FS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
Ext3 Security Labels
CONFIG_EXT3_FS_SECURITY
&ldquo;安全标签&rdquo; 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 &ldquo;N&rdquo;.
The Extended 4 (ext4) filesystem
CONFIG_EXT4_FS
Ext4 日志型文件系统. 详见 &quot; Documentation/filesystems/ext4.txt&quot; 文档.
Use ext4 for ext2/ext3 file systems
CONFIG_EXT4_USE_FOR_EXT23
在 ext2/ext3 文件系统上使用 ext4 驱动. 这样可以对 ext2/ext3/ext4 三种文件系统只使用同一个驱动. 主要目的是减少内核尺寸.
Ext4 POSIX Access Control Lists
CONFIG_EXT4_FS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
Ext4 Security Labels
CONFIG_EXT4_FS_SECURITY
&ldquo;安全标签&rdquo; 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 &ldquo;N&rdquo;.
EXT4 debugging support
CONFIG_EXT4_DEBUG
仅供调试使用
JBD (ext3) debugging support
CONFIG_JBD_DEBUG
仅供调试使用
JBD2 (ext4) debugging support
CONFIG_JBD2_DEBUG
仅供调试使用
Reiserfs support
CONFIG_REISERFS_FS
曾经的明星文件系统, 特别擅长处理大量小文件的场合, 由于其创始人入狱, 前景不明.
Enable reiserfs debug mode
CONFIG_REISERFS_CHECK
仅供调试使用
Stats in /proc/fs/reiserfs
CONFIG_REISERFS_PROC_INFO
在 / proc/fs/reiserfs 文件中显示 Reiserfs 文件系统的状态, 仅供调试使用
ReiserFS extended attributes
CONFIG_REISERFS_FS_XATTR
ReiserFS 文件系统 扩展属性 (与 inode 关联的 name:value 对) 支持. 详见 attr 手册. 不确定的选 &ldquo;N&rdquo;.
ReiserFS POSIX Access Control Lists
CONFIG_REISERFS_FS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
ReiserFS Security Labels
CONFIG_REISERFS_FS_SECURITY
&ldquo;安全标签&rdquo; 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 &ldquo;N&rdquo;.
JFS filesystem support
CONFIG_JFS_FS
JFS 日志型文件系统. 详见 &quot; Documentation/filesystems/jfs.txt&quot; 文档.
JFS POSIX Access Control Lists
CONFIG_JFS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
JFS Security Labels
CONFIG_JFS_SECURITY
&ldquo;安全标签&rdquo; 允许选择使用不同安全模块 (如 SELinux) 实现的访问控制模型, 如果你没有使用需要扩展属性的安全模块, 可以选 &ldquo;N&rdquo;.
JFS debugging
CONFIG_JFS_DEBUG
仅供调试使用
JFS statistics
CONFIG_JFS_STATISTICS
在 / proc/fs/jfs / 目录中显示 JFS 文件系统的统计信息
XFS filesystem support
CONFIG_XFS_FS
XFS 日志型文件系统是一个高性能的文件系统 (笔者的最爱), 擅长大文件和多线程. 详见 &quot; Documentation/filesystems/&ldquo;目录中&quot;xfs*.txt&rdquo; 系列文档.
XFS Quota support
CONFIG_XFS_QUOTA
XFS 磁盘配额 (使用专用的 xfs_quota 工具)比通用磁盘配额模块 (CONFIG_QUOTA) 拥有更高级的特性, 它不但能够控制用户或组的磁盘用量, 还能控制项目 (文件夹) 的磁盘用量(无论哪个用户在项目的文件夹中创建文件), 但是不能同时使用组配额和项目配额. 此外, 对 XFS 来说, 配额数据记录在文件系统元数据中, 而不是像 CONFIG_QUOTA 那样记录在 aquota.user 和 aquota.group 文件中. 最后, XFS 配额和通用磁盘配额是两个相互独立的系统, 可以同时并存.
XFS POSIX ACL support
CONFIG_XFS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
XFS Realtime subvolume support
CONFIG_XFS_RT
&ldquo;实时子卷&rdquo; 是专门存储文件数据的卷, 可以允许将日志与数据分开在不同的磁盘上, 例如将大块头的流媒体文件存储在高速磁盘组成的实时子卷上. 详见 xfs 手册页.
XFS Verbose Warnings
CONFIG_XFS_WARN
仅供调试使用
XFS Debugging support
CONFIG_XFS_DEBUG
仅供调试使用
GFS2 file system support
CONFIG_GFS2_FS
GFS2 可用于 搭建高可用集群文件系统, 由红帽公司开发, 允许所有集群节点并行访问, 同时又能够完美的保持文件系统的一致性: 一个节点对文件系统的任何修改都立即对所有其他节点可见. 详见 &quot; Documentation/filesystems/&ldquo;目录中&quot;gfs*.txt&rdquo; 系列文档.
GFS2 DLM locking
CONFIG_GFS2_FS_LOCKING_DLM
GFS2 分布式锁管理器 ( DLM). 务必选 &ldquo;Y&rdquo;, 除非你知道自己在做什么.
OCFS2 file system support
CONFIG_OCFS2_FS
OCFS2( Oracle 集群文件系统) 的目标是成为一种通用文件系统. OCFS2 能使集群中的所有节点并发的通过标准文件系统接口来访问存储备. 要使用 OCFS2 还需要 ocfs2-tools 的帮助. 详见 &quot; Documentation/filesystems/ocfs2.txt&quot; 文档.
O2CB Kernelspace Clustering
CONFIG_OCFS2_FS_O2CB
O2CB(OCFS2 Cluster Base) 是位于内核空间的集群服务结构. 具体包括: NM(节点管理器, 监控所有节点),HB(心跳服务),TCP(控制节点间的通讯),DLM(分布式锁管理器),CONFIGFS(用户配置文件系统驱动, 挂载点是 / config),DLMFS(用户空间和内核空间 DLM 的接口). 开启此项后, 将只需要很少量的用户空间组件 (也就是 ocfs2-tools),OCFS2 就可以转起来了. 但它只能玩转 OCFS2 自身, 玩不了其他集群.
OCFS2 Userspace Clustering
CONFIG_OCFS2_FS_USERSPACE_CLUSTER
为用户空间的集群服务提供支持. 目的是为了配合 CONFIG_DLM 模块一起使用.
OCFS2 statistics
CONFIG_OCFS2_FS_STATS
允许对 OCFS2 的使用状况进行一些统计. 开启后会增加内存占用.
OCFS2 logging support
CONFIG_OCFS2_DEBUG_MASKLOG
仅供调试使用
OCFS2 expensive checks
CONFIG_OCFS2_DEBUG_FS
以性能为代价提供了存储一致性检测, 仅供调试使用
Btrfs filesystem support
CONFIG_BTRFS_FS
Btrfs 是由 Oracle 于 2007 年宣布的支持写时复制 (COW) 的文件系统. 拥有众多抢眼球的特性: 软 RAID 管理, 卷管理, 克隆 / 快照, 压缩功能, 支持跨多块磁盘动态增大或收缩卷. 其目标是成为 下一代 Linux 标准文件系统. 详见 &quot; Documentation/filesystems/btrfs.txt&quot; 文档.
Btrfs POSIX Access Control Lists
CONFIG_BTRFS_FS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 不确定的选 &ldquo;N&rdquo;.
Btrfs with integrity check tool compiled in (DANGEROUS)
CONFIG_BTRFS_FS_CHECK_INTEGRITY
仅供调试使用
Btrfs will run sanity tests upon loading
CONFIG_BTRFS_FS_RUN_SANITY_TESTS
仅供调试使用
Btrfs debugging support
仅供调试使用
NILFS2 file system support
CONFIG_NILFS2_FS
NILFS2 是一种非常前卫的 &ldquo;log-structured&rdquo; 文件系统, 是 Linux 下一代文件系统的有力竞争者. NILFS2 将底层设备当作一种只能追加写 (append) 的设备, 文件系统的任何修改都只以顺序追加的方式写入磁盘 (而是不覆盖旧数据), 从而避免耗时的寻道(seek) 操作, 从而大幅提升写入性能 (因为文件系统的整体效率主要由写操作的效率决定). 此种思路带来了一系列靓瞎眼的特性: 自动不间断快照(可以迅速恢复被删除的文件或者回到先前某个特定的时间点), 快速崩溃恢复(比大多数日志型文件系统还要快), 高性能(在 SSD 上更有绝对优势). 但也带来了一个新问题: 需要垃圾收集机制以清理旧数据, 造成垃圾收集时的性能降低(可以通过合理安排垃圾收集时间来避免).NILFS2 目前不支持如下功能: atime(访问时间),POSIX ACL, 扩展属性. 不过考虑到 SSD(固态硬盘) 即将成为主流, 假以时日, 前途大大的啊!. 详见 &quot; Documentation/filesystems/nilfs2.txt&quot; 文档.
F2FS filesystem support
CONFIG_F2FS_FS
F2FS 也是一种非常前卫的 &ldquo;log-structured&rdquo; 文件系统, 针对基于 NAND 闪存的存储设备进行了特别设计, 使之更加适应新的存储介质 (也就是闪存), 据称它 是目前 SSD 上性能最好的文件系统.
Direct Access (DAX) support
CONFIG_FS_DAX
DAX(Direct Access)的含义是绕过内存缓冲直接访问块设备. 选 &ldquo;Y&rdquo; 后, 就可以用 &ldquo;mount -o dax&rdquo; 方式挂载块设备以避免使用 pagecache 作为 I/O 缓冲. 例如将持续性非易失内存 (断电内容不丢失) 作磁盘用时, 或者挂载内存盘时, 使用此特性便恰到好处. 还有一种用法是在虚拟机内使用 &ldquo;mount -o dax&rdquo; 方式挂载已经缓存在宿主机内存中的块设备文件(或者倒过来也可以).
Enable POSIX file locking API
CONFIG_FILE_LOCKING
POSIX 标准文件锁定 API 支持. NFS 之类的网络文件系统和给文件加锁与解锁的 flock() 系统调用需要它. 不确定的选 &ldquo;Y&rdquo;.
Dnotify support
CONFIG_DNOTIFY
旧式的基于目录的文件变化的通知机制 (已被 Inotify 取代), 目前仅有 NFSv4 以及少量古董程序依赖它. 不确定的选 &ldquo;N&rdquo;.
Inotify support for userspace
CONFIG_INOTIFY_USER
用户空间的 Inotify 支持. Inotify 是替代 Dnotify 的文件系统变化通知机制. 建议选 &ldquo;Y&rdquo;.[提示] 如果你使用了 systemd 作为 init, 那就必须选 &ldquo;Y&rdquo;.
Filesystem wide access notification
CONFIG_FANOTIFY
fanotify 是一种打算取代 Inotify 的文件系统变化通知机制, 不过, 由于目前 Fanotify 比 inotify 支持的文件系统事件类型少很多, 完全取代 Inotify 还不现实. Udev 的 &quot; Predictable Network Interface Names&quot;功能依赖于它. 建议选&quot;Y&quot;.[提示] 如果你使用了 systemd 作为 init, 那就必须选 &ldquo;Y&rdquo;.
fanotify permissions checking
CONFIG_FANOTIFY_ACCESS_PERMISSIONS
允许 fanotify 的监听器 (listener) 对文件系统事件进行权限检查. 这样, 监听器就可以在系统访问某个文件之前, 首先扫描此文件. 某些防病毒程序以及 分级存储管理系统可能需要此特性. 不确定的选 &ldquo;N&rdquo;.
Quota support
CONFIG_QUOTA
通用的磁盘配额支持 (限制某个用户或者某组用户的磁盘占用空间). 需要配合 quota-tools 工具使用.
Report quota messages through netlink interface
CONFIG_QUOTA_NETLINK_INTERFACE
通过 netlink 接口报告 QUOTA 的警告信息 (例如 &ldquo;到达限额&rdquo;). 不确定的选 &ldquo;Y&rdquo;.
Print quota warnings to console (OBSOLETE)
CONFIG_PRINT_QUOTA_WARNING
将 QUOTA 的警告信息直接显示在控制台上. 反对使用, 未来会移除此项. 选 &ldquo;N&rdquo;.
Additional quota sanity checks
CONFIG_QUOTA_DEBUG
对 quota 内部结构进行额外的完整性检查. 主要用于调试目的. 不确定的选 &ldquo;N&rdquo;.
Old quota format support
CONFIG_QFMT_V1
老旧的 v1 版配额格式 (linux-2.4.22 之前使用的格式) 支持. 选 &ldquo;N&rdquo;.
Quota format vfsv0 and vfsv1 support
CONFIG_QFMT_V2
vfsv0/vfsv1 配额格式支持. 两者都支持 32 位的 UID/GID, 而 vfsv1 还支持 64 位的 inode/block 配额. 建议开启.
Kernel automounter version 4 support (also supports v3)
CONFIG_AUTOFS4_FS
第四版内核按需自动挂载文件系统的支持 (也支持 v3). 此特性需要配合用户空间工具 ( autofs 或 Systemd) 使用, 以实现仅在某个文件系统挂载点真正被访问到的时候才触发挂载操作.[提示] 使用了 systemd 的系统建议选 &ldquo;Y&rdquo;.
FUSE (Filesystem in Userspace) support
CONFIG_FUSE_FS
FUSE 允许在用户空间实现一个全功能的文件系统, 还有一个与之对应的 libfuse2 库和相关工具. 详见 &quot; Documentation/filesystems/fuse.txt&quot; 文档. 如果你打算开发一个自己的文件系统或者使用一个基于 FUSE 的文件系统 (例如 NTFS-3G 或 ZFS-FUSE 或 GlusterFS), 可以选 &ldquo;Y&rdquo;.
Character device in Userspace support
CONFIG_CUSE
这是一个 FUSE 扩展, 用于在用户空间实现字符设备支持.
Overlay filesystem support
CONFIG_OVERLAY_FS
overlay 的含意是以层叠的方式组合上下两个文件系统层, 常和容器技术配合使用. 详见 Documentation/filesystems/overlayfs.txt 文档.
Caches
文件系统缓存
General filesystem local caching manager
CONFIG_FSCACHE
通用文件系统本地缓存管理器. 它为各种不同的文件系统 (例如网络文件系统) 提供了统一的本地缓存框架. 这样各种缓存实现可以作为插件添加进来. 详见 &quot; Documentation/filesystems/caching/fscache.txt&quot; 文档.
Gather statistical information on local caching
CONFIG_FSCACHE_STATS
收集本地缓存的统计信息 (这会增加系统运行负载), 并通过 / proc/fs/fscache/stats 文件导出到用户空间. 主要用于调试目的.
Gather latency information on local caching
CONFIG_FSCACHE_HISTOGRAM
收集本地缓存的延迟信息 (这会增加系统运行负载), 并通过 / proc/fs/fscache/histogram 文件导出到用户空间. 主要用于调试目的.
Debug FS-Cache
CONFIG_FSCACHE_DEBUG
仅供调试使用
Maintain global object list for debugging purposes
CONFIG_FSCACHE_OBJECT_LIST
在 / proc/fs/fscache/objects 文件中维护一个活动缓存对象的全局列表. 仅用于调试目的.
Filesystem caching on files
CONFIG_CACHEFILES
将一个已挂载的文件系统用作另一个文件系统的缓存. 例如将一个本地磁盘分区挂载为一个远程网络文件系统的缓存, 或者将一个高速设备 (例如 SSD) 用作一个低速设备 (例如普通硬盘) 的缓存.
Debug CacheFiles
CONFIG_CACHEFILES_DEBUG
仅供调试使用
Gather latency information on CacheFiles
CONFIG_CACHEFILES_HISTOGRAM
收集本地缓存的延迟信息 (这会增加系统运行负载), 并通过 / proc/fs/cachefiles/histogram 文件导出到用户空间. 主要用于调试目的.
CD-ROM/DVD Filesystems
CD-ROM/DVD 光盘文件系统
ISO 9660 CDROM file system support
CONFIG_ISO9660_FS
ISO9660 是所有 CD/DVD 光盘通用的标准文件系统. 建议选 &ldquo;Y&rdquo;. 详见 &quot; Documentation/filesystems/isofs.txt&quot; 文档.
Microsoft Joliet CDROM extensions
CONFIG_JOLIET
Microsoft 对 ISO9660 文件系统的 Joliet 扩展, 允许在文件名中使用 Unicode 字符, 也允许长文件名. 建议选 &ldquo;Y&rdquo;.
Transparent decompression extension
CONFIG_ZISOFS
Linux 对 ISO9660 文件系统的扩展, 允许将数据透明的压缩存储在 CD 上. 使用并不广泛, 不确定的可以选 &ldquo;N&rdquo;.
UDF file system support
CONFIG_UDF_FS
UDF 被设计为可擦写格式 (其实质是管理增量写入), 其目标是取代 ISO9660, 现已经广泛地用于大容量 DVD 光盘上 (特别是刻录盘). 建议选 &ldquo;Y&rdquo;. 详见 &quot; Documentation/filesystems/udf.txt&quot; 文档.
DOS/FAT/NT Filesystems
DOS/FAT/NTFS 文件系统
MSDOS fs support
CONFIG_MSDOS_FS
古老的 MSDOS 文件系统 (FAT16), 基本绝种了
VFAT (Windows-95) fs support
CONFIG_VFAT_FS
从 Win95 开始使用的 VFAT 文件系统 (FAT32). 如果你要使用基于 UEFI 平台的电脑, 并且使用 GPT 磁盘分区, 则必须选 &ldquo;Y&rdquo;. 详见 &quot; Documentation/filesystems/vfat.txt&quot; 文档.
Default codepage for FAT
CONFIG_FAT_DEFAULT_CODEPAGE
在 FAT 系列文件系统上,&ldquo;8.3&rdquo; 格式的短文件名以特定的 代码页进行存储 (可以通过 chcp 命令查看), 但长文件名却以 Unicode 进行存储. 此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页. 可以通过 &ldquo;codepage&rdquo; 挂载选项进行修改. 简体中文通常使用 &ldquo;936&rdquo;, 繁体中文通常使用 &ldquo;950&rdquo;.
Default iocharset for FAT
CONFIG_FAT_DEFAULT_IOCHARSET
指定默认以什么 字符集显示文件名, 这个值可以通过 &ldquo;iocharset&rdquo; 挂载选项修改. 但必须与系统的 locale 设置保持一致. 例如在 &ldquo;zh_CN.UTF-8&rdquo; 或 &ldquo;en_US.UTF-8&rdquo; 的情况下应该使用 &ldquo;utf8&rdquo;.[注意] 应谨慎使用 &ldquo;iocharset=utf8&rdquo;, 因为它会导致 FAT 文件系统上的文件名变得大小写敏感.
exFAT fs support
CONFIG_EXFAT_FS
exfat-nofuse 开源项目提供的内核级 exFAT,FAT12,FAT16,FAT32(vfat) 文件系统支持 补丁. 此补丁是取代前面两个内核自带的 FAT 驱动的更优秀替代品.
enable discard support
CONFIG_EXFAT_DISCARD
&ldquo;discard&rdquo; 挂载选项支持. 在 U 盘或者 SSD 上使用此文件系统的用户必选 &ldquo;Y&rdquo;.
enable delayed sync
CONFIG_EXFAT_DELAYED_SYNC
延迟刷写磁盘脏数据, 可提高文件系统性能. 有电池的笔记本或者有 UPS 的台式机建议选 &ldquo;Y&rdquo;.
enable kernel debug features via ioctl
CONFIG_EXFAT_KERNEL_DEBUG
仅供调试使用.
print debug messages
CONFIG_EXFAT_DEBUG_MSG
仅供调试使用
Default codepage for exFAT
CONFIG_EXFAT_DEFAULT_CODEPAGE
在 FAT 系列文件系统上,&ldquo;8.3&rdquo; 格式的短文件名以特定的 代码页进行存储 (可以通过 chcp 命令查看), 但长文件名却以 Unicode 进行存储. 此选项的作用就是指定将长文件名转换为短文件名时使用的默认代码页. 可以通过 &ldquo;codepage&rdquo; 挂载选项进行修改. 简体中文通常使用 &ldquo;936&rdquo;, 繁体中文通常使用 &ldquo;950&rdquo;.
Default iocharset for exFAT
CONFIG_EXFAT_DEFAULT_IOCHARSET
指定默认以什么 字符集显示文件名, 这个值可以通过 &ldquo;iocharset&rdquo; 挂载选项修改. 但必须与系统的 locale 设置保持一致. 例如在 &ldquo;zh_CN.UTF-8&rdquo; 或 &ldquo;en_US.UTF-8&rdquo; 的情况下应该使用 &ldquo;utf8&rdquo;.[注意] 应谨慎使用 &ldquo;iocharset=utf8&rdquo;, 因为它会导致 FAT 文件系统上的文件名变得大小写敏感.
NTFS file system support
CONFIG_NTFS_FS
NTFS 文件系统. 仅选中此项表示仅支持只读 (不支持 NTFS 压缩或加密文件), 不支持写入. 详见 &quot; Documentation/filesystems/ntfs.txt&quot; 文档.
NTFS debugging support
CONFIG_NTFS_DEBUG
仅供调试使用
NTFS write support
CONFIG_NTFS_RW
由于微软没有公开 NTFS 的技术标准, 所以内核只能支持非常残缺的写入功能: 仅能覆盖已存在的文件但不能改变其长度, 不能创建文件或目录. 建议选 &ldquo;N&rdquo;.[提示] 在 Linux 环境下写入 NTFS 始终是一件危险的事情, 即使对于 NTFS-3G 也是如此, 除了不支持压缩或加密文件之外, 网上还有不少 血的教训, 有兴趣可以搜搜.
Pseudo filesystems
伪文件系统
/proc file system support
CONFIG_PROC_FS
显示系统状态的虚拟文件系统 (进程信息, irq 设置, 内存使用, 设备驱动, 网络状态等), 通常挂载到 &quot; /proc&quot;目录. 许多程序依赖于它, systemd 也依赖于它. 选&quot;Y&quot;, 除非你知道自己在做什么. 详见&quot; Documentation/filesystems/proc.txt&quot; 文档.
/proc/kcore support
CONFIG_PROC_KCORE
系统物理内存的映象. 建议选 &ldquo;N&rdquo;.
/proc/vmcore support
CONFIG_PROC_VMCORE
以 ELF 格式转储的已崩溃内核镜像, 仅供调试使用
Sysctl support (/proc/sys)
CONFIG_PROC_SYSCTL
显示各种不同的内核调节参数, 并让 root 用户能通过 / proc/sys / 目录交互地更改其中的某些内容. 必选 &ldquo;Y&rdquo;, 除非你是嵌入式系统并且知道自己在做什么. 详见 &quot; Documentation/sysctl/&quot; 目录中的文档.
Enable /proc page monitoring
CONFIG_PROC_PAGE_MONITOR
用于监视进程内存占用的接口 (/proc/<pid>/{smaps,clear_refs,pagemap} 和 / proc/{kpagecount,kpageflags}). 建议选 &ldquo;Y&rdquo;.
sysfs file system support
CONFIG_SYSFS
导出内核内部对象及其属性和对象之间的相互关系的文件系统, 通常挂载到 &quot; /sys&quot;目录, sysfs 把连接在系统上的设备和总线以及驱动程序等组织成为一个分级的文件, 并允许通过该文件系统调整某些内核子系统以及设备的参数. 内核启动时依靠它挂载类似&quot;/dev/sda1&quot;这样形式的根分区, 禁用 sysfs 后必须在内核引导参数中使用设备号指定根分区 (类似&quot;root=03:01&quot;这样).systemd 依赖于它. 选&quot;Y&quot;, 除非你知道自己在做什么. 详见&quot; Documentation/filesystems/&ldquo;目录中&quot;sysfs*.txt&rdquo; 系列文档.
Tmpfs virtual memory file system support (former shm fs)
CONFIG_TMPFS
tmpfs 文件系统 (以前叫 shm[共享内存] 文件系统), 大多数系统的正常运行都依赖于它(例如 Udev 使用的 &ldquo;/dev/&rdquo; 目录通常挂载为 tmpfs). 选 &ldquo;Y&rdquo;, 除非你知道自己在做什么. 详见 &quot; Documentation/filesystems/tmpfs.txt&quot; 文档.
Tmpfs POSIX Access Control Lists
CONFIG_TMPFS_POSIX_ACL
POSIX  ACL(访问控制列表) 支持, 这是一种超越 &ldquo;owner/group/world&rdquo; 的权限管理方式, 可以更精细的针对每个用户进行访问控制. 详见 acl 手册. 许多发行版都要求 / dev / 目录支持 ACL(例如让 ALSA 相关的文件可以正常工作), 并且 systemd 也建议开启它. 不确定的选 &ldquo;Y&rdquo;.
Tmpfs extended attributes
CONFIG_TMPFS_XATTR
TMPFS 文件系统 扩展属性 (与 inode 关联的 name:value 对) 支持 (仅支持 trusted.* 和 security.* 命名空间). 详见 attr 手册. 由于它被 CONFIG_TMPFS_POSIX_ACL 依赖, 并且 systemd 也建议开启它. 建议选 &ldquo;Y&rdquo;.
HugeTLB file system support
CONFIG_HUGETLBFS
这是使用大内存页的传统方式, 需要专门进行配置以及应用程序的特别支持. 推荐使用较新的 透明大内存页 (CONFIG_TRANSPARENT_HUGEPAGE). 选 &ldquo;N&rdquo;.
Userspace-driven configuration filesystem
CONFIG_CONFIGFS_FS
configfs 是一个基于内存的虚拟文件系统, 与 sysfs 类似但又有不同: configfs 用于从用户空间查看 / 修改 / 创建 / 删除内核对象, 而 sysfs 仅能查看 / 修改由内核负责创建和删除的对象. 通常挂载到 &ldquo;/config&rdquo; 目录. 详见 &quot; Documentation/configfs/&ldquo;目录中的文档. 不确定的选&quot;N&rdquo;.
Miscellaneous filesystems
CONFIG_MISC_FILESYSTEMS
各种非主流的杂项文件系统, 有些是专用于嵌入式系统, 有些是来自于其他操作系统, 还有些专用于某些特定场合.
{此处省略哪些非常非主流的文件系统} eCrypt filesystem layer support
CONFIG_ECRYPT_FS
eCryptfs 是一个符合 POSIX 标准的企业级文件系统加密栈 (加密 / 解密转换层), 工作在 VFS(虚拟文件系统) 层, 可以在各种普通文件系统上使用 (需要 ecryptfs-utils 工具).eCryptfs 将加密元数据保存在每个文件的首部, 从而允许文件在不同主机之间任意移动, 同时又能确保仅在内核密钥环中拥有正确密钥的时候才能解密文件的内容. 此外, eCryptfs 还支持高级密匙管理和配置策略.[提示] 使用 eCryptfs 之后, 读操作性能最大可下降 1/3 左右, 写操作性能则普遍下降一个数量级.
Enable notifications for userspace key wrap/unwrap
CONFIG_ECRYPT_FS_MESSAGING
允许 ecryptfsd 守护进程操作 / dev/ecryptfs 设备. 这将允许用户空间使用其他后端 (例如 OpenSSL) 加密 / 解密 FEK(file encryption key). 不确定的选 &ldquo;N&rdquo;.
SquashFS 4.0 - Squashed file system support
CONFIG_SQUASHFS
SquashFS 是一种高压缩率的只读文件系统, 可以使用多种压缩算法 (例如 zlib,xz,lzo). SquashFS 常用于嵌入式设备和 LiveCD 系统.
Squashfs XATTR support
CONFIG_SQUASHFS_XATTR
Squashfs 文件系统 扩展属性 (与 inode 关联的 name:value 对) 支持. 详见 attr 手册. 不确定的选 &ldquo;N&rdquo;.
Include support for ZLIB compressed file systems
CONFIG_SQUASHFS_ZLIB
ZLIB 是 Squashfs 默认的标准压缩算法. 在压缩率和性能之间达到了最佳的平衡.
Include support for LZO compressed file systems
CONFIG_SQUASHFS_LZO
LZO 是性能最佳的压缩算法 (CPU 和内存占用都很低), 但是压缩率确是最差的. 常用于资源有限的嵌入式系统.
Include support for XZ compressed file systems
CONFIG_SQUASHFS_XZ
XZ 是压缩率最佳的压缩算法, 但其 CPU 和内存占用都最高. 可用于 PC 环境.
Use 4K device block size?
CONFIG_SQUASHFS_4K_DEVBLK_SIZE
出于降低潜伏时间的考虑, Squashfs 默认使用 1K 大小的块. 但是在 MTD NAND 设备上, 使用 4K 大小的块才可以获得最佳性能. 此外, 在大多数设备上, 使用 4K 大小的块才能获得最佳连续读取性能. 如果你的 Squashfs 位于闪存设备上, 建议选 &ldquo;Y&rdquo;. 否则建议选 &ldquo;N&rdquo;.
Additional option for memory-constrained systems
CONFIG_SQUASHFS_EMBEDDED
允许强制指定缓存大小. 不确定的选 &ldquo;N&rdquo;.
Number of fragments cached
CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE
SquashFS 默认缓存最后 3 个从文件系统上读取的片段. 降低此值 (最小值是 &ldquo;1&rdquo;, 不能设为 &ldquo;0&rdquo;) 可以降低内存的占用, 但是会增加底层物理设备的读取次数. 增加此值则正好相反.[提示]按一般经验, 大于 &ldquo;3&rdquo; 的值并不能带来显著的性能提升.
EFI Variable filesystem
CONFIG_EFIVAR_FS
efivarfs 是访问 &ldquo;EFI 变量&rdquo; 的新方式, 意在取代传统的 sysfs(CONFIG_EFI_VARS) 方式, 其主要优点是可以突破 sysfs 中变量值不能超出 1024 字节的限制. 开启后可支持各种 操作 EFI 变量的工具: efivar‎, efibootmgr, vathpela/efibootmgr, uefivars, efitools, fwts(Firmware Test Suite).systemd 依赖于它. 建议选 &ldquo;Y&rdquo;.
Network File Systems
CONFIG_NETWORK_FILESYSTEMS
网络文件系统
NFS client support
CONFIG_NFS_FS
NFS(Network File System) 客户端支持, 这样就可以使用 nfs-utils 包中的 mount.nfs 工具挂载远程服务器提供的 NFS 文件系统. 详见 nfs 手册页.
NFS client support for NFS version 2
CONFIG_NFS_V2
NFSv2(RFC 1094) 版本协议支持
NFS client support for NFS version 3
CONFIG_NFS_V3
NFSv3(RFC 1813) 版本协议支持
NFS client support for the NFSv3 ACL protocol extension
CONFIG_NFS_V3_ACL
为 NFSv3 添加 POSIX ACL 支持 (Solaris NFSv3 ACL). 大多数 NFS 服务器都不支持这个扩展. 不确定的选 &ldquo;N&rdquo;.
NFS client support for NFS version 4
CONFIG_NFS_V4
NFSv4(RFC 3530) 版本协议支持
Provide swap over NFS support
CONFIG_NFS_SWAP
允许将 NFS 文件系统用做 swap 分区.
NFS client support for NFSv4.1
CONFIG_NFS_V4_1
NFSv4.1(RFC 5661) 版本协议客户端支持, 这样就可以使用 nfs-utils 包中的 mount.nfs 工具挂载远程服务器提供的 NFS 文件系统. 详见 nfs 手册页以及 NFS 各个版本之间的比较.
NFSv4.1 Implementation ID Domain
CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN
NFSv4.1 规范新引入了 会话机制, 该选项定义在建立会话过程中使用在 EXCHANGE_ID 指令中的 &ldquo;domain&rdquo; 部分的值. 这个值必须是个标准的 DNS 域名格式. 如果你没有修改内核的 NFS 客户端代码, 那么请保持默认值 &ldquo;kernel.org&rdquo;.
Root file system on NFS
CONFIG_ROOT_NFS
允许将 NFS 挂载为根文件系统 (root=/dev/nfs), 通常用于没有本地存储设备的无盘工作站 (还必须开启 CONFIG_IP_PNP 以及至少一个子项). 详见 &quot; Documentation/filesystems/nfs/nfsroot.txt&quot; 文档.
Provide NFS client caching support
CONFIG_NFS_FSCACHE
为 NFS 提供本地缓存支持, 也就是利用 CONFIG_FSCACHE 选项的功能.
Use the legacy NFS DNS resolver
CONFIG_NFS_USE_LEGACY_DNS
内核现在有自己的 DNS 解析实现, 如果你依然想使用老式的 DNS 解析脚本, 可以选 &ldquo;Y&rdquo;. 不确定的选 &ldquo;N&rdquo;.
NFS server support
CONFIG_NFSD
NFS 服务器端支持. 要实现此功能, 还需要 nfs-utils 软件包的支持. 详见 nfs 手册页. 这里也有一个 NFS 文章系列可以看看. 此选项内嵌了 NFSv2 协议支持.
NFS server support for NFS version 3
CONFIG_NFSD_V3
NFSv3(RFC 1813) 版本协议支持
NFS server support for the NFSv3 ACL protocol extension
CONFIG_NFSD_V3_ACL
为 NFSv3 添加 POSIX ACL 支持 (Solaris NFSv3 ACL). 此扩展并不属于 NFSv3 协议的官方内容.
NFS server support for NFS version 4
CONFIG_NFSD_V4
NFSv4(RFC 3530) 版本协议支持
NFS server manual fault injection
CONFIG_NFSD_FAULT_INJECTION
仅供调试使用
Secure RPC: Kerberos V mechanism
CONFIG_RPCSEC_GSS_KRB5
为使用 Kerberos V5 GSS-API 身份验证机制 (RFC1964) 的 安全 RPC 提供支持. 要实现此功能, 还需要 nfs-utils 软件包以及用户空间的 Kerberos 支持.
RPC: Enable dprintk debugging
CONFIG_SUNRPC_DEBUG
允许使用 rpcdebug 工具调试 RPC 故障, 如果选 &ldquo;N&rdquo; 会让故障调试特别困难.
Ceph distributed file system
CONFIG_CEPH_FS
允许挂载 Ceph 分布式文件系统. 不确定的选 &ldquo;N&rdquo;. 详见 &quot; Documentation/filesystems/ceph.txt&quot; 文档.
CIFS support (advanced network filesystem, SMBFS successor)
CONFIG_CIFS
CIFS(Common Internet File System) 协议客户端支持. CIFS 主要用于 Linux 与 Windows 之间共享文件系统. 如果你打算挂载 Windows 的共享文件夹, 或者由 Samba 提供的文件系统, 就选 &ldquo;Y&rdquo;. 详见 &quot; Documentation/filesystems/cifs.txt&quot; 文档.
CIFS statistics
CONFIG_CIFS_STATS
在 / proc/fs/cifs/Stats 文件中显示每个被挂载的 CIFS 文件系统的统计信息
Extended statistics
CONFIG_CIFS_STATS2
在 / proc/fs/cifs / 目录下显示更详细的统计信息. 对运行性能和内存占用都有些影响. 不确定的选 &ldquo;N&rdquo;.
Support legacy servers which use weaker LANMAN security
CONFIG_CIFS_WEAK_PW_HASH
选 &ldquo;N&rdquo;, 除非你确实知道自己在干什么.
Kerberos/SPNEGO advanced session setup
CONFIG_CIFS_UPCALL
Kerberos/ SPNEGO 高级会话支持. 不确定的选 &ldquo;N&rdquo;.
CIFS extended attributes
CONFIG_CIFS_XATTR
CIFS 文件系统 扩展属性 (与 inode 关联的 name:value 对) 支持. 不确定的选 &ldquo;N&rdquo;.
CIFS POSIX Extensions
CONFIG_CIFS_POSIX
CIFS POSIX 扩展. 不确定的选 &ldquo;N&rdquo;.
Provide CIFS ACL support
CONFIG_CIFS_ACL
允许从服务器抓取 CIFS/NTFS ACL. 不确定的选 &ldquo;N&rdquo;.
Enable CIFS debugging routines
CONFIG_CIFS_DEBUG
仅供调试使用
DFS feature support
CONFIG_CIFS_DFS_UPCALL
DFS(Distributed File System) 支持. 不确定的选 &ldquo;N&rdquo;.
SMB2 network file system support
CONFIG_CIFS_SMB2
仅供开发与调试使用
Provide CIFS client caching support
CONFIG_CIFS_FSCACHE
为 CIFS 提供本地缓存支持, 也就是利用 CONFIG_FSCACHE 选项的功能.
NCP file system support (to mount NetWare volumes)
CONFIG_NCP_FS
NCP(NetWare Core Protocol) 协议支持. 这东西早就销声匿迹了, 选 &ldquo;N&rdquo;.
Coda file system support (advanced network fs)
CONFIG_CODA_FS
Coda 是一种比 NFS 更先进的分布式集群文件系统. LVS(Linux Virtual Server) 就采用了 Coda 分布式文件系统. 详见 &quot; Documentation/filesystems/coda.txt&quot; 文档.
Andrew File System support
CONFIG_AFS_FS
AFS(Andrew File System) 文件系统的实验性支持, 目前仅支持只读访问. 详见 &quot; Documentation/filesystems/afs.txt&quot; 文档.
Provide AFS client caching support
CONFIG_AFS_FSCACHE
为 AFS 提供本地缓存支持, 也就是利用 CONFIG_FSCACHE 选项的功能.
Plan 9 Resource Sharing Support (9P2000)
CONFIG_9P_FS
9P2000 协议是 Plan 9 概念网络操作系统上使用的资源共享协议. 不确定的选 &ldquo;N&rdquo;.
Native language support
CONFIG_NLS
本地语言支持. 仅在你使用 FAT/NTFS/JOLIET 文件系统的情况下才需要这个东西.
Default NLS Option
CONFIG_NLS_DEFAULT
挂载文件系统时, 控制台的默认本地语言 (不是文件系统用于存储文件名的语言), 建议设为 &ldquo;utf8&rdquo;(因为控制台的默认编码是 &ldquo;utf8&rdquo;:vt.default_utf8=1).
{此处省略的各种字符集请按需选择}
Distributed Lock Manager (DLM)
CONFIG_DLM
通用的分布式锁管理器 ( DLM). 用于为各种分布式文件系统提供通用的锁定支持. 集群强烈依赖于这个驱动.
DLM debugging
CONFIG_DLM_DEBUG
仅供开发与调试使用
Kernel hacking
内核 hack 选项
Show timing information on printks
CONFIG_PRINTK_TIME
在控制台和 syslog() 系统调用的输出中包含 printk() 消息的时间戳, 以便于直接显示内核启动过程中各步骤所用的时间. 注意: 无论此项是否开启, 时间戳总会被记录在 / dev/kmsg 中, 开启此项仅相当于使用 &ldquo;printk.time=1&rdquo; 内核引导参数.
Default message log level (1-7)
CONFIG_DEFAULT_MESSAGE_LOGLEVEL
printk() 内核消息日志的默认级别, 取值范围是 [1,7]. 任何由 printk 显示的字符串通常记录在 / var/log/messages 文件里. 数值越大显示的消息就越详细: 1=ALERT,2=CRIT,3=ERR,4=WARNING,5=NOTICE,6=INFO,7=DEBUG.
Enable __deprecated logic
CONFIG_ENABLE_WARN_DEPRECATED
编译时开启 &ldquo;反对使用&rdquo; 逻辑检查, 关闭此项将不会显示类似 &ldquo;warning:&lsquo;foo&rsquo;is deprecated (declared at kernel/power/somefile.c:1234)&rdquo; 这样的警告消息.
Enable _<em>must_check logic
CONFIG_ENABLE_MUST_CHECK
编译时开启 &ldquo;必须检查&rdquo; 逻辑检查, 关闭此项将不会显示类似 &ldquo;warning: ignoring return value of&rsquo;foo&rsquo;, declared with attribute warn_unused_result&rdquo; 这样的警告消息.
Warn for stack frames larger than (needs gcc 4.4)
CONFIG_FRAME_WARN
堆栈帧大小警告阈值, 设置过小会导致编译时警告太多, 设为 &ldquo;0&rdquo; 可以关闭警告, 需要 GCC-4.4 或更高版本
Strip assembler-generated symbols during link
CONFIG_STRIP_ASM_SYMS
连接时剥离汇编器产生的内部符号 (类似&rsquo;.Lxxx&rsquo;), 这样可以净化 get_wchan() 之类的输出, 同时还可以减小内核尺寸. 建议开启.
Magic SysRq key
CONFIG_MAGIC_SYSRQ
开启 &quot; 魔法键 &ldquo;( SysRq, 允许用户按下 Alt+PrintScreen 后发送给内核特殊的命令) 支持 (可以通过 &ldquo;echo 0&gt; /proc/sys/kernel/sysrq&rdquo; 关闭). 由于 SysRq 会带来安全隐患 (允许未经登录的操作), 所以你应该仅在确实需要的场合开启. 更多详情参见 &quot; Documentation/sysrq.txt&rdquo; 文档
Enable magic SysRq key functions by default
CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE
设置默认开启哪些魔法键. 设为 &ldquo;1&rdquo; 表示开启所有魔法键, 设为 &ldquo;0&rdquo; 表示禁用所有魔法键. 或者按照 &quot; Documentation/sysrq.txt&quot; 文档的指引设置特定的码位.
Generate readable assembler code
CONFIG_READABLE_ASM
生成人类易读的汇编输出, 以方便内核调试. 这会禁用一些编译优化措施, 也会降低内核的运行速度.
Enable unused/obsolete exported symbols
CONFIG_UNUSED_SYMBOLS
导出无用和废弃的符号, 这将使内核不必要的增大. 建议关闭.
Debug Filesystem
CONFIG_DEBUG_FS
debugfs 是内核开发者用来存储调试信息的虚拟文件系统. 不搞内核开发就别选
Run &lsquo;make headers_check&rsquo; when building vmlinux
CONFIG_HEADERS_CHECK
在编译内核时运行&rsquo;make headers_check&rsquo;命令检查内核头文件的正确性, 当你修改了与用户空间相关的内核头文件后应该启用该选项
Enable full Section mismatch analysis
CONFIG_DEBUG_SECTION_MISMATCH
在编译时检查无效的引用. 仅供内核开发者使用
Make section mismatch errors non-fatal
CONFIG_SECTION_MISMATCH_WARN_ONLY
若选 &ldquo;N&rdquo;, 那么一旦出现 &ldquo;section mismatch&rdquo;, 将会直接导致编译失败 (而不是仅仅抛出警告). 建议选 &ldquo;N&rdquo;.
Kernel debugging
CONFIG_DEBUG_KERNEL
仅供内核开发者使用.[提示] 如果你开启了 CONFIG_EXPERT, 此项会被强制选中, 如果这不是你想要的, 可以到内核源码树的根目录下使用 &ldquo;sed -i&rsquo;/select DEBUG_KERNEL/d&rsquo;usr/src/linux/init/Kconfig&rdquo; 命令去掉这个依赖.
Panic on Oops
CONFIG_PANIC_ON_OOPS
当内核 oops 时, 直接 panic 掉 (相当于 Windows 蓝屏死机), 这样可以确保内核停止工作, 避免导致无法预料的后果. 等价于使用 &ldquo;oops=panic&rdquo; 内核引导参数. 不确定的选 &ldquo;Y&rdquo;.
panic timeout
CONFIG_PANIC_TIMEOUT
如何处理内核崩溃 (panic):(1) 若设为 &ldquo;0&rdquo; 则表示无限等待, 不做任何处理;(2)若设为正整数则表示等待设定的秒数之后重启;(3)若设为负整数则表示立即重启.
Enable extra timekeeping sanity checking
CONFIG_DEBUG_TIMEKEEPING
仅供内核开发者使用
Detect Hung Tasks
CONFIG_DETECT_HUNG_TASK
探测挂起的任务 (进程被锁住或者冻结了, 处于不可中断的 &ldquo;D&rdquo; 状态). 由于仅能检测, 不能做进一步的处理, 所以仅用于帮助内核调试.
Collect scheduler debugging info
CONFIG_SCHED_DEBUG
提供一个 &ldquo;/proc/sched_debug&rdquo; 文件以帮助调试调度程序. 仅供内核开发以及调试调度程序使用.
Collect scheduler statistics
CONFIG_SCHEDSTATS
收集调度程序的统计信息, 并展示在 &ldquo;/proc/schedstat&rdquo; 文件中. 可以用于调试调度程序, 或者调整特定的应用程序. 不确定的选 &ldquo;N&rdquo;.
Collect kernel timers statistics
CONFIG_TIMER_STATS
收集内核计时器的统计信息, 并展示在 &ldquo;/proc/timer_stats&rdquo; 文件中. 使用 &ldquo;echo 1 &gt; /proc/timer_stats&rdquo; 开启统计, 使用 &ldquo;echo 0 &gt; /proc/timer_stats&rdquo; 关闭统计. 不确定的选 &ldquo;N&rdquo;.
Debug object operations
CONFIG_DEBUG_OBJECTS
跟踪各种对象的生命周期 (life time), 并校验对这些对象的各种操作. 仅供内核调试.
Debug slab memory allocations
CONFIG_DEBUG_SLAB
仅供内核开发者使用
SLUB debugging on by default
CONFIG_SLUB_DEBUG_ON
默认开启 SLUB 内存分配器调试功能. 仅供调试, 切勿用于生产环境.
Enable SLUB performance statistics
CONFIG_SLUB_STATS
收集 SLUB 内存分配器的性能统计信息. 仅供调试, 切勿用于生产环境.
Kernel memory leak detector
CONFIG_DEBUG_KMEMLEAK
内核内存泄漏检测. 仅供内核调试.
Debug preemptible kernel
CONFIG_DEBUG_PREEMPT
对内核的主动抢占特性进行调试. 仅供内核开发者使用
RT Mutex debugging, deadlock detection
CONFIG_DEBUG_RT_MUTEXES
仅供内核开发者使用
Built-in scriptable tester for rt-mutexes
CONFIG_RT_MUTEX_TESTER
仅供内核开发者使用
Spinlock and rw-lock debugging: basic checks
CONFIG_DEBUG_SPINLOCK
仅供内核开发者使用
Mutex debugging: basic checks
CONFIG_DEBUG_MUTEXES
仅供内核开发者使用
Lock debugging: detect incorrect freeing of live locks
CONFIG_DEBUG_LOCK_ALLOC
仅供内核开发者使用
Lock debugging: prove locking correctness
CONFIG_PROVE_LOCKING
仅供内核开发者使用
Lock usage statistics
CONFIG_LOCK_STAT
仅供内核开发者使用
Lock dependency engine debugging
CONFIG_DEBUG_LOCKDEP
仅供内核开发者使用
Sleep inside atomic section checking
CONFIG_DEBUG_ATOMIC_SLEEP
仅供内核开发者使用
Locking API boot-time self-tests
CONFIG_DEBUG_LOCKING_API_SELFTESTS
在内核启动时运行一个简短的加锁 / 解锁函数 (spinlocks,rwlocks,mutexes,rwsems) 自我测试. 仅供内核开发者使用
Stack utilization instrumentation
CONFIG_DEBUG_STACK_USAGE
仅供内核开发者使用
kobject debugging
CONFIG_DEBUG_KOBJECT
仅供内核开发者使用
Verbose BUG() reporting (adds 70K)
CONFIG_DEBUG_BUGVERBOSE
在内核 panic 时让 BUG() 函数报告更详细的信息. 内核将会增大 70-100K.
Compile the kernel with debug info
CONFIG_DEBUG_INFO
以调试方式编译内核 (gcc -g). 仅供内核开发者使用
Debug VM
CONFIG_DEBUG_VM
仅供内核开发者使用
Debug VM translations
CONFIG_DEBUG_VIRTUAL
仅供内核开发者使用
Debug filesystem writers count
CONFIG_DEBUG_WRITECOUNT
仅供内核开发者使用
Debug memory initialisation
CONFIG_DEBUG_MEMORY_INIT
在内存初始化时增加额外的合理性检查. 不确定的选 &ldquo;Y&rdquo;.
Debug linked list manipulation
CONFIG_DEBUG_LIST
仅供内核开发者使用
Linked list sorting test
CONFIG_TEST_LIST_SORT
仅供内核开发者使用
Debug SG table operations
CONFIG_DEBUG_SG
仅供内核开发者使用
Debug notifier call chains
CONFIG_DEBUG_NOTIFIERS
仅供内核开发者使用
Debug credential management
CONFIG_DEBUG_CREDENTIALS
仅供内核开发者使用
Compile the kernel with frame pointers
CONFIG_FRAME_POINTER
仅供内核开发者使用
Delay each boot printk message by N milliseconds
CONFIG_BOOT_PRINTK_DELAY
仅供内核开发者使用
Stack backtrace support
CONFIG_STACKTRACE
仅供内核开发者使用.
RCU Debugging
仅供内核开发者使用. 建议所有子项全选 &ldquo;N&rdquo;.
Kprobes sanity tests
CONFIG_KPROBES_SANITY_TEST
仅供内核开发者使用
Self test for the backtrace code
CONFIG_BACKTRACE_SELF_TEST
仅供内核开发者使用
Force extended block device numbers and spread them
CONFIG_DEBUG_BLOCK_EXT_DEVT
仅供内核开发者使用
Force weak per-cpu definitions
CONFIG_DEBUG_FORCE_WEAK_PER_CPU
仅供内核开发者使用
Debug access to per_cpu maps
CONFIG_DEBUG_PER_CPU_MAPS
仅供内核开发者使用
Linux Kernel Dump Test Tool Module
CONFIG_LKDTM
仅供内核开发者使用
Notifier error injection
CONFIG_NOTIFIER_ERROR_INJECTION
仅供内核开发者使用
Fault-injection framework
CONFIG_FAULT_INJECTION
仅供内核开发者使用
Latency measuring infrastructure
CONFIG_LATENCYTOP
仅供内核开发者使用
Strict user copy size checks
CONFIG_DEBUG_STRICT_USER_COPY_CHECKS
仅供内核开发者使用
Debug page memory allocations
CONFIG_DEBUG_PAGEALLOC
仅供内核开发者使用
Tracers
CONFIG_FTRACE
仅供内核开发者使用. 建议选 &ldquo;N&rdquo;.
Runtime Testing
运行时自我检查. 建议子项全选 &ldquo;N&rdquo;.
Red-Black tree test
CONFIG_RBTREE_TEST
仅供内核开发者使用
Interval tree test
CONFIG_INTERVAL_TREE_TEST
仅供内核开发者使用
Remote debugging over FireWire early on boot
CONFIG_PROVIDE_OHCI1394_DMA_INIT
仅供内核开发者使用
Remote debugging over FireWire with firewire-ohci
CONFIG_FIREWIRE_OHCI_REMOTE_DMA
仅供内核开发者使用
Build targets in Documentation/ tree
CONFIG_BUILD_DOCSRC
编译内核源码树下 &ldquo;Documentation&rdquo; 目录中的目标. 不确定的选 &ldquo;N&rdquo;.
Enable dynamic printk() support
CONFIG_DYNAMIC_DEBUG
仅供内核开发者使用
Enable debugging of DMA-API usage
CONFIG_DMA_API_DEBUG
仅供内核开发者使用
Perform an atomic64_t self-test at boot
CONFIG_ATOMIC64_SELFTEST
仅供内核开发者使用
Self test for hardware accelerated raid6 recovery
CONFIG_ASYNC_RAID6_TEST
仅供内核开发者使用
Sample kernel code
CONFIG_SAMPLES
内核示例代码. 仅供内核开发者使用
KGDB: kernel debugger
CONFIG_KGDB
仅供内核开发者使用
kmemcheck: trap use of uninitialized memory
CONFIG_KMEMCHECK
仅供内核开发者使用
Test functions located in the string_helpers module at runtime
CONFIG_TEST_STRING_HELPERS
仅供内核开发者使用
Test kstrto*() family of functions at runtime
CONFIG_TEST_KSTRTOX
仅供内核开发者使用
Filter access to /dev/mem
CONFIG_STRICT_DEVMEM
如果选 &ldquo;N&rdquo;, 那么用户空间的 root 用户将可以通过 /dev/mem 访问所有内存空间 (包括用户空间与内核空间), 以方便调试内核. 如果选 &ldquo;Y&rdquo;, 那么内核空间除了 PCI 和 BIOS 部分以及数据区之外, 都禁止访问, 以保护系统安全. 不确定的选 &ldquo;Y&rdquo;.
Enable verbose x86 bootup info messages
CONFIG_X86_VERBOSE_BOOTUP
在启动时显示额外 bzimage 解压消息, 显示详细的内核引导信息. 建议选 &ldquo;N&rdquo; 使引导过程更安静 (依然会显示错误信息).
Early printk
CONFIG_EARLY_PRINTK
将内核日志直接输出到 VGA 缓冲或串口. 这有助于调试那些在控制台尚未完成初始化之前就造成系统崩溃的 bug.
Early printk via EHCI debug port
CONFIG_EARLY_PRINTK_DBGP
支持将内核日志直接通过 EHCI 调试端口输出. 选 &ldquo;N&rdquo;, 除非你想调试内核.
Dump the EFI pagetable
CONFIG_EFI_PGT_DUMP
仅供内核开发者使用
Check for stack overflows
CONFIG_DEBUG_STACKOVERFLOW
仅供内核开发者使用
Export kernel pagetable layout to userspace via debugfs
CONFIG_X86_PTDUMP
仅供内核开发者使用
Write protect kernel read-only data structures
CONFIG_DEBUG_RODATA
仅供内核开发者使用
Set loadable kernel module data as NX and text as RO
CONFIG_DEBUG_SET_MODULE_RONX
将内核模块的数据区标记为 NX(不可执行), 文本段标记为 RO(只读), 以防止不良模块 (例如被植入病毒的模块) 对系统的破坏, 也能预防某些类型的内核入侵. 这需要 CPU 支持 NX 位 (CPU flags 中要含有 &ldquo;nx&rdquo; 标志). 但是这也有副作用: 会与运行时代码补丁冲突, 还会导致动态内核跟踪失效. 建议选 &ldquo;Y&rdquo;, 除非你需要调试内核, 或者需要为运行中的模块打补丁.
Testcase for the NX non-executable stack feature
CONFIG_DEBUG_NX_TEST
对处理器的 NX 的测试用例. 仅供内核开发者使用
Set upper limit of TLB entries to flush one-by-one
CONFIG_DEBUG_TLBFLUSH
仅供内核开发者使用
Enable doublefault exception handler
CONFIG_DOUBLEFAULT
仅供内核开发者使用
Enable IOMMU debugging
CONFIG_IOMMU_DEBUG
仅供内核开发者使用
Enable IOMMU stress-test mode
CONFIG_IOMMU_STRESS
仅供内核开发者使用
IOMMU leak tracing
CONFIG_IOMMU_LEAK
仅供内核开发者使用
x86 instruction decoder selftest
CONFIG_X86_DECODER_SELFTEST
仅供内核开发者使用
IO delay type
IO 延迟方式
port 0x80 based port-IO delay
CONFIG_IO_DELAY_0X80
传统的 Linux IO 延迟方式, 久经考验, 也是最安全的默认值.
port 0xed based port-IO delay
CONFIG_IO_DELAY_0XED
基于 0xed 端口的 IO 延迟方式, 主要是为了避免和基于 0x80 端口的 主板诊断卡冲突. 绝大多数人都没有主板诊断卡, 除非那些专门维修主板的硬件工程师.
udelay based port-IO delay
CONFIG_IO_DELAY_UDELAY
使用内核端 udelay() 函数作为延迟方法 (简单的延迟 2 微秒). 可以不占用任何 IO 端口空间.
no port-IO delay
CONFIG_IO_DELAY_NONE
不使用任何 port-IO 延迟机制. 只要你的机器不是老古董, 建议选择此项.
Debug boot parameters
CONFIG_DEBUG_BOOT_PARAMS
仅供内核开发者使用
CPA self-test code
CONFIG_CPA_DEBUG
仅供内核开发者使用
Allow gcc to uninline functions marked &lsquo;inline&rsquo;
CONFIG_OPTIMIZE_INLINING
允许 GCC 将标记为内联 (inline) 的函数变成非内联(uninline). 选 &ldquo;Y&rdquo; 后将完全无视代码中的 &ldquo;inline&rdquo; 标记, 完全由 GCC 自行决定是否应该将函数内联. 由于 GCC4.x 系列更新了判断函数是否应该内联的算法, 选 &ldquo;Y&rdquo; 后, 编译出的内核体积会减小(但运行速度未必提升). 建议选 &ldquo;Y&rdquo;.
NMI Selftest
CONFIG_DEBUG_NMI_SELFTEST
对不可屏蔽中断 (Non Maskable Interrupt) 进行自检, 仅供内核开发者使用
ATOM Punit debug driver
CONFIG_PUNIT_ATOM_DEBUG
仅供内核开发者使用
Security options
安全选项
这里的选项不明白的建议不要选, 否则有可能弄巧成拙.
Enable access key retention support
CONFIG_KEYS
在内核中保留认证令牌 ( authentication token)和访问密钥 (access key).eCryptfs(CONFIG_ECRYPT_FS) 与 Docker 依赖于它. 不确定的选 &ldquo;N&rdquo;.
TRUSTED KEYS
CONFIG_TRUSTED_KEYS
&ldquo;TRUSTED KEY&rdquo; 的意思是由 TPM( 可信赖平台模块) 用 RSA 算法封装的一对随机数. 开启此项后, 内核将可以为创建 / 封装 / 解封 &ldquo;TRUSTED KEY&rdquo; 提供支持. 如果引导 PCR(平台配置寄存器) 和各种条件都匹配, 那么 TPM 只解封密钥. 用户空间永远只能看到加密过后的二进制内容. 不确定的选 &ldquo;N&rdquo;.
ENCRYPTED KEYS
CONFIG_ENCRYPTED_KEYS
&ldquo;ENCRYPTED KEY&rdquo; 的意思是由内核封装的一对随机数, 该对随机数可以用一个 &ldquo;主密钥&rdquo; 使用对称加密算法进行加密和解密. 开启此项后, 内核将可以为创建 / 加密 / 解密 &ldquo;ENCRYPTED KEY&rdquo; 提供支持.&ldquo;主密钥&rdquo; 既可以是 &ldquo;TRUSTED KEY&rdquo; 也可以是 &ldquo;user-key&rdquo;(用户选择的密钥). 用户空间永远只能看到 / 存储加密过后的二进制内容. 不确定的选 &ldquo;N&rdquo;.
Enable the /proc/keys file by which keys may be viewed
CONFIG_KEYS_DEBUG_PROC_KEYS
开启 &ldquo;/proc/keys&rdquo; 文件支持, 该文件中保存了系统上所有可见的密钥. 注意, LSM(Linux 安全模块) 安全检查仍然是必须的. 不确定的选 &ldquo;N&rdquo;.
Restrict unprivileged access to the kernel syslog
CONFIG_SECURITY_DMESG_RESTRICT
禁止非特权用户访问内核日志 ( dmesg), 相当于 &ldquo;echo 1 &gt; /proc/sys/kernel/dmesg_restrict&rdquo;. 不确定的选 &ldquo;N&rdquo;.
Enable different security models
CONFIG_SECURITY
允许内核选择不同的 LSM( Linux 安全模块), 如果未选中则内核将使用默认的安全模块 (&ldquo;Default security module&rdquo;). 不确定的选 &ldquo;N&rdquo;.
Enable the securityfs filesystem
CONFIG_SECURITYFS
securityfs 安全文件系统支持. 当前仅被 TPM bios 字符设备驱动以及 IMA(完整性提供者) 使用. 它与 SELinux 或 SMACK 之类没有关系. 不确定的选 &ldquo;N&rdquo;.
Socket and Networking Security Hooks
CONFIG_SECURITY_NETWORK
允许安全模块通过 Security Hook 对 Socket 与 Networking 进行访问控制. 不确定的选 &ldquo;N&rdquo;.
XFRM (IPSec) Networking Security Hooks
CONFIG_SECURITY_NETWORK_XFRM
为 XFRM(IPSec) 启用安全 Hook. 这样安全模块可以通过这些 hook, 根据 IPSec 策略标签, 实现针对每个网络包的访问控制. 非 IPSec 通信则被当做 &ldquo;无标签&rdquo; 处理, 仅允许那些被明确批准可以不使用策略标签的 socket 才能不通过 IPSec 进行通信. 不确定的选 &ldquo;N&rdquo;.
Security hooks for pathname based access control
CONFIG_SECURITY_PATH
此安全钩子程序可以让各种安全模块实现基于路径的访问控制. 不确定的选 &ldquo;N&rdquo;.
Enable Intel(R) Trusted Execution Technology (Intel(R) TXT)
CONFIG_INTEL_TXT
支持使用 可信引导 ( Trusted Boot) 技术引导内核 (需要使用 tboot 模块). 这将使用英特尔 TXT( 可信任执行技术) 来引导内核. 在不支持 TXT 的平台上开启此项没有效果. 详见 &quot; Documentation/intel_txt.txt&quot;文档. 不确定的选&quot;N&quot;.
Low address space for LSM to protect from user allocation
CONFIG_LSM_MMAP_MIN_ADDR
禁止用户空间分配的低位内存范围. 禁止用户写入低位内存有助于降低内核 NULL 指针漏洞造成的破坏 (参见 CONFIG_DEFAULT_MMAP_MIN_ADDR 选项). 建议保持默认值 &ldquo;65536&rdquo;.
NSA SELinux Support
CONFIG_SECURITY_SELINUX
SELinux(安全增强 Linux)是美国国家安全局 (NSA) 开发的 Linux 安全模块, 它拥有一个灵活而强制性的访问控制结构, 可防御未知攻击, 相当于 B1 级的军事安全性能 (比微软所谓的 C2 等高得多). 应用 SELinux 后, 可以减轻恶意攻击或恶意软件带来的灾难, 对机密性和完整性有很高要求的信息, 亦可提供很高的安全保障. 但另一方面, 如果不深入 了解 SELinux 知识而盲目使用, 则会弄巧成拙. 不确定的选 &ldquo;N&rdquo;.
NSA SELinux boot parameter
CONFIG_SECURITY_SELINUX_BOOTPARAM
添加 &ldquo;selinux&rdquo; 内核引导参数. 以允许在引导时使用&rsquo;selinux=0&rsquo;禁用 SELinux 或&rsquo;selinux=1&rsquo;启用 SELinux.
NSA SELinux boot parameter default value
CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE
&ldquo;selinux&rdquo; 内核引导参数的默认值.
NSA SELinux runtime disable
CONFIG_SECURITY_SELINUX_DISABLE
允许在运行时禁用 SELinux. 建议选 &ldquo;N&rdquo;.
NSA SELinux Development Support
CONFIG_SECURITY_SELINUX_DEVELOP
SELinux 开发支持. 开启此项后, 除非明确使用 &ldquo;enforcing=1&rdquo; 引导参数让内核以 &ldquo;强制模式&rdquo; 运行, 否则内核将以 &ldquo;许可模式&rdquo; 运行 (记录所有事件, 同时允许所有操作). 主要用于测试 SELinux 以及策略开发. 此外, 开启此项后, 还可以在运行时通过 &ldquo;/selinux/enforce&rdquo; 让内核在 &ldquo;强制模式&rdquo; 与 &ldquo;许可模式&rdquo; 之间切换.
NSA SELinux AVC Statistics
CONFIG_SECURITY_SELINUX_AVC_STATS
搜集访问向量缓存 (access vector cache) 的统计信息并在 / selinux/avc/cache_stats 中显示出来. 这些信息可以用 avcstat 之类的工具查看.
NSA SELinux checkreqprot default value
CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE
内核引导参数 &ldquo;checkreqprot&rdquo; 的默认值. 设为 &ldquo;0&rdquo; 表示默认检查内核要求执行的保护策略, 设为 &ldquo;1&rdquo; 表示默认检查应用程序要求执行的保护策略. 此值还可以在运行时通过 / selinux/checkreqprot 修改. 不确定的选 &ldquo;1&rdquo;.
NSA SELinux maximum supported policy format version
CONFIG_SECURITY_SELINUX_POLICYDB_VERSION_MAX
将支持的策略格式的最高版本设置为一个特定的数值. 该数值将通过 / selinux/policyvers 向用户空间报告, 并在加载策略时被使用. 不确定的选 &ldquo;N&rdquo;.
NSA SELinux maximum supported policy format version value
支持策略格式的最高版本的数值. 可以通过 &ldquo;checkpolicy -V&rdquo; 命令检查当前工具链支持的版本数值.
Simplified Mandatory Access Control Kernel Support
CONFIG_SECURITY_SMACK
Smack(简化的强制访问控制内核) 内核安全模块. Smack 是一种简单而有效的强制访问控制机制, 它的简单体现在安全策略的配置很简单, 它的有效体现在完全使用 LSM 作为其控制手段. 不确定的选 &ldquo;N&rdquo;.
TOMOYO Linux Support
CONFIG_SECURITY_TOMOYO
TOMOYO Linux 是日本 NTT 数据公司开发的一种 Linux 安全模块. 不确定的选 &ldquo;N&rdquo;.
AppArmor support
CONFIG_SECURITY_APPARMOR
AppArmor(应用盔甲) 是来自 Novell 的一种 Linux 安全模块. AppArmor 使用文件路径来跟踪程序限制, 是最容易配置的安全模块. 不确定的选 &ldquo;N&rdquo;.
Yama support
CONFIG_SECURITY_YAMA
Yama(阎王) 是 3.4 版内核新引入的一种 Linux 安全模块. 不确定的选 &ldquo;N&rdquo;.
Digital signature verification using multiple keyrings
CONFIG_INTEGRITY_SIGNATURE
允许使用多个 密钥环 (keyring)进行数字签名验证, 也就允许为多个不同的使用场合 (evm,ima,module) 分别使用不同的 keyring. 看不懂的选 &ldquo;N&rdquo;.
Enable asymmetric keys support
CONFIG_INTEGRITY_ASYMMETRIC_KEYS
允许使用非对称密钥进行数字签名验证.
Integrity Measurement Architecture(IMA)
CONFIG_IMA
IMA(完整性度量架构) 是一个在 TCG( 可信计算工作组) 技术规范之上提出的完整性检查技术. IMA 维护着一个系统关键文件的哈希值列表, 从而可以检测这些关键文件是否被篡改. 如果系统上有 TPM 安全芯片, 那么 IMA 还会在 TPM 芯片内存储哈希值的集合. 这样的 TPM 芯片可以提供给第三方, 用于检查系统上的关键文件是否被篡改. 不确定的选 &ldquo;N&rdquo;.
Enables auditing support
CONFIG_IMA_AUDIT
添加 &ldquo;ima_audit&rdquo; 内核引导参数支持. 当设为 &ldquo;ima_audit=1&rdquo; 时, 将允许显示完整性审计信息.
Appraise integrity measurements
CONFIG_IMA_APPRAISE
本地完整性鉴定支持. 这样就可以在加载文件时检验它的完整性. 这要求系统配置 EVM 支持. 不确定的选 &ldquo;N&rdquo;.
EVM support
CONFIG_EVM
EVM 通过保护文件的安全扩展属性来对抗完整性攻击.
EVM HMAC version
CONFIG_EVM_HMAC_VERSION
支持的 EVM HMAC 版本:&ldquo;1&rdquo; 表示原始版本, 默认值 &ldquo;2&rdquo; 表示添加了文件系统 UUID 支持的改进版本.
Default security module
内核默认的安全模块.[提示]&ldquo;Unix Discretionary Access Controls&rdquo; 是经典的 UNIX 基于目录的访问控制安全模型. 如果没有开启任何安全模块, 这将是默认值.
Cryptographic API
内核加密 API 支持
这里的加密算法被广泛的应用于驱动程序通信协议等机制中. 子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上. 使用内核树外的模块时可能需要手动选择.
FIPS 200 compliance
CONFIG_CRYPTO_FIPS
&ldquo;fips&rdquo; 内核引导参数支持. 这是在 FIPS200 认证的系统中运行所必须的. 选 &ldquo;N&rdquo;, 除非你确实知道自己在做什么.
RSA algorithm
CONFIG_CRYPTO_RSA
&quot; RSA&quot; 公钥加密算法. 能同时用于密钥交换和数字签名.
Cryptographic algorithm manager
CONFIG_CRYPTO_MANAGER
创建默认的加密模版实例, 提供了操作内核的加密特性所需的软件.
Userspace cryptographic algorithm configuration
CONFIG_CRYPTO_USER
允许用户空间配置内核加密实例. 不确定的选 &ldquo;N&rdquo;.
Disable run-time self tests
CONFIG_CRYPTO_MANAGER_DISABLE_TESTS
禁止在注册算法时进行简单的自我检测. 不确定的选 &ldquo;Y&rdquo;.
GF(2^128) multiplication functions
CONFIG_CRYPTO_GF128MUL
由高效表格驱动的 伽罗瓦域 GF(2^128) 乘法器支持. 某些加密模式需要它. 不确定的选 &ldquo;N&rdquo;. 如果有其它模块需要此特性, 会被自动选中.
Null algorithms
CONFIG_CRYPTO_NULL
NULL 加密算法 (什么也不做), 用于 IPsec 协议的封装安全载荷模块 (ESP)
Parallel crypto engine
CONFIG_CRYPTO_PCRYPT
将任意加密算法转化成并行算法, 并在内核线程中执行.
Software async crypto daemon
CONFIG_CRYPTO_CRYPTD
这是一个通用的软件异步加密守护进程, 可将任意的同步软件加密算法转换成在内核线程中执行的异步算法.
Software async multi-buffer crypto daemon
CONFIG_CRYPTO_MCRYPTD
这是一个通用的软件异步加密守护进程, 可将任意的多缓冲加密算法转换成在内核线程中执行的异步多缓冲加密算法.
Authenc support
CONFIG_CRYPTO_AUTHENC
用于 IPSec 组合模式的包装器: 认证加密并对 IPSec 提供多重加密.
Testing module
CONFIG_CRYPTO_TEST
丑陋的加密测试模块. 仅供调试使用.
CCM support
CONFIG_CRYPTO_CCM
CBC-MAC 计数器. IPsec 需要它.
GCM/GMAC support
CONFIG_CRYPTO_GCM
GCM( Galois/Counter Mode) 与 GMAC(Galois Message Authentication Code) 支持. IPsec 需要它.[注释]GCM 是一种对称加密算法的块密码工作模式, 使用 128 位块大小. 块密码工作模式可以分为加密模式, 认证模式, 认证加密模式. GCM 模式为认证模式的一种, 提供认证和加密两种功能.
Sequence Number IV Generator
CONFIG_CRYPTO_SEQIV
序号初始向量 (IV) 生成器. 它基于一个序号与一个盐粒子 (salt) 的异或值生成一个向量. 此算法主要用于块密码的 CTR(计数模式).
CBC support
CONFIG_CRYPTO_CBC
块密码工作模式: 密码分组链接 (Cipher Block Chaining) 模式. IPSec 需要它.
CTR support
CONFIG_CRYPTO_CTR
块密码工作模式: 计数器 (Counter) 模式. IPSec 需要它.
CTS support
CONFIG_CRYPTO_CTS
块密码工作模式: 密文窃取 (Cipher Text Stealing) 模式. Kerberos gss 机制支持的 AES 加密需要它.
ECB support
CONFIG_CRYPTO_ECB
块密码工作模式电子密码本 (Electronic CodeBook) 模式. 这是最简单的分组密码算法, 只是简单的分别加密每个块.
LRW support
CONFIG_CRYPTO_LRW
块密码工作模式:LRW(Liskov Rivest Wagner) 模式. 这个模式以三个人名命名. 这是一种小数据块加密模式, 加密后的数据保持与明文数据同样的长度, 专门用于 CONFIG_DM_CRYPT 模块加密磁盘区块 (使用 &ldquo;aes-lrw-benbi&rdquo; 指定).
PCBC support
CONFIG_CRYPTO_PCBC
块密码工作模式: 填充密码块链接 (Propagating Cipher Block Chaining) 模式. CONFIG_AF_RXRPC 需要它.
XTS support
CONFIG_CRYPTO_XTS
块密码工作模式:XTS 模式. 这是 IEEE1619/D16 规范制定的一种小数据块加密模式, 加密后的数据保持与明文数据同样的长度, 专门用于加密磁盘区块 (使用 &ldquo;aes-xts-plain&rdquo; 指定).
CMAC support
CONFIG_CRYPTO_CMAC
NIST(美国国家标准与技术研究所) 制定的基于密文的 消息认证码 ( Cipher-based Message Authentication Code)
HMAC support
CONFIG_CRYPTO_HMAC
基于哈希的消息验证代码 ( RFC2104). 在发送方和接收方共享机密密钥的前提下, HMAC 可用于确定通过不安全信道发送的消息是否被篡改. IPSec 需要它.
XCBC support
CONFIG_CRYPTO_XCBC
基于哈希的加密算法 ( RFC3566)
VMAC support
CONFIG_CRYPTO_VMAC
VMAC 是一种专用于 64 位 CPU 的高速消息认证算法
CRC32c CRC algorithm
CONFIG_CRYPTO_CRC32C
CRC32c 摘要算法是常见的 CRC32 循环冗余校验的一个变种, 仅多项式常数不同, 算法完全一样. 常用于 iSCSI 和 SCTP 数据校验.
CRC32c INTEL hardware acceleration
CONFIG_CRYPTO_CRC32C_INTEL
利用 SSE4.2 指令集中专用的 &ldquo;CRC32&rdquo; 指令, 可以提高最少 10 倍的运算速度. 如果你的 CPU 支持 SSE4.2, 建议选 &ldquo;Y&rdquo;.
CRC32 CRC algorithm
CONFIG_CRYPTO_CRC32
经典的 CRC32 循环冗余校验算法.
CRC32 PCLMULQDQ hardware acceleration
CONFIG_CRYPTO_CRC32_PCLMUL
使用处理器的 PCLMULQDQ 指令 (又称 CLMUL 指令集, 其实只有一条指令) 加速 CRC32 的运算. PCLMULQDQ 是从 Intel  Westmere 和 AMD  Bulldozer 开始引入的指令 (隶属于 AES 指令集). 可以大幅提升 CRC32 的运算速度. 如果你的 CPU 支持 AES 指令集 (grep aes /proc/cpuinfo), 建议选 &ldquo;Y&rdquo;.
CRCT10DIF algorithm
CONFIG_CRYPTO_CRCT10DIF
CRC T10 DIF(Data Integrity Field) 算法可用于保障 T10/SCSI 设备的端到端的数据完整性.
CRCT10DIF PCLMULQDQ hardware acceleration
CONFIG_CRYPTO_CRCT10DIF_PCLMUL
使用处理器的 PCLMULQDQ 指令 (又称 CLMUL 指令集, 其实只有一条指令) 加速 CRC T10 DIF 的运算. PCLMULQDQ 是从 Intel  Westmere 和 AMD  Bulldozer 开始引入的指令 (隶属于 AES 指令集). 可以大幅提升 CRC T10 DIF 的运算速度. 如果你的 CPU 支持 AES 指令集 (grep aes /proc/cpuinfo), 建议选 &ldquo;Y&rdquo;.
GHASH digest algorithm
CONFIG_CRYPTO_GHASH
GHASH 是用于 GCM(Galois/Counter Mode) 的消息摘要算法.
MD4 digest algorithm
CONFIG_CRYPTO_MD4
老旧的 MD4(RFC1320) 摘要算法, 已经被淘汰.
MD5 digest algorithm
CONFIG_CRYPTO_MD5
广泛使用的 MD5(RFC1321) 摘要算法, 128 位. 已经被发现可以快速找到碰撞, 正逐渐淘汰中.
Michael MIC keyed digest algorithm
CONFIG_CRYPTO_MICHAEL_MIC
Michael MIC 是仅用于 TKIP(IEEE 802.11i) 的摘要算法. 不能用于其它场合, 因为它存在一些缺陷.
RIPEMD-128 digest algorithm
CONFIG_CRYPTO_RMD128
RIPEMD-128(ISO/IEC 10118-3:2004)128 位摘要算法. 安全性不高, 不建议使用.
RIPEMD-160 digest algorithm
CONFIG_CRYPTO_RMD160
RIPEMD-160(ISO/IEC 10118-3:2004)160 位摘要算法. 是替代各种 128 位摘要算法 (RIPEMD-128,MD5,MD4) 的首选. 其运算速度和 SHA1 相当, 但是目前尚无已知有效的攻击方法.
RIPEMD-256 digest algorithm
CONFIG_CRYPTO_RMD256
RIPEMD-256 在本质上和 RIPEMD-128 是一样的. 因为 RIPEMD 的设计者们根本就没有真正设计 256 和 320 位这两种标准, 他们只是在 128 位和 160 位的基础上, 修改了初始参数和 s-box 来达到输出为 256 和 320 位的目的. 所以, 256 位的强度和 128 相当, 而 320 位的强度和 160 位相当.
RIPEMD-320 digest algorithm
CONFIG_CRYPTO_RMD320
RIPEMD-320 在本质上和 RIPEMD-160 是一样的. 因为 RIPEMD 的设计者们根本就没有真正设计 256 和 320 位这两种标准, 他们只是在 128 位和 160 位的基础上, 修改了初始参数和 s-box 来达到输出为 256 和 320 位的目的. 所以, 256 位的强度和 128 相当, 而 320 位的强度和 160 位相当.
SHA1 digest algorithm
CONFIG_CRYPTO_SHA1
目前使用最广泛的 SHA-1(FIPS 180-1/DFIPS 180-2)160 位摘要算法是 SHA 家族中的一员, 在许多安全协议中广为使用 (TLS,SSL,PGP,SSH,S/MIME,IPsec 等).SHA-1 曾被视为是 MD5 的后继者, 但由于出现了针对 SHA-1 的理论上破解的方法 (不等于实践中被破解), 有些人已经开始改用其它的替代算法 (例如 SHA-3).
SHA1 digest algorithm (SSSE3/AVX)
CONFIG_CRYPTO_SHA1_SSSE3
使用 SSSE3/ AVX 指令集加速 SHA-1 的计算. 如果你的 CPU 支持 SSSE3/AVX 指令集, 建议选 &ldquo;Y&rdquo;.
SHA256 digest algorithm (SSSE3/AVX/AVX2)
CONFIG_CRYPTO_SHA256_SSSE3
使用 SSSE3/ AVX/ AVX2 指令集加速 SHA-256 的计算.
SHA512 digest algorithm (SSSE3/AVX/AVX2)
CONFIG_CRYPTO_SHA512_SSSE3
使用 SSSE3/ AVX/ AVX2 指令集加速 SHA-512 的计算.
SHA224 and SHA256 digest algorithm
CONFIG_CRYPTO_SHA256
SHA-224 和 SHA-256 摘要算法, 速度较 SHA1 稍慢, 都属于 &ldquo;SHA-2&rdquo; 系列, 目前尚无已知的有效攻击方法. 但并未被广泛使用.
SHA384 and SHA512 digest algorithms
CONFIG_CRYPTO_SHA512
SHA-384 和 SHA-512 摘要算法, 速度大约只有 SHA1 的 40-50%, 都属于 &ldquo;SHA-2&rdquo; 系列, 目前尚无已知的有效攻击方法. 但并未被广泛使用.
Tiger digest algorithms
CONFIG_CRYPTO_TGR192
Tiger 号称是最快的哈希算法, 专门为 64 位机器做了优化.
Whirlpool digest algorithms
CONFIG_CRYPTO_WP512
Whirlpool 是一种 512 位的摘要算法, 利用了已有的 AES 分组密码算法构造 Hash 函数, 拥有相当高的安全性, 已经被列入了 ISO 标准, 目前最新版本为 3.0(2003 年发布).
GHASH digest algorithm (CLMUL-NI accelerated)
CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL
使用 CPU 的 CLMUL 指令集 (包含在 AES 指令集中) 加速 GHASH 摘要算法.
AES cipher algorithms
CONFIG_CRYPTO_AES
AES(FIPS-197) 又称 &ldquo;Rijndael&rdquo;, 是目前最佳的 对称加密算法, 快速且节省内存, 可以使用 128/192/256 位密钥, 是目前使用最广泛的对称加密算法.
AES cipher algorithms (x86_64)
CONFIG_CRYPTO_AES_X86_64
针对 x86_64 架构的 AES 实现.
AES cipher algorithms (AES-NI)
CONFIG_CRYPTO_AES_NI_INTEL
使用 AES 指令集加速 AES 的计算. 如果你的 CPU 支持 AES 指令集 (grep aes /proc/cpuinfo), 建议选 &ldquo;Y&rdquo;.
Anubis cipher algorithm
CONFIG_CRYPTO_ANUBIS
Anubis 是一种分组密码算法. 分组长度为 128 位, 密钥长度可变 (最低 128 位), 圈数可变 (最低 12 圈). 是欧洲于 2000 年 1 月 1 日启动的 NESSIE 计划 17 个候选分组加密算法之一.
ARC4 cipher algorithm
CONFIG_CRYPTO_ARC4
一种脆弱的流对称加密算法, 仅用于已经被淘汰的 WEP.
Blowfish cipher algorithm
CONFIG_CRYPTO_BLOWFISH
Blowfish 对称加密算法, 一种又老又慢的对称加密算法.
Blowfish cipher algorithm (x86_64)
CONFIG_CRYPTO_BLOWFISH_X86_64
针对 x86_64 架构的 Blowfish 实现
Blowfish cipher algorithm (x86_64/AVX2)
CONFIG_CRYPTO_BLOWFISH_AVX2_X86_64
使用 AVX2 指令集加速 Blowfish 的计算.
Camellia cipher algorithms
CONFIG_CRYPTO_CAMELLIA
Camellia 是欧盟 NESSIE 项目的选定算法, 也是日本 CRYPTREC 项目的推荐算法. 可以使用 128/192/256 位密钥, 具有与 AES 同等级的安全强度及运算速度.
Camellia cipher algorithm (x86_64)
CONFIG_CRYPTO_CAMELLIA_X86_64
针对 x86_64 架构的 Camellia 实现
Camellia cipher algorithm (x86_64/AES-NI/AVX)
CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64
使用 AES 指令集 / AVX 指令集加速 Camellia 的计算.
Camellia cipher algorithm (x86_64/AES-NI/AVX2)
CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64
使用 AES 指令集 / AVX2 指令集加速 Camellia 的计算.
CAST5 (CAST-128) cipher algorithm
CONFIG_CRYPTO_CAST5
老旧的 CAST5(CAST-128) 对称加密算法
CAST5 (CAST-128) cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_CAST5_AVX_X86_64
使用 AVX 指令集加速 CAST5 的计算.
CAST6 (CAST-256) cipher algorithm
CONFIG_CRYPTO_CAST6
老旧的 CAST6(CAST-256) 对称加密算法
CAST6 (CAST-256) cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_CAST6_AVX_X86_64
使用 AVX 指令集加速 CAST6 的计算.
DES and Triple DES EDE cipher algorithms
CONFIG_CRYPTO_DES
老旧的 DES 和三重 DES 对称加密算法.
FCrypt cipher algorithm
CONFIG_CRYPTO_FCRYPT
FCrypt 对称加密算法仅用于 CONFIG_AF_RXRPC
Khazad cipher algorithm
CONFIG_CRYPTO_KHAZAD
Khazad 是一种最终进入 NESSIE 决赛的对称加密算法, 专为 64 位 CPU 设计, 支持 128 位密钥.
Salsa20 stream cipher algorithm
CONFIG_CRYPTO_SALSA20
Salsa20 是一种 流密码算法, 也是 eSTREAM 工程最终胜选算法之一.
Salsa20 stream cipher algorithm (x86_64)
CONFIG_CRYPTO_SALSA20_X86_64
针对 x86_64 架构的 Salsa20 实现
SEED cipher algorithm
CONFIG_CRYPTO_SEED
SEED(RFC4269) 对称分组加密算法, 采用 128 位密钥, 是韩国的国家标准.
Serpent cipher algorithm
CONFIG_CRYPTO_SERPENT
Serpent 对称加密算法曾经是 AES 的最终 5 个候选算法之一, 因为速度较 Rijndael 慢而最终得票数次之. 目前尚未发现针对 Serpent 的有效攻击, 因此被认为是一种强安全算法 (甚至被认为比 Rijndael 更安全).
Serpent cipher algorithm (x86_64/SSE2)
CONFIG_CRYPTO_SERPENT_SSE2_X86_64
使用 SSE2 指令集加速 Serpent 的计算.
Serpent cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_SERPENT_AVX_X86_64
使用 AVX 指令集加速 Serpent 的计算.
Serpent cipher algorithm (x86_64/AVX2)
CONFIG_CRYPTO_SERPENT_AVX2_X86_64
使用 AVX2 指令集加速 Serpent 的计算.
TEA, XTEA and XETA cipher algorithms
CONFIG_CRYPTO_TEA
较弱的几种对称加密算法
Twofish cipher algorithm
CONFIG_CRYPTO_TWOFISH
Twofish 是派生自 Blowfish 的对称加密算法, 曾经是 AES 的最终 5 个候选算法之一, 最终得票数第三.
Twofish cipher algorithm (x86_64)
CONFIG_CRYPTO_TWOFISH_X86_64
针对 x86_64 架构的 Twofish 实现
Twofish cipher algorithm (x86_64, 3-way parallel)
CONFIG_CRYPTO_TWOFISH_X86_64_3WAY
针对 x86_64 架构的三路并行 Twofish 实现. 能够充分利用 乱序执行 CPU 的指令周期.
Twofish cipher algorithm (x86_64/AVX)
CONFIG_CRYPTO_TWOFISH_AVX_X86_64
使用 AVX 指令集加速 Twofish 的计算.
Twofish cipher algorithm (x86_64/AVX2)
CONFIG_CRYPTO_TWOFISH_AVX2_X86_64
使用 AVX2 指令集加速 Twofish 的计算.
Deflate compression algorithm
CONFIG_CRYPTO_DEFLATE
Deflate(RFC1951) 无损数据压缩算法. 当在 IPSec 中使用 IPCOMP 协议时才需要.
Zlib compression algorithm
CONFIG_CRYPTO_ZLIB
zlib 无损数据压缩算法是一种事实上的业界标准. 被广泛应用.
LZO compression algorithm
CONFIG_CRYPTO_LZO
LZO 是致力于解压速度的一种无损数据压缩算法.
Pseudo Random Number Generation for Cryptographic modules
CONFIG_CRYPTO_ANSI_CPRNG
符合 ANSI(美国国家标准学会)X9.31-1998 附录 A.2.4 所描述的伪随机数发生器 (基于 3DES). 这是一种较老的算法, 生成的随机数质量不高.
NIST SP800-90A DRBG
CONFIG_CRYPTO_DRBG_MENU
符合 NIST(美国国家标准技术局) SP800-90A 标准的伪随机数发生器 (DRBG). SP800-90A 是美国政府 FIPS 140-2 安全认证强制推广的加密标准, 其中包含了生成强随机数的算法. 这是一种较新的算法, 生成的随机数质量较高. 建议选 &ldquo;Y&rdquo;. 选中此项后, 还需选中至少一个子项.
Enable Hash DRBG
CONFIG_CRYPTO_DRBG_HASH
符合 NIST SP800-90A 标准的 Hash DRBG 变种算法 (基于 SHA256). 建议选 &ldquo;Y&rdquo;.
Enable CTR DRBG
CONFIG_CRYPTO_DRBG_CTR
符合 NIST SP800-90A 标准的 CTR DRBG 变种算法 (基于 AES). 建议选 &ldquo;Y&rdquo;.
Jitterentropy Non-Deterministic Random Number Generator
CONFIG_CRYPTO_JITTERENTROPY
JitterEntropy 伪随机数生成器以 CPU 执行时间的抖动作为熵源, 这是一种高质量的熵源, 可作为其他随机数生成器 ( /dev/urandom) 的种子. 这样就无需在系统启动时从磁盘上加载已经保存的种子文件了.
User-space interface for hash algorithms
CONFIG_CRYPTO_USER_API_HASH
哈希算法的用户空间接口. 不确定的选 &ldquo;N&rdquo;.
User-space interface for symmetric key cipher algorithms
CONFIG_CRYPTO_USER_API_SKCIPHER
对称加密算法的用户空间接口. 不确定的选 &ldquo;N&rdquo;.
User-space interface for random number generator algorithms
CONFIG_CRYPTO_USER_API_RNG
随机数发生器算法的用户空间接口. 不确定的选 &ldquo;N&rdquo;.
User-space interface for AEAD cipher algorithms
CONFIG_CRYPTO_USER_API_AEAD
AEAD(Authenticated-Encryption with Addtional Data) 加密算法的用户空间接口. AEAD 是当前最好的加密模式. 不确定的选 &ldquo;N&rdquo;.
Hardware crypto devices
CONFIG_CRYPTO_HW
硬件加密设备支持
Support for VIA PadLock ACE
CONFIG_CRYPTO_DEV_PADLOCK
带有 PadLock 技术的 VIA 系列处理器支持
PadLock driver for AES algorithm
CONFIG_CRYPTO_DEV_PADLOCK_AES
利用 PadLock 技术 加速 AES 运算.VIA C3 及以上的 CPU 都支持.
PadLock driver for SHA1 and SHA256 algorithms
CONFIG_CRYPTO_DEV_PADLOCK_SHA
利用 PadLock 技术 加速 SHA1 和 SHA256 运算.VIA C7 及以上的 CPU 都支持.
Support for AMD Cryptographic Coprocessor
CONFIG_CRYPTO_DEV_CCP
AMD 密码协处理器支持.
Support for Intel(R) DH895xCC
CONFIG_CRYPTO_DEV_QAT_DH895xCC
支持 QuickAssist 技术的 Intel DH895xcc 芯片. Skylake 的服务器平台的部分 CPU 型号支持 QuickAssist 技术.
Support for Intel(R) DH895xCC Virtual Function
CONFIG_CRYPTO_DEV_QAT_DH895xCCVF
支持 QuickAssist 技术的 Intel DH895xcc 芯片. Skylake 的服务器平台的部分 CPU 型号支持 QuickAssist 技术.
Asymmetric (public-key cryptographic) key type
CONFIG_ASYMMETRIC_KEY_TYPE
非对称加密算法 ( 公钥加密算法)
Asymmetric public-key crypto algorithm subtype
CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE
非对称公钥加密算法子类型. 如果需要生成或者校验签名, 那就还必须配合哈希算法一起使用.
RSA public-key algorithm
CONFIG_PUBLIC_KEY_ALGO_RSA
RSA 算法 ( PKCS#1, RFC3447) 支持
X.509 certificate parser
CONFIG_X509_CERTIFICATE_PARSER
X.509 证书解析支持
Certificates for signature checking
用于检查签名有效性的证书:(1)用于检查内核模块的签名,(2)用于检查全局密钥环 (keyring) 中的密钥的可靠性.
Virtualization
虚拟化支持
仅在将此内核用作宿主机 (host) 的情况下才需要开启这里的子项
Kernel-based Virtual Machine (KVM) support
CONFIG_KVM
KVM( 内核虚拟机) 是一种基于 Linux 内核的 全虚拟化技术, 需要 CPU 支持 x86 硬件虚拟化技术 (Intel VT 或 AMD-V). 开启此项后, 将可以通过字符文件 &ldquo;/dev/kvm&rdquo; 使用虚拟机.
KVM for Intel processors support
CONFIG_KVM_INTEL
Intel VT 技术支持. 也就是 cpu-flags 中有 &ldquo;vmx&rdquo; 标记.
KVM for AMD processors support
CONFIG_KVM_AMD
AMD-V 技术支持. 也就是 cpu-flags 中有 &ldquo;svm&rdquo; 标记.
Audit KVM MMU
CONFIG_KVM_MMU_AUDIT
添加一个 &ldquo;kvm.mmu_audit&rdquo; 内核参数, 用于控制是否允许在运行时对 KVM MMU 进行审计.&ldquo;0&rdquo; 表示禁止审计,&ldquo;1&rdquo; 表示允许审计. 主要用于调试目的. 不确定的选 &ldquo;N&rdquo;.
KVM legacy PCI device assignment support
CONFIG_KVM_DEVICE_ASSIGNMENT
通过 KVM 支持传统的 PCI 设备分配. 内核目前还通过 VFIO(CONFIG_VFIO) 支持一个全功能的 用户空间设备驱动框架, 可以取代这里的功能. 不确定的选 &ldquo;N&rdquo;.
Host kernel accelerator for virtio net
CONFIG_VHOST_NET
在宿主机内核中开启此项后, 可以加速客户机的网络操作速度 (客户机内核需要加载 virtio_net 模块 (CONFIG_VIRTIO_NET)). 建议选 &ldquo;Y&rdquo;.
VHOST_SCSI TCM fabric driver
CONFIG_VHOST_SCSI
Say M here to enable the vhost_scsi TCM fabric module for use with virtio-scsi guests. 看不懂的选 &ldquo;N&rdquo;.
Cross-endian support for vhost
CONFIG_VHOST_CROSS_ENDIAN_LEGACY
允许宿主机支持不同大小端顺序的客户机中老旧的 virtio 设备. 仅在宿主机与客户机的大小端顺序不一致的场合 (ppc64/arm64) 才有意义. 不确定的选 &ldquo;N&rdquo;.
Library routines
库子程序
子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上. 使用内核树外的模块时可能需要手动选择.
CRC-CCITT functions
CONFIG_CRC_CCITT
为内核树外的模块提供 CRC-CCITT 循环验证算法支持.
CRC16 functions
CONFIG_CRC16
为内核树外的模块提供 CRC16 循环验证算法支持.
CRC calculation for the T10 Data Integrity Field
CONFIG_CRC_T10DIF
为内核树外的模块提供 CRC 循环验证算法支持. 从而允许内核树外的 SCSI 模块利用 T10/SCSI Data Integrity Field 保障 端到端的数据完整性.
CRC ITU-T V.41 functions
CONFIG_CRC_ITU_T
为内核树外的模块提供 CRC ITU-T V.41 循环验证算法支持.
CRC32/CRC32c functions
CONFIG_CRC32
为内核树外的模块提供 CRC32/CRC32c 循环验证算法支持.
CRC32 perform self test on init
CONFIG_CRC32_SELFTEST
在 CRC32 算法初始化的时候进行一个简单的自我测试. 不确定的选 &ldquo;N&rdquo;.
CRC32 implementation
选择 CRC32 算法的实现方式. 不确定的请保持默认值 &ldquo;Slice by 8 bytes&rdquo;, 除非你知道自己在做什么.
CRC7 functions
CONFIG_CRC7
为内核树外的模块提供 CRC7 循环验证算法支持.
CRC32c (Castagnoli, et al) Cyclic Redundancy-Check
CONFIG_LIBCRC32C
为内核树外的模块提供 CRC32c 循环验证算法支持.
CRC8 function
CONFIG_CRC8
为内核树外的模块提供 CRC8 循环验证算法支持.
XZ decompression support
CONFIG_XZ_DEC
为内核树外的模块提供 XZ 解压支持. 详见 &quot; Documentation/xz.txt&quot;文档. 子项是针对不同平台的&quot;BCJ filter decoder&quot;. 按需选择即可.
XZ decompressor tester
CONFIG_XZ_DEC_TEST
XZ 解压测试程序. 不确定的选 &ldquo;N&rdquo;.
Averaging functions
CONFIG_AVERAGE
为内核树外的模块提供 averaging 函数支持
CORDIC algorithm
CONFIG_CORDIC
为内核树外的模块提供 CORDIC 算法支持
JEDEC DDR data
CONFIG_DDR
为内核树外的 DDR SDRAM 内存控制器驱动提供获取 JEDEC 数据支持.
Select compiled-in fonts
CONFIG_FONTS
选择内嵌到内核中的字体 (点阵字库, 仅包含 ASCII 字符和 扩展 ASCII 字符, 共 256 个). 选 &ldquo;N&rdquo; 表示内嵌自动选择的默认字体, 选 &ldquo;Y&rdquo; 表示可以手动选择内嵌的字体.[提示] 可到 drivers/video/console 目录下找到相应的 &ldquo;font</em>*.c&rdquo; 文件, 将其中的 &ldquo;0&rdquo; 全部替换为空格, 即可看到点阵字符.
VGA 8x8 font
CONFIG_FONT_8x8
这是传统上高分辨率 (高于 80x50) 下使用的字体. 因为点阵太小, 所以显示的字体质量非常低劣.
VGA 8x16 font
CONFIG_FONT_8x16
这是传统上的标准字体 (用于 80x25), 也是默认内嵌的字体, 最为常见.
{其它字体省略} console 16x16 CJK font ( cover BMP )
CONFIG_FONT_16x16_CJK
CJKTTY 开源项目提供的中文字体支持 (仅支持 UTF-8 字符) 补丁. 如果你希望能够直接在控制台上显示中文, 那么请将此项选 &ldquo;Y&rdquo;, 并同时将其他字体选项全部选 &ldquo;N&rdquo;. 如何改造 Linux 虚拟终端显示中文一文讲解了此补丁的原理.
<Select>	<Exit>	<Help>	<Save>	<Load>
确定	退出	帮助	保存配置	读入配置
全文完
本文由 简悦 SimpRead 优化，用以提升阅读体验
使用了 全新的简悦词法分析引擎 beta，点击查看详细说明
Linux-4.4-x86_64 内核配置选项简介
作者：金步国
General setup 常规设置
Enable loadable module support 可加载模块支持
Enable the block layer 块设备支持
Processor type and features 中央处理器 (CPU) 类型及特性
Power management and ACPI options 电源管理和 ACPI 选项
Bus options (PCI etc.) 总线选项
Executable file formats / Emulations 可执行文件格式 / 仿真
Networking support 网络支持
Device Drivers 设备驱动程序
Firmware Drivers 固件 (Firmware) 驱动
File systems 文件系统
Kernel hacking 内核 hack 选项
Security options 安全选项 这里的选项不明白的建议不要选, 否则有可能弄巧成拙.
Cryptographic API 内核加密 API 支持 这里的加密算法被广泛的应用于驱动程序通信协议等机制中. 子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上. 使用内核树外的模块时可能需要手动选择.
Virtualization 虚拟化支持 仅在将此内核用作宿主机 (host) 的情况下才需要开启这里的子项
Library routines 库子程序 子选项可以全不选, 内核中若有其他部分依赖它, 会自动选上. 使用内核树外的模块时可能需要手动选择.</p>
<p>家好，关于Linux的裁剪，内容实在太多，我想分几篇文章进行讲述，本人主要从自己实际工作出发，给大家讲解在实际工作中如何去做，内容可能不全，还请大家见谅。好了，废话少说，接下来我们就说说如何基于ARM对Linux进行实战裁剪。</p>
<p>今天这篇文章就从内核“通用配置”开始，以后每个大菜单会有一篇文章进行讲解。</p>
<p>在开始“通用配置”之前，我们先来做一些准备工作：</p>
<p>1.基于ARM架构编译好内核，参考上篇《ARM架构的linux内核交叉编译》；</p>
<p>2.修改内核Makefile文件，第一步完成后直接执行make menuconfig，进入后发现还是X86平台的配置，这里就有些不方便了，如何做到进菜单就可以配置基于ARM64的内核呢？这里提供一个方法是（你或许还有好的办法，请留言，一起学习 :-) ）：</p>
<p>缺省的Makefile里是ARCH ?= $(SUBARCH),这里我把SUBARCH去掉，直接给ARCH变量赋值arm64，再进内核配置菜单，OK，搞定。</p>
<p>这样定制Makefile还有个好处，不用每次编译都带编译参数。</p>
<p>铺垫的工作做好了，接下来我们就一个配置一个配置介绍，如何选择和配置关键通用项：</p>
<p>1.support for paging of anonymous memory(swap)</p>
<p>swap字眼让大家想到了swap分区，没错这个确实和swap分区有关，不过，内核中如果屏蔽掉这项后，内核将不再支持swap分区，相应的依赖于swap分区的功能就都屏蔽掉了，也就是内存中的数据无法存到swap分区。如果你是嵌入式系统建议关闭此项提高系统速度，前提是你有足够的内存。</p>
<p>config BPF_JIT
bool &ldquo;Enable BPF Just In Time compiler&rdquo;
depends on BPF
depends on HAVE_CBPF_JIT || HAVE_EBPF_JIT
depends on MODULES
help
BPF programs are normally handled by a BPF interpreter. This option
allows the kernel to generate native code when a program is loaded
into the kernel. This will significantly speed-up processing of BPF
programs.</p>
<pre><code>  Note, an admin should enable this feature changing:
  /proc/sys/net/core/bpf_jit_enable
  /proc/sys/net/core/bpf_jit_harden   (optional)
  /proc/sys/net/core/bpf_jit_kallsyms (optional)
</code></pre>
<p>BPF(Berkeley Packet Filter) 的过滤功能通常由一个解释器 (interpreter) 解释执行 BPF 虚拟机指令的方式工作. 开启此项, 内核在加载过滤指令后, 会将其编译为本地指令, 以加快执行速度. 网络嗅探程序 (libpcap/tcpdump) 可以从中受益. 注意: 需要 &ldquo;echo 1 &gt; /proc/sys/net/core/bpf_jit_enable&rdquo; 之后才能生效.</p>
<p><a href="http://zh.wikipedia.org/wiki/BPF">BPF(Berkeley Packet Filter)</a>的过滤功能通常由一个解释器(interpreter)解释执行BPF虚拟机指令的方式工作.开启此项,内核在加载过滤指令后,会将其编译为本地指令,以加快执行速度.网络嗅探程序(libpcap/tcpdump)可以从中受益.注意:需要&quot;echo 1 &gt; /proc/sys/net/core/bpf_jit_enable&quot;之后才能生效.</p>

      <details><summary>End</summary>is start.</details>
    </div>

    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/wechat-pay.jpg">
        <span>微信打赏</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="/img/reward/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          <a href="/tags/gentoo/">gentoo</a>
          <a href="/tags/%E5%AE%89%E8%A3%85/">安装</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/code/linux/gentoo-install/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Gentoo 安装</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/megax/">
            <span class="next-text nav-default">Linux 安装 mega 生物分析软件</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  


    <div>
      <div class="pagination__title">
        <span class="pagination__title-h" style="font-size: 20px;">💬评论</span>
      <hr/>
    </div>
  <div id="tcomment"></div>
    <script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.20/dist/twikoo.all.min.js">
    </script>
    <script>
        twikoo.init({
            envId: "https://00002000.netlify.app/.netlify/functions/twikoo",
        el: "#tcomment",
            lang: 'zh-CN',
            region: "ap-guangzhou",
        path: window.TWIKOO_MAGIC_PATH||window.location.pathname,
        })
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by Twikoo.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:seeu100@outlook.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/seeu100" class="iconfont icon-github" title="github"></a>
      <a href="https://www.zhihu.com/people/seeu100" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://space.bilibili.com/197358900" class="iconfont icon-bilibili" title="bilibili"></a>
    <a href="https://blog.00002000.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>00002000</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
    <script type="text/javascript" src="/lib/timeago/timeago-3.0.2.min.js"></script>
    <script type="text/javascript" src="/lib/timeago/timeago.locales-3.0.2.min.js"></script>
  <script><!-- NOTE: timeago.js uses the language code format like "zh_CN" (underscore and case sensitive) -->
    var languageCode = "zh_CN".replace(/-/g, '_').replace(/_(.*)/, function ($0, $1) {return $0.replace($1, $1.toUpperCase());});
    timeago().render(document.querySelectorAll('.timeago'), languageCode);
    timeago.cancel();  
  </script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
